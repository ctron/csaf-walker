/**
 * @param {Array<import('./shared/types').DocumentTest>} tests
 * @param {any} doc
 */
async function validateLib (tests, doc) {
  let isValid = true;
  const testResults =
    /** @type {({ name: string } & import('./shared/types').Result)[]} */ ([]);

  for (const test of tests) {
    const result = await test(doc);
    const testIsValid =
      typeof result.isValid === 'boolean' ? result.isValid : true;
    testResults.push({
      isValid: testIsValid,
      errors: result.errors ?? [],
      warnings: result.warnings ?? [],
      infos: result.infos ?? [],
      name: test.name,
    });
    isValid = isValid && testIsValid;
  }

  return { tests: testResults, isValid }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var dist = {exports: {}};

var formats = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
	function fmtDef(validate, compare) {
	    return { validate, compare };
	}
	exports.fullFormats = {
	    // date: http://tools.ietf.org/html/rfc3339#section-5.6
	    date: fmtDef(date, compareDate),
	    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
	    time: fmtDef(time, compareTime),
	    "date-time": fmtDef(date_time, compareDateTime),
	    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
	    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
	    uri,
	    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
	    // uri-template: https://tools.ietf.org/html/rfc6570
	    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
	    // For the source: https://gist.github.com/dperini/729294
	    // For test cases: https://mathiasbynens.be/demo/url-regex
	    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
	    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
	    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
	    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
	    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
	    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
	    regex,
	    // uuid: http://tools.ietf.org/html/rfc4122
	    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
	    // JSON-pointer: https://tools.ietf.org/html/rfc6901
	    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
	    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
	    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
	    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
	    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
	    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
	    // byte: https://github.com/miguelmota/is-base64
	    byte,
	    // signed 32 bit integer
	    int32: { type: "number", validate: validateInt32 },
	    // signed 64 bit integer
	    int64: { type: "number", validate: validateInt64 },
	    // C-type float
	    float: { type: "number", validate: validateNumber },
	    // C-type double
	    double: { type: "number", validate: validateNumber },
	    // hint to the UI to hide input strings
	    password: true,
	    // unchecked string payload
	    binary: true,
	};
	exports.fastFormats = {
	    ...exports.fullFormats,
	    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
	    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
	    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
	    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
	    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
	    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
	    // email (sources from jsen validator):
	    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
	    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
	    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
	};
	exports.formatNames = Object.keys(exports.fullFormats);
	function isLeapYear(year) {
	    // https://tools.ietf.org/html/rfc3339#appendix-C
	    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
	}
	const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
	const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	function date(str) {
	    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
	    const matches = DATE.exec(str);
	    if (!matches)
	        return false;
	    const year = +matches[1];
	    const month = +matches[2];
	    const day = +matches[3];
	    return (month >= 1 &&
	        month <= 12 &&
	        day >= 1 &&
	        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
	}
	function compareDate(d1, d2) {
	    if (!(d1 && d2))
	        return undefined;
	    if (d1 > d2)
	        return 1;
	    if (d1 < d2)
	        return -1;
	    return 0;
	}
	const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
	function time(str, withTimeZone) {
	    const matches = TIME.exec(str);
	    if (!matches)
	        return false;
	    const hour = +matches[1];
	    const minute = +matches[2];
	    const second = +matches[3];
	    const timeZone = matches[5];
	    return (((hour <= 23 && minute <= 59 && second <= 59) ||
	        (hour === 23 && minute === 59 && second === 60)) &&
	        (!withTimeZone || timeZone !== ""));
	}
	function compareTime(t1, t2) {
	    if (!(t1 && t2))
	        return undefined;
	    const a1 = TIME.exec(t1);
	    const a2 = TIME.exec(t2);
	    if (!(a1 && a2))
	        return undefined;
	    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
	    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
	    if (t1 > t2)
	        return 1;
	    if (t1 < t2)
	        return -1;
	    return 0;
	}
	const DATE_TIME_SEPARATOR = /t|\s/i;
	function date_time(str) {
	    // http://tools.ietf.org/html/rfc3339#section-5.6
	    const dateTime = str.split(DATE_TIME_SEPARATOR);
	    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
	}
	function compareDateTime(dt1, dt2) {
	    if (!(dt1 && dt2))
	        return undefined;
	    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
	    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
	    const res = compareDate(d1, d2);
	    if (res === undefined)
	        return undefined;
	    return res || compareTime(t1, t2);
	}
	const NOT_URI_FRAGMENT = /\/|:/;
	const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
	function uri(str) {
	    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
	    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
	}
	const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
	function byte(str) {
	    BYTE.lastIndex = 0;
	    return BYTE.test(str);
	}
	const MIN_INT32 = -(2 ** 31);
	const MAX_INT32 = 2 ** 31 - 1;
	function validateInt32(value) {
	    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
	}
	function validateInt64(value) {
	    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
	    return Number.isInteger(value);
	}
	function validateNumber() {
	    return true;
	}
	const Z_ANCHOR = /[^\\]\\Z/;
	function regex(str) {
	    if (Z_ANCHOR.test(str))
	        return false;
	    try {
	        new RegExp(str);
	        return true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
} (formats));

var limit = {};

var ajv$l = {exports: {}};

var core$3 = {};

var validate$i = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code$1;
	hasRequiredCode = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$1));
	return code$1;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode();
		const scope_1 = requireScope();
		var code_2 = requireCode();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	exports.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	exports.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	exports.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	exports.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	exports.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	exports.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	exports.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	exports.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	exports.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	exports.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	exports.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	exports.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	exports.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	exports.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	exports.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type = exports.Type || (exports.Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	exports.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	exports.checkStrictMode = checkStrictMode;
	
} (util));

var names$1 = {};

Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$B = requireCodegen();
const names = {
    // validation function arguments
    data: new codegen_1$B.Name("data"),
    // args passed from referencing schema
    valCxt: new codegen_1$B.Name("valCxt"),
    instancePath: new codegen_1$B.Name("instancePath"),
    parentData: new codegen_1$B.Name("parentData"),
    parentDataProperty: new codegen_1$B.Name("parentDataProperty"),
    rootData: new codegen_1$B.Name("rootData"),
    dynamicAnchors: new codegen_1$B.Name("dynamicAnchors"),
    // function scoped variables
    vErrors: new codegen_1$B.Name("vErrors"),
    errors: new codegen_1$B.Name("errors"),
    this: new codegen_1$B.Name("this"),
    // "globals"
    self: new codegen_1$B.Name("self"),
    scope: new codegen_1$B.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1$B.Name("json"),
    jsonPos: new codegen_1$B.Name("jsonPos"),
    jsonLen: new codegen_1$B.Name("jsonLen"),
    jsonPart: new codegen_1$B.Name("jsonPart"),
};
names$1.default = names;

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = util;
		const names_1 = names$1;
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"),
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors));
	return errors;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const names_1 = names$1;
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
rules.getRules = getRules;

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
	const rules_1 = rules;
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const util_1 = util;
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType = exports.DataType || (exports.DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	exports.getSchemaTypes = getSchemaTypes;
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	exports.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	exports.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	exports.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	exports.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	exports.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
} (dataType));

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util;
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$A = requireCodegen();
const util_1$v = util;
const names_1$9 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1$A._) `${prop}` }, true);
        cxt.error();
    });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1$A.or)(...properties.map((prop) => (0, codegen_1$A.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$A._) `${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1$A._) `Object.prototype.hasOwnProperty`,
    });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return (0, codegen_1$A._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1$A._) `${data}${(0, codegen_1$A.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1$A._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1$A._) `${data}${(0, codegen_1$A.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1$A.or)(cond, (0, codegen_1$A.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1$v.alwaysValidSchema)(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1$A._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1$9.default.instancePath, (0, codegen_1$A.strConcat)(names_1$9.default.instancePath, errorPath)],
        [names_1$9.default.parentData, it.parentData],
        [names_1$9.default.parentDataProperty, it.parentDataProperty],
        [names_1$9.default.rootData, names_1$9.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1$9.default.dynamicAnchors, names_1$9.default.dynamicAnchors]);
    const args = (0, codegen_1$A._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1$A.nil ? (0, codegen_1$A._) `${func}.call(${context}, ${args})` : (0, codegen_1$A._) `${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$A._) `new RegExp`;
function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1$A._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern}, ${u})`,
    });
}
code.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1$A._) `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: util_1$v.Type.Num,
            }, valid);
            gen.if((0, codegen_1$A.not)(valid), notValid);
        });
    }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1$v.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, (0, codegen_1$A._) `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if((0, codegen_1$A.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = names$1;
	const code_1 = code;
	const errors_1 = requireErrors();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util;
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve$1 = {};

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

var jsonSchemaTraverse = {exports: {}};

var traverse$1 = jsonSchemaTraverse.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse$1.keywords || (opts.allKeys && !(key in traverse$1.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}

var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;

Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$u = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef$1(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef$1(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef$1))
            return true;
        if (typeof sch == "object" && hasRef$1(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1$u.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = resolver.parse(id);
    return _getFullPath(resolver, p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(resolver, p) {
    const serialized = resolver.serialize(p);
    return serialized.split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            baseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const _resolve = this.opts.uriResolver.resolve;
            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal$2(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
resolve$1.getSchemaRefs = getSchemaRefs;

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate$i;
	hasRequiredValidate = 1;
	Object.defineProperty(validate$i, "__esModule", { value: true });
	validate$i.getData = validate$i.KeywordCxt = validate$i.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = dataType;
	const applicability_1 = requireApplicability();
	const dataType_2 = dataType;
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = names$1;
	const resolve_1 = resolve$1;
	const util_1 = util;
	const errors_1 = requireErrors();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate$i.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate$i.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate$i.getData = getData;
	
	return validate$i;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = resolve$1;
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$z = requireCodegen();
const validation_error_1 = requireValidation_error();
const names_1$8 = names$1;
const resolve_1 = resolve$1;
const util_1$t = util;
const validate_1$1 = requireValidate();
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
compile.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1$z.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1$z._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1$8.default.data,
        parentData: names_1$8.default.parentData,
        parentDataProperty: names_1$8.default.parentDataProperty,
        dataNames: [names_1$8.default.data],
        dataPathArr: [codegen_1$z.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1$z.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1$z.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1$z._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1$1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$8.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1$8.default.self}`, `${names_1$8.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1$z.Name ? undefined : props,
                items: items instanceof codegen_1$z.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1$z.Name,
                dynamicItems: items instanceof codegen_1$z.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1$z.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
compile.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1$t.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1$t.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}

var $id$9 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$a = "object";
var required$1 = [
	"$data"
];
var properties$b = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$9,
	description: description,
	type: type$a,
	required: required$1,
	properties: properties$b,
	additionalProperties: additionalProperties$1
};

var uri$1 = {};

var uri_all = {exports: {}};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

(function (module, exports) {
	(function (global, factory) {
		factory(exports) ;
	}(commonjsGlobal, (function (exports) {
	function merge() {
	    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
	        sets[_key] = arguments[_key];
	    }

	    if (sets.length > 1) {
	        sets[0] = sets[0].slice(0, -1);
	        var xl = sets.length - 1;
	        for (var x = 1; x < xl; ++x) {
	            sets[x] = sets[x].slice(1, -1);
	        }
	        sets[xl] = sets[xl].slice(1);
	        return sets.join('');
	    } else {
	        return sets[0];
	    }
	}
	function subexp(str) {
	    return "(?:" + str + ")";
	}
	function typeOf(o) {
	    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
	}
	function toUpperCase(str) {
	    return str.toUpperCase();
	}
	function toArray(obj) {
	    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
	}
	function assign(target, source) {
	    var obj = target;
	    if (source) {
	        for (var key in source) {
	            obj[key] = source[key];
	        }
	    }
	    return obj;
	}

	function buildExps(isIRI) {
	    var ALPHA$$ = "[A-Za-z]",
	        DIGIT$$ = "[0-9]",
	        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
	        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
	        //expanded
	    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
	        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
	        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
	        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
	        //subset, excludes bidi control characters
	    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
	        //subset
	    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
	        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
	        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
	        //relaxed parsing rules
	    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
	        H16$ = subexp(HEXDIG$$ + "{1,4}"),
	        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
	        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
	        //                           6( h16 ":" ) ls32
	    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
	        //                      "::" 5( h16 ":" ) ls32
	    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
	        //[               h16 ] "::" 4( h16 ":" ) ls32
	    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
	        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
	    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
	        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
	    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
	        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
	    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
	        //[ *4( h16 ":" ) h16 ] "::"              ls32
	    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
	        //[ *5( h16 ":" ) h16 ] "::"              h16
	    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
	        //[ *6( h16 ":" ) h16 ] "::"
	    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
	        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
	        //RFC 6874, with relaxed parsing rules
	    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
	        //RFC 6874
	    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
	        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
	        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
	        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
	    return {
	        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
	        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
	        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
	        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
	        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
	        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
	        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
	        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
	        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
	    };
	}
	var URI_PROTOCOL = buildExps(false);

	var IRI_PROTOCOL = buildExps(true);

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();













	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	/** Highest positive signed 32-bit float value */

	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'

	/** Regular expressions */
	var regexPunycode = /^xn--/;
	var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
	var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

	/** Error messages */
	var errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	};

	/** Convenience shortcuts */
	var baseMinusTMin = base - tMin;
	var floor = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error$1(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var result = [];
		var length = array.length;
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		while (counter < length) {
			var value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// It's a high surrogate, and there is a next character.
				var extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// Low surrogate.
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// It's an unmatched surrogate; only append this code unit, in case the
					// next code unit is the high surrogate of a surrogate pair.
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	var ucs2encode = function ucs2encode(array) {
		return String.fromCodePoint.apply(String, toConsumableArray(array));
	};

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	var basicToDigit = function basicToDigit(codePoint) {
		if (codePoint - 0x30 < 0x0A) {
			return codePoint - 0x16;
		}
		if (codePoint - 0x41 < 0x1A) {
			return codePoint - 0x41;
		}
		if (codePoint - 0x61 < 0x1A) {
			return codePoint - 0x61;
		}
		return base;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	var digitToBasic = function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	var adapt = function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	var decode = function decode(input) {
		// Don't use UCS-2.
		var output = [];
		var inputLength = input.length;
		var i = 0;
		var n = initialN;
		var bias = initialBias;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		var basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (var j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error$1('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			var oldi = i;
			for (var w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error$1('invalid-input');
				}

				var digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error$1('overflow');
				}

				i += digit * w;
				var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				var baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error$1('overflow');
				}

				w *= baseMinusT;
			}

			var out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error$1('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output.
			output.splice(i++, 0, n);
		}

		return String.fromCodePoint.apply(String, output);
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	var encode = function encode(input) {
		var output = [];

		// Convert the input in UCS-2 to an array of Unicode code points.
		input = ucs2decode(input);

		// Cache the length.
		var inputLength = input.length;

		// Initialize the state.
		var n = initialN;
		var delta = 0;
		var bias = initialBias;

		// Handle the basic code points.
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var _currentValue2 = _step.value;

				if (_currentValue2 < 0x80) {
					output.push(stringFromCharCode(_currentValue2));
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		var basicLength = output.length;
		var handledCPCount = basicLength;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string with a delimiter unless it's empty.
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			var m = maxInt;
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var currentValue = _step2.value;

					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow.
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			var handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error$1('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var _currentValue = _step3.value;

					if (_currentValue < n && ++delta > maxInt) {
						error$1('overflow');
					}
					if (_currentValue == n) {
						// Represent delta as a generalized variable-length integer.
						var q = delta;
						for (var k = base;; /* no condition */k += base) {
							var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
							if (q < t) {
								break;
							}
							var qMinusT = q - t;
							var baseMinusT = base - t;
							output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	};

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	var toUnicode = function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	};

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	var toASCII = function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	};

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	var punycode = {
		/**
	  * A string representing the current Punycode.js version number.
	  * @memberOf punycode
	  * @type String
	  */
		'version': '2.1.0',
		/**
	  * An object of methods to convert from JavaScript's internal character
	  * representation (UCS-2) to Unicode code points, and back.
	  * @see <https://mathiasbynens.be/notes/javascript-encoding>
	  * @memberOf punycode
	  * @type Object
	  */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/**
	 * URI.js
	 *
	 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
	 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
	 * @see http://github.com/garycourt/uri-js
	 */
	/**
	 * Copyright 2011 Gary Court. All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without modification, are
	 * permitted provided that the following conditions are met:
	 *
	 *    1. Redistributions of source code must retain the above copyright notice, this list of
	 *       conditions and the following disclaimer.
	 *
	 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
	 *       of conditions and the following disclaimer in the documentation and/or other materials
	 *       provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
	 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
	 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
	 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
	 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * The views and conclusions contained in the software and documentation are those of the
	 * authors and should not be interpreted as representing official policies, either expressed
	 * or implied, of Gary Court.
	 */
	var SCHEMES = {};
	function pctEncChar(chr) {
	    var c = chr.charCodeAt(0);
	    var e = void 0;
	    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
	    return e;
	}
	function pctDecChars(str) {
	    var newStr = "";
	    var i = 0;
	    var il = str.length;
	    while (i < il) {
	        var c = parseInt(str.substr(i + 1, 2), 16);
	        if (c < 128) {
	            newStr += String.fromCharCode(c);
	            i += 3;
	        } else if (c >= 194 && c < 224) {
	            if (il - i >= 6) {
	                var c2 = parseInt(str.substr(i + 4, 2), 16);
	                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
	            } else {
	                newStr += str.substr(i, 6);
	            }
	            i += 6;
	        } else if (c >= 224) {
	            if (il - i >= 9) {
	                var _c = parseInt(str.substr(i + 4, 2), 16);
	                var c3 = parseInt(str.substr(i + 7, 2), 16);
	                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
	            } else {
	                newStr += str.substr(i, 9);
	            }
	            i += 9;
	        } else {
	            newStr += str.substr(i, 3);
	            i += 3;
	        }
	    }
	    return newStr;
	}
	function _normalizeComponentEncoding(components, protocol) {
	    function decodeUnreserved(str) {
	        var decStr = pctDecChars(str);
	        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
	    }
	    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
	    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	    return components;
	}

	function _stripLeadingZeros(str) {
	    return str.replace(/^0*(.*)/, "$1") || "0";
	}
	function _normalizeIPv4(host, protocol) {
	    var matches = host.match(protocol.IPV4ADDRESS) || [];

	    var _matches = slicedToArray(matches, 2),
	        address = _matches[1];

	    if (address) {
	        return address.split(".").map(_stripLeadingZeros).join(".");
	    } else {
	        return host;
	    }
	}
	function _normalizeIPv6(host, protocol) {
	    var matches = host.match(protocol.IPV6ADDRESS) || [];

	    var _matches2 = slicedToArray(matches, 3),
	        address = _matches2[1],
	        zone = _matches2[2];

	    if (address) {
	        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
	            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
	            last = _address$toLowerCase$2[0],
	            first = _address$toLowerCase$2[1];

	        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
	        var lastFields = last.split(":").map(_stripLeadingZeros);
	        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
	        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
	        var lastFieldsStart = lastFields.length - fieldCount;
	        var fields = Array(fieldCount);
	        for (var x = 0; x < fieldCount; ++x) {
	            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
	        }
	        if (isLastFieldIPv4Address) {
	            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
	        }
	        var allZeroFields = fields.reduce(function (acc, field, index) {
	            if (!field || field === "0") {
	                var lastLongest = acc[acc.length - 1];
	                if (lastLongest && lastLongest.index + lastLongest.length === index) {
	                    lastLongest.length++;
	                } else {
	                    acc.push({ index: index, length: 1 });
	                }
	            }
	            return acc;
	        }, []);
	        var longestZeroFields = allZeroFields.sort(function (a, b) {
	            return b.length - a.length;
	        })[0];
	        var newHost = void 0;
	        if (longestZeroFields && longestZeroFields.length > 1) {
	            var newFirst = fields.slice(0, longestZeroFields.index);
	            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
	            newHost = newFirst.join(":") + "::" + newLast.join(":");
	        } else {
	            newHost = fields.join(":");
	        }
	        if (zone) {
	            newHost += "%" + zone;
	        }
	        return newHost;
	    } else {
	        return host;
	    }
	}
	var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
	var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
	function parse(uriString) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var components = {};
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
	    var matches = uriString.match(URI_PARSE);
	    if (matches) {
	        if (NO_MATCH_IS_UNDEFINED) {
	            //store each component
	            components.scheme = matches[1];
	            components.userinfo = matches[3];
	            components.host = matches[4];
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = matches[7];
	            components.fragment = matches[8];
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = matches[5];
	            }
	        } else {
	            //IE FIX for improper RegExp matching
	            //store each component
	            components.scheme = matches[1] || undefined;
	            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
	            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
	            components.port = parseInt(matches[5], 10);
	            components.path = matches[6] || "";
	            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
	            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
	            //fix port number
	            if (isNaN(components.port)) {
	                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
	            }
	        }
	        if (components.host) {
	            //normalize IP hosts
	            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
	        }
	        //determine reference type
	        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
	            components.reference = "same-document";
	        } else if (components.scheme === undefined) {
	            components.reference = "relative";
	        } else if (components.fragment === undefined) {
	            components.reference = "absolute";
	        } else {
	            components.reference = "uri";
	        }
	        //check for reference errors
	        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
	            components.error = components.error || "URI is not a " + options.reference + " reference.";
	        }
	        //find scheme handler
	        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	        //check if scheme can't handle IRIs
	        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	            //if host component is a domain name
	            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            }
	            //convert IRI -> URI
	            _normalizeComponentEncoding(components, URI_PROTOCOL);
	        } else {
	            //normalize encodings
	            _normalizeComponentEncoding(components, protocol);
	        }
	        //perform scheme specific parsing
	        if (schemeHandler && schemeHandler.parse) {
	            schemeHandler.parse(components, options);
	        }
	    } else {
	        components.error = components.error || "URI can not be parsed.";
	    }
	    return components;
	}

	function _recomposeAuthority(components, options) {
	    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    if (components.userinfo !== undefined) {
	        uriTokens.push(components.userinfo);
	        uriTokens.push("@");
	    }
	    if (components.host !== undefined) {
	        //normalize IP hosts, add brackets and escape zone separator for IPv6
	        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
	            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
	        }));
	    }
	    if (typeof components.port === "number" || typeof components.port === "string") {
	        uriTokens.push(":");
	        uriTokens.push(String(components.port));
	    }
	    return uriTokens.length ? uriTokens.join("") : undefined;
	}

	var RDS1 = /^\.\.?\//;
	var RDS2 = /^\/\.(\/|$)/;
	var RDS3 = /^\/\.\.(\/|$)/;
	var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
	function removeDotSegments(input) {
	    var output = [];
	    while (input.length) {
	        if (input.match(RDS1)) {
	            input = input.replace(RDS1, "");
	        } else if (input.match(RDS2)) {
	            input = input.replace(RDS2, "/");
	        } else if (input.match(RDS3)) {
	            input = input.replace(RDS3, "/");
	            output.pop();
	        } else if (input === "." || input === "..") {
	            input = "";
	        } else {
	            var im = input.match(RDS5);
	            if (im) {
	                var s = im[0];
	                input = input.slice(s.length);
	                output.push(s);
	            } else {
	                throw new Error("Unexpected dot segment condition");
	            }
	        }
	    }
	    return output.join("");
	}

	function serialize(components) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
	    var uriTokens = [];
	    //find scheme handler
	    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
	    //perform scheme specific serialization
	    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
	    if (components.host) {
	        //if host component is an IPv6 address
	        if (protocol.IPV6ADDRESS.test(components.host)) ;
	        //TODO: normalize IPv6 address as per RFC 5952

	        //if host component is a domain name
	        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
	                //convert IDN via punycode
	                try {
	                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
	                } catch (e) {
	                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	            }
	    }
	    //normalize encoding
	    _normalizeComponentEncoding(components, protocol);
	    if (options.reference !== "suffix" && components.scheme) {
	        uriTokens.push(components.scheme);
	        uriTokens.push(":");
	    }
	    var authority = _recomposeAuthority(components, options);
	    if (authority !== undefined) {
	        if (options.reference !== "suffix") {
	            uriTokens.push("//");
	        }
	        uriTokens.push(authority);
	        if (components.path && components.path.charAt(0) !== "/") {
	            uriTokens.push("/");
	        }
	    }
	    if (components.path !== undefined) {
	        var s = components.path;
	        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	            s = removeDotSegments(s);
	        }
	        if (authority === undefined) {
	            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
	        }
	        uriTokens.push(s);
	    }
	    if (components.query !== undefined) {
	        uriTokens.push("?");
	        uriTokens.push(components.query);
	    }
	    if (components.fragment !== undefined) {
	        uriTokens.push("#");
	        uriTokens.push(components.fragment);
	    }
	    return uriTokens.join(""); //merge tokens into a string
	}

	function resolveComponents(base, relative) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var skipNormalization = arguments[3];

	    var target = {};
	    if (!skipNormalization) {
	        base = parse(serialize(base, options), options); //normalize base components
	        relative = parse(serialize(relative, options), options); //normalize relative components
	    }
	    options = options || {};
	    if (!options.tolerant && relative.scheme) {
	        target.scheme = relative.scheme;
	        //target.authority = relative.authority;
	        target.userinfo = relative.userinfo;
	        target.host = relative.host;
	        target.port = relative.port;
	        target.path = removeDotSegments(relative.path || "");
	        target.query = relative.query;
	    } else {
	        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	            //target.authority = relative.authority;
	            target.userinfo = relative.userinfo;
	            target.host = relative.host;
	            target.port = relative.port;
	            target.path = removeDotSegments(relative.path || "");
	            target.query = relative.query;
	        } else {
	            if (!relative.path) {
	                target.path = base.path;
	                if (relative.query !== undefined) {
	                    target.query = relative.query;
	                } else {
	                    target.query = base.query;
	                }
	            } else {
	                if (relative.path.charAt(0) === "/") {
	                    target.path = removeDotSegments(relative.path);
	                } else {
	                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	                        target.path = "/" + relative.path;
	                    } else if (!base.path) {
	                        target.path = relative.path;
	                    } else {
	                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
	                    }
	                    target.path = removeDotSegments(target.path);
	                }
	                target.query = relative.query;
	            }
	            //target.authority = base.authority;
	            target.userinfo = base.userinfo;
	            target.host = base.host;
	            target.port = base.port;
	        }
	        target.scheme = base.scheme;
	    }
	    target.fragment = relative.fragment;
	    return target;
	}

	function resolve(baseURI, relativeURI, options) {
	    var schemelessOptions = assign({ scheme: 'null' }, options);
	    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
	}

	function normalize(uri, options) {
	    if (typeof uri === "string") {
	        uri = serialize(parse(uri, options), options);
	    } else if (typeOf(uri) === "object") {
	        uri = parse(serialize(uri, options), options);
	    }
	    return uri;
	}

	function equal(uriA, uriB, options) {
	    if (typeof uriA === "string") {
	        uriA = serialize(parse(uriA, options), options);
	    } else if (typeOf(uriA) === "object") {
	        uriA = serialize(uriA, options);
	    }
	    if (typeof uriB === "string") {
	        uriB = serialize(parse(uriB, options), options);
	    } else if (typeOf(uriB) === "object") {
	        uriB = serialize(uriB, options);
	    }
	    return uriA === uriB;
	}

	function escapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
	}

	function unescapeComponent(str, options) {
	    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
	}

	var handler = {
	    scheme: "http",
	    domainHost: true,
	    parse: function parse(components, options) {
	        //report missing host
	        if (!components.host) {
	            components.error = components.error || "HTTP URIs must have a host.";
	        }
	        return components;
	    },
	    serialize: function serialize(components, options) {
	        var secure = String(components.scheme).toLowerCase() === "https";
	        //normalize the default port
	        if (components.port === (secure ? 443 : 80) || components.port === "") {
	            components.port = undefined;
	        }
	        //normalize the empty path
	        if (!components.path) {
	            components.path = "/";
	        }
	        //NOTE: We do not parse query strings for HTTP URIs
	        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	        //and not the HTTP spec.
	        return components;
	    }
	};

	var handler$1 = {
	    scheme: "https",
	    domainHost: handler.domainHost,
	    parse: handler.parse,
	    serialize: handler.serialize
	};

	function isSecure(wsComponents) {
	    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
	}
	//RFC 6455
	var handler$2 = {
	    scheme: "ws",
	    domainHost: true,
	    parse: function parse(components, options) {
	        var wsComponents = components;
	        //indicate if the secure flag is set
	        wsComponents.secure = isSecure(wsComponents);
	        //construct resouce name
	        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
	        wsComponents.path = undefined;
	        wsComponents.query = undefined;
	        return wsComponents;
	    },
	    serialize: function serialize(wsComponents, options) {
	        //normalize the default port
	        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
	            wsComponents.port = undefined;
	        }
	        //ensure scheme matches secure flag
	        if (typeof wsComponents.secure === 'boolean') {
	            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
	            wsComponents.secure = undefined;
	        }
	        //reconstruct path from resource name
	        if (wsComponents.resourceName) {
	            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
	                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
	                path = _wsComponents$resourc2[0],
	                query = _wsComponents$resourc2[1];

	            wsComponents.path = path && path !== '/' ? path : undefined;
	            wsComponents.query = query;
	            wsComponents.resourceName = undefined;
	        }
	        //forbid fragment component
	        wsComponents.fragment = undefined;
	        return wsComponents;
	    }
	};

	var handler$3 = {
	    scheme: "wss",
	    domainHost: handler$2.domainHost,
	    parse: handler$2.parse,
	    serialize: handler$2.serialize
	};

	var O = {};
	//RFC 3986
	var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
	var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
	var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
	//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
	//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
	//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
	//const VCHAR$$ = "[\\x21-\\x7E]";
	//const WSP$$ = "[\\x20\\x09]";
	//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
	//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
	//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
	//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
	var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
	var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
	var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
	var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
	var UNRESERVED = new RegExp(UNRESERVED$$, "g");
	var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
	var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
	var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
	var NOT_HFVALUE = NOT_HFNAME;
	function decodeUnreserved(str) {
	    var decStr = pctDecChars(str);
	    return !decStr.match(UNRESERVED) ? str : decStr;
	}
	var handler$4 = {
	    scheme: "mailto",
	    parse: function parse$$1(components, options) {
	        var mailtoComponents = components;
	        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
	        mailtoComponents.path = undefined;
	        if (mailtoComponents.query) {
	            var unknownHeaders = false;
	            var headers = {};
	            var hfields = mailtoComponents.query.split("&");
	            for (var x = 0, xl = hfields.length; x < xl; ++x) {
	                var hfield = hfields[x].split("=");
	                switch (hfield[0]) {
	                    case "to":
	                        var toAddrs = hfield[1].split(",");
	                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
	                            to.push(toAddrs[_x]);
	                        }
	                        break;
	                    case "subject":
	                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
	                        break;
	                    case "body":
	                        mailtoComponents.body = unescapeComponent(hfield[1], options);
	                        break;
	                    default:
	                        unknownHeaders = true;
	                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
	                        break;
	                }
	            }
	            if (unknownHeaders) mailtoComponents.headers = headers;
	        }
	        mailtoComponents.query = undefined;
	        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
	            var addr = to[_x2].split("@");
	            addr[0] = unescapeComponent(addr[0]);
	            if (!options.unicodeSupport) {
	                //convert Unicode IDN -> ASCII IDN
	                try {
	                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
	                } catch (e) {
	                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
	                }
	            } else {
	                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
	            }
	            to[_x2] = addr.join("@");
	        }
	        return mailtoComponents;
	    },
	    serialize: function serialize$$1(mailtoComponents, options) {
	        var components = mailtoComponents;
	        var to = toArray(mailtoComponents.to);
	        if (to) {
	            for (var x = 0, xl = to.length; x < xl; ++x) {
	                var toAddr = String(to[x]);
	                var atIdx = toAddr.lastIndexOf("@");
	                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
	                var domain = toAddr.slice(atIdx + 1);
	                //convert IDN via punycode
	                try {
	                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
	                } catch (e) {
	                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
	                }
	                to[x] = localPart + "@" + domain;
	            }
	            components.path = to.join(",");
	        }
	        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
	        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
	        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
	        var fields = [];
	        for (var name in headers) {
	            if (headers[name] !== O[name]) {
	                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
	            }
	        }
	        if (fields.length) {
	            components.query = fields.join("&");
	        }
	        return components;
	    }
	};

	var URN_PARSE = /^([^\:]+)\:(.*)/;
	//RFC 2141
	var handler$5 = {
	    scheme: "urn",
	    parse: function parse$$1(components, options) {
	        var matches = components.path && components.path.match(URN_PARSE);
	        var urnComponents = components;
	        if (matches) {
	            var scheme = options.scheme || urnComponents.scheme || "urn";
	            var nid = matches[1].toLowerCase();
	            var nss = matches[2];
	            var urnScheme = scheme + ":" + (options.nid || nid);
	            var schemeHandler = SCHEMES[urnScheme];
	            urnComponents.nid = nid;
	            urnComponents.nss = nss;
	            urnComponents.path = undefined;
	            if (schemeHandler) {
	                urnComponents = schemeHandler.parse(urnComponents, options);
	            }
	        } else {
	            urnComponents.error = urnComponents.error || "URN can not be parsed.";
	        }
	        return urnComponents;
	    },
	    serialize: function serialize$$1(urnComponents, options) {
	        var scheme = options.scheme || urnComponents.scheme || "urn";
	        var nid = urnComponents.nid;
	        var urnScheme = scheme + ":" + (options.nid || nid);
	        var schemeHandler = SCHEMES[urnScheme];
	        if (schemeHandler) {
	            urnComponents = schemeHandler.serialize(urnComponents, options);
	        }
	        var uriComponents = urnComponents;
	        var nss = urnComponents.nss;
	        uriComponents.path = (nid || options.nid) + ":" + nss;
	        return uriComponents;
	    }
	};

	var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
	//RFC 4122
	var handler$6 = {
	    scheme: "urn:uuid",
	    parse: function parse(urnComponents, options) {
	        var uuidComponents = urnComponents;
	        uuidComponents.uuid = uuidComponents.nss;
	        uuidComponents.nss = undefined;
	        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
	            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
	        }
	        return uuidComponents;
	    },
	    serialize: function serialize(uuidComponents, options) {
	        var urnComponents = uuidComponents;
	        //normalize UUID
	        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
	        return urnComponents;
	    }
	};

	SCHEMES[handler.scheme] = handler;
	SCHEMES[handler$1.scheme] = handler$1;
	SCHEMES[handler$2.scheme] = handler$2;
	SCHEMES[handler$3.scheme] = handler$3;
	SCHEMES[handler$4.scheme] = handler$4;
	SCHEMES[handler$5.scheme] = handler$5;
	SCHEMES[handler$6.scheme] = handler$6;

	exports.SCHEMES = SCHEMES;
	exports.pctEncChar = pctEncChar;
	exports.pctDecChars = pctDecChars;
	exports.parse = parse;
	exports.removeDotSegments = removeDotSegments;
	exports.serialize = serialize;
	exports.resolveComponents = resolveComponents;
	exports.resolve = resolve;
	exports.normalize = normalize;
	exports.equal = equal;
	exports.escapeComponent = escapeComponent;
	exports.unescapeComponent = unescapeComponent;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));
	
} (uri_all, uri_all.exports));

var uri_allExports = uri_all.exports;

Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = uri_allExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	const validation_error_1 = requireValidation_error();
	const ref_error_1 = requireRef_error();
	const rules_1 = rules;
	const compile_1 = compile;
	const codegen_2 = requireCodegen();
	const resolve_1 = resolve$1;
	const dataType_1 = dataType;
	const util_1 = util;
	const $dataRefSchema = require$$9;
	const uri_1 = uri$1;
	const defaultRegExp = (str, flags) => new RegExp(str, flags);
	defaultRegExp.code = "new RegExp";
	const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
	const EXT_SCOPE_NAMES = new Set([
	    "validate",
	    "serialize",
	    "parse",
	    "wrapper",
	    "root",
	    "schema",
	    "keyword",
	    "pattern",
	    "formats",
	    "validate$data",
	    "func",
	    "obj",
	    "Error",
	]);
	const removedOptions = {
	    errorDataPath: "",
	    format: "`validateFormats: false` can be used instead.",
	    nullable: '"nullable" keyword is supported by default.',
	    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
	    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
	    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
	    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
	    sourceCode: "Use option `code: {source: true}`",
	    strictDefaults: "It is default now, see option `strict`.",
	    strictKeywords: "It is default now, see option `strict`.",
	    uniqueItems: '"uniqueItems" keyword is always validated.',
	    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
	    cache: "Map is used as cache, schema object as key.",
	    serialize: "Map is used as cache, schema object as key.",
	    ajvErrors: "It is default now.",
	};
	const deprecatedOptions = {
	    ignoreKeywordsWithRef: "",
	    jsPropertySyntax: "",
	    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
	};
	const MAX_EXPRESSION = 200;
	// eslint-disable-next-line complexity
	function requiredOptions(o) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
	    const s = o.strict;
	    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
	    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
	    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
	    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
	    return {
	        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
	        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
	        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
	        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
	        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
	        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
	        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
	        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
	        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
	        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
	        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
	        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
	        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
	        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
	        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
	        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
	        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
	        uriResolver: uriResolver,
	    };
	}
	class Ajv {
	    constructor(opts = {}) {
	        this.schemas = {};
	        this.refs = {};
	        this.formats = {};
	        this._compilations = new Set();
	        this._loading = {};
	        this._cache = new Map();
	        opts = this.opts = { ...opts, ...requiredOptions(opts) };
	        const { es5, lines } = this.opts.code;
	        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
	        this.logger = getLogger(opts.logger);
	        const formatOpt = opts.validateFormats;
	        opts.validateFormats = false;
	        this.RULES = (0, rules_1.getRules)();
	        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
	        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
	        this._metaOpts = getMetaSchemaOptions.call(this);
	        if (opts.formats)
	            addInitialFormats.call(this);
	        this._addVocabularies();
	        this._addDefaultMetaSchema();
	        if (opts.keywords)
	            addInitialKeywords.call(this, opts.keywords);
	        if (typeof opts.meta == "object")
	            this.addMetaSchema(opts.meta);
	        addInitialSchemas.call(this);
	        opts.validateFormats = formatOpt;
	    }
	    _addVocabularies() {
	        this.addKeyword("$async");
	    }
	    _addDefaultMetaSchema() {
	        const { $data, meta, schemaId } = this.opts;
	        let _dataRefSchema = $dataRefSchema;
	        if (schemaId === "id") {
	            _dataRefSchema = { ...$dataRefSchema };
	            _dataRefSchema.id = _dataRefSchema.$id;
	            delete _dataRefSchema.$id;
	        }
	        if (meta && $data)
	            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
	    }
	    defaultMeta() {
	        const { meta, schemaId } = this.opts;
	        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
	    }
	    validate(schemaKeyRef, // key, ref or schema object
	    data // to be validated
	    ) {
	        let v;
	        if (typeof schemaKeyRef == "string") {
	            v = this.getSchema(schemaKeyRef);
	            if (!v)
	                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
	        }
	        else {
	            v = this.compile(schemaKeyRef);
	        }
	        const valid = v(data);
	        if (!("$async" in v))
	            this.errors = v.errors;
	        return valid;
	    }
	    compile(schema, _meta) {
	        const sch = this._addSchema(schema, _meta);
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    compileAsync(schema, meta) {
	        if (typeof this.opts.loadSchema != "function") {
	            throw new Error("options.loadSchema should be a function");
	        }
	        const { loadSchema } = this.opts;
	        return runCompileAsync.call(this, schema, meta);
	        async function runCompileAsync(_schema, _meta) {
	            await loadMetaSchema.call(this, _schema.$schema);
	            const sch = this._addSchema(_schema, _meta);
	            return sch.validate || _compileAsync.call(this, sch);
	        }
	        async function loadMetaSchema($ref) {
	            if ($ref && !this.getSchema($ref)) {
	                await runCompileAsync.call(this, { $ref }, true);
	            }
	        }
	        async function _compileAsync(sch) {
	            try {
	                return this._compileSchemaEnv(sch);
	            }
	            catch (e) {
	                if (!(e instanceof ref_error_1.default))
	                    throw e;
	                checkLoaded.call(this, e);
	                await loadMissingSchema.call(this, e.missingSchema);
	                return _compileAsync.call(this, sch);
	            }
	        }
	        function checkLoaded({ missingSchema: ref, missingRef }) {
	            if (this.refs[ref]) {
	                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
	            }
	        }
	        async function loadMissingSchema(ref) {
	            const _schema = await _loadSchema.call(this, ref);
	            if (!this.refs[ref])
	                await loadMetaSchema.call(this, _schema.$schema);
	            if (!this.refs[ref])
	                this.addSchema(_schema, ref, meta);
	        }
	        async function _loadSchema(ref) {
	            const p = this._loading[ref];
	            if (p)
	                return p;
	            try {
	                return await (this._loading[ref] = loadSchema(ref));
	            }
	            finally {
	                delete this._loading[ref];
	            }
	        }
	    }
	    // Adds schema to the instance
	    addSchema(schema, // If array is passed, `key` will be ignored
	    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
	    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
	    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
	    ) {
	        if (Array.isArray(schema)) {
	            for (const sch of schema)
	                this.addSchema(sch, undefined, _meta, _validateSchema);
	            return this;
	        }
	        let id;
	        if (typeof schema === "object") {
	            const { schemaId } = this.opts;
	            id = schema[schemaId];
	            if (id !== undefined && typeof id != "string") {
	                throw new Error(`schema ${schemaId} must be string`);
	            }
	        }
	        key = (0, resolve_1.normalizeId)(key || id);
	        this._checkUnique(key);
	        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
	        return this;
	    }
	    // Add schema that will be used to validate other schemas
	    // options in META_IGNORE_OPTIONS are alway set to false
	    addMetaSchema(schema, key, // schema key
	    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
	    ) {
	        this.addSchema(schema, key, true, _validateSchema);
	        return this;
	    }
	    //  Validate schema against its meta-schema
	    validateSchema(schema, throwOrLogError) {
	        if (typeof schema == "boolean")
	            return true;
	        let $schema;
	        $schema = schema.$schema;
	        if ($schema !== undefined && typeof $schema != "string") {
	            throw new Error("$schema must be a string");
	        }
	        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
	        if (!$schema) {
	            this.logger.warn("meta-schema not available");
	            this.errors = null;
	            return true;
	        }
	        const valid = this.validate($schema, schema);
	        if (!valid && throwOrLogError) {
	            const message = "schema is invalid: " + this.errorsText();
	            if (this.opts.validateSchema === "log")
	                this.logger.error(message);
	            else
	                throw new Error(message);
	        }
	        return valid;
	    }
	    // Get compiled schema by `key` or `ref`.
	    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
	    getSchema(keyRef) {
	        let sch;
	        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
	            keyRef = sch;
	        if (sch === undefined) {
	            const { schemaId } = this.opts;
	            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
	            sch = compile_1.resolveSchema.call(this, root, keyRef);
	            if (!sch)
	                return;
	            this.refs[keyRef] = sch;
	        }
	        return (sch.validate || this._compileSchemaEnv(sch));
	    }
	    // Remove cached schema(s).
	    // If no parameter is passed all schemas but meta-schemas are removed.
	    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
	    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
	    removeSchema(schemaKeyRef) {
	        if (schemaKeyRef instanceof RegExp) {
	            this._removeAllSchemas(this.schemas, schemaKeyRef);
	            this._removeAllSchemas(this.refs, schemaKeyRef);
	            return this;
	        }
	        switch (typeof schemaKeyRef) {
	            case "undefined":
	                this._removeAllSchemas(this.schemas);
	                this._removeAllSchemas(this.refs);
	                this._cache.clear();
	                return this;
	            case "string": {
	                const sch = getSchEnv.call(this, schemaKeyRef);
	                if (typeof sch == "object")
	                    this._cache.delete(sch.schema);
	                delete this.schemas[schemaKeyRef];
	                delete this.refs[schemaKeyRef];
	                return this;
	            }
	            case "object": {
	                const cacheKey = schemaKeyRef;
	                this._cache.delete(cacheKey);
	                let id = schemaKeyRef[this.opts.schemaId];
	                if (id) {
	                    id = (0, resolve_1.normalizeId)(id);
	                    delete this.schemas[id];
	                    delete this.refs[id];
	                }
	                return this;
	            }
	            default:
	                throw new Error("ajv.removeSchema: invalid parameter");
	        }
	    }
	    // add "vocabulary" - a collection of keywords
	    addVocabulary(definitions) {
	        for (const def of definitions)
	            this.addKeyword(def);
	        return this;
	    }
	    addKeyword(kwdOrDef, def // deprecated
	    ) {
	        let keyword;
	        if (typeof kwdOrDef == "string") {
	            keyword = kwdOrDef;
	            if (typeof def == "object") {
	                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
	                def.keyword = keyword;
	            }
	        }
	        else if (typeof kwdOrDef == "object" && def === undefined) {
	            def = kwdOrDef;
	            keyword = def.keyword;
	            if (Array.isArray(keyword) && !keyword.length) {
	                throw new Error("addKeywords: keyword must be string or non-empty array");
	            }
	        }
	        else {
	            throw new Error("invalid addKeywords parameters");
	        }
	        checkKeyword.call(this, keyword, def);
	        if (!def) {
	            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
	            return this;
	        }
	        keywordMetaschema.call(this, def);
	        const definition = {
	            ...def,
	            type: (0, dataType_1.getJSONTypes)(def.type),
	            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
	        };
	        (0, util_1.eachItem)(keyword, definition.type.length === 0
	            ? (k) => addRule.call(this, k, definition)
	            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
	        return this;
	    }
	    getKeyword(keyword) {
	        const rule = this.RULES.all[keyword];
	        return typeof rule == "object" ? rule.definition : !!rule;
	    }
	    // Remove keyword
	    removeKeyword(keyword) {
	        // TODO return type should be Ajv
	        const { RULES } = this;
	        delete RULES.keywords[keyword];
	        delete RULES.all[keyword];
	        for (const group of RULES.rules) {
	            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
	            if (i >= 0)
	                group.rules.splice(i, 1);
	        }
	        return this;
	    }
	    // Add format
	    addFormat(name, format) {
	        if (typeof format == "string")
	            format = new RegExp(format);
	        this.formats[name] = format;
	        return this;
	    }
	    errorsText(errors = this.errors, // optional array of validation errors
	    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
	    ) {
	        if (!errors || errors.length === 0)
	            return "No errors";
	        return errors
	            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
	            .reduce((text, msg) => text + separator + msg);
	    }
	    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
	        const rules = this.RULES.all;
	        metaSchema = JSON.parse(JSON.stringify(metaSchema));
	        for (const jsonPointer of keywordsJsonPointers) {
	            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
	            let keywords = metaSchema;
	            for (const seg of segments)
	                keywords = keywords[seg];
	            for (const key in rules) {
	                const rule = rules[key];
	                if (typeof rule != "object")
	                    continue;
	                const { $data } = rule.definition;
	                const schema = keywords[key];
	                if ($data && schema)
	                    keywords[key] = schemaOrData(schema);
	            }
	        }
	        return metaSchema;
	    }
	    _removeAllSchemas(schemas, regex) {
	        for (const keyRef in schemas) {
	            const sch = schemas[keyRef];
	            if (!regex || regex.test(keyRef)) {
	                if (typeof sch == "string") {
	                    delete schemas[keyRef];
	                }
	                else if (sch && !sch.meta) {
	                    this._cache.delete(sch.schema);
	                    delete schemas[keyRef];
	                }
	            }
	        }
	    }
	    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
	        let id;
	        const { schemaId } = this.opts;
	        if (typeof schema == "object") {
	            id = schema[schemaId];
	        }
	        else {
	            if (this.opts.jtd)
	                throw new Error("schema must be object");
	            else if (typeof schema != "boolean")
	                throw new Error("schema must be object or boolean");
	        }
	        let sch = this._cache.get(schema);
	        if (sch !== undefined)
	            return sch;
	        baseId = (0, resolve_1.normalizeId)(id || baseId);
	        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
	        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
	        this._cache.set(sch.schema, sch);
	        if (addSchema && !baseId.startsWith("#")) {
	            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
	            if (baseId)
	                this._checkUnique(baseId);
	            this.refs[baseId] = sch;
	        }
	        if (validateSchema)
	            this.validateSchema(schema, true);
	        return sch;
	    }
	    _checkUnique(id) {
	        if (this.schemas[id] || this.refs[id]) {
	            throw new Error(`schema with key or id "${id}" already exists`);
	        }
	    }
	    _compileSchemaEnv(sch) {
	        if (sch.meta)
	            this._compileMetaSchema(sch);
	        else
	            compile_1.compileSchema.call(this, sch);
	        /* istanbul ignore if */
	        if (!sch.validate)
	            throw new Error("ajv implementation error");
	        return sch.validate;
	    }
	    _compileMetaSchema(sch) {
	        const currentOpts = this.opts;
	        this.opts = this._metaOpts;
	        try {
	            compile_1.compileSchema.call(this, sch);
	        }
	        finally {
	            this.opts = currentOpts;
	        }
	    }
	}
	exports.default = Ajv;
	Ajv.ValidationError = validation_error_1.default;
	Ajv.MissingRefError = ref_error_1.default;
	function checkOptions(checkOpts, options, msg, log = "error") {
	    for (const key in checkOpts) {
	        const opt = key;
	        if (opt in options)
	            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
	    }
	}
	function getSchEnv(keyRef) {
	    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
	    return this.schemas[keyRef] || this.refs[keyRef];
	}
	function addInitialSchemas() {
	    const optsSchemas = this.opts.schemas;
	    if (!optsSchemas)
	        return;
	    if (Array.isArray(optsSchemas))
	        this.addSchema(optsSchemas);
	    else
	        for (const key in optsSchemas)
	            this.addSchema(optsSchemas[key], key);
	}
	function addInitialFormats() {
	    for (const name in this.opts.formats) {
	        const format = this.opts.formats[name];
	        if (format)
	            this.addFormat(name, format);
	    }
	}
	function addInitialKeywords(defs) {
	    if (Array.isArray(defs)) {
	        this.addVocabulary(defs);
	        return;
	    }
	    this.logger.warn("keywords option as map is deprecated, pass array");
	    for (const keyword in defs) {
	        const def = defs[keyword];
	        if (!def.keyword)
	            def.keyword = keyword;
	        this.addKeyword(def);
	    }
	}
	function getMetaSchemaOptions() {
	    const metaOpts = { ...this.opts };
	    for (const opt of META_IGNORE_OPTIONS)
	        delete metaOpts[opt];
	    return metaOpts;
	}
	const noLogs = { log() { }, warn() { }, error() { } };
	function getLogger(logger) {
	    if (logger === false)
	        return noLogs;
	    if (logger === undefined)
	        return console;
	    if (logger.log && logger.warn && logger.error)
	        return logger;
	    throw new Error("logger must implement log, warn and error methods");
	}
	const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
	function checkKeyword(keyword, def) {
	    const { RULES } = this;
	    (0, util_1.eachItem)(keyword, (kwd) => {
	        if (RULES.keywords[kwd])
	            throw new Error(`Keyword ${kwd} is already defined`);
	        if (!KEYWORD_NAME.test(kwd))
	            throw new Error(`Keyword ${kwd} has invalid name`);
	    });
	    if (!def)
	        return;
	    if (def.$data && !("code" in def || "validate" in def)) {
	        throw new Error('$data keyword must have "code" or "validate" function');
	    }
	}
	function addRule(keyword, definition, dataType) {
	    var _a;
	    const post = definition === null || definition === void 0 ? void 0 : definition.post;
	    if (dataType && post)
	        throw new Error('keyword with "post" flag cannot have "type"');
	    const { RULES } = this;
	    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
	    if (!ruleGroup) {
	        ruleGroup = { type: dataType, rules: [] };
	        RULES.rules.push(ruleGroup);
	    }
	    RULES.keywords[keyword] = true;
	    if (!definition)
	        return;
	    const rule = {
	        keyword,
	        definition: {
	            ...definition,
	            type: (0, dataType_1.getJSONTypes)(definition.type),
	            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
	        },
	    };
	    if (definition.before)
	        addBeforeRule.call(this, ruleGroup, rule, definition.before);
	    else
	        ruleGroup.rules.push(rule);
	    RULES.all[keyword] = rule;
	    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
	}
	function addBeforeRule(ruleGroup, rule, before) {
	    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
	    if (i >= 0) {
	        ruleGroup.rules.splice(i, 0, rule);
	    }
	    else {
	        ruleGroup.rules.push(rule);
	        this.logger.warn(`rule ${before} is not defined`);
	    }
	}
	function keywordMetaschema(def) {
	    let { metaSchema } = def;
	    if (metaSchema === undefined)
	        return;
	    if (def.$data && this.opts.$data)
	        metaSchema = schemaOrData(metaSchema);
	    def.validateSchema = this.compile(metaSchema, true);
	}
	const $dataRef = {
	    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
	};
	function schemaOrData(schema) {
	    return { anyOf: [schema, $dataRef] };
	}
	
} (core$3));

var draft7 = {};

var core$2 = {};

var id = {};

Object.defineProperty(id, "__esModule", { value: true });
const def$J = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
id.default = def$J;

var ref$1 = {};

Object.defineProperty(ref$1, "__esModule", { value: true });
ref$1.callRef = ref$1.getValidate = void 0;
const ref_error_1$3 = requireRef_error();
const code_1$c = code;
const codegen_1$y = requireCodegen();
const names_1$7 = names$1;
const compile_1$3 = compile;
const util_1$s = util;
const def$I = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1$3.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1$3.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1$3.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1$y._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$y.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1$y.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1$y._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref$1.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1$7.default.this : codegen_1$y.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1$y._) `await ${(0, code_1$c.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1$y._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1$c.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1$y._) `${source}.errors`;
        gen.assign(names_1$7.default.vErrors, (0, codegen_1$y._) `${names_1$7.default.vErrors} === null ? ${errs} : ${names_1$7.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1$7.default.errors, (0, codegen_1$y._) `${names_1$7.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1$s.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1$y._) `${source}.evaluated.props`);
                it.props = util_1$s.mergeEvaluated.props(gen, props, it.props, codegen_1$y.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1$s.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1$y._) `${source}.evaluated.items`);
                it.items = util_1$s.mergeEvaluated.items(gen, items, it.items, codegen_1$y.Name);
            }
        }
    }
}
ref$1.callRef = callRef;
ref$1.default = def$I;

Object.defineProperty(core$2, "__esModule", { value: true });
const id_1 = id;
const ref_1$6 = ref$1;
const core$1 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1$6.default,
];
core$2.default = core$1;

var validation$2 = {};

var limitNumber = {};

Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$x = requireCodegen();
const ops = codegen_1$x.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error$n = {
    message: ({ keyword, schemaCode }) => (0, codegen_1$x.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1$x._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def$H = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$n,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1$x._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
limitNumber.default = def$H;

var multipleOf = {};

Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$w = requireCodegen();
const error$m = {
    message: ({ schemaCode }) => (0, codegen_1$w.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1$w._) `{multipleOf: ${schemaCode}}`,
};
const def$G = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$m,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1$w._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1$w._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1$w._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
multipleOf.default = def$G;

var limitLength = {};

var ucs2length$1 = {};

Object.defineProperty(ucs2length$1, "__esModule", { value: true });
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';

Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$v = requireCodegen();
const util_1$r = util;
const ucs2length_1 = ucs2length$1;
const error$l = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1$v.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1$v._) `{limit: ${schemaCode}}`,
};
const def$F = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$l,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1$v.operators.GT : codegen_1$v.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1$v._) `${data}.length` : (0, codegen_1$v._) `${(0, util_1$r.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1$v._) `${len} ${op} ${schemaCode}`);
    },
};
limitLength.default = def$F;

var pattern = {};

Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$b = code;
const codegen_1$u = requireCodegen();
const error$k = {
    message: ({ schemaCode }) => (0, codegen_1$u.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$u._) `{pattern: ${schemaCode}}`,
};
const def$E = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$k,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1$u._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1$b.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1$u._) `!${regExp}.test(${data})`);
    },
};
pattern.default = def$E;

var limitProperties = {};

Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$t = requireCodegen();
const error$j = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1$t.str) `must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1$t._) `{limit: ${schemaCode}}`,
};
const def$D = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$j,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1$t.operators.GT : codegen_1$t.operators.LT;
        cxt.fail$data((0, codegen_1$t._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
limitProperties.default = def$D;

var required = {};

Object.defineProperty(required, "__esModule", { value: true });
const code_1$a = code;
const codegen_1$s = requireCodegen();
const util_1$q = util;
const error$i = {
    message: ({ params: { missingProperty } }) => (0, codegen_1$s.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1$s._) `{missingProperty: ${missingProperty}}`,
};
const def$C = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$i,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1$q.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1$s.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1$a.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1$a.checkMissingProp)(cxt, schema, missing));
                (0, code_1$a.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1$a.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1$a.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1$s.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1$s.nil);
        }
    },
};
required.default = def$C;

var limitItems = {};

Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$r = requireCodegen();
const error$h = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1$r.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$r._) `{limit: ${schemaCode}}`,
};
const def$B = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$h,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1$r.operators.GT : codegen_1$r.operators.LT;
        cxt.fail$data((0, codegen_1$r._) `${data}.length ${op} ${schemaCode}`);
    },
};
limitItems.default = def$B;

var uniqueItems = {};

var equal$1 = {};

Object.defineProperty(equal$1, "__esModule", { value: true });
// https://github.com/ajv-validator/ajv/issues/889
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;

Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$q = requireCodegen();
const util_1$p = util;
const equal_1$2 = equal$1;
const error$g = {
    message: ({ params: { i, j } }) => (0, codegen_1$q.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1$q._) `{i: ${i}, j: ${j}}`,
};
const def$A = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$g,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1$q._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1$q._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1$q._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1$q._) `{}`);
            gen.for((0, codegen_1$q._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1$q._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1$q._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1$q._) `typeof ${item} == "string"`, (0, codegen_1$q._) `${item} += "_"`);
                gen
                    .if((0, codegen_1$q._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1$q._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1$q._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1$p.useFunc)(gen, equal_1$2.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1$q._) `;${i}--;`, () => gen.for((0, codegen_1$q._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1$q._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
uniqueItems.default = def$A;

var _const = {};

Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$p = requireCodegen();
const util_1$o = util;
const equal_1$1 = equal$1;
const error$f = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1$p._) `{allowedValue: ${schemaCode}}`,
};
const def$z = {
    keyword: "const",
    $data: true,
    error: error$f,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1$p._) `!${(0, util_1$o.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1$p._) `${schema} !== ${data}`);
        }
    },
};
_const.default = def$z;

var _enum$1 = {};

Object.defineProperty(_enum$1, "__esModule", { value: true });
const codegen_1$o = requireCodegen();
const util_1$n = util;
const equal_1 = equal$1;
const error$e = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$o._) `{allowedValues: ${schemaCode}}`,
};
const def$y = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$e,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1$n.useFunc)(gen, equal_1.default)));
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1$o.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1$o._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1$o._) `${getEql()}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1$o._) `${data} === ${sch}`;
        }
    },
};
_enum$1.default = def$y;

Object.defineProperty(validation$2, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1$1 = _enum$1;
const validation$1 = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1$1.default,
];
validation$2.default = validation$1;

var applicator$1 = {};

var additionalItems = {};

Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$n = requireCodegen();
const util_1$m = util;
const error$d = {
    message: ({ params: { len } }) => (0, codegen_1$n.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$n._) `{limit: ${len}}`,
};
const def$x = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$d,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1$m.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1$n._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1$n._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1$m.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1$n._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1$n.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1$m.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1$n.not)(valid), () => gen.break());
        });
    }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$x;

var prefixItems = {};

var items = {};

Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$m = requireCodegen();
const util_1$l = util;
const code_1$9 = code;
const def$w = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1$l.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1$9.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1$l.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1$m._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1$l.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1$m._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1$l.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
items.validateTuple = validateTuple;
items.default = def$w;

Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$v = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items"),
};
prefixItems.default = def$v;

var items2020 = {};

Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$l = requireCodegen();
const util_1$k = util;
const code_1$8 = code;
const additionalItems_1$1 = additionalItems;
const error$c = {
    message: ({ params: { len } }) => (0, codegen_1$l.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$l._) `{limit: ${len}}`,
};
const def$u = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error$c,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1$k.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1$8.validateArray)(cxt));
    },
};
items2020.default = def$u;

var contains = {};

Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$k = requireCodegen();
const util_1$j = util;
const error$b = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1$k.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1$k.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1$k._) `{minContains: ${min}}` : (0, codegen_1$k._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def$t = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$b,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1$k._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1$j.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1$j.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1$j.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1$k._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1$k._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1$k._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1$j.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1$k._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1$k._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1$k._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1$k._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
contains.default = def$t;

var dependencies = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = util;
	const code_1 = code;
	exports.error = {
	    message: ({ params: { property, depsCount, deps } }) => {
	        const property_ies = depsCount === 1 ? "property" : "properties";
	        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
	    },
	    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
	};
	const def = {
	    keyword: "dependencies",
	    type: "object",
	    schemaType: "object",
	    error: exports.error,
	    code(cxt) {
	        const [propDeps, schDeps] = splitDependencies(cxt);
	        validatePropertyDeps(cxt, propDeps);
	        validateSchemaDeps(cxt, schDeps);
	    },
	};
	function splitDependencies({ schema }) {
	    const propertyDeps = {};
	    const schemaDeps = {};
	    for (const key in schema) {
	        if (key === "__proto__")
	            continue;
	        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
	        deps[key] = schema[key];
	    }
	    return [propertyDeps, schemaDeps];
	}
	function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
	    const { gen, data, it } = cxt;
	    if (Object.keys(propertyDeps).length === 0)
	        return;
	    const missing = gen.let("missing");
	    for (const prop in propertyDeps) {
	        const deps = propertyDeps[prop];
	        if (deps.length === 0)
	            continue;
	        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
	        cxt.setParams({
	            property: prop,
	            depsCount: deps.length,
	            deps: deps.join(", "),
	        });
	        if (it.allErrors) {
	            gen.if(hasProperty, () => {
	                for (const depProp of deps) {
	                    (0, code_1.checkReportMissingProp)(cxt, depProp);
	                }
	            });
	        }
	        else {
	            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
	            (0, code_1.reportMissingProp)(cxt, missing);
	            gen.else();
	        }
	    }
	}
	exports.validatePropertyDeps = validatePropertyDeps;
	function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    for (const prop in schemaDeps) {
	        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
	            continue;
	        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
	            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
	            cxt.mergeValidEvaluated(schCxt, valid);
	        }, () => gen.var(valid, true) // TODO var
	        );
	        cxt.ok(valid);
	    }
	}
	exports.validateSchemaDeps = validateSchemaDeps;
	exports.default = def;
	
} (dependencies));

var propertyNames = {};

Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$j = requireCodegen();
const util_1$i = util;
const error$a = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1$j._) `{propertyName: ${params.propertyName}}`,
};
const def$s = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$a,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1$i.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1$j.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
propertyNames.default = def$s;

var additionalProperties = {};

Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$i = requireCodegen();
const names_1$6 = names$1;
const util_1$h = util;
const error$9 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1$i._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def$r = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$9,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1$h.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1$7.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1$7.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1$i._) `${errsCount} === ${names_1$6.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1$h.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1$7.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1$i.or)(...props.map((p) => (0, codegen_1$i._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1$i.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1$i.or)(definedProp, ...patProps.map((p) => (0, codegen_1$i._) `${(0, code_1$7.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1$i.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1$i._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1$h.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1$i.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1$i.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1$h.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
additionalProperties.default = def$r;

var properties$a = {};

Object.defineProperty(properties$a, "__esModule", { value: true });
const validate_1 = requireValidate();
const code_1$6 = code;
const util_1$g = util;
const additionalProperties_1$1 = additionalProperties;
const def$q = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
        }
        const allProps = (0, code_1$6.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1$g.mergeEvaluated.props(gen, (0, util_1$g.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1$g.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1$6.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
properties$a.default = def$q;

var patternProperties = {};

Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$5 = code;
const codegen_1$h = requireCodegen();
const util_1$f = util;
const util_2 = util;
const def$p = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1$5.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1$f.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1$h.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1$f.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1$h._) `${(0, code_1$5.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1$h._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1$h.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
patternProperties.default = def$p;

var not = {};

Object.defineProperty(not, "__esModule", { value: true });
const util_1$e = util;
const def$o = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1$e.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
not.default = def$o;

var anyOf = {};

Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1$4 = code;
const def$n = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1$4.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
anyOf.default = def$n;

var oneOf = {};

Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$g = requireCodegen();
const util_1$d = util;
const error$8 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1$g._) `{passingSchemas: ${params.passing}}`,
};
const def$m = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$8,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1$d.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1$g._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1$g._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1$g.Name);
                });
            });
        }
    },
};
oneOf.default = def$m;

var allOf$1 = {};

Object.defineProperty(allOf$1, "__esModule", { value: true });
const util_1$c = util;
const def$l = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1$c.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
allOf$1.default = def$l;

var _if = {};

Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$f = requireCodegen();
const util_1$b = util;
const error$7 = {
    message: ({ params }) => (0, codegen_1$f.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1$f._) `{failingKeyword: ${params.ifClause}}`,
};
const def$k = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$7,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1$b.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1$f.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1$f._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1$b.alwaysValidSchema)(it, schema);
}
_if.default = def$k;

var thenElse = {};

Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$a = util;
const def$j = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1$a.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
thenElse.default = def$j;

Object.defineProperty(applicator$1, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1$2 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1$2 = properties$a;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf$1;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1$2.default,
        properties_1$2.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
applicator$1.default = getApplicator;

var format$3 = {};

var format$2 = {};

Object.defineProperty(format$2, "__esModule", { value: true });
const codegen_1$e = requireCodegen();
const error$6 = {
    message: ({ schemaCode }) => (0, codegen_1$e.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$e._) `{format: ${schemaCode}}`,
};
const def$i = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$6,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1$e._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1$e._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$e._) `${fDef}.type || "string"`).assign(format, (0, codegen_1$e._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$e._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1$e.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1$e.nil;
                return (0, codegen_1$e._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1$e._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1$e._) `${format}(${data})`;
                const validData = (0, codegen_1$e._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1$e._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1$e.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1$e._) `${opts.code.formats}${(0, codegen_1$e.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$e._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1$e._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1$e._) `${fmtRef}(${data})` : (0, codegen_1$e._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
format$2.default = def$i;

Object.defineProperty(format$3, "__esModule", { value: true });
const format_1$2 = format$2;
const format$1 = [format_1$2.default];
format$3.default = format$1;

var metadata$2 = {};

Object.defineProperty(metadata$2, "__esModule", { value: true });
metadata$2.contentVocabulary = metadata$2.metadataVocabulary = void 0;
metadata$2.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
metadata$2.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];

Object.defineProperty(draft7, "__esModule", { value: true });
const core_1$1 = core$2;
const validation_1$1 = validation$2;
const applicator_1$1 = applicator$1;
const format_1$1 = format$3;
const metadata_1$7 = metadata$2;
const draft7Vocabularies = [
    core_1$1.default,
    validation_1$1.default,
    (0, applicator_1$1.default)(),
    format_1$1.default,
    metadata_1$7.metadataVocabulary,
    metadata_1$7.contentVocabulary,
];
draft7.default = draft7Vocabularies;

var discriminator$1 = {};

var types$1 = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DiscrError = void 0;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(exports.DiscrError || (exports.DiscrError = {}));
	
} (types$1));

Object.defineProperty(discriminator$1, "__esModule", { value: true });
const codegen_1$d = requireCodegen();
const types_1$3 = types$1;
const compile_1$2 = compile;
const util_1$9 = util;
const error$5 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1$3.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$d._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def$h = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error$5,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1$d._) `${data}${(0, codegen_1$d.getProperty)(tagName)}`);
        gen.if((0, codegen_1$d._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1$3.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1$d._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1$3.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1$d.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$9.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    sch = compile_1$2.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
                    if (sch instanceof compile_1$2.SchemaEnv)
                        sch = sch.schema;
                }
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
discriminator$1.default = def$h;

var $schema$8 = "http://json-schema.org/draft-07/schema#";
var $id$8 = "http://json-schema.org/draft-07/schema#";
var title$8 = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$9 = [
	"object",
	"boolean"
];
var properties$9 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3$1 = {
	$schema: $schema$8,
	$id: $id$8,
	title: title$8,
	definitions: definitions,
	type: type$9,
	properties: properties$9,
	"default": true
};

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	const core_1 = core$3;
	const draft7_1 = draft7;
	const discriminator_1 = discriminator$1;
	const draft7MetaSchema = require$$3$1;
	const META_SUPPORT_DATA = ["/properties"];
	const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
	class Ajv extends core_1.default {
	    _addVocabularies() {
	        super._addVocabularies();
	        draft7_1.default.forEach((v) => this.addVocabulary(v));
	        if (this.opts.discriminator)
	            this.addKeyword(discriminator_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        if (!this.opts.meta)
	            return;
	        const metaSchema = this.opts.$data
	            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
	            : draft7MetaSchema;
	        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
	        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	}
	module.exports = exports = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	var validation_error_1 = requireValidation_error();
	Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
	var ref_error_1 = requireRef_error();
	Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
	
} (ajv$l, ajv$l.exports));

var ajvExports = ajv$l.exports;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.formatLimitDefinition = void 0;
	const ajv_1 = ajvExports;
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	exports.formatLimitDefinition = {
	    keyword: Object.keys(KWDs),
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, keyword, it } = cxt;
	        const { opts, self } = it;
	        if (!opts.validateFormats)
	            return;
	        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
	        if (fCxt.$data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fmt = gen.const("fmt", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);
	            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != "object"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
	        }
	        function validateFormat() {
	            const format = fCxt.schema;
	            const fmtDef = self.formats[format];
	            if (!fmtDef || fmtDef === true)
	                return;
	            if (typeof fmtDef != "object" ||
	                fmtDef instanceof RegExp ||
	                typeof fmtDef.compare != "function") {
	                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
	            }
	            const fmt = gen.scopeValue("formats", {
	                key: format,
	                ref: fmtDef,
	                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,
	            });
	            cxt.fail$data(compareCode(fmt));
	        }
	        function compareCode(fmt) {
	            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
	        }
	    },
	    dependencies: ["format"],
	};
	const formatLimitPlugin = (ajv) => {
	    ajv.addKeyword(exports.formatLimitDefinition);
	    return ajv;
	};
	exports.default = formatLimitPlugin;
	
} (limit));

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	const formats_1 = formats;
	const limit_1 = limit;
	const codegen_1 = requireCodegen();
	const fullName = new codegen_1.Name("fullFormats");
	const fastName = new codegen_1.Name("fastFormats");
	const formatsPlugin = (ajv, opts = { keywords: true }) => {
	    if (Array.isArray(opts)) {
	        addFormats(ajv, opts, formats_1.fullFormats, fullName);
	        return ajv;
	    }
	    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
	    const list = opts.formats || formats_1.formatNames;
	    addFormats(ajv, list, formats, exportName);
	    if (opts.keywords)
	        limit_1.default(ajv);
	    return ajv;
	};
	formatsPlugin.get = (name, mode = "full") => {
	    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
	    const f = formats[name];
	    if (!f)
	        throw new Error(`Unknown format "${name}"`);
	    return f;
	};
	function addFormats(ajv, list, fs, exportName) {
	    var _a;
	    var _b;
	    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = codegen_1._ `require("ajv-formats/dist/formats").${exportName}`);
	    for (const f of list)
	        ajv.addFormat(f, fs[f]);
	}
	module.exports = exports = formatsPlugin;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = formatsPlugin;
	
} (dist, dist.exports));

var distExports = dist.exports;
var addFormats = /*@__PURE__*/getDefaultExportFromCjs(distExports);

var _2020 = {exports: {}};

var draft2020 = {};

var dynamic$1 = {};

var dynamicAnchor$1 = {};

Object.defineProperty(dynamicAnchor$1, "__esModule", { value: true });
dynamicAnchor$1.dynamicAnchor = void 0;
const codegen_1$c = requireCodegen();
const names_1$5 = names$1;
const compile_1$1 = compile;
const ref_1$5 = ref$1;
const def$g = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (cxt) => dynamicAnchor(cxt, cxt.schema),
};
function dynamicAnchor(cxt, anchor) {
    const { gen, it } = cxt;
    it.schemaEnv.root.dynamicAnchors[anchor] = true;
    const v = (0, codegen_1$c._) `${names_1$5.default.dynamicAnchors}${(0, codegen_1$c.getProperty)(anchor)}`;
    const validate = it.errSchemaPath === "#" ? it.validateName : _getValidate(cxt);
    gen.if((0, codegen_1$c._) `!${v}`, () => gen.assign(v, validate));
}
dynamicAnchor$1.dynamicAnchor = dynamicAnchor;
function _getValidate(cxt) {
    const { schemaEnv, schema, self } = cxt.it;
    const { root, baseId, localRefs, meta } = schemaEnv.root;
    const { schemaId } = self.opts;
    const sch = new compile_1$1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
    compile_1$1.compileSchema.call(self, sch);
    return (0, ref_1$5.getValidate)(cxt, sch);
}
dynamicAnchor$1.default = def$g;

var dynamicRef$1 = {};

Object.defineProperty(dynamicRef$1, "__esModule", { value: true });
dynamicRef$1.dynamicRef = void 0;
const codegen_1$b = requireCodegen();
const names_1$4 = names$1;
const ref_1$4 = ref$1;
const def$f = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (cxt) => dynamicRef(cxt, cxt.schema),
};
function dynamicRef(cxt, ref) {
    const { gen, keyword, it } = cxt;
    if (ref[0] !== "#")
        throw new Error(`"${keyword}" only supports hash fragment reference`);
    const anchor = ref.slice(1);
    if (it.allErrors) {
        _dynamicRef();
    }
    else {
        const valid = gen.let("valid", false);
        _dynamicRef(valid);
        cxt.ok(valid);
    }
    function _dynamicRef(valid) {
        // TODO the assumption here is that `recursiveRef: #` always points to the root
        // of the schema object, which is not correct, because there may be $id that
        // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.
        // Because of that 2 tests in recursiveRef.json fail.
        // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ "$ref": "#" }`).
        // (This problem is not tested in JSON-Schema-Test-Suite)
        if (it.schemaEnv.root.dynamicAnchors[anchor]) {
            const v = gen.let("_v", (0, codegen_1$b._) `${names_1$4.default.dynamicAnchors}${(0, codegen_1$b.getProperty)(anchor)}`);
            gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));
        }
        else {
            _callRef(it.validateName, valid)();
        }
    }
    function _callRef(validate, valid) {
        return valid
            ? () => gen.block(() => {
                (0, ref_1$4.callRef)(cxt, validate);
                gen.let(valid, true);
            })
            : () => (0, ref_1$4.callRef)(cxt, validate);
    }
}
dynamicRef$1.dynamicRef = dynamicRef;
dynamicRef$1.default = def$f;

var recursiveAnchor = {};

Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
const dynamicAnchor_1$1 = dynamicAnchor$1;
const util_1$8 = util;
const def$e = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(cxt) {
        if (cxt.schema)
            (0, dynamicAnchor_1$1.dynamicAnchor)(cxt, "");
        else
            (0, util_1$8.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
    },
};
recursiveAnchor.default = def$e;

var recursiveRef = {};

Object.defineProperty(recursiveRef, "__esModule", { value: true });
const dynamicRef_1$1 = dynamicRef$1;
const def$d = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (cxt) => (0, dynamicRef_1$1.dynamicRef)(cxt, cxt.schema),
};
recursiveRef.default = def$d;

Object.defineProperty(dynamic$1, "__esModule", { value: true });
const dynamicAnchor_1 = dynamicAnchor$1;
const dynamicRef_1 = dynamicRef$1;
const recursiveAnchor_1 = recursiveAnchor;
const recursiveRef_1 = recursiveRef;
const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
dynamic$1.default = dynamic;

var next$1 = {};

var dependentRequired = {};

Object.defineProperty(dependentRequired, "__esModule", { value: true });
const dependencies_1$1 = dependencies;
const def$c = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: dependencies_1$1.error,
    code: (cxt) => (0, dependencies_1$1.validatePropertyDeps)(cxt),
};
dependentRequired.default = def$c;

var dependentSchemas = {};

Object.defineProperty(dependentSchemas, "__esModule", { value: true });
const dependencies_1 = dependencies;
const def$b = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),
};
dependentSchemas.default = def$b;

var limitContains = {};

Object.defineProperty(limitContains, "__esModule", { value: true });
const util_1$7 = util;
const def$a = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword, parentSchema, it }) {
        if (parentSchema.contains === undefined) {
            (0, util_1$7.checkStrictMode)(it, `"${keyword}" without "contains" is ignored`);
        }
    },
};
limitContains.default = def$a;

Object.defineProperty(next$1, "__esModule", { value: true });
const dependentRequired_1 = dependentRequired;
const dependentSchemas_1 = dependentSchemas;
const limitContains_1 = limitContains;
const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
next$1.default = next;

var unevaluated$2 = {};

var unevaluatedProperties = {};

Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
const codegen_1$a = requireCodegen();
const util_1$6 = util;
const names_1$3 = names$1;
const error$4 = {
    message: "must NOT have unevaluated properties",
    params: ({ params }) => (0, codegen_1$a._) `{unevaluatedProperty: ${params.unevaluatedProperty}}`,
};
const def$9 = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: true,
    error: error$4,
    code(cxt) {
        const { gen, schema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, props } = it;
        if (props instanceof codegen_1$a.Name) {
            gen.if((0, codegen_1$a._) `${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
        }
        else if (props !== true) {
            gen.forIn("key", data, (key) => props === undefined
                ? unevaluatedPropCode(key)
                : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
        }
        it.props = true;
        cxt.ok((0, codegen_1$a._) `${errsCount} === ${names_1$3.default.errors}`);
        function unevaluatedPropCode(key) {
            if (schema === false) {
                cxt.setParams({ unevaluatedProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (!(0, util_1$6.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                cxt.subschema({
                    keyword: "unevaluatedProperties",
                    dataProp: key,
                    dataPropType: util_1$6.Type.Str,
                }, valid);
                if (!allErrors)
                    gen.if((0, codegen_1$a.not)(valid), () => gen.break());
            }
        }
        function unevaluatedDynamic(evaluatedProps, key) {
            return (0, codegen_1$a._) `!${evaluatedProps} || !${evaluatedProps}[${key}]`;
        }
        function unevaluatedStatic(evaluatedProps, key) {
            const ps = [];
            for (const p in evaluatedProps) {
                if (evaluatedProps[p] === true)
                    ps.push((0, codegen_1$a._) `${key} !== ${p}`);
            }
            return (0, codegen_1$a.and)(...ps);
        }
    },
};
unevaluatedProperties.default = def$9;

var unevaluatedItems = {};

Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
const codegen_1$9 = requireCodegen();
const util_1$5 = util;
const error$3 = {
    message: ({ params: { len } }) => (0, codegen_1$9.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$9._) `{limit: ${len}}`,
};
const def$8 = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: error$3,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        const items = it.items || 0;
        if (items === true)
            return;
        const len = gen.const("len", (0, codegen_1$9._) `${data}.length`);
        if (schema === false) {
            cxt.setParams({ len: items });
            cxt.fail((0, codegen_1$9._) `${len} > ${items}`);
        }
        else if (typeof schema == "object" && !(0, util_1$5.alwaysValidSchema)(it, schema)) {
            const valid = gen.var("valid", (0, codegen_1$9._) `${len} <= ${items}`);
            gen.if((0, codegen_1$9.not)(valid), () => validateItems(valid, items));
            cxt.ok(valid);
        }
        it.items = true;
        function validateItems(valid, from) {
            gen.forRange("i", from, len, (i) => {
                cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1$5.Type.Num }, valid);
                if (!it.allErrors)
                    gen.if((0, codegen_1$9.not)(valid), () => gen.break());
            });
        }
    },
};
unevaluatedItems.default = def$8;

Object.defineProperty(unevaluated$2, "__esModule", { value: true });
const unevaluatedProperties_1 = unevaluatedProperties;
const unevaluatedItems_1 = unevaluatedItems;
const unevaluated$1 = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
unevaluated$2.default = unevaluated$1;

Object.defineProperty(draft2020, "__esModule", { value: true });
const core_1 = core$2;
const validation_1 = validation$2;
const applicator_1 = applicator$1;
const dynamic_1 = dynamic$1;
const next_1 = next$1;
const unevaluated_1 = unevaluated$2;
const format_1 = format$3;
const metadata_1$6 = metadata$2;
const draft2020Vocabularies = [
    dynamic_1.default,
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(true),
    format_1.default,
    metadata_1$6.metadataVocabulary,
    metadata_1$6.contentVocabulary,
    next_1.default,
    unevaluated_1.default,
];
draft2020.default = draft2020Vocabularies;

var jsonSchema202012 = {};

var $schema$7 = "https://json-schema.org/draft/2020-12/schema";
var $id$7 = "https://json-schema.org/draft/2020-12/schema";
var $vocabulary$7 = {
	"https://json-schema.org/draft/2020-12/vocab/core": true,
	"https://json-schema.org/draft/2020-12/vocab/applicator": true,
	"https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
	"https://json-schema.org/draft/2020-12/vocab/validation": true,
	"https://json-schema.org/draft/2020-12/vocab/meta-data": true,
	"https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
	"https://json-schema.org/draft/2020-12/vocab/content": true
};
var $dynamicAnchor$7 = "meta";
var title$7 = "Core and Validation specifications meta-schema";
var allOf = [
	{
		$ref: "meta/core"
	},
	{
		$ref: "meta/applicator"
	},
	{
		$ref: "meta/unevaluated"
	},
	{
		$ref: "meta/validation"
	},
	{
		$ref: "meta/meta-data"
	},
	{
		$ref: "meta/format-annotation"
	},
	{
		$ref: "meta/content"
	}
];
var type$8 = [
	"object",
	"boolean"
];
var $comment = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.";
var properties$8 = {
	definitions: {
		$comment: "\"definitions\" has been replaced by \"$defs\".",
		type: "object",
		additionalProperties: {
			$dynamicRef: "#meta"
		},
		deprecated: true,
		"default": {
		}
	},
	dependencies: {
		$comment: "\"dependencies\" has been split and replaced by \"dependentSchemas\" and \"dependentRequired\" in order to serve their differing semantics.",
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$dynamicRef: "#meta"
				},
				{
					$ref: "meta/validation#/$defs/stringArray"
				}
			]
		},
		deprecated: true,
		"default": {
		}
	},
	$recursiveAnchor: {
		$comment: "\"$recursiveAnchor\" has been replaced by \"$dynamicAnchor\".",
		$ref: "meta/core#/$defs/anchorString",
		deprecated: true
	},
	$recursiveRef: {
		$comment: "\"$recursiveRef\" has been replaced by \"$dynamicRef\".",
		$ref: "meta/core#/$defs/uriReferenceString",
		deprecated: true
	}
};
var require$$0 = {
	$schema: $schema$7,
	$id: $id$7,
	$vocabulary: $vocabulary$7,
	$dynamicAnchor: $dynamicAnchor$7,
	title: title$7,
	allOf: allOf,
	type: type$8,
	$comment: $comment,
	properties: properties$8
};

var $schema$6 = "https://json-schema.org/draft/2020-12/schema";
var $id$6 = "https://json-schema.org/draft/2020-12/meta/applicator";
var $vocabulary$6 = {
	"https://json-schema.org/draft/2020-12/vocab/applicator": true
};
var $dynamicAnchor$6 = "meta";
var title$6 = "Applicator vocabulary meta-schema";
var type$7 = [
	"object",
	"boolean"
];
var properties$7 = {
	prefixItems: {
		$ref: "#/$defs/schemaArray"
	},
	items: {
		$dynamicRef: "#meta"
	},
	contains: {
		$dynamicRef: "#meta"
	},
	additionalProperties: {
		$dynamicRef: "#meta"
	},
	properties: {
		type: "object",
		additionalProperties: {
			$dynamicRef: "#meta"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$dynamicRef: "#meta"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependentSchemas: {
		type: "object",
		additionalProperties: {
			$dynamicRef: "#meta"
		},
		"default": {
		}
	},
	propertyNames: {
		$dynamicRef: "#meta"
	},
	"if": {
		$dynamicRef: "#meta"
	},
	then: {
		$dynamicRef: "#meta"
	},
	"else": {
		$dynamicRef: "#meta"
	},
	allOf: {
		$ref: "#/$defs/schemaArray"
	},
	anyOf: {
		$ref: "#/$defs/schemaArray"
	},
	oneOf: {
		$ref: "#/$defs/schemaArray"
	},
	not: {
		$dynamicRef: "#meta"
	}
};
var $defs$2 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$dynamicRef: "#meta"
		}
	}
};
var require$$1 = {
	$schema: $schema$6,
	$id: $id$6,
	$vocabulary: $vocabulary$6,
	$dynamicAnchor: $dynamicAnchor$6,
	title: title$6,
	type: type$7,
	properties: properties$7,
	$defs: $defs$2
};

var $schema$5 = "https://json-schema.org/draft/2020-12/schema";
var $id$5 = "https://json-schema.org/draft/2020-12/meta/unevaluated";
var $vocabulary$5 = {
	"https://json-schema.org/draft/2020-12/vocab/unevaluated": true
};
var $dynamicAnchor$5 = "meta";
var title$5 = "Unevaluated applicator vocabulary meta-schema";
var type$6 = [
	"object",
	"boolean"
];
var properties$6 = {
	unevaluatedItems: {
		$dynamicRef: "#meta"
	},
	unevaluatedProperties: {
		$dynamicRef: "#meta"
	}
};
var require$$2 = {
	$schema: $schema$5,
	$id: $id$5,
	$vocabulary: $vocabulary$5,
	$dynamicAnchor: $dynamicAnchor$5,
	title: title$5,
	type: type$6,
	properties: properties$6
};

var $schema$4 = "https://json-schema.org/draft/2020-12/schema";
var $id$4 = "https://json-schema.org/draft/2020-12/meta/content";
var $vocabulary$4 = {
	"https://json-schema.org/draft/2020-12/vocab/content": true
};
var $dynamicAnchor$4 = "meta";
var title$4 = "Content vocabulary meta-schema";
var type$5 = [
	"object",
	"boolean"
];
var properties$5 = {
	contentEncoding: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentSchema: {
		$dynamicRef: "#meta"
	}
};
var require$$3 = {
	$schema: $schema$4,
	$id: $id$4,
	$vocabulary: $vocabulary$4,
	$dynamicAnchor: $dynamicAnchor$4,
	title: title$4,
	type: type$5,
	properties: properties$5
};

var $schema$3 = "https://json-schema.org/draft/2020-12/schema";
var $id$3 = "https://json-schema.org/draft/2020-12/meta/core";
var $vocabulary$3 = {
	"https://json-schema.org/draft/2020-12/vocab/core": true
};
var $dynamicAnchor$3 = "meta";
var title$3 = "Core vocabulary meta-schema";
var type$4 = [
	"object",
	"boolean"
];
var properties$4 = {
	$id: {
		$ref: "#/$defs/uriReferenceString",
		$comment: "Non-empty fragments not allowed.",
		pattern: "^[^#]*#?$"
	},
	$schema: {
		$ref: "#/$defs/uriString"
	},
	$ref: {
		$ref: "#/$defs/uriReferenceString"
	},
	$anchor: {
		$ref: "#/$defs/anchorString"
	},
	$dynamicRef: {
		$ref: "#/$defs/uriReferenceString"
	},
	$dynamicAnchor: {
		$ref: "#/$defs/anchorString"
	},
	$vocabulary: {
		type: "object",
		propertyNames: {
			$ref: "#/$defs/uriString"
		},
		additionalProperties: {
			type: "boolean"
		}
	},
	$comment: {
		type: "string"
	},
	$defs: {
		type: "object",
		additionalProperties: {
			$dynamicRef: "#meta"
		}
	}
};
var $defs$1 = {
	anchorString: {
		type: "string",
		pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
	},
	uriString: {
		type: "string",
		format: "uri"
	},
	uriReferenceString: {
		type: "string",
		format: "uri-reference"
	}
};
var require$$4 = {
	$schema: $schema$3,
	$id: $id$3,
	$vocabulary: $vocabulary$3,
	$dynamicAnchor: $dynamicAnchor$3,
	title: title$3,
	type: type$4,
	properties: properties$4,
	$defs: $defs$1
};

var $schema$2 = "https://json-schema.org/draft/2020-12/schema";
var $id$2 = "https://json-schema.org/draft/2020-12/meta/format-annotation";
var $vocabulary$2 = {
	"https://json-schema.org/draft/2020-12/vocab/format-annotation": true
};
var $dynamicAnchor$2 = "meta";
var title$2 = "Format vocabulary meta-schema for annotation results";
var type$3 = [
	"object",
	"boolean"
];
var properties$3 = {
	format: {
		type: "string"
	}
};
var require$$5 = {
	$schema: $schema$2,
	$id: $id$2,
	$vocabulary: $vocabulary$2,
	$dynamicAnchor: $dynamicAnchor$2,
	title: title$2,
	type: type$3,
	properties: properties$3
};

var $schema$1 = "https://json-schema.org/draft/2020-12/schema";
var $id$1 = "https://json-schema.org/draft/2020-12/meta/meta-data";
var $vocabulary$1 = {
	"https://json-schema.org/draft/2020-12/vocab/meta-data": true
};
var $dynamicAnchor$1 = "meta";
var title$1 = "Meta-data vocabulary meta-schema";
var type$2 = [
	"object",
	"boolean"
];
var properties$2 = {
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	deprecated: {
		type: "boolean",
		"default": false
	},
	readOnly: {
		type: "boolean",
		"default": false
	},
	writeOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	}
};
var require$$6 = {
	$schema: $schema$1,
	$id: $id$1,
	$vocabulary: $vocabulary$1,
	$dynamicAnchor: $dynamicAnchor$1,
	title: title$1,
	type: type$2,
	properties: properties$2
};

var $schema = "https://json-schema.org/draft/2020-12/schema";
var $id = "https://json-schema.org/draft/2020-12/meta/validation";
var $vocabulary = {
	"https://json-schema.org/draft/2020-12/vocab/validation": true
};
var $dynamicAnchor = "meta";
var title = "Validation vocabulary meta-schema";
var type$1 = [
	"object",
	"boolean"
];
var properties$1 = {
	type: {
		anyOf: [
			{
				$ref: "#/$defs/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/$defs/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	"const": true,
	"enum": {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/$defs/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/$defs/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	maxItems: {
		$ref: "#/$defs/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/$defs/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	maxContains: {
		$ref: "#/$defs/nonNegativeInteger"
	},
	minContains: {
		$ref: "#/$defs/nonNegativeInteger",
		"default": 1
	},
	maxProperties: {
		$ref: "#/$defs/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/$defs/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/$defs/stringArray"
	},
	dependentRequired: {
		type: "object",
		additionalProperties: {
			$ref: "#/$defs/stringArray"
		}
	}
};
var $defs = {
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		$ref: "#/$defs/nonNegativeInteger",
		"default": 0
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var require$$7 = {
	$schema: $schema,
	$id: $id,
	$vocabulary: $vocabulary,
	$dynamicAnchor: $dynamicAnchor,
	title: title,
	type: type$1,
	properties: properties$1,
	$defs: $defs
};

Object.defineProperty(jsonSchema202012, "__esModule", { value: true });
const metaSchema = require$$0;
const applicator = require$$1;
const unevaluated = require$$2;
const content = require$$3;
const core = require$$4;
const format = require$$5;
const metadata$1 = require$$6;
const validation = require$$7;
const META_SUPPORT_DATA = ["/properties"];
function addMetaSchema2020($data) {
    [
        metaSchema,
        applicator,
        unevaluated,
        content,
        core,
        with$data(this, format),
        metadata$1,
        with$data(this, validation),
    ].forEach((sch) => this.addMetaSchema(sch, undefined, false));
    return this;
    function with$data(ajv, sch) {
        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
    }
}
jsonSchema202012.default = addMetaSchema2020;

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	const core_1 = core$3;
	const draft2020_1 = draft2020;
	const discriminator_1 = discriminator$1;
	const json_schema_2020_12_1 = jsonSchema202012;
	const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
	class Ajv2020 extends core_1.default {
	    constructor(opts = {}) {
	        super({
	            ...opts,
	            dynamicRef: true,
	            next: true,
	            unevaluated: true,
	        });
	    }
	    _addVocabularies() {
	        super._addVocabularies();
	        draft2020_1.default.forEach((v) => this.addVocabulary(v));
	        if (this.opts.discriminator)
	            this.addKeyword(discriminator_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        const { $data, meta } = this.opts;
	        if (!meta)
	            return;
	        json_schema_2020_12_1.default.call(this, $data);
	        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	}
	module.exports = exports = Ajv2020;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv2020;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	var validation_error_1 = requireValidation_error();
	Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
	var ref_error_1 = requireRef_error();
	Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
	
} (_2020, _2020.exports));

var _2020Exports = _2020.exports;
var Ajv2020 = /*@__PURE__*/getDefaultExportFromCjs(_2020Exports);

var cvss_v2_0 = {
  license: [
    'Copyright (c) 2017, FIRST.ORG, INC.',
    'All rights reserved.',
    '',
    'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the ',
    'following conditions are met:',
    '1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following ',
    '   disclaimer.',
    '2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the ',
    '   following disclaimer in the documentation and/or other materials provided with the distribution.',
    '3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote ',
    '   products derived from this software without specific prior written permission.',
    '',
    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, ",
    'INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ',
    'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ',
    'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ',
    'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, ',
    'WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',
    'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.',
  ],
  $schema: 'https://json-schema.org/draft/2020-12/schema',
  title: 'JSON Schema for Common Vulnerability Scoring System version 2.0',
  $id: 'https://www.first.org/cvss/cvss-v2.0.json?20170531',
  type: 'object',
  $defs: {
    accessVectorType: {
      type: 'string',
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL'],
    },
    accessComplexityType: {
      type: 'string',
      enum: ['HIGH', 'MEDIUM', 'LOW'],
    },
    authenticationType: {
      type: 'string',
      enum: ['MULTIPLE', 'SINGLE', 'NONE'],
    },
    ciaType: {
      type: 'string',
      enum: ['NONE', 'PARTIAL', 'COMPLETE'],
    },
    exploitabilityType: {
      type: 'string',
      enum: [
        'UNPROVEN',
        'PROOF_OF_CONCEPT',
        'FUNCTIONAL',
        'HIGH',
        'NOT_DEFINED',
      ],
    },
    remediationLevelType: {
      type: 'string',
      enum: [
        'OFFICIAL_FIX',
        'TEMPORARY_FIX',
        'WORKAROUND',
        'UNAVAILABLE',
        'NOT_DEFINED',
      ],
    },
    reportConfidenceType: {
      type: 'string',
      enum: ['UNCONFIRMED', 'UNCORROBORATED', 'CONFIRMED', 'NOT_DEFINED'],
    },
    collateralDamagePotentialType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'LOW_MEDIUM', 'MEDIUM_HIGH', 'HIGH', 'NOT_DEFINED'],
    },
    targetDistributionType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'MEDIUM', 'HIGH', 'NOT_DEFINED'],
    },
    ciaRequirementType: {
      type: 'string',
      enum: ['LOW', 'MEDIUM', 'HIGH', 'NOT_DEFINED'],
    },
    scoreType: {
      type: 'number',
      minimum: 0,
      maximum: 10,
    },
  },
  properties: {
    version: {
      description: 'CVSS Version',
      type: 'string',
      enum: ['2.0'],
    },
    vectorString: {
      type: 'string',
      pattern:
        '^((AV:[NAL]|AC:[LMH]|Au:[MSN]|[CIA]:[NPC]|E:(U|POC|F|H|ND)|RL:(OF|TF|W|U|ND)|RC:(UC|UR|C|ND)|CDP:(N|L|LM|MH|H|ND)|TD:(N|L|M|H|ND)|[CIA]R:(L|M|H|ND))/)*(AV:[NAL]|AC:[LMH]|Au:[MSN]|[CIA]:[NPC]|E:(U|POC|F|H|ND)|RL:(OF|TF|W|U|ND)|RC:(UC|UR|C|ND)|CDP:(N|L|LM|MH|H|ND)|TD:(N|L|M|H|ND)|[CIA]R:(L|M|H|ND))$',
    },
    accessVector: { $ref: '#/$defs/accessVectorType' },
    accessComplexity: { $ref: '#/$defs/accessComplexityType' },
    authentication: { $ref: '#/$defs/authenticationType' },
    confidentialityImpact: { $ref: '#/$defs/ciaType' },
    integrityImpact: { $ref: '#/$defs/ciaType' },
    availabilityImpact: { $ref: '#/$defs/ciaType' },
    baseScore: { $ref: '#/$defs/scoreType' },
    exploitability: { $ref: '#/$defs/exploitabilityType' },
    remediationLevel: { $ref: '#/$defs/remediationLevelType' },
    reportConfidence: { $ref: '#/$defs/reportConfidenceType' },
    temporalScore: { $ref: '#/$defs/scoreType' },
    collateralDamagePotential: {
      $ref: '#/$defs/collateralDamagePotentialType',
    },
    targetDistribution: { $ref: '#/$defs/targetDistributionType' },
    confidentialityRequirement: {
      $ref: '#/$defs/ciaRequirementType',
    },
    integrityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    availabilityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    environmentalScore: { $ref: '#/$defs/scoreType' },
  },
  required: ['version', 'vectorString', 'baseScore'],
};

var cvss_v3_0 = {
  license: [
    'Copyright (c) 2017, FIRST.ORG, INC.',
    'All rights reserved.',
    '',
    'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the ',
    'following conditions are met:',
    '1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following ',
    '   disclaimer.',
    '2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the ',
    '   following disclaimer in the documentation and/or other materials provided with the distribution.',
    '3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote ',
    '   products derived from this software without specific prior written permission.',
    '',
    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, ",
    'INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ',
    'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ',
    'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ',
    'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, ',
    'WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',
    'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.',
  ],
  $schema: 'https://json-schema.org/draft/2020-12/schema',
  title: 'JSON Schema for Common Vulnerability Scoring System version 3.0',
  $id: 'https://www.first.org/cvss/cvss-v3.0.json?20170531',
  type: 'object',
  $defs: {
    attackVectorType: {
      type: 'string',
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL'],
    },
    modifiedAttackVectorType: {
      type: 'string',
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL', 'NOT_DEFINED'],
    },
    attackComplexityType: {
      type: 'string',
      enum: ['HIGH', 'LOW'],
    },
    modifiedAttackComplexityType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NOT_DEFINED'],
    },
    privilegesRequiredType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NONE'],
    },
    modifiedPrivilegesRequiredType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NONE', 'NOT_DEFINED'],
    },
    userInteractionType: {
      type: 'string',
      enum: ['NONE', 'REQUIRED'],
    },
    modifiedUserInteractionType: {
      type: 'string',
      enum: ['NONE', 'REQUIRED', 'NOT_DEFINED'],
    },
    scopeType: {
      type: 'string',
      enum: ['UNCHANGED', 'CHANGED'],
    },
    modifiedScopeType: {
      type: 'string',
      enum: ['UNCHANGED', 'CHANGED', 'NOT_DEFINED'],
    },
    ciaType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'HIGH'],
    },
    modifiedCiaType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'HIGH', 'NOT_DEFINED'],
    },
    exploitCodeMaturityType: {
      type: 'string',
      enum: [
        'UNPROVEN',
        'PROOF_OF_CONCEPT',
        'FUNCTIONAL',
        'HIGH',
        'NOT_DEFINED',
      ],
    },
    remediationLevelType: {
      type: 'string',
      enum: [
        'OFFICIAL_FIX',
        'TEMPORARY_FIX',
        'WORKAROUND',
        'UNAVAILABLE',
        'NOT_DEFINED',
      ],
    },
    confidenceType: {
      type: 'string',
      enum: ['UNKNOWN', 'REASONABLE', 'CONFIRMED', 'NOT_DEFINED'],
    },
    ciaRequirementType: {
      type: 'string',
      enum: ['LOW', 'MEDIUM', 'HIGH', 'NOT_DEFINED'],
    },
    scoreType: {
      type: 'number',
      minimum: 0,
      maximum: 10,
    },
    severityType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    },
  },
  properties: {
    version: {
      description: 'CVSS Version',
      type: 'string',
      enum: ['3.0'],
    },
    vectorString: {
      type: 'string',
      pattern:
        '^CVSS:3.0/((AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])/)*(AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$',
    },
    attackVector: { $ref: '#/$defs/attackVectorType' },
    attackComplexity: { $ref: '#/$defs/attackComplexityType' },
    privilegesRequired: { $ref: '#/$defs/privilegesRequiredType' },
    userInteraction: { $ref: '#/$defs/userInteractionType' },
    scope: { $ref: '#/$defs/scopeType' },
    confidentialityImpact: { $ref: '#/$defs/ciaType' },
    integrityImpact: { $ref: '#/$defs/ciaType' },
    availabilityImpact: { $ref: '#/$defs/ciaType' },
    baseScore: { $ref: '#/$defs/scoreType' },
    baseSeverity: { $ref: '#/$defs/severityType' },
    exploitCodeMaturity: { $ref: '#/$defs/exploitCodeMaturityType' },
    remediationLevel: { $ref: '#/$defs/remediationLevelType' },
    reportConfidence: { $ref: '#/$defs/confidenceType' },
    temporalScore: { $ref: '#/$defs/scoreType' },
    temporalSeverity: { $ref: '#/$defs/severityType' },
    confidentialityRequirement: {
      $ref: '#/$defs/ciaRequirementType',
    },
    integrityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    availabilityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    modifiedAttackVector: {
      $ref: '#/$defs/modifiedAttackVectorType',
    },
    modifiedAttackComplexity: {
      $ref: '#/$defs/modifiedAttackComplexityType',
    },
    modifiedPrivilegesRequired: {
      $ref: '#/$defs/modifiedPrivilegesRequiredType',
    },
    modifiedUserInteraction: {
      $ref: '#/$defs/modifiedUserInteractionType',
    },
    modifiedScope: { $ref: '#/$defs/modifiedScopeType' },
    modifiedConfidentialityImpact: {
      $ref: '#/$defs/modifiedCiaType',
    },
    modifiedIntegrityImpact: { $ref: '#/$defs/modifiedCiaType' },
    modifiedAvailabilityImpact: { $ref: '#/$defs/modifiedCiaType' },
    environmentalScore: { $ref: '#/$defs/scoreType' },
    environmentalSeverity: { $ref: '#/$defs/severityType' },
  },
  required: ['version', 'vectorString', 'baseScore', 'baseSeverity'],
};

var cvss_v3_1 = {
  license: [
    'Copyright (c) 2019, FIRST.ORG, INC.',
    'All rights reserved.',
    '',
    'Redistribution and use in source and binary forms, with or without modification, are permitted provided that the ',
    'following conditions are met:',
    '1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following ',
    '   disclaimer.',
    '2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the ',
    '   following disclaimer in the documentation and/or other materials provided with the distribution.',
    '3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote ',
    '   products derived from this software without specific prior written permission.',
    '',
    "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, ",
    'INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ',
    'DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, ',
    'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR ',
    'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, ',
    'WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE ',
    'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.',
  ],

  $schema: 'https://json-schema.org/draft/2020-12/schema',
  title: 'JSON Schema for Common Vulnerability Scoring System version 3.1',
  $id: 'https://www.first.org/cvss/cvss-v3.1.json?20190610',
  type: 'object',
  $defs: {
    attackVectorType: {
      type: 'string',
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL'],
    },
    modifiedAttackVectorType: {
      type: 'string',
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL', 'NOT_DEFINED'],
    },
    attackComplexityType: {
      type: 'string',
      enum: ['HIGH', 'LOW'],
    },
    modifiedAttackComplexityType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NOT_DEFINED'],
    },
    privilegesRequiredType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NONE'],
    },
    modifiedPrivilegesRequiredType: {
      type: 'string',
      enum: ['HIGH', 'LOW', 'NONE', 'NOT_DEFINED'],
    },
    userInteractionType: {
      type: 'string',
      enum: ['NONE', 'REQUIRED'],
    },
    modifiedUserInteractionType: {
      type: 'string',
      enum: ['NONE', 'REQUIRED', 'NOT_DEFINED'],
    },
    scopeType: {
      type: 'string',
      enum: ['UNCHANGED', 'CHANGED'],
    },
    modifiedScopeType: {
      type: 'string',
      enum: ['UNCHANGED', 'CHANGED', 'NOT_DEFINED'],
    },
    ciaType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'HIGH'],
    },
    modifiedCiaType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'HIGH', 'NOT_DEFINED'],
    },
    exploitCodeMaturityType: {
      type: 'string',
      enum: [
        'UNPROVEN',
        'PROOF_OF_CONCEPT',
        'FUNCTIONAL',
        'HIGH',
        'NOT_DEFINED',
      ],
    },
    remediationLevelType: {
      type: 'string',
      enum: [
        'OFFICIAL_FIX',
        'TEMPORARY_FIX',
        'WORKAROUND',
        'UNAVAILABLE',
        'NOT_DEFINED',
      ],
    },
    confidenceType: {
      type: 'string',
      enum: ['UNKNOWN', 'REASONABLE', 'CONFIRMED', 'NOT_DEFINED'],
    },
    ciaRequirementType: {
      type: 'string',
      enum: ['LOW', 'MEDIUM', 'HIGH', 'NOT_DEFINED'],
    },
    scoreType: {
      type: 'number',
      minimum: 0,
      maximum: 10,
    },
    severityType: {
      type: 'string',
      enum: ['NONE', 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    },
  },
  properties: {
    version: {
      description: 'CVSS Version',
      type: 'string',
      enum: ['3.1'],
    },
    vectorString: {
      type: 'string',
      pattern:
        '^CVSS:3.1/((AV:[NALP]|AC:[LH]|PR:[NLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])/)*(AV:[NALP]|AC:[LH]|PR:[NLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$',
    },
    attackVector: { $ref: '#/$defs/attackVectorType' },
    attackComplexity: { $ref: '#/$defs/attackComplexityType' },
    privilegesRequired: { $ref: '#/$defs/privilegesRequiredType' },
    userInteraction: { $ref: '#/$defs/userInteractionType' },
    scope: { $ref: '#/$defs/scopeType' },
    confidentialityImpact: { $ref: '#/$defs/ciaType' },
    integrityImpact: { $ref: '#/$defs/ciaType' },
    availabilityImpact: { $ref: '#/$defs/ciaType' },
    baseScore: { $ref: '#/$defs/scoreType' },
    baseSeverity: { $ref: '#/$defs/severityType' },
    exploitCodeMaturity: { $ref: '#/$defs/exploitCodeMaturityType' },
    remediationLevel: { $ref: '#/$defs/remediationLevelType' },
    reportConfidence: { $ref: '#/$defs/confidenceType' },
    temporalScore: { $ref: '#/$defs/scoreType' },
    temporalSeverity: { $ref: '#/$defs/severityType' },
    confidentialityRequirement: {
      $ref: '#/$defs/ciaRequirementType',
    },
    integrityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    availabilityRequirement: { $ref: '#/$defs/ciaRequirementType' },
    modifiedAttackVector: {
      $ref: '#/$defs/modifiedAttackVectorType',
    },
    modifiedAttackComplexity: {
      $ref: '#/$defs/modifiedAttackComplexityType',
    },
    modifiedPrivilegesRequired: {
      $ref: '#/$defs/modifiedPrivilegesRequiredType',
    },
    modifiedUserInteraction: {
      $ref: '#/$defs/modifiedUserInteractionType',
    },
    modifiedScope: { $ref: '#/$defs/modifiedScopeType' },
    modifiedConfidentialityImpact: {
      $ref: '#/$defs/modifiedCiaType',
    },
    modifiedIntegrityImpact: { $ref: '#/$defs/modifiedCiaType' },
    modifiedAvailabilityImpact: { $ref: '#/$defs/modifiedCiaType' },
    environmentalScore: { $ref: '#/$defs/scoreType' },
    environmentalSeverity: { $ref: '#/$defs/severityType' },
  },
  required: ['version', 'vectorString', 'baseScore', 'baseSeverity'],
};

const csafAjv = new Ajv2020({ strict: false, allErrors: true });
addFormats(csafAjv);
csafAjv.addSchema(cvss_v2_0, 'https://www.first.org/cvss/cvss-v2.0.json');
csafAjv.addSchema(cvss_v3_0, 'https://www.first.org/cvss/cvss-v3.0.json');
csafAjv.addSchema(cvss_v3_1, 'https://www.first.org/cvss/cvss-v3.1.json');

var schema$3 = {
  $id: 'https://docs.oasis-open.org/csaf/csaf/v2.0/csaf_json_schema.json?strict',
  $schema: 'https://json-schema.org/draft/2020-12/schema',
  $defs: {
    acknowledgments_t: {
      description: 'Contains a list of acknowledgment elements.',
      items: {
        additionalProperties: false,
        description:
          'Acknowledges contributions by describing those that contributed.',
        minProperties: 1,
        properties: {
          names: {
            description: 'Contains the names of entities being recognized.',
            items: {
              description: 'Contains the name of a single person.',
              examples: ['Albert Einstein', 'Johann Sebastian Bach'],
              minLength: 1,
              title: 'Name of entity being recognized',
              type: 'string',
            },
            minItems: 1,
            title: 'List of acknowledged names',
            type: 'array',
          },
          organization: {
            description:
              'Contains the name of a contributing organization being recognized.',
            examples: ['CISA', 'Google Project Zero', 'Talos'],
            minLength: 1,
            title: 'Contributing organization',
            type: 'string',
          },
          summary: {
            description:
              'SHOULD represent any contextual details the document producers wish to make known about the acknowledgment or acknowledged parties.',
            examples: [
              'First analysis of Coordinated Multi-Stream Attack (CMSA)',
            ],
            minLength: 1,
            title: 'Summary of the acknowledgment',
            type: 'string',
          },
          urls: {
            description:
              'Specifies a list of URLs or location of the reference to be acknowledged.',
            items: {
              description:
                'Contains the URL or location of the reference to be acknowledged.',
              format: 'uri',
              title: 'URL of acknowledgment',
              type: 'string',
            },
            minItems: 1,
            title: 'List of URLs',
            type: 'array',
          },
        },
        title: 'Acknowledgment',
        type: 'object',
      },
      minItems: 1,
      title: 'List of acknowledgments',
      type: 'array',
    },
    branches_t: {
      description:
        'Contains branch elements as children of the current element.',
      items: {
        additionalProperties: false,
        description:
          'Is a part of the hierarchical structure of the product tree.',
        maxProperties: 3,
        minProperties: 3,
        properties: {
          branches: {
            $ref: '#/$defs/branches_t',
          },
          category: {
            description: 'Describes the characteristics of the labeled branch.',
            enum: [
              'architecture',
              'host_name',
              'language',
              'legacy',
              'patch_level',
              'product_family',
              'product_name',
              'product_version',
              'product_version_range',
              'service_pack',
              'specification',
              'vendor',
            ],
            title: 'Category of the branch',
            type: 'string',
          },
          name: {
            description:
              "Contains the canonical descriptor or 'friendly name' of the branch.",
            examples: [
              '10',
              '365',
              'Microsoft',
              'Office',
              'PCS 7',
              'SIMATIC',
              'Siemens',
              'Windows',
            ],
            minLength: 1,
            title: 'Name of the branch',
            type: 'string',
          },
          product: {
            $ref: '#/$defs/full_product_name_t',
          },
        },
        required: ['category', 'name'],
        title: 'Branch',
        type: 'object',
      },
      minItems: 1,
      title: 'List of branches',
      type: 'array',
    },
    full_product_name_t: {
      additionalProperties: false,
      description:
        'Specifies information about the product and assigns the product_id.',
      properties: {
        name: {
          description:
            'The value should be the product\u2019s full canonical name, including version number and other attributes, as it would be used in a human-friendly document.',
          examples: [
            'Cisco AnyConnect Secure Mobility Client 2.3.185',
            'Microsoft Host Integration Server 2006 Service Pack 1',
          ],
          minLength: 1,
          title: 'Textual description of the product',
          type: 'string',
        },
        product_id: {
          $ref: '#/$defs/product_id_t',
        },
        product_identification_helper: {
          additionalProperties: false,
          description:
            'Provides at least one method which aids in identifying the product in an asset database.',
          minProperties: 1,
          properties: {
            cpe: {
              description:
                'The Common Platform Enumeration (CPE) attribute refers to a method for naming platforms external to this specification.',
              minLength: 5,
              pattern:
                '^(cpe:2\\.3:[aho\\*\\-](:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){5}(:(([a-zA-Z]{2,3}(-([a-zA-Z]{2}|[0-9]{3}))?)|[\\*\\-]))(:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){4})|([c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6})$',
              title: 'Common Platform Enumeration representation',
              type: 'string',
            },
            hashes: {
              description:
                'Contains a list of cryptographic hashes usable to identify files.',
              items: {
                additionalProperties: false,
                description:
                  'Contains all information to identify a file based on its cryptographic hash values.',
                properties: {
                  file_hashes: {
                    description:
                      'Contains a list of cryptographic hashes for this file.',
                    items: {
                      additionalProperties: false,
                      description:
                        'Contains one hash value and algorithm of the file to be identified.',
                      properties: {
                        algorithm: {
                          default: 'sha256',
                          description:
                            'Contains the name of the cryptographic hash algorithm used to calculate the value.',
                          examples: [
                            'blake2b512',
                            'sha256',
                            'sha3-512',
                            'sha384',
                            'sha512',
                          ],
                          minLength: 1,
                          title: 'Algorithm of the cryptographic hash',
                          type: 'string',
                        },
                        value: {
                          description:
                            'Contains the cryptographic hash value in hexadecimal representation.',
                          examples: [
                            '37df33cb7464da5c7f077f4d56a32bc84987ec1d85b234537c1c1a4d4fc8d09dc29e2e762cb5203677bf849a2855a0283710f1f5fe1d6ce8d5ac85c645d0fcb3',
                            '4775203615d9534a8bfca96a93dc8b461a489f69124a130d786b42204f3341cc',
                            '9ea4c8200113d49d26505da0e02e2f49055dc078d1ad7a419b32e291c7afebbb84badfbd46dec42883bea0b2a1fa697c',
                          ],
                          minLength: 32,
                          pattern: '^[0-9a-fA-F]{32,}$',
                          title: 'Value of the cryptographic hash',
                          type: 'string',
                        },
                      },
                      required: ['algorithm', 'value'],
                      title: 'File hash',
                      type: 'object',
                    },
                    minItems: 1,
                    title: 'List of file hashes',
                    type: 'array',
                  },
                  filename: {
                    description:
                      'Contains the name of the file which is identified by the hash values.',
                    examples: ['WINWORD.EXE', 'msotadddin.dll', 'sudoers.so'],
                    minLength: 1,
                    title: 'Filename',
                    type: 'string',
                  },
                },
                required: ['file_hashes', 'filename'],
                title: 'Cryptographic hashes',
                type: 'object',
              },
              minItems: 1,
              title: 'List of hashes',
              type: 'array',
            },
            model_numbers: {
              description: 'Contains a list of parts, or full model numbers.',
              items: {
                description:
                  'Contains a part, or a full model number of the component to identify.',
                minLength: 1,
                title: 'Model number',
                type: 'string',
              },
              minItems: 1,
              title: 'List of models',
              type: 'array',
              uniqueItems: true,
            },
            purl: {
              description:
                'The package URL (purl) attribute refers to a method for reliably identifying and locating software packages external to this specification.',
              format: 'uri',
              minLength: 7,
              pattern: '^pkg:[A-Za-z\\.\\-\\+][A-Za-z0-9\\.\\-\\+]*/.+',
              title: 'package URL representation',
              type: 'string',
            },
            sbom_urls: {
              description:
                'Contains a list of URLs where SBOMs for this product can be retrieved.',
              items: {
                description: 'Contains a URL of one SBOM for this product.',
                format: 'uri',
                title: 'SBOM URL',
                type: 'string',
              },
              minItems: 1,
              title: 'List of SBOM URLs',
              type: 'array',
            },
            serial_numbers: {
              description: 'Contains a list of parts, or full serial numbers.',
              items: {
                description:
                  'Contains a part, or a full serial number of the component to identify.',
                minLength: 1,
                title: 'Serial number',
                type: 'string',
              },
              minItems: 1,
              title: 'List of serial numbers',
              type: 'array',
              uniqueItems: true,
            },
            skus: {
              description:
                'Contains a list of parts, or full stock keeping units.',
              items: {
                description:
                  'Contains a part, or a full stock keeping unit (SKU) which is used in the ordering process to identify the component.',
                minLength: 1,
                title: 'Stock keeping unit',
                type: 'string',
              },
              minItems: 1,
              title: 'List of stock keeping units',
              type: 'array',
            },
            x_generic_uris: {
              description:
                'Contains a list of identifiers which are either vendor-specific or derived from a standard not yet supported.',
              items: {
                additionalProperties: false,
                description:
                  'Provides a generic extension point for any identifier which is either vendor-specific or derived from a standard not yet supported.',
                properties: {
                  namespace: {
                    description:
                      'Refers to a URL which provides the name and knowledge about the specification used or is the namespace in which these values are valid.',
                    format: 'uri',
                    title: 'Namespace of the generic URI',
                    type: 'string',
                  },
                  uri: {
                    description: 'Contains the identifier itself.',
                    format: 'uri',
                    title: 'URI',
                    type: 'string',
                  },
                },
                required: ['namespace', 'uri'],
                title: 'Generic URI',
                type: 'object',
              },
              minItems: 1,
              title: 'List of generic URIs',
              type: 'array',
            },
          },
          title: 'Helper to identify the product',
          type: 'object',
        },
      },
      required: ['name', 'product_id'],
      title: 'Full product name',
      type: 'object',
    },
    lang_t: {
      description:
        'Identifies a language, corresponding to IETF BCP 47 / RFC 5646. See IETF language registry: https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry',
      examples: ['de', 'en', 'fr', 'frc', 'jp'],
      pattern:
        '^(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-[A-WY-Za-wy-z0-9](-[A-Za-z0-9]{2,8})+)*(-[Xx](-[A-Za-z0-9]{1,8})+)?|[Xx](-[A-Za-z0-9]{1,8})+|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Mm][Ii][Nn][Gg][Oo])$',
      title: 'Language type',
      type: 'string',
    },
    notes_t: {
      description: 'Contains notes which are specific to the current context.',
      items: {
        additionalProperties: false,
        description:
          'Is a place to put all manner of text blobs related to the current context.',
        properties: {
          audience: {
            description: 'Indicate who is intended to read it.',
            examples: [
              'all',
              'executives',
              'operational management and system administrators',
              'safety engineers',
            ],
            minLength: 1,
            title: 'Audience of note',
            type: 'string',
          },
          category: {
            description: 'Choice of what kind of note this is.',
            enum: [
              'description',
              'details',
              'faq',
              'general',
              'legal_disclaimer',
              'other',
              'summary',
            ],
            title: 'Note category',
            type: 'string',
          },
          text: {
            description:
              'The contents of the note. Content varies depending on type.',
            minLength: 1,
            title: 'Note contents',
            type: 'string',
          },
          title: {
            description:
              'Provides a concise description of what is contained in the text of the note.',
            examples: [
              'Details',
              'Executive summary',
              'Technical summary',
              'Impact on safety systems',
            ],
            minLength: 1,
            title: 'Title of note',
            type: 'string',
          },
        },
        required: ['category', 'text'],
        title: 'Note',
        type: 'object',
      },
      minItems: 1,
      title: 'List of notes',
      type: 'array',
    },
    product_group_id_t: {
      description:
        'Token required to identify a group of products so that it can be referred to from other parts in the document. There is no predefined or required format for the product_group_id as long as it uniquely identifies a group in the context of the current document.',
      examples: ['CSAFGID-0001', 'CSAFGID-0002', 'CSAFGID-0020'],
      minLength: 1,
      title: 'Reference token for product group instance',
      type: 'string',
    },
    product_groups_t: {
      description:
        'Specifies a list of product_group_ids to give context to the parent item.',
      items: {
        $ref: '#/$defs/product_group_id_t',
      },
      minItems: 1,
      title: 'List of product_group_ids',
      type: 'array',
      uniqueItems: true,
    },
    product_id_t: {
      description:
        'Token required to identify a full_product_name so that it can be referred to from other parts in the document. There is no predefined or required format for the product_id as long as it uniquely identifies a product in the context of the current document.',
      examples: ['CSAFPID-0004', 'CSAFPID-0008'],
      minLength: 1,
      title: 'Reference token for product instance',
      type: 'string',
    },
    products_t: {
      description:
        'Specifies a list of product_ids to give context to the parent item.',
      items: {
        $ref: '#/$defs/product_id_t',
      },
      minItems: 1,
      title: 'List of product_ids',
      type: 'array',
      uniqueItems: true,
    },
    references_t: {
      description: 'Holds a list of references.',
      items: {
        additionalProperties: false,
        description:
          'Holds any reference to conferences, papers, advisories, and other resources that are related and considered related to either a surrounding part of or the entire document and to be of value to the document consumer.',
        properties: {
          category: {
            default: 'external',
            description:
              'Indicates whether the reference points to the same document or vulnerability in focus (depending on scope) or to an external resource.',
            enum: ['external', 'self'],
            title: 'Category of reference',
            type: 'string',
          },
          summary: {
            description: 'Indicates what this reference refers to.',
            minLength: 1,
            title: 'Summary of the reference',
            type: 'string',
          },
          url: {
            description: 'Provides the URL for the reference.',
            format: 'uri',
            title: 'URL of reference',
            type: 'string',
          },
        },
        required: ['summary', 'url'],
        title: 'Reference',
        type: 'object',
      },
      minItems: 1,
      title: 'List of references',
      type: 'array',
    },
    version_t: {
      description:
        'Specifies a version string to denote clearly the evolution of the content of the document. Format must be either integer or semantic versioning.',
      examples: ['1', '4', '0.9.0', '1.4.3', '2.40.0+21AF26D3'],
      pattern:
        '^(0|[1-9][0-9]*)$|^((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)$',
      title: 'Version',
      type: 'string',
    },
  },
  additionalProperties: false,
  description:
    'Representation of security advisory information as a JSON document.',
  properties: {
    document: {
      additionalProperties: false,
      description:
        'Captures the meta-data about this document describing a particular set of security advisories.',
      properties: {
        acknowledgments: {
          $ref: '#/$defs/acknowledgments_t',
          description:
            'Contains a list of acknowledgment elements associated with the whole document.',
          title: 'Document acknowledgments',
        },
        aggregate_severity: {
          additionalProperties: false,
          description:
            "Is a vehicle that is provided by the document producer to convey the urgency and criticality with which the one or more vulnerabilities reported should be addressed. It is a document-level metric and applied to the document as a whole \u2014 not any specific vulnerability. The range of values in this field is defined according to the document producer's policies and procedures.",
          properties: {
            namespace: {
              description: 'Points to the namespace so referenced.',
              format: 'uri',
              title: 'Namespace of aggregate severity',
              type: 'string',
            },
            text: {
              description:
                'Provides a severity which is independent of - and in addition to - any other standard metric for determining the impact or severity of a given vulnerability (such as CVSS).',
              examples: ['Critical', 'Important', 'Moderate'],
              minLength: 1,
              title: 'Text of aggregate severity',
              type: 'string',
            },
          },
          required: ['text'],
          title: 'Aggregate severity',
          type: 'object',
        },
        category: {
          description:
            'Defines a short canonical name, chosen by the document producer, which will inform the end user as to the category of document.',
          examples: [
            'csaf_base',
            'csaf_security_advisory',
            'csaf_vex',
            'Example Company Security Notice',
          ],
          minLength: 1,
          pattern: '^[^\\s\\-_\\.](.*[^\\s\\-_\\.])?$',
          title: 'Document category',
          type: 'string',
        },
        csaf_version: {
          description:
            'Gives the version of the CSAF specification which the document was generated for.',
          enum: ['2.0'],
          title: 'CSAF version',
          type: 'string',
        },
        distribution: {
          additionalProperties: false,
          description:
            'Describe any constraints on how this document might be shared.',
          minProperties: 1,
          properties: {
            text: {
              description:
                'Provides a textual description of additional constraints.',
              examples: [
                'Copyright 2021, Example Company, All Rights Reserved.',
                'Distribute freely.',
                'Share only on a need-to-know-basis only.',
              ],
              minLength: 1,
              title: 'Textual description',
              type: 'string',
            },
            tlp: {
              additionalProperties: false,
              description:
                'Provides details about the TLP classification of the document.',
              properties: {
                label: {
                  description: 'Provides the TLP label of the document.',
                  enum: ['AMBER', 'GREEN', 'RED', 'WHITE'],
                  title: 'Label of TLP',
                  type: 'string',
                },
                url: {
                  default: 'https://www.first.org/tlp/',
                  description:
                    'Provides a URL where to find the textual description of the TLP version which is used in this document. Default is the URL to the definition by FIRST.',
                  examples: [
                    'https://www.us-cert.gov/tlp',
                    'https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Kritis/Merkblatt_TLP.pdf',
                  ],
                  format: 'uri',
                  title: 'URL of TLP version',
                  type: 'string',
                },
              },
              required: ['label'],
              title: 'Traffic Light Protocol (TLP)',
              type: 'object',
            },
          },
          title: 'Rules for sharing document',
          type: 'object',
        },
        lang: {
          $ref: '#/$defs/lang_t',
          description:
            'Identifies the language used by this document, corresponding to IETF BCP 47 / RFC 5646.',
          title: 'Document language',
        },
        notes: {
          $ref: '#/$defs/notes_t',
          description: 'Holds notes associated with the whole document.',
          title: 'Document notes',
        },
        publisher: {
          additionalProperties: false,
          description:
            'Provides information about the publisher of the document.',
          properties: {
            category: {
              description:
                'Provides information about the category of publisher releasing the document.',
              enum: [
                'coordinator',
                'discoverer',
                'other',
                'translator',
                'user',
                'vendor',
              ],
              title: 'Category of publisher',
              type: 'string',
            },
            contact_details: {
              description:
                'Information on how to contact the publisher, possibly including details such as web sites, email addresses, phone numbers, and postal mail addresses.',
              examples: [
                'Example Company can be reached at contact_us@example.com, or via our website at https://www.example.com/contact.',
              ],
              minLength: 1,
              title: 'Contact details',
              type: 'string',
            },
            issuing_authority: {
              description:
                "Provides information about the authority of the issuing party to release the document, in particular, the party's constituency and responsibilities or other obligations.",
              minLength: 1,
              title: 'Issuing authority',
              type: 'string',
            },
            name: {
              description: 'Contains the name of the issuing party.',
              examples: ['BSI', 'Cisco PSIRT', 'Siemens ProductCERT'],
              minLength: 1,
              title: 'Name of publisher',
              type: 'string',
            },
            namespace: {
              description:
                'Contains a URL which is under control of the issuing party and can be used as a globally unique identifier for that issuing party.',
              examples: ['https://csaf.io', 'https://www.example.com'],
              format: 'uri',
              title: 'Namespace of publisher',
              type: 'string',
            },
          },
          required: ['category', 'name', 'namespace'],
          title: 'Publisher',
          type: 'object',
        },
        references: {
          $ref: '#/$defs/references_t',
          description:
            'Holds a list of references associated with the whole document.',
          title: 'Document references',
        },
        source_lang: {
          $ref: '#/$defs/lang_t',
          description:
            'If this copy of the document is a translation then the value of this property describes from which language this document was translated.',
          title: 'Source language',
        },
        title: {
          description:
            'This SHOULD be a canonical name for the document, and sufficiently unique to distinguish it from similar documents.',
          examples: [
            'Cisco IPv6 Crafted Packet Denial of Service Vulnerability',
            'Example Company Cross-Site-Scripting Vulnerability in Example Generator',
          ],
          minLength: 1,
          title: 'Title of this document',
          type: 'string',
        },
        tracking: {
          additionalProperties: false,
          description:
            'Is a container designated to hold all management attributes necessary to track a CSAF document as a whole.',
          properties: {
            aliases: {
              description:
                'Contains a list of alternate names for the same document.',
              items: {
                description:
                  'Specifies a non-empty string that represents a distinct optional alternative ID used to refer to the document.',
                examples: ['CVE-2019-12345'],
                minLength: 1,
                title: 'Alternate name',
                type: 'string',
              },
              minItems: 1,
              title: 'Aliases',
              type: 'array',
              uniqueItems: true,
            },
            current_release_date: {
              description:
                'The date when the current revision of this document was released',
              format: 'date-time',
              title: 'Current release date',
              type: 'string',
            },
            generator: {
              additionalProperties: false,
              description:
                'Is a container to hold all elements related to the generation of the document. These items will reference when the document was actually created, including the date it was generated and the entity that generated it.',
              properties: {
                date: {
                  description:
                    'This SHOULD be the current date that the document was generated. Because documents are often generated internally by a document producer and exist for a nonzero amount of time before being released, this field MAY be different from the Initial Release Date and Current Release Date.',
                  format: 'date-time',
                  title: 'Date of document generation',
                  type: 'string',
                },
                engine: {
                  additionalProperties: false,
                  description:
                    'Contains information about the engine that generated the CSAF document.',
                  properties: {
                    name: {
                      description:
                        'Represents the name of the engine that generated the CSAF document.',
                      examples: ['Red Hat rhsa-to-cvrf', 'Secvisogram', 'TVCE'],
                      minLength: 1,
                      title: 'Engine name',
                      type: 'string',
                    },
                    version: {
                      description:
                        'Contains the version of the engine that generated the CSAF document.',
                      examples: ['0.6.0', '1.0.0-beta+exp.sha.a1c44f85', '2'],
                      minLength: 1,
                      title: 'Engine version',
                      type: 'string',
                    },
                  },
                  required: ['name'],
                  title: 'Engine of document generation',
                  type: 'object',
                },
              },
              required: ['engine'],
              title: 'Document generator',
              type: 'object',
            },
            id: {
              description:
                'The ID is a simple label that provides for a wide range of numbering values, types, and schemes. Its value SHOULD be assigned and maintained by the original document issuing authority.',
              examples: [
                'Example Company - 2019-YH3234',
                'RHBA-2019:0024',
                'cisco-sa-20190513-secureboot',
              ],
              minLength: 1,
              pattern: '^[\\S](.*[\\S])?$',
              title: 'Unique identifier for the document',
              type: 'string',
            },
            initial_release_date: {
              description: 'The date when this document was first published.',
              format: 'date-time',
              title: 'Initial release date',
              type: 'string',
            },
            revision_history: {
              description:
                'Holds one revision item for each version of the CSAF document, including the initial one.',
              items: {
                additionalProperties: false,
                description:
                  'Contains all the information elements required to track the evolution of a CSAF document.',
                properties: {
                  date: {
                    description: 'The date of the revision entry',
                    format: 'date-time',
                    title: 'Date of the revision',
                    type: 'string',
                  },
                  legacy_version: {
                    description:
                      'Contains the version string used in an existing document with the same content.',
                    minLength: 1,
                    title: 'Legacy version of the revision',
                    type: 'string',
                  },
                  number: {
                    $ref: '#/$defs/version_t',
                  },
                  summary: {
                    description:
                      'Holds a single non-empty string representing a short description of the changes.',
                    examples: ['Initial version.'],
                    minLength: 1,
                    title: 'Summary of the revision',
                    type: 'string',
                  },
                },
                required: ['date', 'number', 'summary'],
                title: 'Revision',
                type: 'object',
              },
              minItems: 1,
              title: 'Revision history',
              type: 'array',
            },
            status: {
              description: 'Defines the draft status of the document.',
              enum: ['draft', 'final', 'interim'],
              title: 'Document status',
              type: 'string',
            },
            version: {
              $ref: '#/$defs/version_t',
            },
          },
          required: [
            'current_release_date',
            'id',
            'initial_release_date',
            'revision_history',
            'status',
            'version',
          ],
          title: 'Tracking',
          type: 'object',
        },
      },
      required: ['category', 'csaf_version', 'publisher', 'title', 'tracking'],
      title: 'Document level meta-data',
      type: 'object',
    },
    product_tree: {
      additionalProperties: false,
      description:
        'Is a container for all fully qualified product names that can be referenced elsewhere in the document.',
      minProperties: 1,
      properties: {
        branches: {
          $ref: '#/$defs/branches_t',
        },
        full_product_names: {
          description: 'Contains a list of full product names.',
          items: {
            $ref: '#/$defs/full_product_name_t',
          },
          minItems: 1,
          title: 'List of full product names',
          type: 'array',
        },
        product_groups: {
          description: 'Contains a list of product groups.',
          items: {
            additionalProperties: false,
            description:
              'Defines a new logical group of products that can then be referred to in other parts of the document to address a group of products with a single identifier.',
            properties: {
              group_id: {
                $ref: '#/$defs/product_group_id_t',
              },
              product_ids: {
                description:
                  'Lists the product_ids of those products which known as one group in the document.',
                items: {
                  $ref: '#/$defs/product_id_t',
                },
                minItems: 2,
                title: 'List of Product IDs',
                type: 'array',
                uniqueItems: true,
              },
              summary: {
                description:
                  'Gives a short, optional description of the group.',
                examples: [
                  'Products supporting Modbus.',
                  'The x64 versions of the operating system.',
                ],
                minLength: 1,
                title: 'Summary of the product group',
                type: 'string',
              },
            },
            required: ['group_id', 'product_ids'],
            title: 'Product group',
            type: 'object',
          },
          minItems: 1,
          title: 'List of product groups',
          type: 'array',
        },
        relationships: {
          description: 'Contains a list of relationships.',
          items: {
            additionalProperties: false,
            description:
              'Establishes a link between two existing full_product_name_t elements, allowing the document producer to define a combination of two products that form a new full_product_name entry.',
            properties: {
              category: {
                description:
                  'Defines the category of relationship for the referenced component.',
                enum: [
                  'default_component_of',
                  'external_component_of',
                  'installed_on',
                  'installed_with',
                  'optional_component_of',
                ],
                title: 'Relationship category',
                type: 'string',
              },
              full_product_name: {
                $ref: '#/$defs/full_product_name_t',
              },
              product_reference: {
                $ref: '#/$defs/product_id_t',
                description:
                  'Holds a Product ID that refers to the Full Product Name element, which is referenced as the first element of the relationship.',
                title: 'Product reference',
              },
              relates_to_product_reference: {
                $ref: '#/$defs/product_id_t',
                description:
                  'Holds a Product ID that refers to the Full Product Name element, which is referenced as the second element of the relationship.',
                title: 'Relates to product reference',
              },
            },
            required: [
              'category',
              'full_product_name',
              'product_reference',
              'relates_to_product_reference',
            ],
            title: 'Relationship',
            type: 'object',
          },
          minItems: 1,
          title: 'List of relationships',
          type: 'array',
        },
      },
      title: 'Product tree',
      type: 'object',
    },
    vulnerabilities: {
      description:
        'Represents a list of all relevant vulnerability information items.',
      items: {
        additionalProperties: false,
        description:
          'Is a container for the aggregation of all fields that are related to a single vulnerability in the document.',
        minProperties: 1,
        properties: {
          acknowledgments: {
            $ref: '#/$defs/acknowledgments_t',
            description:
              'Contains a list of acknowledgment elements associated with this vulnerability item.',
            title: 'Vulnerability acknowledgments',
          },
          cve: {
            description:
              'Holds the MITRE standard Common Vulnerabilities and Exposures (CVE) tracking number for the vulnerability.',
            pattern: '^CVE-[0-9]{4}-[0-9]{4,}$',
            title: 'CVE',
            type: 'string',
          },
          cwe: {
            additionalProperties: false,
            description:
              'Holds the MITRE standard Common Weakness Enumeration (CWE) for the weakness associated.',
            properties: {
              id: {
                description: 'Holds the ID for the weakness associated.',
                examples: ['CWE-22', 'CWE-352', 'CWE-79'],
                pattern: '^CWE-[1-9]\\d{0,5}$',
                title: 'Weakness ID',
                type: 'string',
              },
              name: {
                description:
                  'Holds the full name of the weakness as given in the CWE specification.',
                examples: [
                  'Cross-Site Request Forgery (CSRF)',
                  "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
                  "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
                ],
                minLength: 1,
                title: 'Weakness name',
                type: 'string',
              },
            },
            required: ['id', 'name'],
            title: 'CWE',
            type: 'object',
          },
          discovery_date: {
            description:
              'Holds the date and time the vulnerability was originally discovered.',
            format: 'date-time',
            title: 'Discovery date',
            type: 'string',
          },
          flags: {
            description: 'Contains a list of machine readable flags.',
            items: {
              additionalProperties: false,
              description:
                'Contains product specific information in regard to this vulnerability as a single machine readable flag.',
              properties: {
                date: {
                  description:
                    'Contains the date when assessment was done or the flag was assigned.',
                  format: 'date-time',
                  title: 'Date of the flag',
                  type: 'string',
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                label: {
                  description: 'Specifies the machine readable label.',
                  enum: [
                    'component_not_present',
                    'inline_mitigations_already_exist',
                    'vulnerable_code_cannot_be_controlled_by_adversary',
                    'vulnerable_code_not_in_execute_path',
                    'vulnerable_code_not_present',
                  ],
                  title: 'Label of the flag',
                  type: 'string',
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
              },
              required: ['label'],
              title: 'Flag',
              type: 'object',
            },
            minItems: 1,
            title: 'List of flags',
            type: 'array',
            uniqueItems: true,
          },
          ids: {
            description:
              'Represents a list of unique labels or tracking IDs for the vulnerability (if such information exists).',
            items: {
              additionalProperties: false,
              description:
                'Contains a single unique label or tracking ID for the vulnerability.',
              properties: {
                system_name: {
                  description:
                    'Indicates the name of the vulnerability tracking or numbering system.',
                  examples: ['Cisco Bug ID', 'GitHub Issue'],
                  minLength: 1,
                  title: 'System name',
                  type: 'string',
                },
                text: {
                  description:
                    'Is unique label or tracking ID for the vulnerability (if such information exists).',
                  examples: ['CSCso66472', 'oasis-tcs/csaf#210'],
                  minLength: 1,
                  title: 'Text',
                  type: 'string',
                },
              },
              required: ['system_name', 'text'],
              title: 'ID',
              type: 'object',
            },
            minItems: 1,
            title: 'List of IDs',
            type: 'array',
            uniqueItems: true,
          },
          involvements: {
            description: 'Contains a list of involvements.',
            items: {
              additionalProperties: false,
              description:
                'Is a container, that allows the document producers to comment on the level of involvement (or engagement) of themselves or third parties in the vulnerability identification, scoping, and remediation process.',
              properties: {
                date: {
                  description:
                    'Holds the date and time of the involvement entry.',
                  format: 'date-time',
                  title: 'Date of involvement',
                  type: 'string',
                },
                party: {
                  description: 'Defines the category of the involved party.',
                  enum: [
                    'coordinator',
                    'discoverer',
                    'other',
                    'user',
                    'vendor',
                  ],
                  title: 'Party category',
                  type: 'string',
                },
                status: {
                  description: 'Defines contact status of the involved party.',
                  enum: [
                    'completed',
                    'contact_attempted',
                    'disputed',
                    'in_progress',
                    'not_contacted',
                    'open',
                  ],
                  title: 'Party status',
                  type: 'string',
                },
                summary: {
                  description:
                    'Contains additional context regarding what is going on.',
                  minLength: 1,
                  title: 'Summary of the involvement',
                  type: 'string',
                },
              },
              required: ['party', 'status'],
              title: 'Involvement',
              type: 'object',
            },
            minItems: 1,
            title: 'List of involvements',
            type: 'array',
            uniqueItems: true,
          },
          notes: {
            $ref: '#/$defs/notes_t',
            description: 'Holds notes associated with this vulnerability item.',
            title: 'Vulnerability notes',
          },
          product_status: {
            additionalProperties: false,
            description:
              'Contains different lists of product_ids which provide details on the status of the referenced product related to the current vulnerability. ',
            minProperties: 1,
            properties: {
              first_affected: {
                $ref: '#/$defs/products_t',
                description:
                  'These are the first versions of the releases known to be affected by the vulnerability.',
                title: 'First affected',
              },
              first_fixed: {
                $ref: '#/$defs/products_t',
                description:
                  'These versions contain the first fix for the vulnerability but may not be the recommended fixed versions.',
                title: 'First fixed',
              },
              fixed: {
                $ref: '#/$defs/products_t',
                description:
                  'These versions contain a fix for the vulnerability but may not be the recommended fixed versions.',
                title: 'Fixed',
              },
              known_affected: {
                $ref: '#/$defs/products_t',
                description:
                  'These versions are known to be affected by the vulnerability.',
                title: 'Known affected',
              },
              known_not_affected: {
                $ref: '#/$defs/products_t',
                description:
                  'These versions are known not to be affected by the vulnerability.',
                title: 'Known not affected',
              },
              last_affected: {
                $ref: '#/$defs/products_t',
                description:
                  'These are the last versions in a release train known to be affected by the vulnerability. Subsequently released versions would contain a fix for the vulnerability.',
                title: 'Last affected',
              },
              recommended: {
                $ref: '#/$defs/products_t',
                description:
                  'These versions have a fix for the vulnerability and are the vendor-recommended versions for fixing the vulnerability.',
                title: 'Recommended',
              },
              under_investigation: {
                $ref: '#/$defs/products_t',
                description:
                  'It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation - the result will be provided in a later release of the document.',
                title: 'Under investigation',
              },
            },
            title: 'Product status',
            type: 'object',
          },
          references: {
            $ref: '#/$defs/references_t',
            description:
              'Holds a list of references associated with this vulnerability item.',
            title: 'Vulnerability references',
          },
          release_date: {
            description:
              'Holds the date and time the vulnerability was originally released into the wild.',
            format: 'date-time',
            title: 'Release date',
            type: 'string',
          },
          remediations: {
            description: 'Contains a list of remediations.',
            items: {
              additionalProperties: false,
              description:
                'Specifies details on how to handle (and presumably, fix) a vulnerability.',
              properties: {
                category: {
                  description:
                    'Specifies the category which this remediation belongs to.',
                  enum: [
                    'mitigation',
                    'no_fix_planned',
                    'none_available',
                    'vendor_fix',
                    'workaround',
                  ],
                  title: 'Category of the remediation',
                  type: 'string',
                },
                date: {
                  description:
                    'Contains the date from which the remediation is available.',
                  format: 'date-time',
                  title: 'Date of the remediation',
                  type: 'string',
                },
                details: {
                  description:
                    'Contains a thorough human-readable discussion of the remediation.',
                  minLength: 1,
                  title: 'Details of the remediation',
                  type: 'string',
                },
                entitlements: {
                  description: 'Contains a list of entitlements.',
                  items: {
                    description:
                      'Contains any possible vendor-defined constraints for obtaining fixed software or hardware that fully resolves the vulnerability.',
                    minLength: 1,
                    title: 'Entitlement of the remediation',
                    type: 'string',
                  },
                  minItems: 1,
                  title: 'List of entitlements',
                  type: 'array',
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
                restart_required: {
                  additionalProperties: false,
                  description:
                    'Provides information on category of restart is required by this remediation to become effective.',
                  properties: {
                    category: {
                      description:
                        'Specifies what category of restart is required by this remediation to become effective.',
                      enum: [
                        'connected',
                        'dependencies',
                        'machine',
                        'none',
                        'parent',
                        'service',
                        'system',
                        'vulnerable_component',
                        'zone',
                      ],
                      title: 'Category of restart',
                      type: 'string',
                    },
                    details: {
                      description:
                        'Provides additional information for the restart. This can include details on procedures, scope or impact.',
                      minLength: 1,
                      title: 'Additional restart information',
                      type: 'string',
                    },
                  },
                  required: ['category'],
                  title: 'Restart required by remediation',
                  type: 'object',
                },
                url: {
                  description:
                    'Contains the URL where to obtain the remediation.',
                  format: 'uri',
                  title: 'URL to the remediation',
                  type: 'string',
                },
              },
              required: ['category', 'details'],
              title: 'Remediation',
              type: 'object',
            },
            minItems: 1,
            title: 'List of remediations',
            type: 'array',
          },
          scores: {
            description:
              'contains score objects for the current vulnerability.',
            items: {
              additionalProperties: false,
              description:
                'specifies information about (at least one) score of the vulnerability and for which products the given value applies.',
              minProperties: 2,
              properties: {
                cvss_v2: {
                  $ref: 'https://www.first.org/cvss/cvss-v2.0.json',
                },
                cvss_v3: {
                  oneOf: [
                    {
                      $ref: 'https://www.first.org/cvss/cvss-v3.0.json',
                    },
                    {
                      $ref: 'https://www.first.org/cvss/cvss-v3.1.json',
                    },
                  ],
                },
                products: {
                  $ref: '#/$defs/products_t',
                },
              },
              required: ['products'],
              title: 'Score',
              type: 'object',
            },
            minItems: 1,
            title: 'List of scores',
            type: 'array',
          },
          threats: {
            description:
              'Contains information about a vulnerability that can change with time.',
            items: {
              additionalProperties: false,
              description:
                'Contains the vulnerability kinetic information. This information can change as the vulnerability ages and new information becomes available.',
              properties: {
                category: {
                  description:
                    'Categorizes the threat according to the rules of the specification.',
                  enum: ['exploit_status', 'impact', 'target_set'],
                  title: 'Category of the threat',
                  type: 'string',
                },
                date: {
                  description:
                    'Contains the date when the assessment was done or the threat appeared.',
                  format: 'date-time',
                  title: 'Date of the threat',
                  type: 'string',
                },
                details: {
                  description:
                    'Represents a thorough human-readable discussion of the threat.',
                  minLength: 1,
                  title: 'Details of the threat',
                  type: 'string',
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
              },
              required: ['category', 'details'],
              title: 'Threat',
              type: 'object',
            },
            minItems: 1,
            title: 'List of threats',
            type: 'array',
          },
          title: {
            description:
              'Gives the document producer the ability to apply a canonical name or title to the vulnerability.',
            minLength: 1,
            title: 'Title',
            type: 'string',
          },
        },
        title: 'Vulnerability',
        type: 'object',
      },
      minItems: 1,
      title: 'Vulnerabilities',
      type: 'array',
    },
  },
  required: ['document'],
  title: 'Common Security Advisory Framework',
  type: 'object',
};

const validate$h = csafAjv.compile(schema$3);

/**
 * @param {any} doc
 */
function csaf_2_0_strict(doc) {
  let isValid = validate$h(doc);
  /**
   *
   * @type {Array<{
   *    message?: string
   *    instancePath: string
   *  }>}
   */
  const errors = validate$h.errors ?? [];
  return {
    isValid,
    errors: errors.map((e) => ({
      ...e,
      message: e.message ?? 'unexpected empty error message',
    })),
  }
}

var schema$2 = {
  $schema: 'https://json-schema.org/draft/2020-12/schema',
  $id: 'https://docs.oasis-open.org/csaf/csaf/v2.0/csaf_json_schema.json',
  title: 'Common Security Advisory Framework',
  description:
    'Representation of security advisory information as a JSON document.',
  type: 'object',
  $defs: {
    acknowledgments_t: {
      title: 'List of acknowledgments',
      description: 'Contains a list of acknowledgment elements.',
      type: 'array',
      minItems: 1,
      items: {
        title: 'Acknowledgment',
        description:
          'Acknowledges contributions by describing those that contributed.',
        type: 'object',
        minProperties: 1,
        properties: {
          names: {
            title: 'List of acknowledged names',
            description: 'Contains the names of entities being recognized.',
            type: 'array',
            minItems: 1,
            items: {
              title: 'Name of entity being recognized',
              description: 'Contains the name of a single person.',
              type: 'string',
              minLength: 1,
              examples: ['Albert Einstein', 'Johann Sebastian Bach'],
            },
          },
          organization: {
            title: 'Contributing organization',
            description:
              'Contains the name of a contributing organization being recognized.',
            type: 'string',
            minLength: 1,
            examples: ['CISA', 'Google Project Zero', 'Talos'],
          },
          summary: {
            title: 'Summary of the acknowledgment',
            description:
              'SHOULD represent any contextual details the document producers wish to make known about the acknowledgment or acknowledged parties.',
            type: 'string',
            minLength: 1,
            examples: [
              'First analysis of Coordinated Multi-Stream Attack (CMSA)',
            ],
          },
          urls: {
            title: 'List of URLs',
            description:
              'Specifies a list of URLs or location of the reference to be acknowledged.',
            type: 'array',
            minItems: 1,
            items: {
              title: 'URL of acknowledgment',
              description:
                'Contains the URL or location of the reference to be acknowledged.',
              type: 'string',
              format: 'uri',
            },
          },
        },
      },
    },
    branches_t: {
      title: 'List of branches',
      description:
        'Contains branch elements as children of the current element.',
      type: 'array',
      minItems: 1,
      items: {
        title: 'Branch',
        description:
          'Is a part of the hierarchical structure of the product tree.',
        type: 'object',
        maxProperties: 3,
        minProperties: 3,
        required: ['category', 'name'],
        properties: {
          branches: {
            $ref: '#/$defs/branches_t',
          },
          category: {
            title: 'Category of the branch',
            description: 'Describes the characteristics of the labeled branch.',
            type: 'string',
            enum: [
              'architecture',
              'host_name',
              'language',
              'legacy',
              'patch_level',
              'product_family',
              'product_name',
              'product_version',
              'product_version_range',
              'service_pack',
              'specification',
              'vendor',
            ],
          },
          name: {
            title: 'Name of the branch',
            description:
              "Contains the canonical descriptor or 'friendly name' of the branch.",
            type: 'string',
            minLength: 1,
            examples: [
              '10',
              '365',
              'Microsoft',
              'Office',
              'PCS 7',
              'SIMATIC',
              'Siemens',
              'Windows',
            ],
          },
          product: {
            $ref: '#/$defs/full_product_name_t',
          },
        },
      },
    },
    full_product_name_t: {
      title: 'Full product name',
      description:
        'Specifies information about the product and assigns the product_id.',
      type: 'object',
      required: ['name', 'product_id'],
      properties: {
        name: {
          title: 'Textual description of the product',
          description:
            'The value should be the products full canonical name, including version number and other attributes, as it would be used in a human-friendly document.',
          type: 'string',
          minLength: 1,
          examples: [
            'Cisco AnyConnect Secure Mobility Client 2.3.185',
            'Microsoft Host Integration Server 2006 Service Pack 1',
          ],
        },
        product_id: {
          $ref: '#/$defs/product_id_t',
        },
        product_identification_helper: {
          title: 'Helper to identify the product',
          description:
            'Provides at least one method which aids in identifying the product in an asset database.',
          type: 'object',
          minProperties: 1,
          properties: {
            cpe: {
              title: 'Common Platform Enumeration representation',
              description:
                'The Common Platform Enumeration (CPE) attribute refers to a method for naming platforms external to this specification.',
              type: 'string',
              pattern:
                '^(cpe:2\\.3:[aho\\*\\-](:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){5}(:(([a-zA-Z]{2,3}(-([a-zA-Z]{2}|[0-9]{3}))?)|[\\*\\-]))(:(((\\?*|\\*?)([a-zA-Z0-9\\-\\._]|(\\\\[\\\\\\*\\?!"#\\$%&\'\\(\\)\\+,/:;<=>@\\[\\]\\^`\\{\\|\\}~]))+(\\?*|\\*?))|[\\*\\-])){4})|([c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\\._\\-~%]*){0,6})$',
              minLength: 5,
            },
            hashes: {
              title: 'List of hashes',
              description:
                'Contains a list of cryptographic hashes usable to identify files.',
              type: 'array',
              minItems: 1,
              items: {
                title: 'Cryptographic hashes',
                description:
                  'Contains all information to identify a file based on its cryptographic hash values.',
                type: 'object',
                required: ['file_hashes', 'filename'],
                properties: {
                  file_hashes: {
                    title: 'List of file hashes',
                    description:
                      'Contains a list of cryptographic hashes for this file.',
                    type: 'array',
                    minItems: 1,
                    items: {
                      title: 'File hash',
                      description:
                        'Contains one hash value and algorithm of the file to be identified.',
                      type: 'object',
                      required: ['algorithm', 'value'],
                      properties: {
                        algorithm: {
                          title: 'Algorithm of the cryptographic hash',
                          description:
                            'Contains the name of the cryptographic hash algorithm used to calculate the value.',
                          type: 'string',
                          default: 'sha256',
                          minLength: 1,
                          examples: [
                            'blake2b512',
                            'sha256',
                            'sha3-512',
                            'sha384',
                            'sha512',
                          ],
                        },
                        value: {
                          title: 'Value of the cryptographic hash',
                          description:
                            'Contains the cryptographic hash value in hexadecimal representation.',
                          type: 'string',
                          pattern: '^[0-9a-fA-F]{32,}$',
                          minLength: 32,
                          examples: [
                            '37df33cb7464da5c7f077f4d56a32bc84987ec1d85b234537c1c1a4d4fc8d09dc29e2e762cb5203677bf849a2855a0283710f1f5fe1d6ce8d5ac85c645d0fcb3',
                            '4775203615d9534a8bfca96a93dc8b461a489f69124a130d786b42204f3341cc',
                            '9ea4c8200113d49d26505da0e02e2f49055dc078d1ad7a419b32e291c7afebbb84badfbd46dec42883bea0b2a1fa697c',
                          ],
                        },
                      },
                    },
                  },
                  filename: {
                    title: 'Filename',
                    description:
                      'Contains the name of the file which is identified by the hash values.',
                    type: 'string',
                    minLength: 1,
                    examples: ['WINWORD.EXE', 'msotadddin.dll', 'sudoers.so'],
                  },
                },
              },
            },
            model_numbers: {
              title: 'List of models',
              description: 'Contains a list of parts, or full model numbers.',
              type: 'array',
              minItems: 1,
              uniqueItems: true,
              items: {
                title: 'Model number',
                description:
                  'Contains a part, or a full model number of the component to identify.',
                type: 'string',
                minLength: 1,
              },
            },
            purl: {
              title: 'package URL representation',
              description:
                'The package URL (purl) attribute refers to a method for reliably identifying and locating software packages external to this specification.',
              type: 'string',
              format: 'uri',
              pattern: '^pkg:[A-Za-z\\.\\-\\+][A-Za-z0-9\\.\\-\\+]*/.+',
              minLength: 7,
            },
            sbom_urls: {
              title: 'List of SBOM URLs',
              description:
                'Contains a list of URLs where SBOMs for this product can be retrieved.',
              type: 'array',
              minItems: 1,
              items: {
                title: 'SBOM URL',
                description: 'Contains a URL of one SBOM for this product.',
                type: 'string',
                format: 'uri',
              },
            },
            serial_numbers: {
              title: 'List of serial numbers',
              description: 'Contains a list of parts, or full serial numbers.',
              type: 'array',
              minItems: 1,
              uniqueItems: true,
              items: {
                title: 'Serial number',
                description:
                  'Contains a part, or a full serial number of the component to identify.',
                type: 'string',
                minLength: 1,
              },
            },
            skus: {
              title: 'List of stock keeping units',
              description:
                'Contains a list of parts, or full stock keeping units.',
              type: 'array',
              minItems: 1,
              items: {
                title: 'Stock keeping unit',
                description:
                  'Contains a part, or a full stock keeping unit (SKU) which is used in the ordering process to identify the component.',
                type: 'string',
                minLength: 1,
              },
            },
            x_generic_uris: {
              title: 'List of generic URIs',
              description:
                'Contains a list of identifiers which are either vendor-specific or derived from a standard not yet supported.',
              type: 'array',
              minItems: 1,
              items: {
                title: 'Generic URI',
                description:
                  'Provides a generic extension point for any identifier which is either vendor-specific or derived from a standard not yet supported.',
                type: 'object',
                required: ['namespace', 'uri'],
                properties: {
                  namespace: {
                    title: 'Namespace of the generic URI',
                    description:
                      'Refers to a URL which provides the name and knowledge about the specification used or is the namespace in which these values are valid.',
                    type: 'string',
                    format: 'uri',
                  },
                  uri: {
                    title: 'URI',
                    description: 'Contains the identifier itself.',
                    type: 'string',
                    format: 'uri',
                  },
                },
              },
            },
          },
        },
      },
    },
    lang_t: {
      title: 'Language type',
      description:
        'Identifies a language, corresponding to IETF BCP 47 / RFC 5646. See IETF language registry: https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry',
      type: 'string',
      pattern:
        '^(([A-Za-z]{2,3}(-[A-Za-z]{3}(-[A-Za-z]{3}){0,2})?|[A-Za-z]{4,8})(-[A-Za-z]{4})?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-[A-WY-Za-wy-z0-9](-[A-Za-z0-9]{2,8})+)*(-[Xx](-[A-Za-z0-9]{1,8})+)?|[Xx](-[A-Za-z0-9]{1,8})+|[Ii]-[Dd][Ee][Ff][Aa][Uu][Ll][Tt]|[Ii]-[Mm][Ii][Nn][Gg][Oo])$',
      examples: ['de', 'en', 'fr', 'frc', 'jp'],
    },
    notes_t: {
      title: 'List of notes',
      description: 'Contains notes which are specific to the current context.',
      type: 'array',
      minItems: 1,
      items: {
        title: 'Note',
        description:
          'Is a place to put all manner of text blobs related to the current context.',
        type: 'object',
        required: ['category', 'text'],
        properties: {
          audience: {
            title: 'Audience of note',
            description: 'Indicate who is intended to read it.',
            type: 'string',
            minLength: 1,
            examples: [
              'all',
              'executives',
              'operational management and system administrators',
              'safety engineers',
            ],
          },
          category: {
            title: 'Note category',
            description: 'Choice of what kind of note this is.',
            type: 'string',
            enum: [
              'description',
              'details',
              'faq',
              'general',
              'legal_disclaimer',
              'other',
              'summary',
            ],
          },
          text: {
            title: 'Note contents',
            description:
              'The contents of the note. Content varies depending on type.',
            type: 'string',
            minLength: 1,
          },
          title: {
            title: 'Title of note',
            description:
              'Provides a concise description of what is contained in the text of the note.',
            type: 'string',
            minLength: 1,
            examples: [
              'Details',
              'Executive summary',
              'Technical summary',
              'Impact on safety systems',
            ],
          },
        },
      },
    },
    product_group_id_t: {
      title: 'Reference token for product group instance',
      description:
        'Token required to identify a group of products so that it can be referred to from other parts in the document. There is no predefined or required format for the product_group_id as long as it uniquely identifies a group in the context of the current document.',
      type: 'string',
      minLength: 1,
      examples: ['CSAFGID-0001', 'CSAFGID-0002', 'CSAFGID-0020'],
    },
    product_groups_t: {
      title: 'List of product_group_ids',
      description:
        'Specifies a list of product_group_ids to give context to the parent item.',
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        $ref: '#/$defs/product_group_id_t',
      },
    },
    product_id_t: {
      title: 'Reference token for product instance',
      description:
        'Token required to identify a full_product_name so that it can be referred to from other parts in the document. There is no predefined or required format for the product_id as long as it uniquely identifies a product in the context of the current document.',
      type: 'string',
      minLength: 1,
      examples: ['CSAFPID-0004', 'CSAFPID-0008'],
    },
    products_t: {
      title: 'List of product_ids',
      description:
        'Specifies a list of product_ids to give context to the parent item.',
      type: 'array',
      minItems: 1,
      uniqueItems: true,
      items: {
        $ref: '#/$defs/product_id_t',
      },
    },
    references_t: {
      title: 'List of references',
      description: 'Holds a list of references.',
      type: 'array',
      minItems: 1,
      items: {
        title: 'Reference',
        description:
          'Holds any reference to conferences, papers, advisories, and other resources that are related and considered related to either a surrounding part of or the entire document and to be of value to the document consumer.',
        type: 'object',
        required: ['summary', 'url'],
        properties: {
          category: {
            title: 'Category of reference',
            description:
              'Indicates whether the reference points to the same document or vulnerability in focus (depending on scope) or to an external resource.',
            type: 'string',
            default: 'external',
            enum: ['external', 'self'],
          },
          summary: {
            title: 'Summary of the reference',
            description: 'Indicates what this reference refers to.',
            type: 'string',
            minLength: 1,
          },
          url: {
            title: 'URL of reference',
            description: 'Provides the URL for the reference.',
            type: 'string',
            format: 'uri',
          },
        },
      },
    },
    version_t: {
      title: 'Version',
      description:
        'Specifies a version string to denote clearly the evolution of the content of the document. Format must be either integer or semantic versioning.',
      type: 'string',
      pattern:
        '^(0|[1-9][0-9]*)$|^((0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)$',
      examples: ['1', '4', '0.9.0', '1.4.3', '2.40.0+21AF26D3'],
    },
  },
  required: ['document'],
  properties: {
    document: {
      title: 'Document level meta-data',
      description:
        'Captures the meta-data about this document describing a particular set of security advisories.',
      type: 'object',
      required: ['category', 'csaf_version', 'publisher', 'title', 'tracking'],
      properties: {
        acknowledgments: {
          title: 'Document acknowledgments',
          description:
            'Contains a list of acknowledgment elements associated with the whole document.',
          $ref: '#/$defs/acknowledgments_t',
        },
        aggregate_severity: {
          title: 'Aggregate severity',
          description:
            "Is a vehicle that is provided by the document producer to convey the urgency and criticality with which the one or more vulnerabilities reported should be addressed. It is a document-level metric and applied to the document as a whole  not any specific vulnerability. The range of values in this field is defined according to the document producer's policies and procedures.",
          type: 'object',
          required: ['text'],
          properties: {
            namespace: {
              title: 'Namespace of aggregate severity',
              description: 'Points to the namespace so referenced.',
              type: 'string',
              format: 'uri',
            },
            text: {
              title: 'Text of aggregate severity',
              description:
                'Provides a severity which is independent of - and in addition to - any other standard metric for determining the impact or severity of a given vulnerability (such as CVSS).',
              type: 'string',
              minLength: 1,
              examples: ['Critical', 'Important', 'Moderate'],
            },
          },
        },
        category: {
          title: 'Document category',
          description:
            'Defines a short canonical name, chosen by the document producer, which will inform the end user as to the category of document.',
          type: 'string',
          pattern: '^[^\\s\\-_\\.](.*[^\\s\\-_\\.])?$',
          minLength: 1,
          examples: [
            'csaf_base',
            'csaf_security_advisory',
            'csaf_vex',
            'Example Company Security Notice',
          ],
        },
        csaf_version: {
          title: 'CSAF version',
          description:
            'Gives the version of the CSAF specification which the document was generated for.',
          type: 'string',
          enum: ['2.0'],
        },
        distribution: {
          title: 'Rules for sharing document',
          description:
            'Describe any constraints on how this document might be shared.',
          type: 'object',
          minProperties: 1,
          properties: {
            text: {
              title: 'Textual description',
              description:
                'Provides a textual description of additional constraints.',
              type: 'string',
              minLength: 1,
              examples: [
                'Copyright 2021, Example Company, All Rights Reserved.',
                'Distribute freely.',
                'Share only on a need-to-know-basis only.',
              ],
            },
            tlp: {
              title: 'Traffic Light Protocol (TLP)',
              description:
                'Provides details about the TLP classification of the document.',
              type: 'object',
              required: ['label'],
              properties: {
                label: {
                  title: 'Label of TLP',
                  description: 'Provides the TLP label of the document.',
                  type: 'string',
                  enum: ['AMBER', 'GREEN', 'RED', 'WHITE'],
                },
                url: {
                  title: 'URL of TLP version',
                  description:
                    'Provides a URL where to find the textual description of the TLP version which is used in this document. Default is the URL to the definition by FIRST.',
                  type: 'string',
                  default: 'https://www.first.org/tlp/',
                  format: 'uri',
                  examples: [
                    'https://www.us-cert.gov/tlp',
                    'https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Kritis/Merkblatt_TLP.pdf',
                  ],
                },
              },
            },
          },
        },
        lang: {
          title: 'Document language',
          description:
            'Identifies the language used by this document, corresponding to IETF BCP 47 / RFC 5646.',
          $ref: '#/$defs/lang_t',
        },
        notes: {
          title: 'Document notes',
          description: 'Holds notes associated with the whole document.',
          $ref: '#/$defs/notes_t',
        },
        publisher: {
          title: 'Publisher',
          description:
            'Provides information about the publisher of the document.',
          type: 'object',
          required: ['category', 'name', 'namespace'],
          properties: {
            category: {
              title: 'Category of publisher',
              description:
                'Provides information about the category of publisher releasing the document.',
              type: 'string',
              enum: [
                'coordinator',
                'discoverer',
                'other',
                'translator',
                'user',
                'vendor',
              ],
            },
            contact_details: {
              title: 'Contact details',
              description:
                'Information on how to contact the publisher, possibly including details such as web sites, email addresses, phone numbers, and postal mail addresses.',
              type: 'string',
              minLength: 1,
              examples: [
                'Example Company can be reached at contact_us@example.com, or via our website at https://www.example.com/contact.',
              ],
            },
            issuing_authority: {
              title: 'Issuing authority',
              description:
                "Provides information about the authority of the issuing party to release the document, in particular, the party's constituency and responsibilities or other obligations.",
              type: 'string',
              minLength: 1,
            },
            name: {
              title: 'Name of publisher',
              description: 'Contains the name of the issuing party.',
              type: 'string',
              minLength: 1,
              examples: ['BSI', 'Cisco PSIRT', 'Siemens ProductCERT'],
            },
            namespace: {
              title: 'Namespace of publisher',
              description:
                'Contains a URL which is under control of the issuing party and can be used as a globally unique identifier for that issuing party.',
              type: 'string',
              format: 'uri',
              examples: ['https://csaf.io', 'https://www.example.com'],
            },
          },
        },
        references: {
          title: 'Document references',
          description:
            'Holds a list of references associated with the whole document.',
          $ref: '#/$defs/references_t',
        },
        source_lang: {
          title: 'Source language',
          description:
            'If this copy of the document is a translation then the value of this property describes from which language this document was translated.',
          $ref: '#/$defs/lang_t',
        },
        title: {
          title: 'Title of this document',
          description:
            'This SHOULD be a canonical name for the document, and sufficiently unique to distinguish it from similar documents.',
          type: 'string',
          minLength: 1,
          examples: [
            'Cisco IPv6 Crafted Packet Denial of Service Vulnerability',
            'Example Company Cross-Site-Scripting Vulnerability in Example Generator',
          ],
        },
        tracking: {
          title: 'Tracking',
          description:
            'Is a container designated to hold all management attributes necessary to track a CSAF document as a whole.',
          type: 'object',
          required: [
            'current_release_date',
            'id',
            'initial_release_date',
            'revision_history',
            'status',
            'version',
          ],
          properties: {
            aliases: {
              title: 'Aliases',
              description:
                'Contains a list of alternate names for the same document.',
              type: 'array',
              minItems: 1,
              uniqueItems: true,
              items: {
                title: 'Alternate name',
                description:
                  'Specifies a non-empty string that represents a distinct optional alternative ID used to refer to the document.',
                type: 'string',
                minLength: 1,
                examples: ['CVE-2019-12345'],
              },
            },
            current_release_date: {
              title: 'Current release date',
              description:
                'The date when the current revision of this document was released',
              type: 'string',
              format: 'date-time',
            },
            generator: {
              title: 'Document generator',
              description:
                'Is a container to hold all elements related to the generation of the document. These items will reference when the document was actually created, including the date it was generated and the entity that generated it.',
              type: 'object',
              required: ['engine'],
              properties: {
                date: {
                  title: 'Date of document generation',
                  description:
                    'This SHOULD be the current date that the document was generated. Because documents are often generated internally by a document producer and exist for a nonzero amount of time before being released, this field MAY be different from the Initial Release Date and Current Release Date.',
                  type: 'string',
                  format: 'date-time',
                },
                engine: {
                  title: 'Engine of document generation',
                  description:
                    'Contains information about the engine that generated the CSAF document.',
                  type: 'object',
                  required: ['name'],
                  properties: {
                    name: {
                      title: 'Engine name',
                      description:
                        'Represents the name of the engine that generated the CSAF document.',
                      type: 'string',
                      minLength: 1,
                      examples: ['Red Hat rhsa-to-cvrf', 'Secvisogram', 'TVCE'],
                    },
                    version: {
                      title: 'Engine version',
                      description:
                        'Contains the version of the engine that generated the CSAF document.',
                      type: 'string',
                      minLength: 1,
                      examples: ['0.6.0', '1.0.0-beta+exp.sha.a1c44f85', '2'],
                    },
                  },
                },
              },
            },
            id: {
              title: 'Unique identifier for the document',
              description:
                'The ID is a simple label that provides for a wide range of numbering values, types, and schemes. Its value SHOULD be assigned and maintained by the original document issuing authority.',
              type: 'string',
              pattern: '^[\\S](.*[\\S])?$',
              minLength: 1,
              examples: [
                'Example Company - 2019-YH3234',
                'RHBA-2019:0024',
                'cisco-sa-20190513-secureboot',
              ],
            },
            initial_release_date: {
              title: 'Initial release date',
              description: 'The date when this document was first published.',
              type: 'string',
              format: 'date-time',
            },
            revision_history: {
              title: 'Revision history',
              description:
                'Holds one revision item for each version of the CSAF document, including the initial one.',
              type: 'array',
              minItems: 1,
              items: {
                title: 'Revision',
                description:
                  'Contains all the information elements required to track the evolution of a CSAF document.',
                type: 'object',
                required: ['date', 'number', 'summary'],
                properties: {
                  date: {
                    title: 'Date of the revision',
                    description: 'The date of the revision entry',
                    type: 'string',
                    format: 'date-time',
                  },
                  legacy_version: {
                    title: 'Legacy version of the revision',
                    description:
                      'Contains the version string used in an existing document with the same content.',
                    type: 'string',
                    minLength: 1,
                  },
                  number: {
                    $ref: '#/$defs/version_t',
                  },
                  summary: {
                    title: 'Summary of the revision',
                    description:
                      'Holds a single non-empty string representing a short description of the changes.',
                    type: 'string',
                    minLength: 1,
                    examples: ['Initial version.'],
                  },
                },
              },
            },
            status: {
              title: 'Document status',
              description: 'Defines the draft status of the document.',
              type: 'string',
              enum: ['draft', 'final', 'interim'],
            },
            version: {
              $ref: '#/$defs/version_t',
            },
          },
        },
      },
    },
    product_tree: {
      title: 'Product tree',
      description:
        'Is a container for all fully qualified product names that can be referenced elsewhere in the document.',
      type: 'object',
      minProperties: 1,
      properties: {
        branches: {
          $ref: '#/$defs/branches_t',
        },
        full_product_names: {
          title: 'List of full product names',
          description: 'Contains a list of full product names.',
          type: 'array',
          minItems: 1,
          items: {
            $ref: '#/$defs/full_product_name_t',
          },
        },
        product_groups: {
          title: 'List of product groups',
          description: 'Contains a list of product groups.',
          type: 'array',
          minItems: 1,
          items: {
            title: 'Product group',
            description:
              'Defines a new logical group of products that can then be referred to in other parts of the document to address a group of products with a single identifier.',
            type: 'object',
            required: ['group_id', 'product_ids'],
            properties: {
              group_id: {
                $ref: '#/$defs/product_group_id_t',
              },
              product_ids: {
                title: 'List of Product IDs',
                description:
                  'Lists the product_ids of those products which known as one group in the document.',
                type: 'array',
                minItems: 2,
                uniqueItems: true,
                items: {
                  $ref: '#/$defs/product_id_t',
                },
              },
              summary: {
                title: 'Summary of the product group',
                description:
                  'Gives a short, optional description of the group.',
                type: 'string',
                minLength: 1,
                examples: [
                  'Products supporting Modbus.',
                  'The x64 versions of the operating system.',
                ],
              },
            },
          },
        },
        relationships: {
          title: 'List of relationships',
          description: 'Contains a list of relationships.',
          type: 'array',
          minItems: 1,
          items: {
            title: 'Relationship',
            description:
              'Establishes a link between two existing full_product_name_t elements, allowing the document producer to define a combination of two products that form a new full_product_name entry.',
            type: 'object',
            required: [
              'category',
              'full_product_name',
              'product_reference',
              'relates_to_product_reference',
            ],
            properties: {
              category: {
                title: 'Relationship category',
                description:
                  'Defines the category of relationship for the referenced component.',
                type: 'string',
                enum: [
                  'default_component_of',
                  'external_component_of',
                  'installed_on',
                  'installed_with',
                  'optional_component_of',
                ],
              },
              full_product_name: {
                $ref: '#/$defs/full_product_name_t',
              },
              product_reference: {
                title: 'Product reference',
                description:
                  'Holds a Product ID that refers to the Full Product Name element, which is referenced as the first element of the relationship.',
                $ref: '#/$defs/product_id_t',
              },
              relates_to_product_reference: {
                title: 'Relates to product reference',
                description:
                  'Holds a Product ID that refers to the Full Product Name element, which is referenced as the second element of the relationship.',
                $ref: '#/$defs/product_id_t',
              },
            },
          },
        },
      },
    },
    vulnerabilities: {
      title: 'Vulnerabilities',
      description:
        'Represents a list of all relevant vulnerability information items.',
      type: 'array',
      minItems: 1,
      items: {
        title: 'Vulnerability',
        description:
          'Is a container for the aggregation of all fields that are related to a single vulnerability in the document.',
        type: 'object',
        minProperties: 1,
        properties: {
          acknowledgments: {
            title: 'Vulnerability acknowledgments',
            description:
              'Contains a list of acknowledgment elements associated with this vulnerability item.',
            $ref: '#/$defs/acknowledgments_t',
          },
          cve: {
            title: 'CVE',
            description:
              'Holds the MITRE standard Common Vulnerabilities and Exposures (CVE) tracking number for the vulnerability.',
            type: 'string',
            pattern: '^CVE-[0-9]{4}-[0-9]{4,}$',
          },
          cwe: {
            title: 'CWE',
            description:
              'Holds the MITRE standard Common Weakness Enumeration (CWE) for the weakness associated.',
            type: 'object',
            required: ['id', 'name'],
            properties: {
              id: {
                title: 'Weakness ID',
                description: 'Holds the ID for the weakness associated.',
                type: 'string',
                pattern: '^CWE-[1-9]\\d{0,5}$',
                examples: ['CWE-22', 'CWE-352', 'CWE-79'],
              },
              name: {
                title: 'Weakness name',
                description:
                  'Holds the full name of the weakness as given in the CWE specification.',
                type: 'string',
                minLength: 1,
                examples: [
                  'Cross-Site Request Forgery (CSRF)',
                  "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
                  "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
                ],
              },
            },
          },
          discovery_date: {
            title: 'Discovery date',
            description:
              'Holds the date and time the vulnerability was originally discovered.',
            type: 'string',
            format: 'date-time',
          },
          flags: {
            title: 'List of flags',
            description: 'Contains a list of machine readable flags.',
            type: 'array',
            minItems: 1,
            uniqueItems: true,
            items: {
              title: 'Flag',
              description:
                'Contains product specific information in regard to this vulnerability as a single machine readable flag.',
              type: 'object',
              required: ['label'],
              properties: {
                date: {
                  title: 'Date of the flag',
                  description:
                    'Contains the date when assessment was done or the flag was assigned.',
                  type: 'string',
                  format: 'date-time',
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                label: {
                  title: 'Label of the flag',
                  description: 'Specifies the machine readable label.',
                  type: 'string',
                  enum: [
                    'component_not_present',
                    'inline_mitigations_already_exist',
                    'vulnerable_code_cannot_be_controlled_by_adversary',
                    'vulnerable_code_not_in_execute_path',
                    'vulnerable_code_not_present',
                  ],
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
              },
            },
          },
          ids: {
            title: 'List of IDs',
            description:
              'Represents a list of unique labels or tracking IDs for the vulnerability (if such information exists).',
            type: 'array',
            minItems: 1,
            uniqueItems: true,
            items: {
              title: 'ID',
              description:
                'Contains a single unique label or tracking ID for the vulnerability.',
              type: 'object',
              required: ['system_name', 'text'],
              properties: {
                system_name: {
                  title: 'System name',
                  description:
                    'Indicates the name of the vulnerability tracking or numbering system.',
                  type: 'string',
                  minLength: 1,
                  examples: ['Cisco Bug ID', 'GitHub Issue'],
                },
                text: {
                  title: 'Text',
                  description:
                    'Is unique label or tracking ID for the vulnerability (if such information exists).',
                  type: 'string',
                  minLength: 1,
                  examples: ['CSCso66472', 'oasis-tcs/csaf#210'],
                },
              },
            },
          },
          involvements: {
            title: 'List of involvements',
            description: 'Contains a list of involvements.',
            type: 'array',
            minItems: 1,
            uniqueItems: true,
            items: {
              title: 'Involvement',
              description:
                'Is a container, that allows the document producers to comment on the level of involvement (or engagement) of themselves or third parties in the vulnerability identification, scoping, and remediation process.',
              type: 'object',
              required: ['party', 'status'],
              properties: {
                date: {
                  title: 'Date of involvement',
                  description:
                    'Holds the date and time of the involvement entry.',
                  type: 'string',
                  format: 'date-time',
                },
                party: {
                  title: 'Party category',
                  description: 'Defines the category of the involved party.',
                  type: 'string',
                  enum: [
                    'coordinator',
                    'discoverer',
                    'other',
                    'user',
                    'vendor',
                  ],
                },
                status: {
                  title: 'Party status',
                  description: 'Defines contact status of the involved party.',
                  type: 'string',
                  enum: [
                    'completed',
                    'contact_attempted',
                    'disputed',
                    'in_progress',
                    'not_contacted',
                    'open',
                  ],
                },
                summary: {
                  title: 'Summary of the involvement',
                  description:
                    'Contains additional context regarding what is going on.',
                  type: 'string',
                  minLength: 1,
                },
              },
            },
          },
          notes: {
            title: 'Vulnerability notes',
            description: 'Holds notes associated with this vulnerability item.',
            $ref: '#/$defs/notes_t',
          },
          product_status: {
            title: 'Product status',
            description:
              'Contains different lists of product_ids which provide details on the status of the referenced product related to the current vulnerability. ',
            type: 'object',
            minProperties: 1,
            properties: {
              first_affected: {
                title: 'First affected',
                description:
                  'These are the first versions of the releases known to be affected by the vulnerability.',
                $ref: '#/$defs/products_t',
              },
              first_fixed: {
                title: 'First fixed',
                description:
                  'These versions contain the first fix for the vulnerability but may not be the recommended fixed versions.',
                $ref: '#/$defs/products_t',
              },
              fixed: {
                title: 'Fixed',
                description:
                  'These versions contain a fix for the vulnerability but may not be the recommended fixed versions.',
                $ref: '#/$defs/products_t',
              },
              known_affected: {
                title: 'Known affected',
                description:
                  'These versions are known to be affected by the vulnerability.',
                $ref: '#/$defs/products_t',
              },
              known_not_affected: {
                title: 'Known not affected',
                description:
                  'These versions are known not to be affected by the vulnerability.',
                $ref: '#/$defs/products_t',
              },
              last_affected: {
                title: 'Last affected',
                description:
                  'These are the last versions in a release train known to be affected by the vulnerability. Subsequently released versions would contain a fix for the vulnerability.',
                $ref: '#/$defs/products_t',
              },
              recommended: {
                title: 'Recommended',
                description:
                  'These versions have a fix for the vulnerability and are the vendor-recommended versions for fixing the vulnerability.',
                $ref: '#/$defs/products_t',
              },
              under_investigation: {
                title: 'Under investigation',
                description:
                  'It is not known yet whether these versions are or are not affected by the vulnerability. However, it is still under investigation - the result will be provided in a later release of the document.',
                $ref: '#/$defs/products_t',
              },
            },
          },
          references: {
            title: 'Vulnerability references',
            description:
              'Holds a list of references associated with this vulnerability item.',
            $ref: '#/$defs/references_t',
          },
          release_date: {
            title: 'Release date',
            description:
              'Holds the date and time the vulnerability was originally released into the wild.',
            type: 'string',
            format: 'date-time',
          },
          remediations: {
            title: 'List of remediations',
            description: 'Contains a list of remediations.',
            type: 'array',
            minItems: 1,
            items: {
              title: 'Remediation',
              description:
                'Specifies details on how to handle (and presumably, fix) a vulnerability.',
              type: 'object',
              required: ['category', 'details'],
              properties: {
                category: {
                  title: 'Category of the remediation',
                  description:
                    'Specifies the category which this remediation belongs to.',
                  type: 'string',
                  enum: [
                    'mitigation',
                    'no_fix_planned',
                    'none_available',
                    'vendor_fix',
                    'workaround',
                  ],
                },
                date: {
                  title: 'Date of the remediation',
                  description:
                    'Contains the date from which the remediation is available.',
                  type: 'string',
                  format: 'date-time',
                },
                details: {
                  title: 'Details of the remediation',
                  description:
                    'Contains a thorough human-readable discussion of the remediation.',
                  type: 'string',
                  minLength: 1,
                },
                entitlements: {
                  title: 'List of entitlements',
                  description: 'Contains a list of entitlements.',
                  type: 'array',
                  minItems: 1,
                  items: {
                    title: 'Entitlement of the remediation',
                    description:
                      'Contains any possible vendor-defined constraints for obtaining fixed software or hardware that fully resolves the vulnerability.',
                    type: 'string',
                    minLength: 1,
                  },
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
                restart_required: {
                  title: 'Restart required by remediation',
                  description:
                    'Provides information on category of restart is required by this remediation to become effective.',
                  type: 'object',
                  required: ['category'],
                  properties: {
                    category: {
                      title: 'Category of restart',
                      description:
                        'Specifies what category of restart is required by this remediation to become effective.',
                      type: 'string',
                      enum: [
                        'connected',
                        'dependencies',
                        'machine',
                        'none',
                        'parent',
                        'service',
                        'system',
                        'vulnerable_component',
                        'zone',
                      ],
                    },
                    details: {
                      title: 'Additional restart information',
                      description:
                        'Provides additional information for the restart. This can include details on procedures, scope or impact.',
                      type: 'string',
                      minLength: 1,
                    },
                  },
                },
                url: {
                  title: 'URL to the remediation',
                  description:
                    'Contains the URL where to obtain the remediation.',
                  type: 'string',
                  format: 'uri',
                },
              },
            },
          },
          scores: {
            title: 'List of scores',
            description:
              'contains score objects for the current vulnerability.',
            type: 'array',
            minItems: 1,
            items: {
              title: 'Score',
              description:
                'specifies information about (at least one) score of the vulnerability and for which products the given value applies.',
              type: 'object',
              minProperties: 2,
              required: ['products'],
              properties: {
                cvss_v2: {
                  $ref: 'https://www.first.org/cvss/cvss-v2.0.json',
                },
                cvss_v3: {
                  oneOf: [
                    {
                      $ref: 'https://www.first.org/cvss/cvss-v3.0.json',
                    },
                    {
                      $ref: 'https://www.first.org/cvss/cvss-v3.1.json',
                    },
                  ],
                },
                products: {
                  $ref: '#/$defs/products_t',
                },
              },
            },
          },
          threats: {
            title: 'List of threats',
            description:
              'Contains information about a vulnerability that can change with time.',
            type: 'array',
            minItems: 1,
            items: {
              title: 'Threat',
              description:
                'Contains the vulnerability kinetic information. This information can change as the vulnerability ages and new information becomes available.',
              type: 'object',
              required: ['category', 'details'],
              properties: {
                category: {
                  title: 'Category of the threat',
                  description:
                    'Categorizes the threat according to the rules of the specification.',
                  type: 'string',
                  enum: ['exploit_status', 'impact', 'target_set'],
                },
                date: {
                  title: 'Date of the threat',
                  description:
                    'Contains the date when the assessment was done or the threat appeared.',
                  type: 'string',
                  format: 'date-time',
                },
                details: {
                  title: 'Details of the threat',
                  description:
                    'Represents a thorough human-readable discussion of the threat.',
                  type: 'string',
                  minLength: 1,
                },
                group_ids: {
                  $ref: '#/$defs/product_groups_t',
                },
                product_ids: {
                  $ref: '#/$defs/products_t',
                },
              },
            },
          },
          title: {
            title: 'Title',
            description:
              'Gives the document producer the ability to apply a canonical name or title to the vulnerability.',
            type: 'string',
            minLength: 1,
          },
        },
      },
    },
  },
};

const validate$g = csafAjv.compile(schema$2);

/**
 * @param {any} doc
 */
function csaf_2_0(doc) {
  let isValid = validate$g(doc);
  /**
   *
   * @type {Array<{
   *    message?: string
   *    instancePath: string
   *  }>}
   */
  const errors = validate$g.errors ?? [];
  return {
    isValid,
    errors: errors.map((e) => ({
      ...e,
      message: e.message ?? 'unexpected empty error message',
    })),
  }
}

var schema$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  csaf_2_0: csaf_2_0,
  csaf_2_0_strict: csaf_2_0_strict
});

var re$2 = {exports: {}};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
];

var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
};

const debug$1 = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug$1;

(function (module, exports) {
	const {
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_LENGTH,
	} = constants$1;
	const debug = debug_1;
	exports = module.exports = {};

	// The actual regexps go on exports.re
	const re = exports.re = [];
	const safeRe = exports.safeRe = [];
	const src = exports.src = [];
	const t = exports.t = {};
	let R = 0;

	const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

	// Replace some greedy regex tokens to prevent regex dos issues. These regex are
	// used internally via the safeRe object since all inputs in this library get
	// normalized first to trim and collapse all extra whitespace. The original
	// regexes are exported for userland consumption and lower level usage. A
	// future breaking change could export the safer regex only with a note that
	// all input should have extra whitespace removed.
	const safeRegexReplacements = [
	  ['\\s', 1],
	  ['\\d', MAX_LENGTH],
	  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
	];

	const makeSafeRegex = (value) => {
	  for (const [token, max] of safeRegexReplacements) {
	    value = value
	      .split(`${token}*`).join(`${token}{0,${max}}`)
	      .split(`${token}+`).join(`${token}{1,${max}}`);
	  }
	  return value
	};

	const createToken = (name, value, isGlobal) => {
	  const safe = makeSafeRegex(value);
	  const index = R++;
	  debug(name, index, value);
	  t[name] = index;
	  src[index] = value;
	  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
	  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
	};

	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.

	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.

	createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
	createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.

	createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

	// ## Main Version
	// Three dot-separated numeric identifiers.

	createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})`);

	createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.

	createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

	createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.

	createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
	}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

	createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
	}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.

	createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.

	createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
	}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.

	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.

	createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
	}${src[t.PRERELEASE]}?${
	  src[t.BUILD]}?`);

	createToken('FULL', `^${src[t.FULLPLAIN]}$`);

	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
	}${src[t.PRERELEASELOOSE]}?${
	  src[t.BUILD]}?`);

	createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

	createToken('GTLT', '((?:<|>)?=?)');

	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

	createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:${src[t.PRERELEASE]})?${
	                     src[t.BUILD]}?` +
	                   `)?)?`);

	createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:${src[t.PRERELEASELOOSE]})?${
	                          src[t.BUILD]}?` +
	                        `)?)?`);

	createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
	createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

	// Coercion.
	// Extract anything that could conceivably be a part of a valid semver
	createToken('COERCE', `${'(^|[^\\d])' +
	              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
	              `(?:$|[^\\d])`);
	createToken('COERCERTL', src[t.COERCE], true);

	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	createToken('LONETILDE', '(?:~>?)');

	createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
	exports.tildeTrimReplace = '$1~';

	createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
	createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	createToken('LONECARET', '(?:\\^)');

	createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
	exports.caretTrimReplace = '$1^';

	createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
	createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
	createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
	}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
	exports.comparatorTrimReplace = '$1$2$3';

	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
	                   `\\s+-\\s+` +
	                   `(${src[t.XRANGEPLAIN]})` +
	                   `\\s*$`);

	createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s+-\\s+` +
	                        `(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s*$`);

	// Star ranges basically just allow anything at all.
	createToken('STAR', '(<|>)?=?\\s*\\*');
	// >=0.0.0 is like a star
	createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
	createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
} (re$2, re$2.exports));

var reExports = re$2.exports;

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({ });
const parseOptions$1 = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
};
var parseOptions_1 = parseOptions$1;

const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers,
};

const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1 } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;

const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor (version, options) {
    options = parseOptions(options);

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER$1 || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER$1 || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER$1 || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$1) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier, identifierBase);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier, identifierBase);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier, identifierBase);
        this.inc('pre', identifier, identifierBase);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase);
        }
        this.inc('pre', identifier, identifierBase);
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0;

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base];
          if (identifierBase === false) {
            prerelease = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease;
            }
          } else {
            this.prerelease = prerelease;
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`;
    }
    return this
  }
};

var semver$2 = SemVer$d;

const SemVer$c = semver$2;
const parse$7 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version
  }
  try {
    return new SemVer$c(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
};

var parse_1 = parse$7;

const parse$6 = parse_1;
const valid$7 = (version, options) => {
  const v = parse$6(version, options);
  return v ? v.version : null
};
var valid_1 = valid$7;

const parse$5 = parse_1;
const clean$1 = (version, options) => {
  const s = parse$5(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
};
var clean_1 = clean$1;

const SemVer$b = semver$2;

const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier;
    identifier = options;
    options = undefined;
  }

  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
};
var inc_1 = inc$1;

const parse$4 = parse_1;

const diff$1 = (version1, version2) => {
  const v1 = parse$4(version1, null, true);
  const v2 = parse$4(version2, null, true);
  const comparison = v1.compare(v2);

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // Otherwise it can be determined by checking the high version

    if (highVersion.patch) {
      // anything higher than a patch bump would result in the wrong version
      return 'patch'
    }

    if (highVersion.minor) {
      // anything higher than a minor bump would result in the wrong version
      return 'minor'
    }

    // bumping major/minor/patch all have same result
    return 'major'
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : '';

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
};

var diff_1 = diff$1;

const SemVer$a = semver$2;
const major$3 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$3;

const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;

const SemVer$8 = semver$2;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;

const parse$3 = parse_1;
const prerelease$4 = (version, options) => {
  const parsed = parse$3(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
};
var prerelease_1 = prerelease$4;

const SemVer$7 = semver$2;
const compare$b = (a, b, loose) =>
  new SemVer$7(a, loose).compare(new SemVer$7(b, loose));

var compare_1 = compare$b;

const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;

const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;

const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
};
var compareBuild_1 = compareBuild$3;

const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;

const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;

const compare$8 = compare_1;
const gt$5 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$5;

const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;

const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;

const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;

const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;

const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;

const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$4 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;

const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version;
      }
      if (typeof b === 'object') {
        b = b.version;
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq$1(a, b, loose)

    case '!=':
      return neq$1(a, b, loose)

    case '>':
      return gt$4(a, b, loose)

    case '>=':
      return gte$2(a, b, loose)

    case '<':
      return lt$2(a, b, loose)

    case '<=':
      return lte$2(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
};
var cmp_1 = cmp$1;

const SemVer$5 = semver$2;
const parse$2 = parse_1;
const { safeRe: re, t } = reExports;

const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null
  }

  return parse$2(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
};
var coerce_1 = coerce$1;

var iterator;
var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator;
	hasRequiredIterator = 1;
	iterator = function (Yallist) {
	  Yallist.prototype[Symbol.iterator] = function* () {
	    for (let walker = this.head; walker; walker = walker.next) {
	      yield walker.value;
	    }
	  };
	};
	return iterator;
}

var yallist;
var hasRequiredYallist;

function requireYallist () {
	if (hasRequiredYallist) return yallist;
	hasRequiredYallist = 1;
	yallist = Yallist;

	Yallist.Node = Node;
	Yallist.create = Yallist;

	function Yallist (list) {
	  var self = this;
	  if (!(self instanceof Yallist)) {
	    self = new Yallist();
	  }

	  self.tail = null;
	  self.head = null;
	  self.length = 0;

	  if (list && typeof list.forEach === 'function') {
	    list.forEach(function (item) {
	      self.push(item);
	    });
	  } else if (arguments.length > 0) {
	    for (var i = 0, l = arguments.length; i < l; i++) {
	      self.push(arguments[i]);
	    }
	  }

	  return self
	}

	Yallist.prototype.removeNode = function (node) {
	  if (node.list !== this) {
	    throw new Error('removing node which does not belong to this list')
	  }

	  var next = node.next;
	  var prev = node.prev;

	  if (next) {
	    next.prev = prev;
	  }

	  if (prev) {
	    prev.next = next;
	  }

	  if (node === this.head) {
	    this.head = next;
	  }
	  if (node === this.tail) {
	    this.tail = prev;
	  }

	  node.list.length--;
	  node.next = null;
	  node.prev = null;
	  node.list = null;

	  return next
	};

	Yallist.prototype.unshiftNode = function (node) {
	  if (node === this.head) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var head = this.head;
	  node.list = this;
	  node.next = head;
	  if (head) {
	    head.prev = node;
	  }

	  this.head = node;
	  if (!this.tail) {
	    this.tail = node;
	  }
	  this.length++;
	};

	Yallist.prototype.pushNode = function (node) {
	  if (node === this.tail) {
	    return
	  }

	  if (node.list) {
	    node.list.removeNode(node);
	  }

	  var tail = this.tail;
	  node.list = this;
	  node.prev = tail;
	  if (tail) {
	    tail.next = node;
	  }

	  this.tail = node;
	  if (!this.head) {
	    this.head = node;
	  }
	  this.length++;
	};

	Yallist.prototype.push = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    push(this, arguments[i]);
	  }
	  return this.length
	};

	Yallist.prototype.unshift = function () {
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    unshift(this, arguments[i]);
	  }
	  return this.length
	};

	Yallist.prototype.pop = function () {
	  if (!this.tail) {
	    return undefined
	  }

	  var res = this.tail.value;
	  this.tail = this.tail.prev;
	  if (this.tail) {
	    this.tail.next = null;
	  } else {
	    this.head = null;
	  }
	  this.length--;
	  return res
	};

	Yallist.prototype.shift = function () {
	  if (!this.head) {
	    return undefined
	  }

	  var res = this.head.value;
	  this.head = this.head.next;
	  if (this.head) {
	    this.head.prev = null;
	  } else {
	    this.tail = null;
	  }
	  this.length--;
	  return res
	};

	Yallist.prototype.forEach = function (fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.head, i = 0; walker !== null; i++) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.next;
	  }
	};

	Yallist.prototype.forEachReverse = function (fn, thisp) {
	  thisp = thisp || this;
	  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
	    fn.call(thisp, walker.value, i, this);
	    walker = walker.prev;
	  }
	};

	Yallist.prototype.get = function (n) {
	  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.next;
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	};

	Yallist.prototype.getReverse = function (n) {
	  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
	    // abort out of the list early if we hit a cycle
	    walker = walker.prev;
	  }
	  if (i === n && walker !== null) {
	    return walker.value
	  }
	};

	Yallist.prototype.map = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.head; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.next;
	  }
	  return res
	};

	Yallist.prototype.mapReverse = function (fn, thisp) {
	  thisp = thisp || this;
	  var res = new Yallist();
	  for (var walker = this.tail; walker !== null;) {
	    res.push(fn.call(thisp, walker.value, this));
	    walker = walker.prev;
	  }
	  return res
	};

	Yallist.prototype.reduce = function (fn, initial) {
	  var acc;
	  var walker = this.head;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.head) {
	    walker = this.head.next;
	    acc = this.head.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = 0; walker !== null; i++) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.next;
	  }

	  return acc
	};

	Yallist.prototype.reduceReverse = function (fn, initial) {
	  var acc;
	  var walker = this.tail;
	  if (arguments.length > 1) {
	    acc = initial;
	  } else if (this.tail) {
	    walker = this.tail.prev;
	    acc = this.tail.value;
	  } else {
	    throw new TypeError('Reduce of empty list with no initial value')
	  }

	  for (var i = this.length - 1; walker !== null; i--) {
	    acc = fn(acc, walker.value, i);
	    walker = walker.prev;
	  }

	  return acc
	};

	Yallist.prototype.toArray = function () {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.head; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.next;
	  }
	  return arr
	};

	Yallist.prototype.toArrayReverse = function () {
	  var arr = new Array(this.length);
	  for (var i = 0, walker = this.tail; walker !== null; i++) {
	    arr[i] = walker.value;
	    walker = walker.prev;
	  }
	  return arr
	};

	Yallist.prototype.slice = function (from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
	    walker = walker.next;
	  }
	  for (; walker !== null && i < to; i++, walker = walker.next) {
	    ret.push(walker.value);
	  }
	  return ret
	};

	Yallist.prototype.sliceReverse = function (from, to) {
	  to = to || this.length;
	  if (to < 0) {
	    to += this.length;
	  }
	  from = from || 0;
	  if (from < 0) {
	    from += this.length;
	  }
	  var ret = new Yallist();
	  if (to < from || to < 0) {
	    return ret
	  }
	  if (from < 0) {
	    from = 0;
	  }
	  if (to > this.length) {
	    to = this.length;
	  }
	  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
	    walker = walker.prev;
	  }
	  for (; walker !== null && i > from; i--, walker = walker.prev) {
	    ret.push(walker.value);
	  }
	  return ret
	};

	Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
	  if (start > this.length) {
	    start = this.length - 1;
	  }
	  if (start < 0) {
	    start = this.length + start;
	  }

	  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
	    walker = walker.next;
	  }

	  var ret = [];
	  for (var i = 0; walker && i < deleteCount; i++) {
	    ret.push(walker.value);
	    walker = this.removeNode(walker);
	  }
	  if (walker === null) {
	    walker = this.tail;
	  }

	  if (walker !== this.head && walker !== this.tail) {
	    walker = walker.prev;
	  }

	  for (var i = 0; i < nodes.length; i++) {
	    walker = insert(this, walker, nodes[i]);
	  }
	  return ret;
	};

	Yallist.prototype.reverse = function () {
	  var head = this.head;
	  var tail = this.tail;
	  for (var walker = head; walker !== null; walker = walker.prev) {
	    var p = walker.prev;
	    walker.prev = walker.next;
	    walker.next = p;
	  }
	  this.head = tail;
	  this.tail = head;
	  return this
	};

	function insert (self, node, value) {
	  var inserted = node === self.head ?
	    new Node(value, null, node, self) :
	    new Node(value, node, node.next, self);

	  if (inserted.next === null) {
	    self.tail = inserted;
	  }
	  if (inserted.prev === null) {
	    self.head = inserted;
	  }

	  self.length++;

	  return inserted
	}

	function push (self, item) {
	  self.tail = new Node(item, self.tail, null, self);
	  if (!self.head) {
	    self.head = self.tail;
	  }
	  self.length++;
	}

	function unshift (self, item) {
	  self.head = new Node(item, null, self.head, self);
	  if (!self.tail) {
	    self.tail = self.head;
	  }
	  self.length++;
	}

	function Node (value, prev, next, list) {
	  if (!(this instanceof Node)) {
	    return new Node(value, prev, next, list)
	  }

	  this.list = list;
	  this.value = value;

	  if (prev) {
	    prev.next = this;
	    this.prev = prev;
	  } else {
	    this.prev = null;
	  }

	  if (next) {
	    next.prev = this;
	    this.next = next;
	  } else {
	    this.next = null;
	  }
	}

	try {
	  // add if support for Symbol.iterator is present
	  requireIterator()(Yallist);
	} catch (er) {}
	return yallist;
}

var lruCache;
var hasRequiredLruCache;

function requireLruCache () {
	if (hasRequiredLruCache) return lruCache;
	hasRequiredLruCache = 1;

	// A linked list to keep track of recently-used-ness
	const Yallist = requireYallist();

	const MAX = Symbol('max');
	const LENGTH = Symbol('length');
	const LENGTH_CALCULATOR = Symbol('lengthCalculator');
	const ALLOW_STALE = Symbol('allowStale');
	const MAX_AGE = Symbol('maxAge');
	const DISPOSE = Symbol('dispose');
	const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
	const LRU_LIST = Symbol('lruList');
	const CACHE = Symbol('cache');
	const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

	const naiveLength = () => 1;

	// lruList is a yallist where the head is the youngest
	// item, and the tail is the oldest.  the list contains the Hit
	// objects as the entries.
	// Each Hit object has a reference to its Yallist.Node.  This
	// never changes.
	//
	// cache is a Map (or PseudoMap) that matches the keys to
	// the Yallist.Node object.
	class LRUCache {
	  constructor (options) {
	    if (typeof options === 'number')
	      options = { max: options };

	    if (!options)
	      options = {};

	    if (options.max && (typeof options.max !== 'number' || options.max < 0))
	      throw new TypeError('max must be a non-negative number')
	    // Kind of weird to have a default max of Infinity, but oh well.
	    this[MAX] = options.max || Infinity;

	    const lc = options.length || naiveLength;
	    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc;
	    this[ALLOW_STALE] = options.stale || false;
	    if (options.maxAge && typeof options.maxAge !== 'number')
	      throw new TypeError('maxAge must be a number')
	    this[MAX_AGE] = options.maxAge || 0;
	    this[DISPOSE] = options.dispose;
	    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
	    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
	    this.reset();
	  }

	  // resize the cache when the max changes.
	  set max (mL) {
	    if (typeof mL !== 'number' || mL < 0)
	      throw new TypeError('max must be a non-negative number')

	    this[MAX] = mL || Infinity;
	    trim(this);
	  }
	  get max () {
	    return this[MAX]
	  }

	  set allowStale (allowStale) {
	    this[ALLOW_STALE] = !!allowStale;
	  }
	  get allowStale () {
	    return this[ALLOW_STALE]
	  }

	  set maxAge (mA) {
	    if (typeof mA !== 'number')
	      throw new TypeError('maxAge must be a non-negative number')

	    this[MAX_AGE] = mA;
	    trim(this);
	  }
	  get maxAge () {
	    return this[MAX_AGE]
	  }

	  // resize the cache when the lengthCalculator changes.
	  set lengthCalculator (lC) {
	    if (typeof lC !== 'function')
	      lC = naiveLength;

	    if (lC !== this[LENGTH_CALCULATOR]) {
	      this[LENGTH_CALCULATOR] = lC;
	      this[LENGTH] = 0;
	      this[LRU_LIST].forEach(hit => {
	        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
	        this[LENGTH] += hit.length;
	      });
	    }
	    trim(this);
	  }
	  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

	  get length () { return this[LENGTH] }
	  get itemCount () { return this[LRU_LIST].length }

	  rforEach (fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].tail; walker !== null;) {
	      const prev = walker.prev;
	      forEachStep(this, fn, walker, thisp);
	      walker = prev;
	    }
	  }

	  forEach (fn, thisp) {
	    thisp = thisp || this;
	    for (let walker = this[LRU_LIST].head; walker !== null;) {
	      const next = walker.next;
	      forEachStep(this, fn, walker, thisp);
	      walker = next;
	    }
	  }

	  keys () {
	    return this[LRU_LIST].toArray().map(k => k.key)
	  }

	  values () {
	    return this[LRU_LIST].toArray().map(k => k.value)
	  }

	  reset () {
	    if (this[DISPOSE] &&
	        this[LRU_LIST] &&
	        this[LRU_LIST].length) {
	      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value));
	    }

	    this[CACHE] = new Map(); // hash of items by key
	    this[LRU_LIST] = new Yallist(); // list of items in order of use recency
	    this[LENGTH] = 0; // length of items in the list
	  }

	  dump () {
	    return this[LRU_LIST].map(hit =>
	      isStale(this, hit) ? false : {
	        k: hit.key,
	        v: hit.value,
	        e: hit.now + (hit.maxAge || 0)
	      }).toArray().filter(h => h)
	  }

	  dumpLru () {
	    return this[LRU_LIST]
	  }

	  set (key, value, maxAge) {
	    maxAge = maxAge || this[MAX_AGE];

	    if (maxAge && typeof maxAge !== 'number')
	      throw new TypeError('maxAge must be a number')

	    const now = maxAge ? Date.now() : 0;
	    const len = this[LENGTH_CALCULATOR](value, key);

	    if (this[CACHE].has(key)) {
	      if (len > this[MAX]) {
	        del(this, this[CACHE].get(key));
	        return false
	      }

	      const node = this[CACHE].get(key);
	      const item = node.value;

	      // dispose of the old one before overwriting
	      // split out into 2 ifs for better coverage tracking
	      if (this[DISPOSE]) {
	        if (!this[NO_DISPOSE_ON_SET])
	          this[DISPOSE](key, item.value);
	      }

	      item.now = now;
	      item.maxAge = maxAge;
	      item.value = value;
	      this[LENGTH] += len - item.length;
	      item.length = len;
	      this.get(key);
	      trim(this);
	      return true
	    }

	    const hit = new Entry(key, value, len, now, maxAge);

	    // oversized objects fall out of cache automatically.
	    if (hit.length > this[MAX]) {
	      if (this[DISPOSE])
	        this[DISPOSE](key, value);

	      return false
	    }

	    this[LENGTH] += hit.length;
	    this[LRU_LIST].unshift(hit);
	    this[CACHE].set(key, this[LRU_LIST].head);
	    trim(this);
	    return true
	  }

	  has (key) {
	    if (!this[CACHE].has(key)) return false
	    const hit = this[CACHE].get(key).value;
	    return !isStale(this, hit)
	  }

	  get (key) {
	    return get(this, key, true)
	  }

	  peek (key) {
	    return get(this, key, false)
	  }

	  pop () {
	    const node = this[LRU_LIST].tail;
	    if (!node)
	      return null

	    del(this, node);
	    return node.value
	  }

	  del (key) {
	    del(this, this[CACHE].get(key));
	  }

	  load (arr) {
	    // reset the cache
	    this.reset();

	    const now = Date.now();
	    // A previous serialized cache has the most recent items first
	    for (let l = arr.length - 1; l >= 0; l--) {
	      const hit = arr[l];
	      const expiresAt = hit.e || 0;
	      if (expiresAt === 0)
	        // the item was created without expiration in a non aged cache
	        this.set(hit.k, hit.v);
	      else {
	        const maxAge = expiresAt - now;
	        // dont add already expired items
	        if (maxAge > 0) {
	          this.set(hit.k, hit.v, maxAge);
	        }
	      }
	    }
	  }

	  prune () {
	    this[CACHE].forEach((value, key) => get(this, key, false));
	  }
	}

	const get = (self, key, doUse) => {
	  const node = self[CACHE].get(key);
	  if (node) {
	    const hit = node.value;
	    if (isStale(self, hit)) {
	      del(self, node);
	      if (!self[ALLOW_STALE])
	        return undefined
	    } else {
	      if (doUse) {
	        if (self[UPDATE_AGE_ON_GET])
	          node.value.now = Date.now();
	        self[LRU_LIST].unshiftNode(node);
	      }
	    }
	    return hit.value
	  }
	};

	const isStale = (self, hit) => {
	  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
	    return false

	  const diff = Date.now() - hit.now;
	  return hit.maxAge ? diff > hit.maxAge
	    : self[MAX_AGE] && (diff > self[MAX_AGE])
	};

	const trim = self => {
	  if (self[LENGTH] > self[MAX]) {
	    for (let walker = self[LRU_LIST].tail;
	      self[LENGTH] > self[MAX] && walker !== null;) {
	      // We know that we're about to delete this one, and also
	      // what the next least recently used key will be, so just
	      // go ahead and set it now.
	      const prev = walker.prev;
	      del(self, walker);
	      walker = prev;
	    }
	  }
	};

	const del = (self, node) => {
	  if (node) {
	    const hit = node.value;
	    if (self[DISPOSE])
	      self[DISPOSE](hit.key, hit.value);

	    self[LENGTH] -= hit.length;
	    self[CACHE].delete(hit.key);
	    self[LRU_LIST].removeNode(node);
	  }
	};

	class Entry {
	  constructor (key, value, length, now, maxAge) {
	    this.key = key;
	    this.value = value;
	    this.length = length;
	    this.now = now;
	    this.maxAge = maxAge || 0;
	  }
	}

	const forEachStep = (self, fn, node, thisp) => {
	  let hit = node.value;
	  if (isStale(self, hit)) {
	    del(self, node);
	    if (!self[ALLOW_STALE])
	      hit = undefined;
	  }
	  if (hit)
	    fn.call(thisp, hit.value, hit.key, self);
	};

	lruCache = LRUCache;
	return lruCache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;
	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.format();
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range
	      .trim()
	      .split(/\s+/)
	      .join(' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.format();
	  }

	  format () {
	    this.range = this.set
	      .map((comps) => comps.join(' ').trim())
	      .join('||')
	      .trim();
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLruCache();
	const cache = new LRU({ max: 1000 });

	const parseOptions = parseOptions_1;
	const Comparator = requireComparator();
	const debug = debug_1;
	const SemVer = semver$2;
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = reExports;
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr, tb) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;
	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = parseOptions_1;
	const { safeRe: re, t } = reExports;
	const cmp = cmp_1;
	const debug = debug_1;
	const SemVer = semver$2;
	const Range = requireRange();
	return comparator;
}

const Range$9 = requireRange();
const satisfies$4 = (version, range, options) => {
  try {
    range = new Range$9(range, options);
  } catch (er) {
    return false
  }
  return range.test(version)
};
var satisfies_1 = satisfies$4;

const Range$8 = requireRange();

// Mostly just for testing and legacy API reasons
const toComparators$1 = (range, options) =>
  new Range$8(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

var toComparators_1 = toComparators$1;

const SemVer$4 = semver$2;
const Range$7 = requireRange();

const maxSatisfying$1 = (versions, range, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer$4(max, options);
      }
    }
  });
  return max
};
var maxSatisfying_1 = maxSatisfying$1;

const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer$3(min, options);
      }
    }
  });
  return min
};
var minSatisfying_1 = minSatisfying$1;

const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$3 = gt_1;

const minVersion$1 = (range, loose) => {
  range = new Range$5(range, loose);

  let minver = new SemVer$2('0.0.0');
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer$2('0.0.0-0');
  if (range.test(minver)) {
    return minver
  }

  minver = null;
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let setMin = null;
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer$2(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt$3(compver, setMin)) {
            setMin = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    });
    if (setMin && (!minver || gt$3(minver, setMin))) {
      minver = setMin;
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
};
var minVersion_1 = minVersion$1;

const Range$4 = requireRange();
const validRange$1 = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range$4(range, options).range || '*'
  } catch (er) {
    return null
  }
};
var valid$6 = validRange$1;

const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$2 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;

const outside$3 = (version, range, hilo, options) => {
  version = new SemVer$1(version, options);
  range = new Range$3(range, options);

  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt$2;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$2;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies$3(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i];

    let high = null;
    let low = null;

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY$1) {
        comparator = new Comparator$2('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
};

var outside_1 = outside$3;

// Determine if version is greater than all the versions possible in the range.
const outside$2 = outside_1;
const gtr$1 = (version, range, options) => outside$2(version, range, '>', options);
var gtr_1 = gtr$1;

const outside$1 = outside_1;
// Determine if version is less than all the versions possible in the range
const ltr$1 = (version, range, options) => outside$1(version, range, '<', options);
var ltr_1 = ltr$1;

const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options)
};
var intersects_1 = intersects$1;

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range, options) => {
  const set = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set.push([first, null]);
  }

  const ranges = [];
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min);
    } else if (!max && min === v[0]) {
      ranges.push('*');
    } else if (!max) {
      ranges.push(`>=${min}`);
    } else if (min === v[0]) {
      ranges.push(`<=${max}`);
    } else {
      ranges.push(`${min} - ${max}`);
    }
  }
  const simplified = ranges.join(' || ');
  const original = typeof range.raw === 'string' ? range.raw : String(range);
  return simplified.length < original.length ? simplified : range
};

const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
};

const minimumVersionWithPreRelease = [new Comparator$1('>=0.0.0-0')];
const minimumVersion = [new Comparator$1('>=0.0.0')];

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion;
    }
  }

  const eqSet = new Set();
  let gt, lt;
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options);
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp;
  if (gt && lt) {
    gtltComp = compare$1(gt.semver, lt.semver, options);
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies$1(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies$1(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies$1(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower;
  let hasDomLT, hasDomGT;
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false;
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false;
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options);
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies$1(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options);
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies$1(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
};

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
};

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
};

var subset_1 = subset$1;

// just pre-load all the stuff that index.js lazily exports
const internalRe = reExports;
const constants = constants$1;
const SemVer = semver$2;
const identifiers = identifiers$1;
const parse$1 = parse_1;
const valid$5 = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major$2 = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease$3 = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt$1 = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$6;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver = {
  parse: parse$1,
  valid: valid$5,
  clean,
  inc,
  diff,
  major: major$2,
  minor,
  patch,
  prerelease: prerelease$3,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt: gt$1,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
};

var semver$1 = /*@__PURE__*/getDefaultExportFromCjs(semver);

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 * @returns {doc is { document: { tracking: { version: string } } }}
 */
const hasTrackingVersionField$6 = (doc) =>
  typeof doc?.document?.tracking?.version === 'string';

/**
 * @param {any} doc
 * @returns {doc is { document: { tracking: { status: string } } }}
 */
const hasTrackingStatusField$6 = (doc) =>
  typeof doc?.document?.tracking?.status === 'string';

/**
 * @param {any} doc
 * @returns {doc is { document: { tracking: { revision_history: Array<{ number: string; date: string }> } } }}
 */
const hasTrackingRevisionHistory$4 = (doc) =>
  Array.isArray(doc?.document?.tracking?.revision_history) &&
  doc?.document?.tracking?.revision_history.every(
    (/** @type {any} */ r) =>
      typeof r.number === 'string' && typeof r.date === 'string'
  );

/**
 * This method collects definitions of product ids and corresponding names and instancePaths in the given document and returns a result object.
 * @param {any} document
 * @returns {{id: string, name: string, instancePath: string}[]}
 */
const collectProductIds$2 = ({ document }) => {
  const entries =
    /** @type {{id: string, name: string, instancePath: string}[]} */ ([]);

  const fullProductNames = document.product_tree?.full_product_names;
  if (fullProductNames) {
    for (let i = 0; i < fullProductNames.length; ++i) {
      const fullProductName = fullProductNames[i];
      if (fullProductName.product_id) {
        entries.push({
          id: fullProductName.product_id,
          name: fullProductName.name ?? '',
          instancePath: `/product_tree/full_product_names/${i}/product_id`,
        });
      }
    }
  }

  const relationships = document.product_tree?.relationships;
  if (relationships) {
    for (let i = 0; i < relationships.length; ++i) {
      const relationship = relationships[i];
      const fullProductName = relationship.full_product_name;
      if (fullProductName) {
        if (fullProductName.product_id) {
          entries.push({
            id: fullProductName.product_id,
            name: fullProductName.name ?? '',
            instancePath: `/product_tree/relationships/${i}/full_product_name/product_id`,
          });
        }
      }
    }
  }

  const branches = document.product_tree?.branches;
  if (branches) {
    traverseBranches$1(branches, entries, '/product_tree/branches');
  }

  return entries
};

/**
 * This method collects group ids and corresponding instancePaths in the given document and returns a result object.
 *
 * @param {any} document
 * @returns {{id: string, name: string, instancePath: string}[]}
 */
const collectGroupIds$2 = ({ document }) => {
  const entries =
    /** @type {{id: string, name: string, instancePath: string}[]} */ ([]);

  const productGroups = document.product_tree?.product_groups;
  if (productGroups) {
    for (let i = 0; i < productGroups.length; ++i) {
      const productGroup = productGroups[i];
      if (productGroup.group_id) {
        entries.push({
          id: productGroup.group_id,
          name: productGroup.summary ?? '',
          instancePath: `/product_tree/product_groups/${i}/group_id`,
        });
      }
    }
  }

  return entries
};

/**
 * @param {{id: string}[]} entries
 * @param {{id: string, instancePath: string}[]} refs
 */
const findMissingDefinitions$2 = (entries, refs) => {
  return refs.filter(
    (ref) => entries.find((e) => e.id === ref.id) === undefined
  )
};

/**
 * @param {Array<Branch>} branches
 * @param {{id: string, name: string, instancePath: string}[]} entries
 * @param {string} instancePath
 */
const traverseBranches$1 = (branches, entries, instancePath) => {
  for (let i = 0; i < branches.length; ++i) {
    const branch = branches[i];
    const branchInstancePath = `${instancePath}/${i}`;
    const fullProductName = branch.product;
    if (fullProductName) {
      if (fullProductName.product_id) {
        entries.push({
          id: fullProductName.product_id,
          name: fullProductName.name ?? '',
          instancePath: `${branchInstancePath}/product/product_id`,
        });
      }
    }
    if (branch.branches)
      traverseBranches$1(
        branch.branches,
        entries,
        `${branchInstancePath}/branches`
      );
  }
};

/**
 * Return positive number if v2 is gte v1 and negative number otherwise
 * @param {string} v1
 * @param {string} v2
 * @returns {number}
 */
const compareVersions = (v1, v2) => {
  if (semver$1.valid(v1) && semver$1.valid(v2)) {
    return semver$1.gte(v2, v1) ? 1 : -1
  } else {
    return parseInt(v2) - parseInt(v1)
  }
};

var docUtils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  collectGroupIds: collectGroupIds$2,
  collectProductIds: collectProductIds$2,
  compareVersions: compareVersions,
  findMissingDefinitions: findMissingDefinitions$2,
  hasTrackingRevisionHistory: hasTrackingRevisionHistory$4,
  hasTrackingStatusField: hasTrackingStatusField$6,
  hasTrackingVersionField: hasTrackingVersionField$6
});

const { collectProductIds: collectProductIds$1 } = docUtils;

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_1(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const productIds = collectProductIds$1({ document: doc });
  const productIdRefs = collectProductIdRefs({ document: doc });
  const missingProductDefinitions = findMissingDefinitions$1(
    productIds,
    productIdRefs
  );
  if (missingProductDefinitions.length > 0) {
    isValid = false;
    missingProductDefinitions.forEach((missingProductDefinition) => {
      errors.push({
        message: 'definition of product id missing',
        instancePath: missingProductDefinition.instancePath,
      });
    });
  }
  return { isValid, errors }
}

/**
 * This method collects references to product ids and corresponding instancePaths in the given document and returns a result object.
 * @param {any} document
 * @returns {{id: string, instancePath: string}[]}
 */
function collectProductIdRefs({ document }) {
  const entries = /** @type {{id: string, instancePath: string}[]} */ ([]);

  const productGroups = document.product_tree?.product_groups;
  if (productGroups) {
    for (let i = 0; i < productGroups.length; ++i) {
      const productGroup = productGroups[i];
      const productIds = productGroup.product_ids;
      if (productIds) {
        for (let j = 0; j < productIds.length; ++j) {
          const productId = productIds[j];
          if (productId) {
            entries.push({
              id: productId,
              instancePath: `/product_tree/product_groups/${i}/product_ids/${j}`,
            });
          }
        }
      }
    }
  }

  const relationshipGroups = document.product_tree?.relationships;
  if (relationshipGroups) {
    for (let i = 0; i < relationshipGroups.length; ++i) {
      const relationshipGroup = relationshipGroups[i];
      const productRef = relationshipGroup.product_reference;
      if (productRef) {
        entries.push({
          id: productRef,
          instancePath: `/product_tree/relationships/${i}/product_reference`,
        });
      }
      const relToProductRef = relationshipGroup.relates_to_product_reference;
      if (relToProductRef) {
        entries.push({
          id: relToProductRef,
          instancePath: `/product_tree/relationships/${i}/relates_to_product_reference`,
        });
      }
    }
  }

  const vulnerabilities = document.vulnerabilities;
  if (vulnerabilities) {
    for (let i = 0; i < vulnerabilities.length; ++i) {
      const vulnerability = vulnerabilities[i];
      collectRefsInProductStatus(
        `/vulnerabilities/${i}/product_status`,
        vulnerability,
        entries
      );
      collectProductRefsInRemediations(
        `/vulnerabilities/${i}/remediations`,
        vulnerability,
        entries
      );
      collectRefsInScores(
        `/vulnerabilities/${i}/scores`,
        vulnerability,
        entries
      );
      collectProductRefsInThreats(
        `/vulnerabilities/${i}/threats`,
        vulnerability,
        entries
      );
    }
  }

  return entries
}

/**
 * @param {string} instancePath
 * @param {{product_status: any}} vulnerability
 * @param {*} entries
 */
const collectRefsInProductStatus = (instancePath, vulnerability, entries) => {
  findRefsInProductStatus(
    vulnerability.product_status?.first_affected,
    `${instancePath}/first_affected`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.first_fixed,
    `${instancePath}/first_fixed`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.fixed,
    `${instancePath}/fixed`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.known_affected,
    `${instancePath}/known_affected`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.known_not_affected,
    `${instancePath}/known_not_affected`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.last_affected,
    `${instancePath}/last_affected`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.recommended,
    `${instancePath}/recommended`,
    entries
  );
  findRefsInProductStatus(
    vulnerability.product_status?.under_investigation,
    `${instancePath}/under_investigation`,
    entries
  );
};

/**
 * @param {string[]} refs
 * @param {string} instancePath
 * @param {{id: string, instancePath: string}[]} entries
 */
const findRefsInProductStatus = (refs, instancePath, entries) => {
  if (refs) {
    for (let i = 0; i < refs.length; ++i) {
      const ref = refs[i];
      if (ref) {
        entries.push({
          id: ref,
          instancePath: `${instancePath}/${i}`,
        });
      }
    }
  }
};

/**
 * @param {string} instancePath
 * @param {{threats: any}} vulnerability
 * @param {*} entries
 */
const collectProductRefsInThreats = (instancePath, vulnerability, entries) => {
  const threats = vulnerability.threats;
  if (threats) {
    for (let i = 0; i < threats.length; ++i) {
      const threat = threats[i];
      const productIds = threat.product_ids;
      if (productIds) {
        for (let j = 0; j < productIds.length; ++j) {
          const productId = productIds[j];
          if (productId) {
            entries.push({
              id: productId,
              instancePath: `${instancePath}/${i}/product_ids/${j}`,
            });
          }
        }
      }
    }
  }
};

/**
 * @param {string} instancePath
 * @param {{scores: any}} vulnerability
 * @param {*} entries
 */
const collectRefsInScores = (instancePath, vulnerability, entries) => {
  const scores = vulnerability.scores;
  if (scores) {
    for (let i = 0; i < scores.length; ++i) {
      const score = scores[i];
      const products = score.products;
      if (products) {
        for (let j = 0; j < products.length; ++j) {
          const productId = products[j];
          if (productId) {
            entries.push({
              id: productId,
              instancePath: `${instancePath}/${i}/products/${j}`,
            });
          }
        }
      }
    }
  }
};

/**
 * @param {string} instancePath
 * @param {{remediations: any}} vulnerability
 * @param {*} entries
 */
const collectProductRefsInRemediations = (
  instancePath,
  vulnerability,
  entries
) => {
  const remediations = vulnerability.remediations;
  if (remediations) {
    for (let i = 0; i < remediations.length; ++i) {
      const remediation = remediations[i];
      const productIds = remediation.product_ids;
      if (productIds) {
        for (let j = 0; j < productIds.length; ++j) {
          const productId = productIds[j];
          if (productId) {
            entries.push({
              id: productId,
              instancePath: `${instancePath}/${i}/product_ids/${j}`,
            });
          }
        }
      }
    }
  }
};

/**
 * @param {{id: string}[]} entries
 * @param {{id: string, instancePath: string}[]} refs
 */
const findMissingDefinitions$1 = (entries, refs) => {
  return refs.filter(
    (ref) => entries.find((e) => e.id === ref.id) === undefined
  )
};

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_2(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const productIds = collectProductIds({ document: doc });
  const duplicateProductIds = findDuplicateEntries$1(productIds);
  if (duplicateProductIds.length > 0) {
    isValid = false;
    duplicateProductIds.forEach((duplicateProductId) => {
      errors.push({
        message: 'duplicate definition product id',
        instancePath: duplicateProductId.instancePath,
      });
    });
  }

  return { isValid, errors }
}

/**
 * This method collects definitions of product ids and corresponding names and instancePaths in the given document and returns a result object.
 * @param {any} document
 * @returns {{id: string, name: string, instancePath: string}[]}
 */
function collectProductIds({ document }) {
  const entries =
    /** @type {{id: string, name: string, instancePath: string}[]} */ ([]);

  const fullProductNames = document.product_tree?.full_product_names;
  if (fullProductNames) {
    for (let i = 0; i < fullProductNames.length; ++i) {
      const fullProductName = fullProductNames[i];
      if (fullProductName.product_id) {
        entries.push({
          id: fullProductName.product_id,
          name: fullProductName.name ?? '',
          instancePath: `/product_tree/full_product_names/${i}/product_id`,
        });
      }
    }
  }

  const relationships = document.product_tree?.relationships;
  if (relationships) {
    for (let i = 0; i < relationships.length; ++i) {
      const relationship = relationships[i];
      const fullProductName = relationship.full_product_name;
      if (fullProductName) {
        if (fullProductName.product_id) {
          entries.push({
            id: fullProductName.product_id,
            name: fullProductName.name ?? '',
            instancePath: `/product_tree/relationships/${i}/full_product_name/product_id`,
          });
        }
      }
    }
  }

  const branches = document.product_tree?.branches;
  if (branches) {
    traverseBranches(branches, entries, '/product_tree/branches');
  }

  return entries
}

/**
 * @param {{id: string, name: string, instancePath: string}[]} entries
 */
const findDuplicateEntries$1 = (entries) => {
  const lookup = entries.reduce((/** @type {any} */ a, entry) => {
    a[entry.id] = ++a[entry.id] || 0;
    return a
  }, {});

  return entries.filter((entry) => lookup[entry.id])
};

/**
 * @param {Array<Branch>} branches
 * @param {{id: string, name: string, instancePath: string}[]} entries
 * @param {string} instancePath
 */
const traverseBranches = (branches, entries, instancePath) => {
  for (let i = 0; i < branches.length; ++i) {
    const branch = branches[i];
    const branchInstancePath = `${instancePath}/${i}`;
    const fullProductName = branch.product;
    if (fullProductName) {
      if (fullProductName.product_id) {
        entries.push({
          id: fullProductName.product_id,
          name: fullProductName.name ?? '',
          instancePath: `${branchInstancePath}/product/product_id`,
        });
      }
    }
    if (branch.branches)
      traverseBranches(
        branch.branches,
        entries,
        `${branchInstancePath}/branches`
      );
  }
};

/**
 * @typedef {object} FullProductName
 * @property {unknown} product_id
 */

/**
 * @typedef {object} Relationship
 * @property {unknown} relates_to_product_reference
 * @property {unknown} product_reference
 * @property {FullProductName | null} [full_product_name]
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_3(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (!Array.isArray(doc.product_tree?.relationships)) {
    return { isValid, errors }
  }

  /** @type {Array<Relationship>} */
  const relationships = doc.product_tree.relationships;

  relationships.forEach((_, index) => {
    /** @type {Set<string>} */
    const erroredAttributeSet = new Set();
    search([], relationships, index, null, ({ key }) => {
      if (typeof key === 'string' && !erroredAttributeSet.has(key)) {
        erroredAttributeSet.add(key);
        isValid = false;
        errors.push({
          instancePath: `/product_tree/relationships/${index}/${key}`,
          message: 'circular reference',
        });
      }
    });
  });

  return { isValid, errors }
}

/**
 * @param {number[]} path
 * @param {Relationship[]} relationships
 * @param {number} index
 * @param {string | null} key
 * @param {(params: { key: string | null }) => void} onCycle
 * @returns
 */
function search(path, relationships, index, key, onCycle) {
  const relationship = relationships[index];
  if (
    typeof relationship.full_product_name?.product_id === 'string' &&
    path.includes(index)
  ) {
    return onCycle({ key })
  }

  if (typeof relationship.product_reference === 'string') {
    const productRelationshipIndex = relationships.findIndex(
      (r) => r.full_product_name?.product_id === relationship.product_reference
    );
    if (productRelationshipIndex !== -1) {
      search(
        [...path, index],
        relationships,
        productRelationshipIndex,
        key ?? 'product_reference',
        onCycle
      );
    }
  }

  if (typeof relationship.relates_to_product_reference === 'string') {
    const relatesToProductRelationshipIndex = relationships.findIndex(
      (r) =>
        r.full_product_name?.product_id ===
        relationship.relates_to_product_reference
    );
    if (relatesToProductRelationshipIndex !== -1) {
      search(
        [...path, index],
        relationships,
        relatesToProductRelationshipIndex,
        key ?? 'relates_to_product_reference',
        onCycle
      );
    }
  }
}

const { findMissingDefinitions, collectGroupIds: collectGroupIds$1 } = docUtils;

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_4(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const groupIds = collectGroupIds$1({ document: doc });
  const groupIdRefs = collectGroupIdRefs({ document: doc });
  const missingGroupDefinitions = findMissingDefinitions(groupIds, groupIdRefs);
  if (missingGroupDefinitions.length > 0) {
    isValid = false;
    missingGroupDefinitions.forEach((missingGroupDefinition) => {
      errors.push({
        message: 'definition of group id missing',
        instancePath: missingGroupDefinition.instancePath,
      });
    });
  }

  return { isValid, errors }
}

/**
 * This method collects references to group ids and corresponding instancePaths in the given document and returns a result object.
 * @param {any} document
 * @returns {{id: string, instancePath: string}[]}
 */
function collectGroupIdRefs({ document }) {
  const entries = /** @type {{id: string, instancePath: string}[]} */ ([]);

  const vulnerabilities = document.vulnerabilities;
  if (vulnerabilities) {
    for (let i = 0; i < vulnerabilities.length; ++i) {
      const vulnerability = vulnerabilities[i];
      collectGroupRefsInRemediations(
        `/vulnerabilities/${i}/remediations`,
        vulnerability,
        entries
      );
      collectGroupRefsInThreats(
        `/vulnerabilities/${i}/threats`,
        vulnerability,
        entries
      );
    }
  }

  return entries
}

/**
 * @param {string} instancePath
 * @param {{remediations: any}} vulnerability
 * @param {*} entries
 */
const collectGroupRefsInRemediations = (
  instancePath,
  vulnerability,
  entries
) => {
  const remediations = vulnerability.remediations;
  if (remediations) {
    for (let i = 0; i < remediations.length; ++i) {
      const remediation = remediations[i];
      const groupIds = remediation.group_ids;
      if (groupIds) {
        for (let j = 0; j < groupIds.length; ++j) {
          const groupId = groupIds[j];
          if (groupId) {
            entries.push({
              id: groupId,
              instancePath: `${instancePath}/${i}/group_ids/${j}`,
            });
          }
        }
      }
    }
  }
};

/**
 * @param {string} instancePath
 * @param {{threats: any}} vulnerability
 * @param {*} entries
 */
const collectGroupRefsInThreats = (instancePath, vulnerability, entries) => {
  const threats = vulnerability.threats;
  if (threats) {
    for (let i = 0; i < threats.length; ++i) {
      const threat = threats[i];
      const groupIds = threat.group_ids;
      if (groupIds) {
        for (let j = 0; j < groupIds.length; ++j) {
          const groupId = groupIds[j];
          if (groupId) {
            entries.push({
              id: groupId,
              instancePath: `${instancePath}/${i}/group_ids/${j}`,
            });
          }
        }
      }
    }
  }
};

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_5(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const groupIds = collectGroupIds({ document: doc });
  const duplicateGroupIds = findDuplicateEntries(groupIds);
  if (duplicateGroupIds.length > 0) {
    isValid = false;
    duplicateGroupIds.forEach((duplicateEntry) => {
      errors.push({
        message: 'duplicate definition product group id',
        instancePath: duplicateEntry.instancePath,
      });
    });
  }

  return { isValid, errors }
}

/**
 * This method collects group ids and corresponding instancePaths in the given document and returns a result object.
 *
 * @param {any} document
 * @returns {{id: string, name: string, instancePath: string}[]}
 */
function collectGroupIds({ document }) {
  const entries =
    /** @type {{id: string, name: string, instancePath: string}[]} */ ([]);

  const productGroups = document.product_tree?.product_groups;
  if (productGroups) {
    for (let i = 0; i < productGroups.length; ++i) {
      const productGroup = productGroups[i];
      if (productGroup.group_id) {
        entries.push({
          id: productGroup.group_id,
          name: productGroup.summary ?? '',
          instancePath: `/product_tree/product_groups/${i}/group_id`,
        });
      }
    }
  }

  return entries
}

/**
 * @param {{id: string, name: string, instancePath: string}[]} entries
 */
const findDuplicateEntries = (entries) => {
  const lookup = entries.reduce((/** @type {any} */ a, entry) => {
    a[entry.id] = ++a[entry.id] || 0;
    return a
  }, {});

  return entries.filter((entry) => lookup[entry.id])
};

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_6(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (Array.isArray(doc.vulnerabilities)) {
    /** @type {Array<any>} */
    const vulnerabilities = doc.vulnerabilities;
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      const productStatus = vulnerability.product_status;
      if (!productStatus) return
      const groups = [
        new Set(
          []
            .concat(
              Array.isArray(productStatus.first_affected)
                ? productStatus.first_affected
                : []
            )
            .concat(
              Array.isArray(productStatus.known_affected)
                ? productStatus.known_affected
                : []
            )
            .concat(
              Array.isArray(productStatus.last_affected)
                ? productStatus.last_affected
                : []
            )
        ),
        new Set(
          Array.isArray(productStatus.known_not_affected)
            ? productStatus.known_not_affected
            : []
        ),
        new Set(
          []
            .concat(
              Array.isArray(productStatus.first_fixed)
                ? productStatus.first_fixed
                : []
            )
            .concat(
              Array.isArray(productStatus.fixed) ? productStatus.fixed : []
            )
        ),
        new Set(
          Array.isArray(productStatus.under_investigation)
            ? productStatus.under_investigation
            : []
        ),
      ];

      groups.forEach((group, index) => {
        const remainingGroups = groups.slice(index + 1);
        group.forEach((productID) => {
          if (remainingGroups.some((g) => g.has(productID))) {
            isValid = false;
            errors.push({
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status`,
              message: `product id "${productID}" is mentioned in contradicting product status groups`,
            });
          }
        });
      });
    });
  }

  return { isValid, errors }
}

/**
 *
 * @param {unknown} doc
 */
function mandatoryTest_6_1_7(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  // 6.1.7 Multiple Scores with same Version per Product
  if (preconditionFor_6_1_7_Matches(doc)) {
    doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      /** @type {Map<string, Set<string>>} */
      const cvssVersionsByProductName = new Map();

      vulnerability.scores?.forEach((score, scoreIndex) => {
        score.products?.forEach((product, productIndex) => {
          const versionSet = cvssVersionsByProductName.get(product) ?? new Set();
          cvssVersionsByProductName.set(product, versionSet);

          if (
            (score.cvss_v2?.version !== undefined &&
              versionSet.has(score.cvss_v2.version)) ||
            (score.cvss_v3?.version !== undefined &&
              versionSet.has(score.cvss_v3.version))
          ) {
            isValid = false;
            errors.push({
              message: `product is already included in these cvss-versions: ${Array.from(
                versionSet.keys()
              ).join(', ')}`,
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/products/${productIndex}`,
            });
          }
          if (score.cvss_v2?.version !== undefined) {
            versionSet.add(score.cvss_v2.version);
          }
          if (score.cvss_v3?.version !== undefined) {
            versionSet.add(score.cvss_v3.version);
          }
        });
      });
    });
  }

  return { errors, isValid }
}

/**
 * @param {unknown} rawDoc
 * @returns {rawDoc is {
 *    vulnerabilities: Array<{
 *      scores?: Array<{
 *        products?: string[]
 *        cvss_v3?: { version?: string }
 *        cvss_v2?: { version?: string }
 *      }>
 *    }>
 *  }}
 */
const preconditionFor_6_1_7_Matches = (rawDoc) => {
  if (typeof rawDoc !== 'object' || !rawDoc) return false
  /** @type {{ vulnerabilities?: unknown }} */
  const doc = rawDoc;
  return (
    Array.isArray(doc.vulnerabilities) &&
    doc.vulnerabilities.every(
      (vulnerability) =>
        (Array.isArray(vulnerability.scores) &&
          vulnerability.scores.every(
            (
              /** @type {{ products?: unknown; cvss_v2?: any; cvss_v3?: any }} */ score
            ) =>
              Array.isArray(score.products) &&
              score.products.every((product) => typeof product === 'string') &&
              ((score.cvss_v2 &&
                (typeof score.cvss_v2.version === 'string' ||
                  score.cvss_v2.version === undefined)) ||
                score.cvss_v2 === undefined) &&
              ((score.cvss_v3 &&
                (typeof score.cvss_v3.version === 'string' ||
                  score.cvss_v3.version === undefined)) ||
                score.cvss_v3 === undefined)
          )) ||
        vulnerability.scores === undefined
    )
  )
};

var jtd$1 = {exports: {}};

var jtd = {};

var ref = {};

var metadata = {};

Object.defineProperty(metadata, "__esModule", { value: true });
metadata.checkMetadata = void 0;
const util_1$4 = util;
const def$7 = {
    keyword: "metadata",
    schemaType: "object",
    code(cxt) {
        checkMetadata(cxt);
        const { gen, schema, it } = cxt;
        if ((0, util_1$4.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
        cxt.ok(valid);
    },
};
function checkMetadata({ it, keyword }, metadata) {
    if (it.jtdMetadata !== metadata) {
        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
    }
}
metadata.checkMetadata = checkMetadata;
metadata.default = def$7;

Object.defineProperty(ref, "__esModule", { value: true });
ref.hasRef = void 0;
const compile_1 = compile;
const codegen_1$8 = requireCodegen();
const ref_error_1$2 = requireRef_error();
const names_1$2 = names$1;
const ref_1$3 = ref$1;
const metadata_1$5 = metadata;
const def$6 = {
    keyword: "ref",
    schemaType: "string",
    code(cxt) {
        (0, metadata_1$5.checkMetadata)(cxt);
        const { gen, data, schema: ref, parentSchema, it } = cxt;
        const { schemaEnv: { root }, } = it;
        const valid = gen.name("valid");
        if (parentSchema.nullable) {
            gen.var(valid, (0, codegen_1$8._) `${data} === null`);
            gen.if((0, codegen_1$8.not)(valid), validateJtdRef);
        }
        else {
            gen.var(valid, false);
            validateJtdRef();
        }
        cxt.ok(valid);
        function validateJtdRef() {
            var _a;
            const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
            if (!refSchema) {
                throw new ref_error_1$2.default(it.opts.uriResolver, "", ref, `No definition ${ref}`);
            }
            if (hasRef(refSchema) || !it.opts.inlineRefs)
                callValidate(refSchema);
            else
                inlineRefSchema(refSchema);
        }
        function callValidate(schema) {
            const sch = compile_1.compileSchema.call(it.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
            const v = (0, ref_1$3.getValidate)(cxt, sch);
            const errsCount = gen.const("_errs", names_1$2.default.errors);
            (0, ref_1$3.callRef)(cxt, v, sch, sch.$async);
            gen.assign(valid, (0, codegen_1$8._) `${errsCount} === ${names_1$2.default.errors}`);
        }
        function inlineRefSchema(schema) {
            const schName = gen.scopeValue("schema", it.opts.code.source === true ? { ref: schema, code: (0, codegen_1$8.stringify)(schema) } : { ref: schema });
            cxt.subschema({
                schema,
                dataTypes: [],
                schemaPath: codegen_1$8.nil,
                topSchemaRef: schName,
                errSchemaPath: `/definitions/${ref}`,
            }, valid);
        }
    },
};
function hasRef(schema) {
    for (const key in schema) {
        let sch;
        if (key === "ref" || (typeof (sch = schema[key]) == "object" && hasRef(sch)))
            return true;
    }
    return false;
}
ref.hasRef = hasRef;
ref.default = def$6;

var type = {};

var timestamp = {};

Object.defineProperty(timestamp, "__esModule", { value: true });
const DT_SEPARATOR = /t|\s/i;
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function validTimestamp(str, allowDate) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    const dt = str.split(DT_SEPARATOR);
    return ((dt.length === 2 && validDate(dt[0]) && validTime(dt[1])) ||
        (allowDate && dt.length === 1 && validDate(dt[0])));
}
timestamp.default = validTimestamp;
function validDate(str) {
    const matches = DATE.exec(str);
    if (!matches)
        return false;
    const y = +matches[1];
    const m = +matches[2];
    const d = +matches[3];
    return (m >= 1 &&
        m <= 12 &&
        d >= 1 &&
        (d <= DAYS[m] ||
            // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
            (m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0))));
}
function validTime(str) {
    const matches = TIME.exec(str);
    if (!matches)
        return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tzH = +(matches[4] || 0);
    const tzM = +(matches[5] || 0);
    return ((hr <= 23 && min <= 59 && sec <= 59) ||
        // leap second
        (hr - tzH === 23 && min - tzM === 59 && sec === 60));
}
validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';

var error$2 = {};

Object.defineProperty(error$2, "__esModule", { value: true });
error$2.typeErrorParams = error$2.typeErrorMessage = error$2.typeError = void 0;
const codegen_1$7 = requireCodegen();
function typeError(t) {
    return {
        message: (cxt) => typeErrorMessage(cxt, t),
        params: (cxt) => typeErrorParams(cxt, t),
    };
}
error$2.typeError = typeError;
function typeErrorMessage({ parentSchema }, t) {
    return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
}
error$2.typeErrorMessage = typeErrorMessage;
function typeErrorParams({ parentSchema }, t) {
    return (0, codegen_1$7._) `{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
}
error$2.typeErrorParams = typeErrorParams;

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.intRange = void 0;
	const codegen_1 = requireCodegen();
	const timestamp_1 = timestamp;
	const util_1 = util;
	const metadata_1 = metadata;
	const error_1 = error$2;
	exports.intRange = {
	    int8: [-128, 127, 3],
	    uint8: [0, 255, 3],
	    int16: [-32768, 32767, 5],
	    uint16: [0, 65535, 5],
	    int32: [-2147483648, 2147483647, 10],
	    uint32: [0, 4294967295, 10],
	};
	const error = {
	    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
	    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema),
	};
	function timestampCode(cxt) {
	    const { gen, data, it } = cxt;
	    const { timestamp, allowDate } = it.opts;
	    if (timestamp === "date")
	        return (0, codegen_1._) `${data} instanceof Date `;
	    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
	    const allowDateArg = allowDate ? (0, codegen_1._) `, true` : codegen_1.nil;
	    const validString = (0, codegen_1._) `typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
	    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._) `${data} instanceof Date`, validString);
	}
	const def = {
	    keyword: "type",
	    schemaType: "string",
	    error,
	    code(cxt) {
	        (0, metadata_1.checkMetadata)(cxt);
	        const { data, schema, parentSchema, it } = cxt;
	        let cond;
	        switch (schema) {
	            case "boolean":
	            case "string":
	                cond = (0, codegen_1._) `typeof ${data} == ${schema}`;
	                break;
	            case "timestamp": {
	                cond = timestampCode(cxt);
	                break;
	            }
	            case "float32":
	            case "float64":
	                cond = (0, codegen_1._) `typeof ${data} == "number"`;
	                break;
	            default: {
	                const sch = schema;
	                cond = (0, codegen_1._) `typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
	                if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
	                    if (sch === "uint32")
	                        cond = (0, codegen_1._) `${cond} && ${data} >= 0`;
	                }
	                else {
	                    const [min, max] = exports.intRange[sch];
	                    cond = (0, codegen_1._) `${cond} && ${data} >= ${min} && ${data} <= ${max}`;
	                }
	            }
	        }
	        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._) `${data} === null`, cond) : cond);
	    },
	};
	exports.default = def;
	
} (type));

var _enum = {};

var nullable = {};

Object.defineProperty(nullable, "__esModule", { value: true });
nullable.checkNullableObject = nullable.checkNullable = void 0;
const codegen_1$6 = requireCodegen();
function checkNullable({ gen, data, parentSchema }, cond = codegen_1$6.nil) {
    const valid = gen.name("valid");
    if (parentSchema.nullable) {
        gen.let(valid, (0, codegen_1$6._) `${data} === null`);
        cond = (0, codegen_1$6.not)(valid);
    }
    else {
        gen.let(valid, false);
    }
    return [valid, cond];
}
nullable.checkNullable = checkNullable;
function checkNullableObject(cxt, cond) {
    const [valid, cond_] = checkNullable(cxt, cond);
    return [valid, (0, codegen_1$6._) `${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
}
nullable.checkNullableObject = checkNullableObject;

Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$5 = requireCodegen();
const metadata_1$4 = metadata;
const nullable_1$3 = nullable;
const error$1 = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$5._) `{allowedValues: ${schemaCode}}`,
};
const def$5 = {
    keyword: "enum",
    schemaType: "array",
    error: error$1,
    code(cxt) {
        (0, metadata_1$4.checkMetadata)(cxt);
        const { gen, data, schema, schemaValue, parentSchema, it } = cxt;
        if (schema.length === 0)
            throw new Error("enum must have non-empty array");
        if (schema.length !== new Set(schema).size)
            throw new Error("enum items must be unique");
        let valid;
        const isString = (0, codegen_1$5._) `typeof ${data} == "string"`;
        if (schema.length >= it.opts.loopEnum) {
            let cond;
            [valid, cond] = (0, nullable_1$3.checkNullable)(cxt, isString);
            gen.if(cond, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            valid = (0, codegen_1$5.and)(isString, (0, codegen_1$5.or)(...schema.map((value) => (0, codegen_1$5._) `${data} === ${value}`)));
            if (parentSchema.nullable)
                valid = (0, codegen_1$5.or)((0, codegen_1$5._) `${data} === null`, valid);
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1$5._) `${valid} = ${data} === ${v}`, () => gen.break()));
        }
    },
};
_enum.default = def$5;

var elements = {};

Object.defineProperty(elements, "__esModule", { value: true });
const util_1$3 = util;
const code_1$3 = code;
const codegen_1$4 = requireCodegen();
const metadata_1$3 = metadata;
const nullable_1$2 = nullable;
const error_1$2 = error$2;
const def$4 = {
    keyword: "elements",
    schemaType: "object",
    error: (0, error_1$2.typeError)("array"),
    code(cxt) {
        (0, metadata_1$3.checkMetadata)(cxt);
        const { gen, data, schema, it } = cxt;
        if ((0, util_1$3.alwaysValidSchema)(it, schema))
            return;
        const [valid] = (0, nullable_1$2.checkNullable)(cxt);
        gen.if((0, codegen_1$4.not)(valid), () => gen.if((0, codegen_1$4._) `Array.isArray(${data})`, () => gen.assign(valid, (0, code_1$3.validateArray)(cxt)), () => cxt.error()));
        cxt.ok(valid);
    },
};
elements.default = def$4;

var properties = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validateProperties = exports.error = void 0;
	const code_1 = code;
	const util_1 = util;
	const codegen_1 = requireCodegen();
	const metadata_1 = metadata;
	const nullable_1 = nullable;
	const error_1 = error$2;
	var PropError;
	(function (PropError) {
	    PropError["Additional"] = "additional";
	    PropError["Missing"] = "missing";
	})(PropError || (PropError = {}));
	exports.error = {
	    message: (cxt) => {
	        const { params } = cxt;
	        return params.propError
	            ? params.propError === PropError.Additional
	                ? "must NOT have additional properties"
	                : `must have property '${params.missingProperty}'`
	            : (0, error_1.typeErrorMessage)(cxt, "object");
	    },
	    params: (cxt) => {
	        const { params } = cxt;
	        return params.propError
	            ? params.propError === PropError.Additional
	                ? (0, codegen_1._) `{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`
	                : (0, codegen_1._) `{error: ${params.propError}, missingProperty: ${params.missingProperty}}`
	            : (0, error_1.typeErrorParams)(cxt, "object");
	    },
	};
	const def = {
	    keyword: "properties",
	    schemaType: "object",
	    error: exports.error,
	    code: validateProperties,
	};
	// const error: KeywordErrorDefinition = {
	//   message: "should NOT have additional properties",
	//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,
	// }
	function validateProperties(cxt) {
	    (0, metadata_1.checkMetadata)(cxt);
	    const { gen, data, parentSchema, it } = cxt;
	    const { additionalProperties, nullable } = parentSchema;
	    if (it.jtdDiscriminator && nullable)
	        throw new Error("JTD: nullable inside discriminator mapping");
	    if (commonProperties()) {
	        throw new Error("JTD: properties and optionalProperties have common members");
	    }
	    const [allProps, properties] = schemaProperties("properties");
	    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
	    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
	        return;
	    }
	    const [valid, cond] = it.jtdDiscriminator === undefined
	        ? (0, nullable_1.checkNullableObject)(cxt, data)
	        : [gen.let("valid", false), true];
	    gen.if(cond, () => gen.assign(valid, true).block(() => {
	        validateProps(properties, "properties", true);
	        validateProps(optProperties, "optionalProperties");
	        if (!additionalProperties)
	            validateAdditional();
	    }));
	    cxt.pass(valid);
	    function commonProperties() {
	        const props = parentSchema.properties;
	        const optProps = parentSchema.optionalProperties;
	        if (!(props && optProps))
	            return false;
	        for (const p in props) {
	            if (Object.prototype.hasOwnProperty.call(optProps, p))
	                return true;
	        }
	        return false;
	    }
	    function schemaProperties(keyword) {
	        const schema = parentSchema[keyword];
	        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
	        if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
	            throw new Error(`JTD: discriminator tag used in ${keyword}`);
	        }
	        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        return [allPs, ps];
	    }
	    function validateProps(props, keyword, required) {
	        const _valid = gen.var("valid");
	        for (const prop of props) {
	            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
	            cxt.ok(_valid);
	        }
	        function missingProperty(prop) {
	            if (required) {
	                gen.assign(_valid, false);
	                cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
	            }
	            else {
	                gen.assign(_valid, true);
	            }
	        }
	    }
	    function applyPropertySchema(prop, keyword, _valid) {
	        cxt.subschema({
	            keyword,
	            schemaProp: prop,
	            dataProp: prop,
	        }, _valid);
	    }
	    function validateAdditional() {
	        gen.forIn("key", data, (key) => {
	            const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator);
	            const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
	            const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
	            gen.if(extra, () => {
	                if (it.opts.removeAdditional) {
	                    gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	                }
	                else {
	                    cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
	                    if (!it.opts.allErrors)
	                        gen.break();
	                }
	            });
	        });
	    }
	    function isAdditional(key, props, keyword, jtdDiscriminator) {
	        let additional;
	        if (props.length > 8) {
	            // TODO maybe an option instead of hard-coded 8?
	            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);
	            additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
	            if (jtdDiscriminator !== undefined) {
	                additional = (0, codegen_1.and)(additional, (0, codegen_1._) `${key} !== ${jtdDiscriminator}`);
	            }
	        }
	        else if (props.length || jtdDiscriminator !== undefined) {
	            const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
	            additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key} !== ${p}`));
	        }
	        else {
	            additional = true;
	        }
	        return additional;
	    }
	}
	exports.validateProperties = validateProperties;
	exports.default = def;
	
} (properties));

var optionalProperties = {};

Object.defineProperty(optionalProperties, "__esModule", { value: true });
const properties_1$1 = properties;
const def$3 = {
    keyword: "optionalProperties",
    schemaType: "object",
    error: properties_1$1.error,
    code(cxt) {
        if (cxt.parentSchema.properties)
            return;
        (0, properties_1$1.validateProperties)(cxt);
    },
};
optionalProperties.default = def$3;

var discriminator = {};

Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1$3 = requireCodegen();
const metadata_1$2 = metadata;
const nullable_1$1 = nullable;
const error_1$1 = error$2;
const types_1$2 = types$1;
const error = {
    message: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError
            ? params.discrError === types_1$2.DiscrError.Tag
                ? `tag "${schema}" must be string`
                : `value of tag "${schema}" must be in mapping`
            : (0, error_1$1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError
            ? (0, codegen_1$3._) `{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}`
            : (0, error_1$1.typeErrorParams)(cxt, "object");
    },
};
const def$2 = {
    keyword: "discriminator",
    schemaType: "string",
    implements: ["mapping"],
    error,
    code(cxt) {
        (0, metadata_1$2.checkMetadata)(cxt);
        const { gen, data, schema, parentSchema } = cxt;
        const [valid, cond] = (0, nullable_1$1.checkNullableObject)(cxt, data);
        gen.if(cond);
        validateDiscriminator();
        gen.elseIf((0, codegen_1$3.not)(valid));
        cxt.error();
        gen.endIf();
        cxt.ok(valid);
        function validateDiscriminator() {
            const tag = gen.const("tag", (0, codegen_1$3._) `${data}${(0, codegen_1$3.getProperty)(schema)}`);
            gen.if((0, codegen_1$3._) `${tag} === undefined`);
            cxt.error(false, { discrError: types_1$2.DiscrError.Tag, tag });
            gen.elseIf((0, codegen_1$3._) `typeof ${tag} == "string"`);
            validateMapping(tag);
            gen.else();
            cxt.error(false, { discrError: types_1$2.DiscrError.Tag, tag }, { instancePath: schema });
            gen.endIf();
        }
        function validateMapping(tag) {
            gen.if(false);
            for (const tagValue in parentSchema.mapping) {
                gen.elseIf((0, codegen_1$3._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(tagValue));
            }
            gen.else();
            cxt.error(false, { discrError: types_1$2.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            cxt.subschema({
                keyword: "mapping",
                schemaProp,
                jtdDiscriminator: schema,
            }, _valid);
            return _valid;
        }
    },
};
discriminator.default = def$2;

var values = {};

Object.defineProperty(values, "__esModule", { value: true });
const util_1$2 = util;
const codegen_1$2 = requireCodegen();
const metadata_1$1 = metadata;
const nullable_1 = nullable;
const error_1 = error$2;
const def$1 = {
    keyword: "values",
    schemaType: "object",
    error: (0, error_1.typeError)("object"),
    code(cxt) {
        (0, metadata_1$1.checkMetadata)(cxt);
        const { gen, data, schema, it } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        if ((0, util_1$2.alwaysValidSchema)(it, schema)) {
            gen.if((0, codegen_1$2.not)((0, codegen_1$2.or)(cond, valid)), () => cxt.error());
        }
        else {
            gen.if(cond);
            gen.assign(valid, validateMap());
            gen.elseIf((0, codegen_1$2.not)(valid));
            cxt.error();
            gen.endIf();
        }
        cxt.ok(valid);
        function validateMap() {
            const _valid = gen.name("valid");
            if (it.allErrors) {
                const validMap = gen.let("valid", true);
                validateValues(() => gen.assign(validMap, false));
                return validMap;
            }
            gen.var(_valid, true);
            validateValues(() => gen.break());
            return _valid;
            function validateValues(notValid) {
                gen.forIn("key", data, (key) => {
                    cxt.subschema({
                        keyword: "values",
                        dataProp: key,
                        dataPropType: util_1$2.Type.Str,
                    }, _valid);
                    gen.if((0, codegen_1$2.not)(_valid), notValid);
                });
            }
        }
    },
};
values.default = def$1;

var union = {};

Object.defineProperty(union, "__esModule", { value: true });
const code_1$2 = code;
const def = {
    keyword: "union",
    schemaType: "array",
    trackErrors: true,
    code: code_1$2.validateUnion,
    error: { message: "must match a schema in union" },
};
union.default = def;

Object.defineProperty(jtd, "__esModule", { value: true });
const ref_1$2 = ref;
const type_1$1 = type;
const enum_1 = _enum;
const elements_1 = elements;
const properties_1 = properties;
const optionalProperties_1 = optionalProperties;
const discriminator_1 = discriminator;
const values_1 = values;
const union_1 = union;
const metadata_1 = metadata;
const jtdVocabulary = [
    "definitions",
    ref_1$2.default,
    type_1$1.default,
    enum_1.default,
    elements_1.default,
    properties_1.default,
    optionalProperties_1.default,
    discriminator_1.default,
    values_1.default,
    union_1.default,
    metadata_1.default,
    { keyword: "additionalProperties", schemaType: "boolean" },
    { keyword: "nullable", schemaType: "boolean" },
];
jtd.default = jtdVocabulary;

var jtdSchema = {};

Object.defineProperty(jtdSchema, "__esModule", { value: true });
const shared = (root) => {
    const sch = {
        nullable: { type: "boolean" },
        metadata: {
            optionalProperties: {
                union: { elements: { ref: "schema" } },
            },
            additionalProperties: true,
        },
    };
    if (root)
        sch.definitions = { values: { ref: "schema" } };
    return sch;
};
const emptyForm = (root) => ({
    optionalProperties: shared(root),
});
const refForm = (root) => ({
    properties: {
        ref: { type: "string" },
    },
    optionalProperties: shared(root),
});
const typeForm = (root) => ({
    properties: {
        type: {
            enum: [
                "boolean",
                "timestamp",
                "string",
                "float32",
                "float64",
                "int8",
                "uint8",
                "int16",
                "uint16",
                "int32",
                "uint32",
            ],
        },
    },
    optionalProperties: shared(root),
});
const enumForm = (root) => ({
    properties: {
        enum: { elements: { type: "string" } },
    },
    optionalProperties: shared(root),
});
const elementsForm = (root) => ({
    properties: {
        elements: { ref: "schema" },
    },
    optionalProperties: shared(root),
});
const propertiesForm = (root) => ({
    properties: {
        properties: { values: { ref: "schema" } },
    },
    optionalProperties: {
        optionalProperties: { values: { ref: "schema" } },
        additionalProperties: { type: "boolean" },
        ...shared(root),
    },
});
const optionalPropertiesForm = (root) => ({
    properties: {
        optionalProperties: { values: { ref: "schema" } },
    },
    optionalProperties: {
        additionalProperties: { type: "boolean" },
        ...shared(root),
    },
});
const discriminatorForm = (root) => ({
    properties: {
        discriminator: { type: "string" },
        mapping: {
            values: {
                metadata: {
                    union: [propertiesForm(false), optionalPropertiesForm(false)],
                },
            },
        },
    },
    optionalProperties: shared(root),
});
const valuesForm = (root) => ({
    properties: {
        values: { ref: "schema" },
    },
    optionalProperties: shared(root),
});
const schema = (root) => ({
    metadata: {
        union: [
            emptyForm,
            refForm,
            typeForm,
            enumForm,
            elementsForm,
            propertiesForm,
            optionalPropertiesForm,
            discriminatorForm,
            valuesForm,
        ].map((s) => s(root)),
    },
});
const jtdMetaSchema = {
    definitions: {
        schema: schema(false),
    },
    ...schema(true),
};
jtdSchema.default = jtdMetaSchema;

var serialize = {};

var types = {};

Object.defineProperty(types, "__esModule", { value: true });
types.jtdForms = void 0;
types.jtdForms = [
    "elements",
    "values",
    "discriminator",
    "properties",
    "optionalProperties",
    "enum",
    "type",
    "ref",
];

var quote$1 = {};

Object.defineProperty(quote$1, "__esModule", { value: true });
const rxEscapable = 
// eslint-disable-next-line no-control-regex, no-misleading-character-class
/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
const escaped = {
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\",
};
function quote(s) {
    rxEscapable.lastIndex = 0;
    return ('"' +
        (rxEscapable.test(s)
            ? s.replace(rxEscapable, (a) => {
                const c = escaped[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            })
            : s) +
        '"');
}
quote$1.default = quote;
quote.code = 'require("ajv/dist/runtime/quote").default';

Object.defineProperty(serialize, "__esModule", { value: true });
const types_1$1 = types;
const __1$1 = compile;
const codegen_1$1 = requireCodegen();
const ref_error_1$1 = requireRef_error();
const names_1$1 = names$1;
const code_1$1 = code;
const ref_1$1 = ref;
const util_1$1 = util;
const quote_1 = quote$1;
const genSerialize = {
    elements: serializeElements,
    values: serializeValues,
    discriminator: serializeDiscriminator,
    properties: serializeProperties,
    optionalProperties: serializeProperties,
    enum: serializeString,
    type: serializeType,
    ref: serializeRef,
};
function compileSerializer(sch, definitions) {
    const _sch = __1$1.getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1$1.CodeGen(this.scope, { es5, lines, ownProperties });
    const serializeName = gen.scopeName("serialize");
    const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1$1.default.data,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        sch.serializeName = serializeName;
        gen.func(serializeName, names_1$1.default.data, false, () => {
            gen.let(names_1$1.default.json, (0, codegen_1$1.str) ``);
            serializeCode(cxt);
            gen.return(names_1$1.default.json);
        });
        gen.optimize(this.opts.code.optimize);
        const serializeFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1$1.default.scope)}return ${serializeFuncCode}`;
        const makeSerialize = new Function(`${names_1$1.default.scope}`, sourceCode);
        const serialize = makeSerialize(this.scope.get());
        this.scope.value(serializeName, { ref: serialize });
        sch.serialize = serialize;
    }
    catch (e) {
        if (sourceCode)
            this.logger.error("Error compiling serializer, function code:", sourceCode);
        delete sch.serialize;
        delete sch.serializeName;
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
    return sch;
}
serialize.default = compileSerializer;
function serializeCode(cxt) {
    let form;
    for (const key of types_1$1.jtdForms) {
        if (key in cxt.schema) {
            form = key;
            break;
        }
    }
    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
}
function serializeNullable(cxt, serializeForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
        return serializeForm(cxt);
    gen.if((0, codegen_1$1._) `${data} === undefined || ${data} === null`, () => gen.add(names_1$1.default.json, (0, codegen_1$1._) `"null"`), () => serializeForm(cxt));
}
function serializeElements(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `[`);
    const first = gen.let("first", true);
    gen.forOf("el", data, (el) => {
        addComma(cxt, first);
        serializeCode({ ...cxt, schema: schema.elements, data: el });
    });
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `]`);
}
function serializeValues(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `{`);
    const first = gen.let("first", true);
    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `}`);
}
function serializeKeyValue(cxt, key, schema, first) {
    const { gen, data } = cxt;
    addComma(cxt, first);
    serializeString({ ...cxt, data: key });
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `:`);
    const value = gen.const("value", (0, codegen_1$1._) `${data}${(0, codegen_1$1.getProperty)(key)}`);
    serializeCode({ ...cxt, schema, data: value });
}
function serializeDiscriminator(cxt) {
    const { gen, schema, data } = cxt;
    const { discriminator } = schema;
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `{${JSON.stringify(discriminator)}:`);
    const tag = gen.const("tag", (0, codegen_1$1._) `${data}${(0, codegen_1$1.getProperty)(discriminator)}`);
    serializeString({ ...cxt, data: tag });
    gen.if(false);
    for (const tagValue in schema.mapping) {
        gen.elseIf((0, codegen_1$1._) `${tag} === ${tagValue}`);
        const sch = schema.mapping[tagValue];
        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
    }
    gen.endIf();
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `}`);
}
function serializeProperties(cxt) {
    const { gen } = cxt;
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `{`);
    serializeSchemaProperties(cxt);
    gen.add(names_1$1.default.json, (0, codegen_1$1.str) `}`);
}
function serializeSchemaProperties(cxt, discriminator) {
    const { gen, schema, data } = cxt;
    const { properties, optionalProperties } = schema;
    const props = keys(properties);
    const optProps = keys(optionalProperties);
    const allProps = allProperties(props.concat(optProps));
    let first = !discriminator;
    let firstProp;
    for (const key of props) {
        if (first)
            first = false;
        else
            gen.add(names_1$1.default.json, (0, codegen_1$1.str) `,`);
        serializeProperty(key, properties[key], keyValue(key));
    }
    if (first)
        firstProp = gen.let("first", true);
    for (const key of optProps) {
        const value = keyValue(key);
        gen.if((0, codegen_1$1.and)((0, codegen_1$1._) `${value} !== undefined`, (0, code_1$1.isOwnProperty)(gen, data, key)), () => {
            addComma(cxt, firstProp);
            serializeProperty(key, optionalProperties[key], value);
        });
    }
    if (schema.additionalProperties) {
        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
    }
    function keys(ps) {
        return ps ? Object.keys(ps) : [];
    }
    function allProperties(ps) {
        if (discriminator)
            ps.push(discriminator);
        if (new Set(ps).size !== ps.length) {
            throw new Error("JTD: properties/optionalProperties/disciminator overlap");
        }
        return ps;
    }
    function keyValue(key) {
        return gen.const("value", (0, codegen_1$1._) `${data}${(0, codegen_1$1.getProperty)(key)}`);
    }
    function serializeProperty(key, propSchema, value) {
        gen.add(names_1$1.default.json, (0, codegen_1$1.str) `${JSON.stringify(key)}:`);
        serializeCode({ ...cxt, schema: propSchema, data: value });
    }
    function isAdditional(key, ps) {
        return ps.length ? (0, codegen_1$1.and)(...ps.map((p) => (0, codegen_1$1._) `${key} !== ${p}`)) : true;
    }
}
function serializeType(cxt) {
    const { gen, schema, data } = cxt;
    switch (schema.type) {
        case "boolean":
            gen.add(names_1$1.default.json, (0, codegen_1$1._) `${data} ? "true" : "false"`);
            break;
        case "string":
            serializeString(cxt);
            break;
        case "timestamp":
            gen.if((0, codegen_1$1._) `${data} instanceof Date`, () => gen.add(names_1$1.default.json, (0, codegen_1$1._) `'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
            break;
        default:
            serializeNumber(cxt);
    }
}
function serializeString({ gen, data }) {
    gen.add(names_1$1.default.json, (0, codegen_1$1._) `${(0, util_1$1.useFunc)(gen, quote_1.default)}(${data})`);
}
function serializeNumber({ gen, data }) {
    gen.add(names_1$1.default.json, (0, codegen_1$1._) `"" + ${data}`);
}
function serializeRef(cxt) {
    const { gen, self, data, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
        throw new ref_error_1$1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1$1.hasRef)(refSchema))
        return serializeCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileSerializer.call(self, new __1$1.SchemaEnv({ schema: refSchema, root }), definitions);
    gen.add(names_1$1.default.json, (0, codegen_1$1._) `${getSerialize(gen, sch)}(${data})`);
}
function getSerialize(gen, sch) {
    return sch.serialize
        ? gen.scopeValue("serialize", { ref: sch.serialize })
        : (0, codegen_1$1._) `${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
}
function serializeEmpty({ gen, data }) {
    gen.add(names_1$1.default.json, (0, codegen_1$1._) `JSON.stringify(${data})`);
}
function addComma({ gen }, first) {
    if (first) {
        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1$1.default.json, (0, codegen_1$1.str) `,`));
    }
    else {
        gen.add(names_1$1.default.json, (0, codegen_1$1.str) `,`);
    }
}

var parse = {};

var parseJson$1 = {};

Object.defineProperty(parseJson$1, "__esModule", { value: true });
parseJson$1.parseJsonString = parseJson$1.parseJsonNumber = parseJson$1.parseJson = void 0;
const rxParseJson = /position\s(\d+)$/;
function parseJson(s, pos) {
    let endPos;
    parseJson.message = undefined;
    let matches;
    if (pos)
        s = s.slice(pos);
    try {
        parseJson.position = pos + s.length;
        return JSON.parse(s);
    }
    catch (e) {
        matches = rxParseJson.exec(e.message);
        if (!matches) {
            parseJson.message = "unexpected end";
            return undefined;
        }
        endPos = +matches[1];
        const c = s[endPos];
        s = s.slice(0, endPos);
        parseJson.position = pos + endPos;
        try {
            return JSON.parse(s);
        }
        catch (e1) {
            parseJson.message = `unexpected token ${c}`;
            return undefined;
        }
    }
}
parseJson$1.parseJson = parseJson;
parseJson.message = undefined;
parseJson.position = 0;
parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
function parseJsonNumber(s, pos, maxDigits) {
    let numStr = "";
    let c;
    parseJsonNumber.message = undefined;
    if (s[pos] === "-") {
        numStr += "-";
        pos++;
    }
    if (s[pos] === "0") {
        numStr += "0";
        pos++;
    }
    else {
        if (!parseDigits(maxDigits)) {
            errorMessage();
            return undefined;
        }
    }
    if (maxDigits) {
        parseJsonNumber.position = pos;
        return +numStr;
    }
    if (s[pos] === ".") {
        numStr += ".";
        pos++;
        if (!parseDigits()) {
            errorMessage();
            return undefined;
        }
    }
    if (((c = s[pos]), c === "e" || c === "E")) {
        numStr += "e";
        pos++;
        if (((c = s[pos]), c === "+" || c === "-")) {
            numStr += c;
            pos++;
        }
        if (!parseDigits()) {
            errorMessage();
            return undefined;
        }
    }
    parseJsonNumber.position = pos;
    return +numStr;
    function parseDigits(maxLen) {
        let digit = false;
        while (((c = s[pos]), c >= "0" && c <= "9" && (maxLen === undefined || maxLen-- > 0))) {
            digit = true;
            numStr += c;
            pos++;
        }
        return digit;
    }
    function errorMessage() {
        parseJsonNumber.position = pos;
        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
    }
}
parseJson$1.parseJsonNumber = parseJsonNumber;
parseJsonNumber.message = undefined;
parseJsonNumber.position = 0;
parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
const escapedChars = {
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "\t",
    '"': '"',
    "/": "/",
    "\\": "\\",
};
const CODE_A = "a".charCodeAt(0);
const CODE_0 = "0".charCodeAt(0);
function parseJsonString(s, pos) {
    let str = "";
    let c;
    parseJsonString.message = undefined;
    // eslint-disable-next-line no-constant-condition, @typescript-eslint/no-unnecessary-condition
    while (true) {
        c = s[pos++];
        if (c === '"')
            break;
        if (c === "\\") {
            c = s[pos];
            if (c in escapedChars) {
                str += escapedChars[c];
                pos++;
            }
            else if (c === "u") {
                pos++;
                let count = 4;
                let code = 0;
                while (count--) {
                    code <<= 4;
                    c = s[pos];
                    if (c === undefined) {
                        errorMessage("unexpected end");
                        return undefined;
                    }
                    c = c.toLowerCase();
                    if (c >= "a" && c <= "f") {
                        code += c.charCodeAt(0) - CODE_A + 10;
                    }
                    else if (c >= "0" && c <= "9") {
                        code += c.charCodeAt(0) - CODE_0;
                    }
                    else {
                        errorMessage(`unexpected token ${c}`);
                        return undefined;
                    }
                    pos++;
                }
                str += String.fromCharCode(code);
            }
            else {
                errorMessage(`unexpected token ${c}`);
                return undefined;
            }
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        }
        else if (c === undefined) {
            errorMessage("unexpected end");
            return undefined;
        }
        else {
            if (c.charCodeAt(0) >= 0x20) {
                str += c;
            }
            else {
                errorMessage(`unexpected token ${c}`);
                return undefined;
            }
        }
    }
    parseJsonString.position = pos;
    return str;
    function errorMessage(msg) {
        parseJsonString.position = pos;
        parseJsonString.message = msg;
    }
}
parseJson$1.parseJsonString = parseJsonString;
parseJsonString.message = undefined;
parseJsonString.position = 0;
parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';

Object.defineProperty(parse, "__esModule", { value: true });
const types_1 = types;
const __1 = compile;
const codegen_1 = requireCodegen();
const ref_error_1 = requireRef_error();
const names_1 = names$1;
const code_1 = code;
const ref_1 = ref;
const type_1 = type;
const parseJson_1 = parseJson$1;
const util_1 = util;
const timestamp_1 = timestamp;
const genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef,
};
function compileParser(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const parseName = gen.scopeName("parse");
    const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen.name("c"),
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen.optimize(this.opts.code.optimize);
        const parseFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
        const parse = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse });
        sch.parse = parse;
    }
    catch (e) {
        if (sourceCode)
            this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
    return sch;
}
parse.default = compileParser;
const undef = (0, codegen_1._) `undefined`;
function parserFunction(cxt) {
    const { gen, parseName, char } = cxt;
    gen.func(parseName, (0, codegen_1._) `${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
        gen.let(names_1.default.data);
        gen.let(char);
        gen.assign((0, codegen_1._) `${parseName}.message`, undef);
        gen.assign((0, codegen_1._) `${parseName}.position`, undef);
        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos} || 0`);
        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json}.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen.if(names_1.default.jsonPart, () => {
            gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
            gen.return(names_1.default.data);
        });
        gen.if((0, codegen_1._) `${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
        jsonSyntaxError(cxt);
    });
}
function parseCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
            form = key;
            break;
        }
    }
    if (form)
        parseNullable(cxt, genParse[form]);
    else
        parseEmpty(cxt);
}
const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
function parseNullable(cxt, parseForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
        return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
}
function parseElements(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "[");
    const ix = gen.let("i", 0);
    gen.assign(data, (0, codegen_1._) `[]`);
    parseItems(cxt, "]", () => {
        const el = gen.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el });
        gen.assign((0, codegen_1._) `${data}[${ix}++]`, el);
    });
}
function parseValues(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
}
function parseItems(cxt, endToken, block) {
    tryParseItems(cxt, endToken, block);
    parseToken(cxt, endToken);
}
function tryParseItems(cxt, endToken, block) {
    const { gen } = cxt;
    gen.for((0, codegen_1._) `;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
        block();
        tryParseToken(cxt, ",", () => gen.break(), hasItem);
    });
    function hasItem() {
        tryParseToken(cxt, endToken, () => { }, jsonSyntaxError);
    }
}
function parseKeyValue(cxt, schema) {
    const { gen } = cxt;
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
}
function parseDiscriminator(cxt) {
    const { gen, data, schema } = cxt;
    const { discriminator, mapping } = schema;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    const startPos = gen.const("pos", names_1.default.jsonPos);
    const value = gen.let("value");
    const tag = gen.let("tag");
    tryParseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if((0, codegen_1._) `${key} === ${discriminator}`, () => {
            parseString({ ...cxt, data: tag });
            gen.assign((0, codegen_1._) `${data}[${key}]`, tag);
            gen.break();
        }, () => parseEmpty({ ...cxt, data: value }) // can be discarded/skipped
        );
    });
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((0, codegen_1._) `${tag} === undefined`);
    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
    for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
    }
    gen.else();
    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
    gen.endIf();
}
function parseProperties(cxt) {
    const { gen, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{}`);
    parseSchemaProperties(cxt);
}
function parseSchemaProperties(cxt, discriminator) {
    const { gen, schema, data } = cxt;
    const { properties, optionalProperties, additionalProperties } = schema;
    parseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
            gen.elseIf((0, codegen_1._) `${key} === ${discriminator}`);
            const tag = gen.let("tag");
            parseString({ ...cxt, data: tag }); // can be discarded, it is already assigned
        }
        gen.else();
        if (additionalProperties) {
            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data}[${key}]` });
        }
        else {
            parsingError(cxt, (0, codegen_1.str) `property ${key} not allowed`);
        }
        gen.endIf();
    });
    if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp}.call(${data}, ${p})`));
        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
    }
}
function parseDefinedProperty(cxt, key, schemas = {}) {
    const { gen } = cxt;
    for (const prop in schemas) {
        gen.elseIf((0, codegen_1._) `${key} === ${prop}`);
        parsePropertyValue(cxt, key, schemas[prop]);
    }
}
function parsePropertyValue(cxt, key, schema) {
    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data}[${key}]` });
}
function parseType(cxt) {
    const { gen, schema, data, self } = cxt;
    switch (schema.type) {
        case "boolean":
            parseBoolean(cxt);
            break;
        case "string":
            parseString(cxt);
            break;
        case "timestamp": {
            parseString(cxt);
            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
            const { allowDate, parseDate } = self.opts;
            const notValid = allowDate ? (0, codegen_1._) `!${vts}(${data}, true)` : (0, codegen_1._) `!${vts}(${data})`;
            const fail = parseDate
                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data} = new Date(${data}), false)`, (0, codegen_1._) `isNaN(${data}.valueOf())`)
                : notValid;
            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));
            break;
        }
        case "float32":
        case "float64":
            parseNumber(cxt);
            break;
        default: {
            const t = schema.type;
            if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
                parseNumber(cxt, 16); // 2 ** 53 - max safe integer
                if (t === "uint32") {
                    gen.if((0, codegen_1._) `${data} < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
                }
            }
            else {
                const [min, max, maxDigits] = type_1.intRange[t];
                parseNumber(cxt, maxDigits);
                gen.if((0, codegen_1._) `${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
            }
        }
    }
}
function parseString(cxt) {
    parseToken(cxt, '"');
    parseWith(cxt, parseJson_1.parseJsonString);
}
function parseEnum(cxt) {
    const { gen, data, schema } = cxt;
    const enumSch = schema.enum;
    parseToken(cxt, '"');
    // TODO loopEnum
    gen.if(false);
    for (const value of enumSch) {
        const valueStr = JSON.stringify(value).slice(1); // remove starting quote
        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)} === ${valueStr}`);
        gen.assign(data, (0, codegen_1.str) `${value}`);
        gen.add(names_1.default.jsonPos, valueStr.length);
    }
    gen.else();
    jsonSyntaxError(cxt);
    gen.endIf();
}
function parseNumber(cxt, maxDigits) {
    const { gen } = cxt;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._) `"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
}
function parseBooleanToken(bool, fail) {
    return (cxt) => {
        const { gen, data } = cxt;
        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
    };
}
function parseRef(cxt) {
    const { gen, self, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1.hasRef)(refSchema))
        return parseCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
    partialParse(cxt, getParser(gen, sch), true);
}
function getParser(gen, sch) {
    return sch.parse
        ? gen.scopeValue("parse", { ref: sch.parse })
        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.parse`;
}
function parseEmpty(cxt) {
    parseWith(cxt, parseJson_1.parseJson);
}
function parseWith(cxt, parseFunc, args) {
    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
}
function partialParse(cxt, parseFunc, args) {
    const { gen, data } = cxt;
    gen.assign(data, (0, codegen_1._) `${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._) `, ${args}` : codegen_1.nil})`);
    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc}.position`);
    gen.if((0, codegen_1._) `${data} === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc}.message`));
}
function parseToken(cxt, tok) {
    tryParseToken(cxt, tok, jsonSyntaxError);
}
function tryParseToken(cxt, tok, fail, success) {
    const { gen } = cxt;
    const n = tok.length;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._) `${jsonSlice(n)} === ${tok}`, () => {
        gen.add(names_1.default.jsonPos, n);
        success === null || success === void 0 ? void 0 : success(cxt);
    }, () => fail(cxt));
}
function skipWhitespace({ gen, char: c }) {
    gen.code((0, codegen_1._) `while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
}
function jsonSlice(len) {
    return len === 1
        ? (0, codegen_1._) `${names_1.default.json}[${names_1.default.jsonPos}]`
        : (0, codegen_1._) `${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
}
function jsonSyntaxError(cxt) {
    parsingError(cxt, (0, codegen_1._) `"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
}
function parsingError({ gen, parseName }, msg) {
    gen.assign((0, codegen_1._) `${parseName}.message`, msg);
    gen.assign((0, codegen_1._) `${parseName}.position`, names_1.default.jsonPos);
    gen.return(undef);
}

(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
	const core_1 = core$3;
	const jtd_1 = jtd;
	const jtd_schema_1 = jtdSchema;
	const serialize_1 = serialize;
	const parse_1 = parse;
	const META_SCHEMA_ID = "JTD-meta-schema";
	class Ajv extends core_1.default {
	    constructor(opts = {}) {
	        super({
	            ...opts,
	            jtd: true,
	        });
	    }
	    _addVocabularies() {
	        super._addVocabularies();
	        this.addVocabulary(jtd_1.default);
	    }
	    _addDefaultMetaSchema() {
	        super._addDefaultMetaSchema();
	        if (!this.opts.meta)
	            return;
	        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
	    }
	    defaultMeta() {
	        return (this.opts.defaultMeta =
	            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
	    }
	    compileSerializer(schema) {
	        const sch = this._addSchema(schema);
	        return sch.serialize || this._compileSerializer(sch);
	    }
	    compileParser(schema) {
	        const sch = this._addSchema(schema);
	        return (sch.parse || this._compileParser(sch));
	    }
	    _compileSerializer(sch) {
	        serialize_1.default.call(this, sch, sch.schema.definitions || {});
	        /* istanbul ignore if */
	        if (!sch.serialize)
	            throw new Error("ajv implementation error");
	        return sch.serialize;
	    }
	    _compileParser(sch) {
	        parse_1.default.call(this, sch, sch.schema.definitions || {});
	        /* istanbul ignore if */
	        if (!sch.parse)
	            throw new Error("ajv implementation error");
	        return sch.parse;
	    }
	}
	module.exports = exports = Ajv;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = Ajv;
	var validate_1 = requireValidate();
	Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
	var codegen_1 = requireCodegen();
	Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
	Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
	Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
	Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
	Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
	Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
	var validation_error_1 = requireValidation_error();
	Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
	var ref_error_1 = requireRef_error();
	Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
	
} (jtd$1, jtd$1.exports));

var jtdExports = jtd$1.exports;
var Ajv = /*@__PURE__*/getDefaultExportFromCjs(jtdExports);

const jtdAjv = new Ajv();

const inputSchema$k = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        optionalProperties: {
          scores: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                cvss_v2: {
                  additionalProperties: true,
                  properties: {},
                },
                cvss_v3: {
                  additionalProperties: true,
                  properties: {},
                },
              },
            },
          },
        },
      },
    },
  },
});

const validate$f = jtdAjv.compile(inputSchema$k);

const validate_2_0 = csafAjv.compile({
  $ref: 'https://www.first.org/cvss/cvss-v2.0.json',
});

const validate_3 = csafAjv.compile({
  oneOf: [
    {
      $ref: 'https://www.first.org/cvss/cvss-v3.0.json',
    },
    {
      $ref: 'https://www.first.org/cvss/cvss-v3.1.json',
    },
  ],
});

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_8(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$f(doc)) {
    return ctx
  }

  for (const [
    vulnerabilityIndex,
    vulnerability,
  ] of doc.vulnerabilities?.entries() ?? []) {
    for (const [scoreIndex, score] of vulnerability.scores?.entries() ?? []) {
      if (score.cvss_v2) {
        const valid = validate_2_0(score.cvss_v2);
        if (!valid) {
          ctx.isValid = false;
          for (const err of validate_2_0.errors ?? []) {
            ctx.errors.push({
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v2${err.instancePath}`,
              message: err.message ?? '',
            });
          }
        }
      }
      if (score.cvss_v3) {
        const valid = validate_3(score.cvss_v3);
        if (!valid) {
          ctx.isValid = false;
          for (const err of validate_3.errors ?? []) {
            ctx.errors.push({
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v3${err.instancePath}`,
              message: err.message ?? '',
            });
          }
        }
      }
    }
  }

  return ctx
}

var main = {};

/**
 * Copyright (c) 2017 - Charles `sparticvs` Timko
 */

function __isValidVectorString(input) {
    if(typeof input !== 'string') {
        throw 'Vector string must be a string';
    }

    const regex = /AV:[LAN]\/AC:[HML]\/Au:[MSN]\/C:[NPC]\/I:[NPC]\/A:[NPC](\/E:(ND|U|POC|F|H)\/RL:(ND|OF|TF|W|U)\/RC:(ND|UC|UR|C))?(\/CDP:(ND|N|L|LM|MH|H)\/TD:(ND|N|L|M|H)\/CR:(ND|L|M|H)\/IR:(ND|L|M|H)\/AR:(ND|L|M|H))?/;

    return input.match(regex) !== null;
}

function __prepareVectorObj(input) {
    if(typeof input !== 'object') {
        throw new Error('param should be of type object');
    }

    const vectorObj = {
        AV: '',
        AC: '',
        Au: '',
        C: '',
        I: '',
        A: '',
        E: 'ND',
        RL: 'ND',
        RC: 'ND',
        CDP: 'ND',
        TD: 'ND',
        CR: 'ND',
        IR: 'ND',
        AR: 'ND',
    };

    for(let k in input) {
        vectorObj[k] = input[k];
    }

    return vectorObj;
}

function __parseVectorString(input) {

    if(typeof input !== 'string') {
        throw 'Vector string must be a string';
    }

    const vectorObj = {
        AV: '',
        AC: '',
        Au: '',
        C: '',
        I: '',
        A: '',
        E: 'ND',
        RL: 'ND',
        RC: 'ND',
        CDP: 'ND',
        TD: 'ND',
        CR: 'ND',
        IR: 'ND',
        AR: 'ND',
    };

    let metrics = input.split('/');

    metrics.forEach(function(metric) {
        let kvPair = metric.split(':');
        if(kvPair.length !== 2) {
            throw 'Metric format is not correct';
        }

        vectorObj[kvPair[0]] = kvPair[1];
    });

    return vectorObj;
}

function __toVectorString(input) {

    if(typeof input !== 'object') {
        throw 'Input needs to be an object';
    }

    var vectorStr = 'AV:' + input['AV'] + '/AC:' + input['AC'] + '/Au:' + input['Au'] + '/C:' + input['C'] + '/I:' + input['I'] + '/A:' + input['A'] + '/E:' + input['E'] + '/RL:' + input['RL'] + '/RC:' + input['RC'] + '/CDP:' + input['CDP'] + '/TD:' + input['TD'] + '/CR:' + input['CR'] + '/IR:' + input['IR'] + '/AR:' + input['AR'];

    return vectorStr;
}
main.toVectorString = __toVectorString;

const AccessVector = {
    L: 0.395,
    A: 0.646,
    N: 1.0,
};

const AccessComplexity = {
    H: 0.35,
    M: 0.61,
    L: 0.71,
};

const Authentication = {
    M: 0.45,
    S: 0.56,
    N: 0.704,
};

const Impacts = {
    N: 0.0,
    P: 0.275,
    C: 0.660,
};

const Exploitability = {
    U: 0.85,
    POC: 0.9,
    F: 0.95,
    H: 1.0,
    ND: 1.0,
};

const RemediationLevel = {
    OF: 0.87,
    TF: 0.90,
    W: 0.95,
    U: 1.0,
    ND: 1.0,
};

const ReportConfidence = {
    UC: 0.90,
    UR: 0.95,
    C: 1.0,
    ND: 1.0,
};

const CollateralDamagePotential = {
    N: 0.0,
    L: 0.1,
    LM: 0.3,
    MH: 0.4,
    H: 0.5,
    ND: 0.0,
};

const TargetDistribution = {
    N: 0.0,
    L: 0.25,
    M: 0.75,
    H: 1.0,
    ND: 1.0,
};

const Requirements = {
    L: 0.5,
    M: 1.0,
    H: 1.51,
    ND: 1.0,
};

function __computeImpact(conf, integrity, avail) {

    if(typeof conf !== 'number' &&
        typeof integrity !== 'number' &&
        typeof avail !== 'number') {
        throw 'Params are of the wrong type';
    }

    return (10.41 * (1 - (1 - conf) * (1 - integrity) * (1 - avail)));
}

function __computeExploitability(av, ac, au) {

    if(typeof av !== 'number' &&
        typeof ac !== 'number' &&
        typeof au !== 'number') {
        throw 'Params are of the wrong type';
    }

    return (20 * av * ac * au);
}

function __fImpact(impact) {

    if(typeof impact !== 'number') {
        throw 'Params are of the wrong type';
    }

    return (impact === 0) ? 0 : 1.176;
}

function __computeBaseScore(input) {
    let scoreObj = {};

    const impact = __computeImpact(Impacts[input.C], Impacts[input.I], Impacts[input.A]);
    const exploitability = __computeExploitability(AccessVector[input.AV], AccessComplexity[input.AC], Authentication[input.Au]);
    const baseScore = (((0.6 * impact) + (0.4 * exploitability) - 1.5) * __fImpact(impact)).toFixed(1);

    scoreObj['base'] = Number.parseFloat(baseScore);

    return scoreObj;
}

function __computeTemporalScore(input) {

    let scoreObj = __computeBaseScore(input);
    const baseScore = scoreObj['base'];
    const temporalScore = (baseScore * Exploitability[input.E] * RemediationLevel[input.RL] * ReportConfidence[input.RC]).toFixed(1);

    scoreObj['temporal'] = Number.parseFloat(temporalScore);

    return scoreObj;
}

function __computeAdjustedImpact(input) {

    const adjustedImpact = (10.41 * (1 - (1 - Impacts[input.C] * Requirements[input.CR]) * (1 - Impacts[input.I] * Requirements[input.IR]) * (1 - Impacts[input.A] * Requirements[input.AR])));
    return Math.min(10, adjustedImpact);
}

function __computeAdjustedBaseScore(input) {

    let scoreObj = {};
    const adjustedImpact = __computeAdjustedImpact(input);
    const exploitability = __computeExploitability(AccessVector[input.AV], AccessComplexity[input.AC], Authentication[input.Au]);
    const adjBaseScore = (((0.6 * adjustedImpact) + (0.4 * exploitability) - 1.5) * __fImpact(adjustedImpact)).toFixed(1);

    scoreObj['base'] = Number.parseFloat(adjBaseScore);
    return scoreObj;
}

function __computeAdjustedTemporalScore(input) {

    let scoreObj = __computeAdjustedBaseScore(input);
    const adjBaseScore = scoreObj['base'];
    const adjTemporalScore = (adjBaseScore * Exploitability[input.E] * RemediationLevel[input.RL] * ReportConfidence[input.RC]).toFixed(1);

    scoreObj['temporal'] = Number.parseFloat(adjTemporalScore);
    return scoreObj;
}

function __computeEnvironmentalScore(input) {

    let scoreObj = __computeAdjustedTemporalScore(input);
    const adjTemporalScore = scoreObj['temporal'];
    const environmentalScore = ((adjTemporalScore + (10 - adjTemporalScore) * CollateralDamagePotential[input.CDP]) * TargetDistribution[input.TD]).toFixed(1);

    scoreObj['environmental'] = Number.parseFloat(environmentalScore);
    return scoreObj;
}

function __inRange(range, value) {
    if(typeof range !== 'string' &&
        typeof value !== 'number') {
        throw 'Params are not the correct type';
    }

    const rangeRegEx = /(-?[\d.]+)-([\d.]+)/;
    const match = rangeRegEx.exec(range);

    const low = Number.parseFloat(match[1]);
    const high = Number.parseFloat(match[2]);

    return low <= value && value < high;
}

const Ratings = {
    '-1.0-0.1': 'Informational',
    '0.1-4': 'Low',
    '4-7': 'Medium',
    '7-9': 'High',
    '9-10.1': 'Critical',
};

const Compute = {
    base: __computeBaseScore,
    temporal: __computeTemporalScore,
    environmental: __computeEnvironmentalScore,
};

function __getRating(score) {
    for(const props in Ratings) {
        if(__inRange(props, score)) {
            return Ratings[props];
        }
    }
    return undefined;
}

function __getScore(input, func) {
    let vector = undefined;
    if(typeof input === 'string') {
        if(__isValidVectorString(input)) {
            vector = __parseVectorString(input);
        } else {
            throw new Error('Invalid Vector String Format. Must be CVSSv2.');
        }
    } else if(typeof input === 'object') {
        vector = __prepareVectorObj(input);
    } else {
        throw new Error('Invalid type for \'input\'');
    }

    return func(vector);
}

function getScore(input, options = {}) {
    let key = 'environmental';
    if(options['baseOnly']) {
        key = 'base';
    }
    if(options['temporal']) {
        key = 'temporal';
    }
    if(options['env']) {
        key = 'environmental';
    }
    let scoreObj = __getScore(input, Compute[key]);
    return scoreObj[key];
}
main.getScore = getScore;

function getBaseScore(input, options = {}) {
    options['baseOnly'] = true;
    return getScore(input, options);
}
main.getBaseScore = getBaseScore;

function getTemporalScore(input, options = {}) {
    options['temporal'] = true;
    return getScore(input, options);
}
main.getTemporalScore = getTemporalScore;

function getEnvironmentalScore(input, options = {}) {
    options['env'] = true;
    return getScore(input, options);
}
main.getEnvironmentalScore = getEnvironmentalScore;

function getRating(score) {
    return __getRating(score);
}
main.getRating = getRating;

function getBase(input, options = {}) {
    const score = getBaseScore(input, options);
    let scoreObj = {
        score: score,
        rating: getRating(score),
    };
    return scoreObj;
}
main.getBase = getBase;

function getTemporal(input, options = {}) {
    const score = getTemporalScore(input, options);
    let scoreObj = {
        score: score,
        rating: getRating(score),
    };
    return scoreObj;
}
main.getTemporal = getTemporal;

function getEnvironmental(input, options = {}) {
    const score = getEnvironmentalScore(input, options);
    let scoreObj = {
        score: score,
        rating: getRating(score),
    };
    return scoreObj;
}
main.getEnvironmental = getEnvironmental;

function getAll(input, options = {}) {
    var scoreObj = {
        base: getBase(input, options),
        temporal: getTemporal(input, options),
        environmental: getEnvironmental(input, options),
    };
    return scoreObj;
}
main.getAll = getAll;

var cvss2js = main;

var cvss2js$1 = /*@__PURE__*/getDefaultExportFromCjs(cvss2js);

/**
 * @param {string | {}} vectorString
 */
function getEnvironmentalScoreFromVectorString(vectorString) {
  const vector = new Map(
    typeof vectorString === 'string'
      ? vectorString.split('/').map((k) => {
          const [key, value] = k.split(':');
          return [key, /** @type {string | null} */ (value ?? null)]
        })
      : Object.entries(vectorString)
  );

  const impactScore =
    10.41 *
    mkflt(
      mkint(1.0) -
        mkint(
          mkflt(mkint(1.0) - mkint(getMetricScoreFloat(vector, 'C'))) *
            mkflt(mkint(1.0) - mkint(getMetricScoreFloat(vector, 'I'))) *
            mkflt(mkint(1.0) - mkint(getMetricScoreFloat(vector, 'A')))
        )
    );
  const exploitabilitySubScore =
    20.0 *
    getMetricScoreFloat(vector, 'AC') *
    getMetricScoreFloat(vector, 'Au') *
    getMetricScoreFloat(vector, 'AV');

  const baseScore = quickRound(
    mkflt(
      mkint(0.6 * impactScore) +
        mkint(0.4 * exploitabilitySubScore) -
        mkint(1.5)
    ) * fImpact(impactScore)
  );

  let environmentalScore = baseScore;

  if (
    vector.has('CDP') ||
    vector.has('TD') ||
    vector.has('CR') ||
    vector.has('IR') ||
    vector.has('AR')
  ) {
    const adjustedImpactScore = Math.min(
      10,
      10.41 *
        mkflt(
          mkint(1.0) -
            mkint(
              mkflt(
                mkint(1.0) -
                  mkint(
                    getMetricScoreFloat(vector, 'C') *
                      getMetricScoreFloat(vector, 'CR')
                  )
              ) *
                (mkflt(
                  mkint(1.0) -
                    mkint(
                      getMetricScoreFloat(vector, 'I') *
                        getMetricScoreFloat(vector, 'IR')
                    )
                ) *
                  mkflt(
                    mkint(1.0) -
                      mkint(
                        getMetricScoreFloat(vector, 'A') *
                          getMetricScoreFloat(vector, 'AR')
                      )
                  ))
            )
        )
    );

    const adjustedBaseScore = quickRound(
      mkflt(
        mkint(0.6 * adjustedImpactScore) +
          mkint(0.4 * exploitabilitySubScore) -
          mkint(1.5)
      ) * fImpact(impactScore)
    );

    const adjustedTemporal = quickRound(
      adjustedBaseScore *
        getMetricScoreFloat(vector, 'E') *
        getMetricScoreFloat(vector, 'RL') *
        getMetricScoreFloat(vector, 'RC')
    );

    environmentalScore = quickRound(
      mkflt(
        mkint(adjustedTemporal) +
          mkint(
            mkflt(mkint(10) - mkint(adjustedTemporal)) *
              getMetricScoreFloat(vector, 'CDP')
          )
      ) * getMetricScoreFloat(vector, 'TD')
    );
  }

  return environmentalScore
}

const intFact = 1000;

/**
 * @param {Map<string, string | null>} vector
 * @param {CVSSField} field
 */
function getMetricScoreFloat(vector, field) {
  const metric = cvssScores.get(field);
  if (!metric) throw new Error('Metric not found')
  let value = vector.get(field) ?? null;
  if (value === null) {
    if (metric.category === 'environmental' || metric.category === 'temporal') {
      value = 'ND';
    } else {
      throw new Error('Missing fields to calculate base score')
    }
  }

  return metric.scores.get(value) ?? 0
}

/**
 * @param {number} original
 * @returns
 */
function quickRound(original) {
  return Math.round(original * 10) / 10
}

/**
 * @param {number} original
 * @returns
 */
function mkflt(original) {
  return original / intFact
}

/**
 * @param {number} original
 * @returns
 */
function mkint(original) {
  return Math.round(original * intFact)
}

/**
 * @param {number} value
 * @returns
 */
function fImpact(value) {
  if (value > 0) {
    return 1.176
  } else {
    return 0
  }
}

/** @typedef {(typeof mapping)[number][1]} CVSSField */

const mapping$1 = /** @type {const} */ ([
  // BASE SCORE
  [
    'accessVector',
    'AV',
    {
      NETWORK: { id: 'N', score: 1 },
      ADJACENT_NETWORK: { id: 'A', score: 0.646 },
      LOCAL: { id: 'L', score: 0.395 },
    },
    'base',
  ],
  [
    'accessComplexity',
    'AC',
    {
      HIGH: { id: 'H', score: 0.35 },
      MEDIUM: { id: 'M', score: 0.61 },
      LOW: { id: 'L', score: 0.71 },
    },
    'base',
  ],
  [
    'authentication',
    'Au',
    {
      MULTIPLE: { id: 'M', score: 0.45 },
      SINGLE: { id: 'S', score: 0.56 },
      NONE: { id: 'N', score: 0.704 },
    },
    'base',
  ],
  [
    'confidentialityImpact',
    'C',
    {
      NONE: { id: 'N', score: 0 },
      PARTIAL: { id: 'P', score: 0.275 },
      COMPLETE: { id: 'C', score: 0.66 },
    },
    'base',
  ],
  [
    'integrityImpact',
    'I',
    {
      NONE: { id: 'N', score: 0 },
      PARTIAL: { id: 'P', score: 0.275 },
      COMPLETE: { id: 'C', score: 0.66 },
    },
    'base',
  ],
  [
    'availabilityImpact',
    'A',
    {
      NONE: { id: 'N', score: 0 },
      PARTIAL: { id: 'P', score: 0.275 },
      COMPLETE: { id: 'C', score: 0.66 },
    },
    'base',
  ],

  // TEMPORAL SCORE
  [
    'exploitability',
    'E',
    {
      UNPROVEN: { id: 'U', score: 0.85 },
      PROOF_OF_CONCEPT: { id: 'POC', score: 0.9 },
      FUNCTIONAL: { id: 'F', score: 0.95 },
      HIGH: { id: 'H', score: 1.0 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'temporal',
  ],
  [
    'remediationLevel',
    'RL',
    {
      OFFICIAL_FIX: { id: 'OF', score: 0.87 },
      TEMPORARY_FIX: { id: 'TF', score: 0.9 },
      WORKAROUND: { id: 'W', score: 0.95 },
      UNAVAILABLE: { id: 'U', score: 1.0 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'temporal',
  ],

  [
    'reportConfidence',
    'RC',
    {
      UNCONFIRMED: { id: 'UC', score: 0.9 },
      UNCORROBORATED: { id: 'UR', score: 0.95 },
      CONFIRMED: { id: 'C', score: 1.0 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'temporal',
  ],

  // ENVIRONMENTAL SCORE
  [
    'collateralDamagePotential',
    'CDP',
    {
      NONE: { id: 'N', score: 0 },
      LOW: { id: 'L', score: 0.1 },
      LOW_MEDIUM: { id: 'LM', score: 0.3 },
      MEDIUM_HIGH: { id: 'MH', score: 0.4 },
      HIGH: { id: 'H', score: 0.5 },
      NOT_DEFINED: { id: 'ND', score: 0 },
    },
    'environmental',
  ],
  [
    'targetDistribution',
    'TD',
    {
      NONE: { id: 'N', score: 0 },
      LOW: { id: 'L', score: 0.25 },
      MEDIUM: { id: 'M', score: 0.75 },
      HIGH: { id: 'H', score: 1.0 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'environmental',
  ],
  [
    'confidentialityRequirement',
    'CR',
    {
      LOW: { id: 'L', score: 0.5 },
      MEDIUM: { id: 'M', score: 1.0 },
      HIGH: { id: 'H', score: 1.51 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'environmental',
  ],
  [
    'integrityRequirement',
    'IR',
    {
      LOW: { id: 'L', score: 0.5 },
      MEDIUM: { id: 'M', score: 1.0 },
      HIGH: { id: 'H', score: 1.51 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'environmental',
  ],
  [
    'availabilityRequirement',
    'AR',
    {
      LOW: { id: 'L', score: 0.5 },
      MEDIUM: { id: 'M', score: 1.0 },
      HIGH: { id: 'H', score: 1.51 },
      NOT_DEFINED: { id: 'ND', score: 1.0 },
    },
    'environmental',
  ],
]);

const cvssScores = new Map(
  mapping$1.map(([, field, values, category]) => [
    field,
    {
      category,
      scores: new Map(
        Object.values(values).map((v) => [
          /** @type {string} */ (v.id),
          /** @type {number} */ (v.score),
        ])
      ),
    },
  ])
);

// @ts-nocheck

/* Copyright (c) 2015, FIRST.ORG, INC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This JavaScript contains two main functions. Both take CVSS metric values and calculate CVSS scores for Base,
 * Temporal and Environmental metric groups, their associated severity ratings, and an overall Vector String.
 *
 * Use CVSS.calculateCVSSFromMetrics if you wish to pass metric values as individual parameters.
 * Use CVSS.calculateCVSSFromVector if you wish to pass metric values as a single Vector String.
 *
 * Changelog
 *
 * 2018-02-15  Darius Wiles   Added a missing pair of parantheses in the Environmental score, specifically
 *                            in the code setting envScore in the main clause (not the else clause). It was changed
 *                            from "min (...), 10" to "min ((...), 10)". This correction does not alter any final
 *                            Environmental scores.
 *
 * 2015-08-04  Darius Wiles   Added CVSS.generateXMLFromMetrics and CVSS.generateXMLFromVector functions to return
 *                            XML string representations of: a set of metric values; or a Vector String respectively.
 *                            Moved all constants and functions to an object named "CVSS" to
 *                            reduce the chance of conflicts in global variables when this file is combined with
 *                            other JavaScript code. This will break all existing code that uses this file until
 *                            the string "CVSS." is prepended to all references. The "Exploitability" metric has been
 *                            renamed "Exploit Code Maturity" in the specification, so the same change has been made
 *                            in the code in this file.
 *
 * 2015-04-24  Darius Wiles   Environmental formula modified to eliminate undesirable behavior caused by subtle
 *                            differences in rounding between Temporal and Environmental formulas that often
 *                            caused the latter to be 0.1 lower than than the former when all Environmental
 *                            metrics are "Not defined". Also added a RoundUp1 function to simplify formulas.
 *
 * 2015-04-09  Darius Wiles   Added calculateCVSSFromVector function, license information, cleaned up code and improved
 *                            comments.
 *
 * 2014-12-12  Darius Wiles   Initial release for CVSS 3.0 Preview 2.
 */

// Constants used in the formula. They are not declared as "const" to avoid problems in older browsers.

var CVSS = {};

CVSS.CVSSVersionIdentifier = "CVSS:3.0";
CVSS.exploitabilityCoefficient = 8.22;
CVSS.scopeCoefficient = 1.08;

// A regular expression to validate that a CVSS 3.0 vector string is well formed. It checks metrics and metric
// values. It does not check that a metric is specified more than once and it does not check that all base
// metrics are present. These checks need to be performed separately.

CVSS.vectorStringRegex_30 = /^CVSS:3\.0\/((AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])\/)*(AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$/;


// Associative arrays mapping each metric value to the constant defined in the CVSS scoring formula in the CVSS v3.0
// specification.

CVSS.Weight = {
  AV:   { N: 0.85,  A: 0.62,  L: 0.55,  P: 0.2},
  AC:   { H: 0.44,  L: 0.77},
  PR:   { U:       {N: 0.85,  L: 0.62,  H: 0.27},         // These values are used if Scope is Unchanged
          C:       {N: 0.85,  L: 0.68,  H: 0.5}},         // These values are used if Scope is Changed
  UI:   { N: 0.85,  R: 0.62},
  S:    { U: 6.42,  C: 7.52},                             // Note: not defined as constants in specification
  CIA:  { N: 0,     L: 0.22,  H: 0.56},                   // C, I and A have the same weights

  E:    { X: 1,     U: 0.91,  P: 0.94,  F: 0.97,  H: 1},
  RL:   { X: 1,     O: 0.95,  T: 0.96,  W: 0.97,  U: 1},
  RC:   { X: 1,     U: 0.92,  R: 0.96,  C: 1},

  CIAR: { X: 1,     L: 0.5,   M: 1,     H: 1.5}           // CR, IR and AR have the same weights
};


// Severity rating bands, as defined in the CVSS v3.0 specification.

CVSS.severityRatings  = [ { name: "None",     bottom: 0.0, top:  0.0},
                          { name: "Low",      bottom: 0.1, top:  3.9},
                          { name: "Medium",   bottom: 4.0, top:  6.9},
                          { name: "High",     bottom: 7.0, top:  8.9},
                          { name: "Critical", bottom: 9.0, top: 10.0} ];




/* ** CVSS.calculateCVSSFromMetrics **
 *
 * Takes Base, Temporal and Environmental metric values as individual parameters. Their values are in the short format
 * defined in the CVSS v3.0 standard definition of the Vector String. For example, the AttackComplexity parameter
 * should be either "H" or "L".
 *
 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
 * passed default to "X" ("Not Defined").
 *
 * The output is an object which always has a property named "success".
 *
 * If no errors are encountered, success is Boolean "true", and the following other properties are defined containing
 * scores, severities and a vector string:
 *   baseMetricScore, baseSeverity,
 *   temporalMetricScore, temporalSeverity,
 *   environmentalMetricScore, environmentalSeverity,
 *   vectorString
 *
 * If errors are encountered, success is Boolean "false", and the following other properties are defined:
 *   errorType - a string indicating the error. Either:
 *                 "MissingBaseMetric", if at least one Base metric has not been defined; or
 *                 "UnknownMetricValue", if at least one metric value is invalid.
 *   errorMetrics - an array of strings representing the metrics at fault. The strings are abbreviated versions of the
 *                  metrics, as defined in the CVSS v3.0 standard definition of the Vector String.
 */
CVSS.calculateCVSSFromMetrics = function (
  AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
  ExploitCodeMaturity, RemediationLevel, ReportConfidence,
  ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
  ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
  ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability) {

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  // ENSURE ALL BASE METRICS ARE DEFINED
  //
  // We need values for all Base Score metrics to calculate scores.
  // If any Base Score parameters are undefined, create an array of missing metrics and return it with an error.

  if (typeof AttackVector       === "undefined" || AttackVector       === "") { badMetrics.push("AV"); }
  if (typeof AttackComplexity   === "undefined" || AttackComplexity   === "") { badMetrics.push("AC"); }
  if (typeof PrivilegesRequired === "undefined" || PrivilegesRequired === "") { badMetrics.push("PR"); }
  if (typeof UserInteraction    === "undefined" || UserInteraction    === "") { badMetrics.push("UI"); }
  if (typeof Scope              === "undefined" || Scope              === "") { badMetrics.push("S");  }
  if (typeof Confidentiality    === "undefined" || Confidentiality    === "") { badMetrics.push("C");  }
  if (typeof Integrity          === "undefined" || Integrity          === "") { badMetrics.push("I");  }
  if (typeof Availability       === "undefined" || Availability       === "") { badMetrics.push("A");  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MissingBaseMetric", errorMetrics: badMetrics };
  }


  // STORE THE METRIC VALUES THAT WERE PASSED AS PARAMETERS
  //
  // Temporal and Environmental metrics are optional, so set them to "X" ("Not Defined") if no value was passed.

  var AV = AttackVector;
  var AC = AttackComplexity;
  var PR = PrivilegesRequired;
  var UI = UserInteraction;
  var S  = Scope;
  var C  = Confidentiality;
  var I  = Integrity;
  var A  = Availability;

  var E =   ExploitCodeMaturity || "X";
  var RL =  RemediationLevel    || "X";
  var RC =  ReportConfidence    || "X";

  var CR =  ConfidentialityRequirement || "X";
  var IR =  IntegrityRequirement       || "X";
  var AR =  AvailabilityRequirement    || "X";
  var MAV = ModifiedAttackVector       || "X";
  var MAC = ModifiedAttackComplexity   || "X";
  var MPR = ModifiedPrivilegesRequired || "X";
  var MUI = ModifiedUserInteraction    || "X";
  var MS =  ModifiedScope              || "X";
  var MC =  ModifiedConfidentiality    || "X";
  var MI =  ModifiedIntegrity          || "X";
  var MA =  ModifiedAvailability       || "X";


  // CHECK VALIDITY OF METRIC VALUES
  //
  // Use the Weight object to ensure that, for every metric, the metric value passed is valid.
  // If any invalid values are found, create an array of their metrics and return it with an error.
  //
  // The Privileges Required (PR) weight depends on Scope, but when checking the validity of PR we must not assume
  // that the given value for Scope is valid. We therefore always look at the weights for Unchanged Scope when
  // performing this check. The same applies for validation of Modified Privileges Required (MPR).
  //
  // The Weights object does not contain "X" ("Not Defined") values for Environmental metrics because we replace them
  // with their Base metric equivalents later in the function. For example, an MAV of "X" will be replaced with the
  // value given for AV. We therefore need to explicitly allow a value of "X" for Environmental metrics.

  if (!CVSS.Weight.AV.hasOwnProperty(AV))   { badMetrics.push("AV"); }
  if (!CVSS.Weight.AC.hasOwnProperty(AC))   { badMetrics.push("AC"); }
  if (!CVSS.Weight.PR.U.hasOwnProperty(PR)) { badMetrics.push("PR"); }
  if (!CVSS.Weight.UI.hasOwnProperty(UI))   { badMetrics.push("UI"); }
  if (!CVSS.Weight.S.hasOwnProperty(S))     { badMetrics.push("S"); }
  if (!CVSS.Weight.CIA.hasOwnProperty(C))   { badMetrics.push("C"); }
  if (!CVSS.Weight.CIA.hasOwnProperty(I))   { badMetrics.push("I"); }
  if (!CVSS.Weight.CIA.hasOwnProperty(A))   { badMetrics.push("A"); }

  if (!CVSS.Weight.E.hasOwnProperty(E))     { badMetrics.push("E"); }
  if (!CVSS.Weight.RL.hasOwnProperty(RL))   { badMetrics.push("RL"); }
  if (!CVSS.Weight.RC.hasOwnProperty(RC))   { badMetrics.push("RC"); }

  if (!(CR  === "X" || CVSS.Weight.CIAR.hasOwnProperty(CR)))  { badMetrics.push("CR"); }
  if (!(IR  === "X" || CVSS.Weight.CIAR.hasOwnProperty(IR)))  { badMetrics.push("IR"); }
  if (!(AR  === "X" || CVSS.Weight.CIAR.hasOwnProperty(AR)))  { badMetrics.push("AR"); }
  if (!(MAV === "X" || CVSS.Weight.AV.hasOwnProperty(MAV)))   { badMetrics.push("MAV"); }
  if (!(MAC === "X" || CVSS.Weight.AC.hasOwnProperty(MAC)))   { badMetrics.push("MAC"); }
  if (!(MPR === "X" || CVSS.Weight.PR.U.hasOwnProperty(MPR))) { badMetrics.push("MPR"); }
  if (!(MUI === "X" || CVSS.Weight.UI.hasOwnProperty(MUI)))   { badMetrics.push("MUI"); }
  if (!(MS  === "X" || CVSS.Weight.S.hasOwnProperty(MS)))     { badMetrics.push("MS"); }
  if (!(MC  === "X" || CVSS.Weight.CIA.hasOwnProperty(MC)))   { badMetrics.push("MC"); }
  if (!(MI  === "X" || CVSS.Weight.CIA.hasOwnProperty(MI)))   { badMetrics.push("MI"); }
  if (!(MA  === "X" || CVSS.Weight.CIA.hasOwnProperty(MA)))   { badMetrics.push("MA"); }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "UnknownMetricValue", errorMetrics: badMetrics };
  }



  // GATHER WEIGHTS FOR ALL METRICS

  var metricWeightAV  = CVSS.Weight.AV    [AV];
  var metricWeightAC  = CVSS.Weight.AC    [AC];
  var metricWeightPR  = CVSS.Weight.PR    [S][PR];  // PR depends on the value of Scope (S).
  var metricWeightUI  = CVSS.Weight.UI    [UI];
  var metricWeightS   = CVSS.Weight.S     [S];
  var metricWeightC   = CVSS.Weight.CIA   [C];
  var metricWeightI   = CVSS.Weight.CIA   [I];
  var metricWeightA   = CVSS.Weight.CIA   [A];

  var metricWeightE   = CVSS.Weight.E     [E];
  var metricWeightRL  = CVSS.Weight.RL    [RL];
  var metricWeightRC  = CVSS.Weight.RC    [RC];

  // For metrics that are modified versions of Base Score metrics, e.g. Modified Attack Vector, use the value of
  // the Base Score metric if the modified version value is "X" ("Not Defined").
  var metricWeightCR  = CVSS.Weight.CIAR  [CR];
  var metricWeightIR  = CVSS.Weight.CIAR  [IR];
  var metricWeightAR  = CVSS.Weight.CIAR  [AR];
  var metricWeightMAV = CVSS.Weight.AV    [MAV !== "X" ? MAV : AV];
  var metricWeightMAC = CVSS.Weight.AC    [MAC !== "X" ? MAC : AC];
  var metricWeightMPR = CVSS.Weight.PR    [MS  !== "X" ? MS  : S] [MPR !== "X" ? MPR : PR];  // Depends on MS.
  var metricWeightMUI = CVSS.Weight.UI    [MUI !== "X" ? MUI : UI];
  var metricWeightMS  = CVSS.Weight.S     [MS  !== "X" ? MS  : S];
  var metricWeightMC  = CVSS.Weight.CIA   [MC  !== "X" ? MC  : C];
  var metricWeightMI  = CVSS.Weight.CIA   [MI  !== "X" ? MI  : I];
  var metricWeightMA  = CVSS.Weight.CIA   [MA  !== "X" ? MA  : A];



  // CALCULATE THE CVSS BASE SCORE

  var baseScore;
  var impactSubScore;
  var exploitabalitySubScore = CVSS.exploitabilityCoefficient * metricWeightAV * metricWeightAC * metricWeightPR * metricWeightUI;
  var impactSubScoreMultiplier = (1 - ((1 - metricWeightC) * (1 - metricWeightI) * (1 - metricWeightA)));

  if (S === 'U') {
    impactSubScore = metricWeightS * impactSubScoreMultiplier;
  } else {
    impactSubScore = metricWeightS * (impactSubScoreMultiplier - 0.029) - 3.25 * Math.pow(impactSubScoreMultiplier - 0.02, 15);
  }

  if (impactSubScore <= 0) {
    baseScore = 0;
  } else {
    if (S === 'U') {
      baseScore = CVSS.roundUp1(Math.min((exploitabalitySubScore + impactSubScore), 10));
    } else {
      baseScore = CVSS.roundUp1(Math.min((exploitabalitySubScore + impactSubScore) * CVSS.scopeCoefficient, 10));
    }
  }



  // CALCULATE THE CVSS TEMPORAL SCORE

  var temporalScore = CVSS.roundUp1(baseScore * metricWeightE * metricWeightRL * metricWeightRC);


  // CALCULATE THE CVSS ENVIRONMENTAL SCORE
  //
  // - envExploitabalitySubScore recalculates the Base Score Exploitability sub-score using any modified values from the
  //   Environmental metrics group in place of the values specified in the Base Score, if any have been defined.
  // - envAdjustedImpactSubScore recalculates the Base Score Impact sub-score using any modified values from the
  //   Environmental metrics group in place of the values specified in the Base Score, and any additional weightings
  //   given in the Environmental metrics group.

  var envScore;
  var envModifiedImpactSubScore;
  var envModifiedExploitabalitySubScore = CVSS.exploitabilityCoefficient * metricWeightMAV * metricWeightMAC * metricWeightMPR * metricWeightMUI;

  var envImpactSubScoreMultiplier = Math.min (1 - (
                                               (1 - metricWeightMC * metricWeightCR) *
                                               (1 - metricWeightMI * metricWeightIR) *
                                               (1 - metricWeightMA * metricWeightAR)), 0.915);

  if (MS === "U" ||
     (MS === "X" && S === "U")) {
    envModifiedImpactSubScore = metricWeightMS * envImpactSubScoreMultiplier;
    envScore = CVSS.roundUp1(CVSS.roundUp1(Math.min((envModifiedImpactSubScore + envModifiedExploitabalitySubScore), 10)) *
                        metricWeightE * metricWeightRL * metricWeightRC);
    } else {
    envModifiedImpactSubScore = metricWeightMS * (envImpactSubScoreMultiplier - 0.029) - 3.25 * Math.pow(envImpactSubScoreMultiplier - 0.02, 15);
    envScore = CVSS.roundUp1(CVSS.roundUp1(Math.min(CVSS.scopeCoefficient * (envModifiedImpactSubScore + envModifiedExploitabalitySubScore), 10)) *
                        metricWeightE * metricWeightRL * metricWeightRC);
  }

  if (envModifiedImpactSubScore <= 0) {
    envScore = 0;
  }


  // CONSTRUCT THE VECTOR STRING

  var vectorString =
    CVSS.CVSSVersionIdentifier +
    "/AV:" + AV +
    "/AC:" + AC +
    "/PR:" + PR +
    "/UI:" + UI +
    "/S:"  + S +
    "/C:"  + C +
    "/I:"  + I +
    "/A:"  + A;

  if (E  !== "X")  {vectorString = vectorString + "/E:" + E;}
  if (RL !== "X")  {vectorString = vectorString + "/RL:" + RL;}
  if (RC !== "X")  {vectorString = vectorString + "/RC:" + RC;}

  if (CR  !== "X") {vectorString = vectorString + "/CR:" + CR;}
  if (IR  !== "X") {vectorString = vectorString + "/IR:"  + IR;}
  if (AR  !== "X") {vectorString = vectorString + "/AR:"  + AR;}
  if (MAV !== "X") {vectorString = vectorString + "/MAV:" + MAV;}
  if (MAC !== "X") {vectorString = vectorString + "/MAC:" + MAC;}
  if (MPR !== "X") {vectorString = vectorString + "/MPR:" + MPR;}
  if (MUI !== "X") {vectorString = vectorString + "/MUI:" + MUI;}
  if (MS  !== "X") {vectorString = vectorString + "/MS:"  + MS;}
  if (MC  !== "X") {vectorString = vectorString + "/MC:"  + MC;}
  if (MI  !== "X") {vectorString = vectorString + "/MI:"  + MI;}
  if (MA  !== "X") {vectorString = vectorString + "/MA:"  + MA;}


  // Return an object containing the scores for all three metric groups, and an overall vector string.

  return {
    success: true,
    baseMetricScore: baseScore.toFixed(1),
    baseSeverity: CVSS.severityRating( baseScore.toFixed(1) ),

    temporalMetricScore: temporalScore.toFixed(1),
    temporalSeverity: CVSS.severityRating( temporalScore.toFixed(1) ),

    environmentalMetricScore: envScore.toFixed(1),
    environmentalSeverity: CVSS.severityRating( envScore.toFixed(1) ),

    vectorString: vectorString
  };
};




/* ** CVSS.calculateCVSSFromVector **
 *
 * Takes Base, Temporal and Environmental metric values as a single string in the Vector String format defined
 * in the CVSS v3.0 standard definition of the Vector String.
 *
 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
 * passed default to "X" ("Not Defined").
 *
 * See the comment for the CVSS.calculateCVSSFromMetrics function for details on the function output. In addition to
 * the error conditions listed for that function, this function can also return:
 *   "MalformedVectorString", if the Vector String passed is does not conform to the format in the standard; or
 *   "MultipleDefinitionsOfMetric", if the Vector String is well formed but defines the same metric (or metrics),
 *                                  more than once.
 */
CVSS.calculateCVSSFromVector = function ( vectorString ) {

  var metricValues = {
    AV:  undefined, AC:  undefined, PR:  undefined, UI:  undefined, S:  undefined,
    C:   undefined, I:   undefined, A:   undefined,
    E:   undefined, RL:  undefined, RC:  undefined,
    CR:  undefined, IR:  undefined, AR:  undefined,
    MAV: undefined, MAC: undefined, MPR: undefined, MUI: undefined, MS: undefined,
    MC:  undefined, MI:  undefined, MA:  undefined
  };

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  if (!CVSS.vectorStringRegex_30.test(vectorString)) {
    return { success: false, errorType: "MalformedVectorString" };
  }

  var metricNameValue = vectorString.substring(CVSS.CVSSVersionIdentifier.length).split("/");

  for (var i in metricNameValue) {
    if (metricNameValue.hasOwnProperty(i)) {

      var singleMetric = metricNameValue[i].split(":");

      if (typeof metricValues[singleMetric[0]] === "undefined") {
        metricValues[singleMetric[0]] = singleMetric[1];
      } else {
        badMetrics.push(singleMetric[0]);
      }
    }
  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MultipleDefinitionsOfMetric", errorMetrics: badMetrics };
  }

  return CVSS.calculateCVSSFromMetrics (
    metricValues.AV,  metricValues.AC,  metricValues.PR,  metricValues.UI,  metricValues.S,
    metricValues.C,   metricValues.I,   metricValues.A,
    metricValues.E,   metricValues.RL,  metricValues.RC,
    metricValues.CR,  metricValues.IR,  metricValues.AR,
    metricValues.MAV, metricValues.MAC, metricValues.MPR, metricValues.MUI, metricValues.MS,
    metricValues.MC,  metricValues.MI,  metricValues.MA);
};




/* ** CVSS.roundUp1 **
 *
 * Rounds up the number passed as a parameter to 1 decimal place and returns the result.
 *
 * Standard JavaScript errors thrown when arithmetic operations are performed on non-numbers will be returned if the
 * given input is not a number.
 */
CVSS.roundUp1 = function (d) {
  return Math.ceil (d * 10) / 10;
};




/* ** CVSS.severityRating **
 *
 * Given a CVSS score, returns the name of the severity rating as defined in the CVSS standard.
 * The input needs to be a number between 0.0 to 10.0, to one decimal place of precision.
 *
 * The following error values may be returned instead of a severity rating name:
 *   NaN (JavaScript "Not a Number") - if the input is not a number.
 *   undefined - if the input is a number that is not within the range of any defined severity rating.
 */
CVSS.severityRating = function (score) {
  var severityRatingLength = CVSS.severityRatings.length;

  var validatedScore = Number(score);

  if (isNaN(validatedScore)) {
    return validatedScore;
  }

  for (var i = 0; i < severityRatingLength; i++) {
    if (score >= CVSS.severityRatings[i].bottom && score <= CVSS.severityRatings[i].top) {
      return CVSS.severityRatings[i].name;
    }
  }

  return undefined;
};



///////////////////////////////////////////////////////////////////////////
// DATA AND FUNCTIONS FOR CREATING AN XML REPRESENTATION OF A CVSS SCORE //
///////////////////////////////////////////////////////////////////////////

// A mapping between abbreviated metric values and the string used in the XML representation.
// For example, a Remediation Level (RL) abbreviated metric value of "W" maps to "WORKAROUND".
// For brevity, Base metric values their modified equivalents in the Environmental metric group. We can do this
// because the latter is the same as the former, except it also includes a "NOT_DEFINED" value.

CVSS.XML_MetricNames = {
  E:    { X: "NOT_DEFINED", U: "UNPROVEN",     P: "PROOF_OF_CONCEPT",  F: "FUNCTIONAL",  H: "HIGH"},
  RL:   { X: "NOT_DEFINED", O: "OFFICIAL_FIX", T: "TEMPORARY_FIX",     W: "WORKAROUND",  U: "UNAVAILABLE"},
  RC:   { X: "NOT_DEFINED", U: "UNKNOWN",      R: "REASONABLE",        C: "CONFIRMED"},

  CIAR: { X: "NOT_DEFINED", L: "LOW",              M: "MEDIUM", H: "HIGH"},         // CR, IR and AR use the same metric names
  MAV:  { N: "NETWORK",     A: "ADJACENT_NETWORK", L: "LOCAL",  P: "PHYSICAL", X: "NOT_DEFINED" },
  MAC:  { H: "HIGH",        L: "LOW",              X: "NOT_DEFINED" },
  MPR:  { N: "NONE",        L: "LOW",              H: "HIGH",   X: "NOT_DEFINED" },
  MUI:  { N: "NONE",        R: "REQUIRED",         X: "NOT_DEFINED" },
  MS:   { U: "UNCHANGED",   C: "CHANGED",          X: "NOT_DEFINED" },
  MCIA: { N: "NONE",        L: "LOW",              H: "HIGH",   X: "NOT_DEFINED" }  // C, I and A use the same metric names
};



/* ** CVSS.generateXMLFromMetrics **
 *
 * Takes Base, Temporal and Environmental metric values as individual parameters. Their values are in the short format
 * defined in the CVSS v3.0 standard definition of the Vector String. For example, the AttackComplexity parameter
 * should be either "H" or "L".
 *
 * Returns a single string containing the metric values in XML form. All Base metrics are required to generate this
 * output. All Temporal and Environmental metric values are optional. Any that are not passed will be represented in
 * the XML as NOT_DEFINED. The function returns a string for simplicity. It is arguably better to return the XML as
 * a DOM object, but at the time of writing this leads to complexity due to older browsers using different JavaScript
 * interfaces to do this. Also for simplicity, all Temporal and Environmental metrics are include in the string,
 * even though those with a value of "Not Defined" do not need to be included.
 *
 * The output of this function is an object which always has a property named "success".
 *
 * If no errors are encountered, success is Boolean "true", and the "xmlString" property contains the XML string
 * representation.
 *
 * If errors are encountered, success is Boolean "false", and other properties are defined as per the
 * CVSS.calculateCVSSFromMetrics function. Refer to the comment for that function for more details.
 */
CVSS.generateXMLFromMetrics = function (
  AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
  ExploitCodeMaturity, RemediationLevel, ReportConfidence,
  ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
  ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
  ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability) {

  // A string containing the XML we wish to output, with placeholders for the CVSS metrics we will substitute for
  // their values, based on the inputs passed to this function.
  var xmlTemplate =
    '<?xml version="1.0" encoding="UTF-8"?>\n' +
    '<cvssv3.0 xmlns="https://www.first.org/cvss/cvss-v3.0.xsd"\n' +
    '  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n' +
    '  xsi:schemaLocation="https://www.first.org/cvss/cvss-v3.0.xsd https://www.first.org/cvss/cvss-v3.0.xsd"\n' +
    '  >\n' +
    '\n' +
    '  <base_metrics>\n' +
    '    <attack-vector>__AttackVector__</attack-vector>\n' +
    '    <attack-complexity>__AttackComplexity__</attack-complexity>\n' +
    '    <privileges-required>__PrivilegesRequired__</privileges-required>\n' +
    '    <user-interaction>__UserInteraction__</user-interaction>\n' +
    '    <scope>__Scope__</scope>\n' +
    '    <confidentiality-impact>__Confidentiality__</confidentiality-impact>\n' +
    '    <integrity-impact>__Integrity__</integrity-impact>\n' +
    '    <availability-impact>__Availability__</availability-impact>\n' +
    '    <base-score>__BaseScore__</base-score>\n' +
    '    <base-severity>__BaseSeverityRating__</base-severity>\n' +
    '  </base_metrics>\n' +
    '\n' +
    '  <temporal_metrics>\n' +
    '    <exploit-code-maturity>__ExploitCodeMaturity__</exploit-code-maturity>\n' +
    '    <remediation-level>__RemediationLevel__</remediation-level>\n' +
    '    <report-confidence>__ReportConfidence__</report-confidence>\n' +
    '    <temporal-score>__TemporalScore__</temporal-score>\n' +
    '    <temporal-severity>__TemporalSeverityRating__</temporal-severity>\n' +
    '  </temporal_metrics>\n' +
    '\n' +
    '  <environmental_metrics>\n' +
    '    <confidentiality-requirement>__ConfidentialityRequirement__</confidentiality-requirement>\n' +
    '    <integrity-requirement>__IntegrityRequirement__</integrity-requirement>\n' +
    '    <availability-requirement>__AvailabilityRequirement__</availability-requirement>\n' +
    '    <modified-attack-vector>__ModifiedAttackVector__</modified-attack-vector>\n' +
    '    <modified-attack-complexity>__ModifiedAttackComplexity__</modified-attack-complexity>\n' +
    '    <modified-privileges-required>__ModifiedPrivilegesRequired__</modified-privileges-required>\n' +
    '    <modified-user-interaction>__ModifiedUserInteraction__</modified-user-interaction>\n' +
    '    <modified-scope>__ModifiedScope__</modified-scope>\n' +
    '    <modified-confidentiality-impact>__ModifiedConfidentiality__</modified-confidentiality-impact>\n' +
    '    <modified-integrity-impact>__ModifiedIntegrity__</modified-integrity-impact>\n' +
    '    <modified-availability-impact>__ModifiedAvailability__</modified-availability-impact>\n' +
    '    <environmental-score>__EnvironmentalScore__</environmental-score>\n' +
    '    <environmental-severity>__EnvironmentalSeverityRating__</environmental-severity>\n' +
    '  </environmental_metrics>\n' +
    '\n' +
    '</cvssv3.0>\n';


  // Call CVSS.calculateCVSSFromMetrics to validate all the parameters and generate scores and severity ratings.
  // If that function returns an error, immediately return it to the caller of this function.
  var result = CVSS.calculateCVSSFromMetrics (
    AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
    ExploitCodeMaturity, RemediationLevel, ReportConfidence,
    ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
    ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
    ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability);

  if (result.success !== true) {
    return result;
  }

  var xmlOutput = xmlTemplate;
  xmlOutput = xmlOutput.replace ("__AttackVector__",        CVSS.XML_MetricNames["MAV"][AttackVector]);
  xmlOutput = xmlOutput.replace ("__AttackComplexity__",    CVSS.XML_MetricNames["MAC"][AttackComplexity]);
  xmlOutput = xmlOutput.replace ("__PrivilegesRequired__",  CVSS.XML_MetricNames["MPR"][PrivilegesRequired]);
  xmlOutput = xmlOutput.replace ("__UserInteraction__",     CVSS.XML_MetricNames["MUI"][UserInteraction]);
  xmlOutput = xmlOutput.replace ("__Scope__",               CVSS.XML_MetricNames["MS"][Scope]);
  xmlOutput = xmlOutput.replace ("__Confidentiality__",     CVSS.XML_MetricNames["MCIA"][Confidentiality]);
  xmlOutput = xmlOutput.replace ("__Integrity__",           CVSS.XML_MetricNames["MCIA"][Integrity]);
  xmlOutput = xmlOutput.replace ("__Availability__",        CVSS.XML_MetricNames["MCIA"][Availability]);
  xmlOutput = xmlOutput.replace ("__BaseScore__",           result.baseMetricScore);
  xmlOutput = xmlOutput.replace ("__BaseSeverityRating__",  result.baseSeverity);

  xmlOutput = xmlOutput.replace ("__ExploitCodeMaturity__",     CVSS.XML_MetricNames["E"][ExploitCodeMaturity || "X"]);
  xmlOutput = xmlOutput.replace ("__RemediationLevel__",        CVSS.XML_MetricNames["RL"][RemediationLevel || "X"]);
  xmlOutput = xmlOutput.replace ("__ReportConfidence__",        CVSS.XML_MetricNames["RC"][ReportConfidence || "X"]);
  xmlOutput = xmlOutput.replace ("__TemporalScore__",           result.temporalMetricScore);
  xmlOutput = xmlOutput.replace ("__TemporalSeverityRating__",  result.temporalSeverity);

  xmlOutput = xmlOutput.replace ("__ConfidentialityRequirement__",  CVSS.XML_MetricNames["CIAR"][ConfidentialityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__IntegrityRequirement__",        CVSS.XML_MetricNames["CIAR"][IntegrityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__AvailabilityRequirement__",     CVSS.XML_MetricNames["CIAR"][AvailabilityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAttackVector__",        CVSS.XML_MetricNames["MAV"][ModifiedAttackVector || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAttackComplexity__",    CVSS.XML_MetricNames["MAC"][ModifiedAttackComplexity || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedPrivilegesRequired__",  CVSS.XML_MetricNames["MPR"][ModifiedPrivilegesRequired || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedUserInteraction__",     CVSS.XML_MetricNames["MUI"][ModifiedUserInteraction || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedScope__",               CVSS.XML_MetricNames["MS"][ModifiedScope || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedConfidentiality__",     CVSS.XML_MetricNames["MCIA"][ModifiedConfidentiality || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedIntegrity__",           CVSS.XML_MetricNames["MCIA"][ModifiedIntegrity || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAvailability__",        CVSS.XML_MetricNames["MCIA"][ModifiedAvailability || "X"]);
  xmlOutput = xmlOutput.replace ("__EnvironmentalScore__",          result.environmentalMetricScore);
  xmlOutput = xmlOutput.replace ("__EnvironmentalSeverityRating__", result.environmentalSeverity);

  return { success: true, xmlString: xmlOutput };
};



/* ** CVSS.generateXMLFromVector **
 *
 * Takes Base, Temporal and Environmental metric values as a single string in the Vector String format defined
 * in the CVSS v3.0 standard definition of the Vector String.
 *
 * Returns an XML string representation of this input. See the comment for CVSS.generateXMLFromMetrics for more
 * detail on inputs, return values and errors. In addition to the error conditions listed for that function, this
 * function can also return:
 *   "MalformedVectorString", if the Vector String passed is does not conform to the format in the standard; or
 *   "MultipleDefinitionsOfMetric", if the Vector String is well formed but defines the same metric (or metrics),
 *                                  more than once.
 */
CVSS.generateXMLFromVector = function ( vectorString ) {

  var metricValues = {
    AV:  undefined, AC:  undefined, PR:  undefined, UI:  undefined, S:  undefined,
    C:   undefined, I:   undefined, A:   undefined,
    E:   undefined, RL:  undefined, RC:  undefined,
    CR:  undefined, IR:  undefined, AR:  undefined,
    MAV: undefined, MAC: undefined, MPR: undefined, MUI: undefined, MS: undefined,
    MC:  undefined, MI:  undefined, MA:  undefined
  };

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  if (!CVSS.vectorStringRegex_30.test(vectorString)) {
    return { success: false, errorType: "MalformedVectorString" };
  }

  var metricNameValue = vectorString.substring(CVSS.CVSSVersionIdentifier.length).split("/");

  for (var i in metricNameValue) {
    if (metricNameValue.hasOwnProperty(i)) {

      var singleMetric = metricNameValue[i].split(":");

      if (typeof metricValues[singleMetric[0]] === "undefined") {
        metricValues[singleMetric[0]] = singleMetric[1];
      } else {
        badMetrics.push(singleMetric[0]);
      }
    }
  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MultipleDefinitionsOfMetric", errorMetrics: badMetrics };
  }

  return CVSS.generateXMLFromMetrics (
    metricValues.AV,  metricValues.AC,  metricValues.PR,  metricValues.UI,  metricValues.S,
    metricValues.C,   metricValues.I,   metricValues.A,
    metricValues.E,   metricValues.RL,  metricValues.RC,
    metricValues.CR,  metricValues.IR,  metricValues.AR,
    metricValues.MAV, metricValues.MAC, metricValues.MPR, metricValues.MUI, metricValues.MS,
    metricValues.MC,  metricValues.MI,  metricValues.MA);
};

// @ts-nocheck

/* Copyright (c) 2019, FIRST.ORG, INC.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote
 *    products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* This JavaScript contains two main functions. Both take CVSS metric values and calculate CVSS scores for Base,
 * Temporal and Environmental metric groups, their associated severity ratings, and an overall Vector String.
 *
 * Use CVSS31.calculateCVSSFromMetrics if you wish to pass metric values as individual parameters.
 * Use CVSS31.calculateCVSSFromVector if you wish to pass metric values as a single Vector String.
 *
 * Changelog
 *
 * 2019-06-01  Darius Wiles   Updates for CVSS version 3.1:
 *
 *                            1) The CVSS31.roundUp1 function now performs rounding using integer arithmetic to
 *                               eliminate problems caused by tiny errors introduced during JavaScript math
 *                               operations. Thanks to Stanislav Kontar of Red Hat for suggesting and testing
 *                               various implementations.
 *
 *                            2) Environmental formulas changed to prevent the Environmental Score decreasing when
 *                               the value of an Environmental metric is raised. The problem affected a small
 *                               percentage of CVSS v3.0 metrics. The change is to the modifiedImpact
 *                               formula, but only affects scores where the Modified Scope is Changed (or the
 *                               Scope is Changed if Modified Scope is Not Defined).
 *
 *                            3) The JavaScript object containing everything in this file has been renamed from
 *                               "CVSS" to "CVSS31" to allow both objects to be included without causing a
 *                               naming conflict.
 *
 *                            4) Variable names and code order have changed to more closely reflect the formulas
 *                               in the CVSS v3.1 Specification Document.
 *
 *                            5) A successful call to calculateCVSSFromMetrics now returns sub-formula values.
 *
 *                            Note that some sets of metrics will produce different scores between CVSS v3.0 and
 *                            v3.1 as a result of changes 1 and 2. See the explanation of changes between these
 *                            two standards in the CVSS v3.1 User Guide for more details.
 *
 * 2018-02-15  Darius Wiles   Added a missing pair of parentheses in the Environmental score, specifically
 *                            in the code setting envScore in the main clause (not the else clause). It was changed
 *                            from "min (...), 10" to "min ((...), 10)". This correction does not alter any final
 *                            Environmental scores.
 *
 * 2015-08-04  Darius Wiles   Added CVSS.generateXMLFromMetrics and CVSS.generateXMLFromVector functions to return
 *                            XML string representations of: a set of metric values; or a Vector String respectively.
 *                            Moved all constants and functions to an object named "CVSS" to
 *                            reduce the chance of conflicts in global variables when this file is combined with
 *                            other JavaScript code. This will break all existing code that uses this file until
 *                            the string "CVSS." is prepended to all references. The "Exploitability" metric has been
 *                            renamed "Exploit Code Maturity" in the specification, so the same change has been made
 *                            in the code in this file.
 *
 * 2015-04-24  Darius Wiles   Environmental formula modified to eliminate undesirable behavior caused by subtle
 *                            differences in rounding between Temporal and Environmental formulas that often
 *                            caused the latter to be 0.1 lower than than the former when all Environmental
 *                            metrics are "Not defined". Also added a RoundUp1 function to simplify formulas.
 *
 * 2015-04-09  Darius Wiles   Added calculateCVSSFromVector function, license information, cleaned up code and improved
 *                            comments.
 *
 * 2014-12-12  Darius Wiles   Initial release for CVSS 3.0 Preview 2.
 */

// Constants used in the formula. They are not declared as "const" to avoid problems in older browsers.

var CVSS31 = {};

CVSS31.CVSSVersionIdentifier = "CVSS:3.1";
CVSS31.exploitabilityCoefficient = 8.22;
CVSS31.scopeCoefficient = 1.08;

// A regular expression to validate that a CVSS 3.1 vector string is well formed. It checks metrics and metric
// values. It does not check that a metric is specified more than once and it does not check that all base
// metrics are present. These checks need to be performed separately.

CVSS31.vectorStringRegex_31 = /^CVSS:3\.1\/((AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])\/)*(AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$/;


// Associative arrays mapping each metric value to the constant defined in the CVSS scoring formula in the CVSS v3.1
// specification.

CVSS31.Weight = {
  AV:   { N: 0.85,  A: 0.62,  L: 0.55,  P: 0.2},
  AC:   { H: 0.44,  L: 0.77},
  PR:   { U:       {N: 0.85,  L: 0.62,  H: 0.27},         // These values are used if Scope is Unchanged
          C:       {N: 0.85,  L: 0.68,  H: 0.5}},         // These values are used if Scope is Changed
  UI:   { N: 0.85,  R: 0.62},
  S:    { U: 6.42,  C: 7.52},                             // Note: not defined as constants in specification
  CIA:  { N: 0,     L: 0.22,  H: 0.56},                   // C, I and A have the same weights

  E:    { X: 1,     U: 0.91,  P: 0.94,  F: 0.97,  H: 1},
  RL:   { X: 1,     O: 0.95,  T: 0.96,  W: 0.97,  U: 1},
  RC:   { X: 1,     U: 0.92,  R: 0.96,  C: 1},

  CIAR: { X: 1,     L: 0.5,   M: 1,     H: 1.5}           // CR, IR and AR have the same weights
};


// Severity rating bands, as defined in the CVSS v3.1 specification.

CVSS31.severityRatings  = [ { name: "None",     bottom: 0.0, top:  0.0},
                            { name: "Low",      bottom: 0.1, top:  3.9},
                            { name: "Medium",   bottom: 4.0, top:  6.9},
                            { name: "High",     bottom: 7.0, top:  8.9},
                            { name: "Critical", bottom: 9.0, top: 10.0} ];




/* ** CVSS31.calculateCVSSFromMetrics **
 *
 * Takes Base, Temporal and Environmental metric values as individual parameters. Their values are in the short format
 * defined in the CVSS v3.1 standard definition of the Vector String. For example, the AttackComplexity parameter
 * should be either "H" or "L".
 *
 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
 * passed default to "X" ("Not Defined").
 *
 * The output is an object which always has a property named "success".
 *
 * If no errors are encountered, success is Boolean "true", and the following other properties are defined containing
 * scores, severities and a vector string:
 *   baseMetricScore, baseSeverity,
 *   temporalMetricScore, temporalSeverity,
 *   environmentalMetricScore, environmentalSeverity,
 *   vectorString
 *
 * The following properties are also defined, and contain sub-formula values:
 *   baseISS, baseImpact, baseExploitability,
 *   environmentalMISS, environmentalModifiedImpact, environmentalModifiedExploitability
 *
 *
 * If errors are encountered, success is Boolean "false", and the following other properties are defined:
 *   errorType - a string indicating the error. Either:
 *                 "MissingBaseMetric", if at least one Base metric has not been defined; or
 *                 "UnknownMetricValue", if at least one metric value is invalid.
 *   errorMetrics - an array of strings representing the metrics at fault. The strings are abbreviated versions of the
 *                  metrics, as defined in the CVSS v3.1 standard definition of the Vector String.
 */
CVSS31.calculateCVSSFromMetrics = function (
  AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
  ExploitCodeMaturity, RemediationLevel, ReportConfidence,
  ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
  ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
  ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability) {

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  // ENSURE ALL BASE METRICS ARE DEFINED
  //
  // We need values for all Base Score metrics to calculate scores.
  // If any Base Score parameters are undefined, create an array of missing metrics and return it with an error.

  if (typeof AttackVector       === "undefined" || AttackVector       === "") { badMetrics.push("AV"); }
  if (typeof AttackComplexity   === "undefined" || AttackComplexity   === "") { badMetrics.push("AC"); }
  if (typeof PrivilegesRequired === "undefined" || PrivilegesRequired === "") { badMetrics.push("PR"); }
  if (typeof UserInteraction    === "undefined" || UserInteraction    === "") { badMetrics.push("UI"); }
  if (typeof Scope              === "undefined" || Scope              === "") { badMetrics.push("S");  }
  if (typeof Confidentiality    === "undefined" || Confidentiality    === "") { badMetrics.push("C");  }
  if (typeof Integrity          === "undefined" || Integrity          === "") { badMetrics.push("I");  }
  if (typeof Availability       === "undefined" || Availability       === "") { badMetrics.push("A");  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MissingBaseMetric", errorMetrics: badMetrics };
  }


  // STORE THE METRIC VALUES THAT WERE PASSED AS PARAMETERS
  //
  // Temporal and Environmental metrics are optional, so set them to "X" ("Not Defined") if no value was passed.

  var AV = AttackVector;
  var AC = AttackComplexity;
  var PR = PrivilegesRequired;
  var UI = UserInteraction;
  var S  = Scope;
  var C  = Confidentiality;
  var I  = Integrity;
  var A  = Availability;

  var E =   ExploitCodeMaturity || "X";
  var RL =  RemediationLevel    || "X";
  var RC =  ReportConfidence    || "X";

  var CR =  ConfidentialityRequirement || "X";
  var IR =  IntegrityRequirement       || "X";
  var AR =  AvailabilityRequirement    || "X";
  var MAV = ModifiedAttackVector       || "X";
  var MAC = ModifiedAttackComplexity   || "X";
  var MPR = ModifiedPrivilegesRequired || "X";
  var MUI = ModifiedUserInteraction    || "X";
  var MS =  ModifiedScope              || "X";
  var MC =  ModifiedConfidentiality    || "X";
  var MI =  ModifiedIntegrity          || "X";
  var MA =  ModifiedAvailability       || "X";


  // CHECK VALIDITY OF METRIC VALUES
  //
  // Use the Weight object to ensure that, for every metric, the metric value passed is valid.
  // If any invalid values are found, create an array of their metrics and return it with an error.
  //
  // The Privileges Required (PR) weight depends on Scope, but when checking the validity of PR we must not assume
  // that the given value for Scope is valid. We therefore always look at the weights for Unchanged Scope when
  // performing this check. The same applies for validation of Modified Privileges Required (MPR).
  //
  // The Weights object does not contain "X" ("Not Defined") values for Environmental metrics because we replace them
  // with their Base metric equivalents later in the function. For example, an MAV of "X" will be replaced with the
  // value given for AV. We therefore need to explicitly allow a value of "X" for Environmental metrics.

  if (!CVSS31.Weight.AV.hasOwnProperty(AV))   { badMetrics.push("AV"); }
  if (!CVSS31.Weight.AC.hasOwnProperty(AC))   { badMetrics.push("AC"); }
  if (!CVSS31.Weight.PR.U.hasOwnProperty(PR)) { badMetrics.push("PR"); }
  if (!CVSS31.Weight.UI.hasOwnProperty(UI))   { badMetrics.push("UI"); }
  if (!CVSS31.Weight.S.hasOwnProperty(S))     { badMetrics.push("S"); }
  if (!CVSS31.Weight.CIA.hasOwnProperty(C))   { badMetrics.push("C"); }
  if (!CVSS31.Weight.CIA.hasOwnProperty(I))   { badMetrics.push("I"); }
  if (!CVSS31.Weight.CIA.hasOwnProperty(A))   { badMetrics.push("A"); }

  if (!CVSS31.Weight.E.hasOwnProperty(E))     { badMetrics.push("E"); }
  if (!CVSS31.Weight.RL.hasOwnProperty(RL))   { badMetrics.push("RL"); }
  if (!CVSS31.Weight.RC.hasOwnProperty(RC))   { badMetrics.push("RC"); }

  if (!(CR  === "X" || CVSS31.Weight.CIAR.hasOwnProperty(CR)))  { badMetrics.push("CR"); }
  if (!(IR  === "X" || CVSS31.Weight.CIAR.hasOwnProperty(IR)))  { badMetrics.push("IR"); }
  if (!(AR  === "X" || CVSS31.Weight.CIAR.hasOwnProperty(AR)))  { badMetrics.push("AR"); }
  if (!(MAV === "X" || CVSS31.Weight.AV.hasOwnProperty(MAV)))   { badMetrics.push("MAV"); }
  if (!(MAC === "X" || CVSS31.Weight.AC.hasOwnProperty(MAC)))   { badMetrics.push("MAC"); }
  if (!(MPR === "X" || CVSS31.Weight.PR.U.hasOwnProperty(MPR))) { badMetrics.push("MPR"); }
  if (!(MUI === "X" || CVSS31.Weight.UI.hasOwnProperty(MUI)))   { badMetrics.push("MUI"); }
  if (!(MS  === "X" || CVSS31.Weight.S.hasOwnProperty(MS)))     { badMetrics.push("MS"); }
  if (!(MC  === "X" || CVSS31.Weight.CIA.hasOwnProperty(MC)))   { badMetrics.push("MC"); }
  if (!(MI  === "X" || CVSS31.Weight.CIA.hasOwnProperty(MI)))   { badMetrics.push("MI"); }
  if (!(MA  === "X" || CVSS31.Weight.CIA.hasOwnProperty(MA)))   { badMetrics.push("MA"); }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "UnknownMetricValue", errorMetrics: badMetrics };
  }



  // GATHER WEIGHTS FOR ALL METRICS

  var metricWeightAV  = CVSS31.Weight.AV    [AV];
  var metricWeightAC  = CVSS31.Weight.AC    [AC];
  var metricWeightPR  = CVSS31.Weight.PR    [S][PR];  // PR depends on the value of Scope (S).
  var metricWeightUI  = CVSS31.Weight.UI    [UI];
  var metricWeightS   = CVSS31.Weight.S     [S];
  var metricWeightC   = CVSS31.Weight.CIA   [C];
  var metricWeightI   = CVSS31.Weight.CIA   [I];
  var metricWeightA   = CVSS31.Weight.CIA   [A];

  var metricWeightE   = CVSS31.Weight.E     [E];
  var metricWeightRL  = CVSS31.Weight.RL    [RL];
  var metricWeightRC  = CVSS31.Weight.RC    [RC];

  // For metrics that are modified versions of Base Score metrics, e.g. Modified Attack Vector, use the value of
  // the Base Score metric if the modified version value is "X" ("Not Defined").
  var metricWeightCR  = CVSS31.Weight.CIAR  [CR];
  var metricWeightIR  = CVSS31.Weight.CIAR  [IR];
  var metricWeightAR  = CVSS31.Weight.CIAR  [AR];
  var metricWeightMAV = CVSS31.Weight.AV    [MAV !== "X" ? MAV : AV];
  var metricWeightMAC = CVSS31.Weight.AC    [MAC !== "X" ? MAC : AC];
  var metricWeightMPR = CVSS31.Weight.PR    [MS  !== "X" ? MS  : S] [MPR !== "X" ? MPR : PR];  // Depends on MS.
  var metricWeightMUI = CVSS31.Weight.UI    [MUI !== "X" ? MUI : UI];
  var metricWeightMS  = CVSS31.Weight.S     [MS  !== "X" ? MS  : S];
  var metricWeightMC  = CVSS31.Weight.CIA   [MC  !== "X" ? MC  : C];
  var metricWeightMI  = CVSS31.Weight.CIA   [MI  !== "X" ? MI  : I];
  var metricWeightMA  = CVSS31.Weight.CIA   [MA  !== "X" ? MA  : A];



  // CALCULATE THE CVSS BASE SCORE

  var iss; /* Impact Sub-Score */
  var impact;
  var exploitability;
  var baseScore;

  iss = (1 - ((1 - metricWeightC) * (1 - metricWeightI) * (1 - metricWeightA)));

  if (S === 'U') {
    impact = metricWeightS * iss;
  } else {
    impact = metricWeightS * (iss - 0.029) - 3.25 * Math.pow(iss - 0.02, 15);
  }

  exploitability = CVSS31.exploitabilityCoefficient * metricWeightAV * metricWeightAC * metricWeightPR * metricWeightUI;

  if (impact <= 0) {
    baseScore = 0;
  } else {
    if (S === 'U') {
      baseScore = CVSS31.roundUp1(Math.min((exploitability + impact), 10));
    } else {
      baseScore = CVSS31.roundUp1(Math.min(CVSS31.scopeCoefficient * (exploitability + impact), 10));
    }
  }


  // CALCULATE THE CVSS TEMPORAL SCORE

  var temporalScore = CVSS31.roundUp1(baseScore * metricWeightE * metricWeightRL * metricWeightRC);


  // CALCULATE THE CVSS ENVIRONMENTAL SCORE
  //
  // - modifiedExploitability recalculates the Base Score Exploitability sub-score using any modified values from the
  //   Environmental metrics group in place of the values specified in the Base Score, if any have been defined.
  // - modifiedImpact recalculates the Base Score Impact sub-score using any modified values from the
  //   Environmental metrics group in place of the values specified in the Base Score, and any additional weightings
  //   given in the Environmental metrics group.

  var miss; /* Modified Impact Sub-Score */
  var modifiedImpact;
  var envScore;
  var modifiedExploitability;

  miss = Math.min (1 -
                    ( (1 - metricWeightMC * metricWeightCR) *
                      (1 - metricWeightMI * metricWeightIR) *
                      (1 - metricWeightMA * metricWeightAR)), 0.915);

  if (MS === "U" ||
     (MS === "X" && S === "U")) {
    modifiedImpact = metricWeightMS * miss;
  } else {
    modifiedImpact = metricWeightMS * (miss - 0.029) - 3.25 * Math.pow(miss * 0.9731 - 0.02, 13);
  }

  modifiedExploitability = CVSS31.exploitabilityCoefficient * metricWeightMAV * metricWeightMAC * metricWeightMPR * metricWeightMUI;

  if (modifiedImpact <= 0) {
    envScore = 0;
  } else if (MS === "U" || (MS === "X" && S === "U")) {
    envScore = CVSS31.roundUp1(CVSS31.roundUp1(Math.min((modifiedImpact + modifiedExploitability), 10)) *
                        metricWeightE * metricWeightRL * metricWeightRC);
  } else {
    envScore = CVSS31.roundUp1(CVSS31.roundUp1(Math.min(CVSS31.scopeCoefficient * (modifiedImpact + modifiedExploitability), 10)) *
                        metricWeightE * metricWeightRL * metricWeightRC);
  }


  // CONSTRUCT THE VECTOR STRING

  var vectorString =
    CVSS31.CVSSVersionIdentifier +
    "/AV:" + AV +
    "/AC:" + AC +
    "/PR:" + PR +
    "/UI:" + UI +
    "/S:"  + S +
    "/C:"  + C +
    "/I:"  + I +
    "/A:"  + A;

  if (E  !== "X")  {vectorString = vectorString + "/E:" + E;}
  if (RL !== "X")  {vectorString = vectorString + "/RL:" + RL;}
  if (RC !== "X")  {vectorString = vectorString + "/RC:" + RC;}

  if (CR  !== "X") {vectorString = vectorString + "/CR:" + CR;}
  if (IR  !== "X") {vectorString = vectorString + "/IR:"  + IR;}
  if (AR  !== "X") {vectorString = vectorString + "/AR:"  + AR;}
  if (MAV !== "X") {vectorString = vectorString + "/MAV:" + MAV;}
  if (MAC !== "X") {vectorString = vectorString + "/MAC:" + MAC;}
  if (MPR !== "X") {vectorString = vectorString + "/MPR:" + MPR;}
  if (MUI !== "X") {vectorString = vectorString + "/MUI:" + MUI;}
  if (MS  !== "X") {vectorString = vectorString + "/MS:"  + MS;}
  if (MC  !== "X") {vectorString = vectorString + "/MC:"  + MC;}
  if (MI  !== "X") {vectorString = vectorString + "/MI:"  + MI;}
  if (MA  !== "X") {vectorString = vectorString + "/MA:"  + MA;}


  // Return an object containing the scores for all three metric groups, and an overall vector string.
  // Sub-formula values are also included.

  return {
    success: true,

    baseMetricScore: baseScore.toFixed(1),
    baseSeverity: CVSS31.severityRating( baseScore.toFixed(1) ),
    baseISS: iss,
    baseImpact: impact,
    baseExploitability: exploitability,

    temporalMetricScore: temporalScore.toFixed(1),
    temporalSeverity: CVSS31.severityRating( temporalScore.toFixed(1) ),

    environmentalMetricScore: envScore.toFixed(1),
    environmentalSeverity: CVSS31.severityRating( envScore.toFixed(1) ),
    environmentalMISS: miss,
    environmentalModifiedImpact: modifiedImpact,
    environmentalModifiedExploitability: modifiedExploitability,

    vectorString: vectorString
  };
};




/* ** CVSS31.calculateCVSSFromVector **
 *
 * Takes Base, Temporal and Environmental metric values as a single string in the Vector String format defined
 * in the CVSS v3.1 standard definition of the Vector String.
 *
 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
 * passed default to "X" ("Not Defined").
 *
 * See the comment for the CVSS31.calculateCVSSFromMetrics function for details on the function output. In addition to
 * the error conditions listed for that function, this function can also return:
 *   "MalformedVectorString", if the Vector String passed does not conform to the format in the standard; or
 *   "MultipleDefinitionsOfMetric", if the Vector String is well formed but defines the same metric (or metrics),
 *                                  more than once.
 */
CVSS31.calculateCVSSFromVector = function ( vectorString ) {

  var metricValues = {
    AV:  undefined, AC:  undefined, PR:  undefined, UI:  undefined, S:  undefined,
    C:   undefined, I:   undefined, A:   undefined,
    E:   undefined, RL:  undefined, RC:  undefined,
    CR:  undefined, IR:  undefined, AR:  undefined,
    MAV: undefined, MAC: undefined, MPR: undefined, MUI: undefined, MS: undefined,
    MC:  undefined, MI:  undefined, MA:  undefined
  };

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  if (!CVSS31.vectorStringRegex_31.test(vectorString)) {
    return { success: false, errorType: "MalformedVectorString" };
  }

  var metricNameValue = vectorString.substring(CVSS31.CVSSVersionIdentifier.length).split("/");

  for (var i in metricNameValue) {
    if (metricNameValue.hasOwnProperty(i)) {

      var singleMetric = metricNameValue[i].split(":");

      if (typeof metricValues[singleMetric[0]] === "undefined") {
        metricValues[singleMetric[0]] = singleMetric[1];
      } else {
        badMetrics.push(singleMetric[0]);
      }
    }
  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MultipleDefinitionsOfMetric", errorMetrics: badMetrics };
  }

  return CVSS31.calculateCVSSFromMetrics (
    metricValues.AV,  metricValues.AC,  metricValues.PR,  metricValues.UI,  metricValues.S,
    metricValues.C,   metricValues.I,   metricValues.A,
    metricValues.E,   metricValues.RL,  metricValues.RC,
    metricValues.CR,  metricValues.IR,  metricValues.AR,
    metricValues.MAV, metricValues.MAC, metricValues.MPR, metricValues.MUI, metricValues.MS,
    metricValues.MC,  metricValues.MI,  metricValues.MA);
};




/* ** CVSS31.roundUp1 **
 *
 * Rounds up its parameter to 1 decimal place and returns the result.
 *
 * Standard JavaScript errors thrown when arithmetic operations are performed on non-numbers will be returned if the
 * given input is not a number.
 *
 * Implementation note: Tiny representation errors in floating point numbers makes rounding complex. For example,
 * consider calculating Math.ceil((1-0.58)*100) by hand. It can be simplified to Math.ceil(0.42*100), then
 * Math.ceil(42), and finally 42. Most JavaScript implementations give 43. The problem is that, on many systems,
 * 1-0.58 = 0.42000000000000004, and the tiny error is enough to push ceil up to the next integer. The implementation
 * below avoids such problems by performing the rounding using integers. The input is first multiplied by 100,000
 * and rounded to the nearest integer to consider 6 decimal places of accuracy, so 0.000001 results in 0.0, but
 * 0.000009 results in 0.1.
 *
 * A more elegant solution may be possible, but the following gives answers consistent with results from an arbitrary
 * precision library.
 */
CVSS31.roundUp1 = function Roundup (input) {
  var int_input = Math.round(input * 100000);

  if (int_input % 10000 === 0) {
    return int_input / 100000;
  } else {
    return (Math.floor(int_input / 10000) + 1) / 10;
  }
};



/* ** CVSS31.severityRating **
 *
 * Given a CVSS score, returns the name of the severity rating as defined in the CVSS standard.
 * The input needs to be a number between 0.0 to 10.0, to one decimal place of precision.
 *
 * The following error values may be returned instead of a severity rating name:
 *   NaN (JavaScript "Not a Number") - if the input is not a number.
 *   undefined - if the input is a number that is not within the range of any defined severity rating.
 */
CVSS31.severityRating = function (score) {
  var severityRatingLength = CVSS31.severityRatings.length;

  var validatedScore = Number(score);

  if (isNaN(validatedScore)) {
    return validatedScore;
  }

  for (var i = 0; i < severityRatingLength; i++) {
    if (score >= CVSS31.severityRatings[i].bottom && score <= CVSS31.severityRatings[i].top) {
      return CVSS31.severityRatings[i].name;
    }
  }

  return undefined;
};



///////////////////////////////////////////////////////////////////////////
// DATA AND FUNCTIONS FOR CREATING AN XML REPRESENTATION OF A CVSS SCORE //
///////////////////////////////////////////////////////////////////////////

// A mapping between abbreviated metric values and the string used in the XML representation.
// For example, a Remediation Level (RL) abbreviated metric value of "W" maps to "WORKAROUND".
// For brevity, every Base metric shares its definition with its equivalent Environmental metric. This is possible
// because the metric values are same between these groups, except that the latter have an additional metric value
// of "NOT_DEFINED".

CVSS31.XML_MetricNames = {
  E:    { X: "NOT_DEFINED", U: "UNPROVEN",     P: "PROOF_OF_CONCEPT",  F: "FUNCTIONAL",  H: "HIGH"},
  RL:   { X: "NOT_DEFINED", O: "OFFICIAL_FIX", T: "TEMPORARY_FIX",     W: "WORKAROUND",  U: "UNAVAILABLE"},
  RC:   { X: "NOT_DEFINED", U: "UNKNOWN",      R: "REASONABLE",        C: "CONFIRMED"},

  CIAR: { X: "NOT_DEFINED", L: "LOW",              M: "MEDIUM", H: "HIGH"},         // CR, IR and AR use the same values
  MAV:  { N: "NETWORK",     A: "ADJACENT_NETWORK", L: "LOCAL",  P: "PHYSICAL", X: "NOT_DEFINED" },
  MAC:  { H: "HIGH",        L: "LOW",              X: "NOT_DEFINED" },
  MPR:  { N: "NONE",        L: "LOW",              H: "HIGH",   X: "NOT_DEFINED" },
  MUI:  { N: "NONE",        R: "REQUIRED",         X: "NOT_DEFINED" },
  MS:   { U: "UNCHANGED",   C: "CHANGED",          X: "NOT_DEFINED" },
  MCIA: { N: "NONE",        L: "LOW",              H: "HIGH",   X: "NOT_DEFINED" }  // C, I and A use the same values
};



/* ** CVSS31.generateXMLFromMetrics **
 *
 * Takes Base, Temporal and Environmental metric values as individual parameters. Their values are in the short format
 * defined in the CVSS v3.1 standard definition of the Vector String. For example, the AttackComplexity parameter
 * should be either "H" or "L".
 *
 * Returns a single string containing the metric values in XML form. All Base metrics are required to generate this
 * output. All Temporal and Environmental metric values are optional. Any that are not passed will be represented in
 * the XML as NOT_DEFINED. The function returns a string for simplicity. It is arguably better to return the XML as
 * a DOM object, but at the time of writing this leads to complexity due to older browsers using different JavaScript
 * interfaces to do this. Also for simplicity, all Temporal and Environmental metrics are included in the string,
 * even though those with a value of "Not Defined" do not need to be included.
 *
 * The output of this function is an object which always has a property named "success".
 *
 * If no errors are encountered, success is Boolean "true", and the "xmlString" property contains the XML string
 * representation.
 *
 * If errors are encountered, success is Boolean "false", and other properties are defined as per the
 * CVSS31.calculateCVSSFromMetrics function. Refer to the comment for that function for more details.
 */
CVSS31.generateXMLFromMetrics = function (
  AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
  ExploitCodeMaturity, RemediationLevel, ReportConfidence,
  ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
  ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
  ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability) {

  // A string containing the XML we wish to output, with placeholders for the CVSS metrics we will substitute for
  // their values, based on the inputs passed to this function.
  var xmlTemplate =
    '<?xml version="1.0" encoding="UTF-8"?>\n' +
    '<cvssv3.1 xmlns="https://www.first.org/cvss/cvss-v3.1.xsd"\n' +
    '  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n' +
    '  xsi:schemaLocation="https://www.first.org/cvss/cvss-v3.1.xsd https://www.first.org/cvss/cvss-v3.1.xsd"\n' +
    '  >\n' +
    '\n' +
    '  <base_metrics>\n' +
    '    <attack-vector>__AttackVector__</attack-vector>\n' +
    '    <attack-complexity>__AttackComplexity__</attack-complexity>\n' +
    '    <privileges-required>__PrivilegesRequired__</privileges-required>\n' +
    '    <user-interaction>__UserInteraction__</user-interaction>\n' +
    '    <scope>__Scope__</scope>\n' +
    '    <confidentiality-impact>__Confidentiality__</confidentiality-impact>\n' +
    '    <integrity-impact>__Integrity__</integrity-impact>\n' +
    '    <availability-impact>__Availability__</availability-impact>\n' +
    '    <base-score>__BaseScore__</base-score>\n' +
    '    <base-severity>__BaseSeverityRating__</base-severity>\n' +
    '  </base_metrics>\n' +
    '\n' +
    '  <temporal_metrics>\n' +
    '    <exploit-code-maturity>__ExploitCodeMaturity__</exploit-code-maturity>\n' +
    '    <remediation-level>__RemediationLevel__</remediation-level>\n' +
    '    <report-confidence>__ReportConfidence__</report-confidence>\n' +
    '    <temporal-score>__TemporalScore__</temporal-score>\n' +
    '    <temporal-severity>__TemporalSeverityRating__</temporal-severity>\n' +
    '  </temporal_metrics>\n' +
    '\n' +
    '  <environmental_metrics>\n' +
    '    <confidentiality-requirement>__ConfidentialityRequirement__</confidentiality-requirement>\n' +
    '    <integrity-requirement>__IntegrityRequirement__</integrity-requirement>\n' +
    '    <availability-requirement>__AvailabilityRequirement__</availability-requirement>\n' +
    '    <modified-attack-vector>__ModifiedAttackVector__</modified-attack-vector>\n' +
    '    <modified-attack-complexity>__ModifiedAttackComplexity__</modified-attack-complexity>\n' +
    '    <modified-privileges-required>__ModifiedPrivilegesRequired__</modified-privileges-required>\n' +
    '    <modified-user-interaction>__ModifiedUserInteraction__</modified-user-interaction>\n' +
    '    <modified-scope>__ModifiedScope__</modified-scope>\n' +
    '    <modified-confidentiality-impact>__ModifiedConfidentiality__</modified-confidentiality-impact>\n' +
    '    <modified-integrity-impact>__ModifiedIntegrity__</modified-integrity-impact>\n' +
    '    <modified-availability-impact>__ModifiedAvailability__</modified-availability-impact>\n' +
    '    <environmental-score>__EnvironmentalScore__</environmental-score>\n' +
    '    <environmental-severity>__EnvironmentalSeverityRating__</environmental-severity>\n' +
    '  </environmental_metrics>\n' +
    '\n' +
    '</cvssv3.1>\n';


  // Call CVSS31.calculateCVSSFromMetrics to validate all the parameters and generate scores and severity ratings.
  // If that function returns an error, immediately return it to the caller of this function.
  var result = CVSS31.calculateCVSSFromMetrics (
    AttackVector, AttackComplexity, PrivilegesRequired, UserInteraction, Scope, Confidentiality, Integrity, Availability,
    ExploitCodeMaturity, RemediationLevel, ReportConfidence,
    ConfidentialityRequirement, IntegrityRequirement, AvailabilityRequirement,
    ModifiedAttackVector, ModifiedAttackComplexity, ModifiedPrivilegesRequired, ModifiedUserInteraction, ModifiedScope,
    ModifiedConfidentiality, ModifiedIntegrity, ModifiedAvailability);

  if (result.success !== true) {
    return result;
  }

  var xmlOutput = xmlTemplate;
  xmlOutput = xmlOutput.replace ("__AttackVector__",        CVSS31.XML_MetricNames["MAV"][AttackVector]);
  xmlOutput = xmlOutput.replace ("__AttackComplexity__",    CVSS31.XML_MetricNames["MAC"][AttackComplexity]);
  xmlOutput = xmlOutput.replace ("__PrivilegesRequired__",  CVSS31.XML_MetricNames["MPR"][PrivilegesRequired]);
  xmlOutput = xmlOutput.replace ("__UserInteraction__",     CVSS31.XML_MetricNames["MUI"][UserInteraction]);
  xmlOutput = xmlOutput.replace ("__Scope__",               CVSS31.XML_MetricNames["MS"][Scope]);
  xmlOutput = xmlOutput.replace ("__Confidentiality__",     CVSS31.XML_MetricNames["MCIA"][Confidentiality]);
  xmlOutput = xmlOutput.replace ("__Integrity__",           CVSS31.XML_MetricNames["MCIA"][Integrity]);
  xmlOutput = xmlOutput.replace ("__Availability__",        CVSS31.XML_MetricNames["MCIA"][Availability]);
  xmlOutput = xmlOutput.replace ("__BaseScore__",           result.baseMetricScore);
  xmlOutput = xmlOutput.replace ("__BaseSeverityRating__",  result.baseSeverity);

  xmlOutput = xmlOutput.replace ("__ExploitCodeMaturity__",     CVSS31.XML_MetricNames["E"][ExploitCodeMaturity || "X"]);
  xmlOutput = xmlOutput.replace ("__RemediationLevel__",        CVSS31.XML_MetricNames["RL"][RemediationLevel || "X"]);
  xmlOutput = xmlOutput.replace ("__ReportConfidence__",        CVSS31.XML_MetricNames["RC"][ReportConfidence || "X"]);
  xmlOutput = xmlOutput.replace ("__TemporalScore__",           result.temporalMetricScore);
  xmlOutput = xmlOutput.replace ("__TemporalSeverityRating__",  result.temporalSeverity);

  xmlOutput = xmlOutput.replace ("__ConfidentialityRequirement__",  CVSS31.XML_MetricNames["CIAR"][ConfidentialityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__IntegrityRequirement__",        CVSS31.XML_MetricNames["CIAR"][IntegrityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__AvailabilityRequirement__",     CVSS31.XML_MetricNames["CIAR"][AvailabilityRequirement || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAttackVector__",        CVSS31.XML_MetricNames["MAV"][ModifiedAttackVector || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAttackComplexity__",    CVSS31.XML_MetricNames["MAC"][ModifiedAttackComplexity || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedPrivilegesRequired__",  CVSS31.XML_MetricNames["MPR"][ModifiedPrivilegesRequired || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedUserInteraction__",     CVSS31.XML_MetricNames["MUI"][ModifiedUserInteraction || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedScope__",               CVSS31.XML_MetricNames["MS"][ModifiedScope || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedConfidentiality__",     CVSS31.XML_MetricNames["MCIA"][ModifiedConfidentiality || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedIntegrity__",           CVSS31.XML_MetricNames["MCIA"][ModifiedIntegrity || "X"]);
  xmlOutput = xmlOutput.replace ("__ModifiedAvailability__",        CVSS31.XML_MetricNames["MCIA"][ModifiedAvailability || "X"]);
  xmlOutput = xmlOutput.replace ("__EnvironmentalScore__",          result.environmentalMetricScore);
  xmlOutput = xmlOutput.replace ("__EnvironmentalSeverityRating__", result.environmentalSeverity);

  return { success: true, xmlString: xmlOutput };
};



/* ** CVSS31.generateXMLFromVector **
 *
 * Takes Base, Temporal and Environmental metric values as a single string in the Vector String format defined
 * in the CVSS v3.1 standard definition of the Vector String.
 *
 * Returns an XML string representation of this input. See the comment for CVSS31.generateXMLFromMetrics for more
 * detail on inputs, return values and errors. In addition to the error conditions listed for that function, this
 * function can also return:
 *   "MalformedVectorString", if the Vector String passed is does not conform to the format in the standard; or
 *   "MultipleDefinitionsOfMetric", if the Vector String is well formed but defines the same metric (or metrics),
 *                                  more than once.
 */
CVSS31.generateXMLFromVector = function ( vectorString ) {

  var metricValues = {
    AV:  undefined, AC:  undefined, PR:  undefined, UI:  undefined, S:  undefined,
    C:   undefined, I:   undefined, A:   undefined,
    E:   undefined, RL:  undefined, RC:  undefined,
    CR:  undefined, IR:  undefined, AR:  undefined,
    MAV: undefined, MAC: undefined, MPR: undefined, MUI: undefined, MS: undefined,
    MC:  undefined, MI:  undefined, MA:  undefined
  };

  // If input validation fails, this array is populated with strings indicating which metrics failed validation.
  var badMetrics = [];

  if (!CVSS31.vectorStringRegex_31.test(vectorString)) {
    return { success: false, errorType: "MalformedVectorString" };
  }

  var metricNameValue = vectorString.substring(CVSS31.CVSSVersionIdentifier.length).split("/");

  for (var i in metricNameValue) {
    if (metricNameValue.hasOwnProperty(i)) {

      var singleMetric = metricNameValue[i].split(":");

      if (typeof metricValues[singleMetric[0]] === "undefined") {
        metricValues[singleMetric[0]] = singleMetric[1];
      } else {
        badMetrics.push(singleMetric[0]);
      }
    }
  }

  if (badMetrics.length > 0) {
    return { success: false, errorType: "MultipleDefinitionsOfMetric", errorMetrics: badMetrics };
  }

  return CVSS31.generateXMLFromMetrics (
    metricValues.AV,  metricValues.AC,  metricValues.PR,  metricValues.UI,  metricValues.S,
    metricValues.C,   metricValues.I,   metricValues.A,
    metricValues.E,   metricValues.RL,  metricValues.RC,
    metricValues.CR,  metricValues.IR,  metricValues.AR,
    metricValues.MAV, metricValues.MAC, metricValues.MPR, metricValues.MUI, metricValues.MS,
    metricValues.MC,  metricValues.MI,  metricValues.MA);
};

const cvss30 = /** @type {import('./first/types').CVSS30} */ (CVSS);
const cvss31 = /** @type {import('./first/types').CVSS31} */ (CVSS31);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_9(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (Array.isArray(doc.vulnerabilities)) {
    /** @type {Array<any>} */
    const vulnerabilities = doc.vulnerabilities;
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (!Array.isArray(vulnerability.scores)) return
      /** @type {Array<any>} */
      const scores = vulnerability.scores;
      scores.forEach((score, scoreIndex) => {
        if (typeof score.cvss_v2?.vectorString === 'string') {
          /**
           * @typedef {object} CVSSV2
           * @property {string} vectorString
           * @property {unknown} baseScore
           * @property {unknown} temporalScore
           * @property {unknown} environmentalScore
           */

          /** @type {CVSSV2} */
          const cvssV2 = score.cvss_v2;
          const result = safelyParseCVSSV2Vector$1(cvssV2.vectorString);

          if (result.success) {
            for (const { score, expectedScore, name } of [
              {
                score: cvssV2.baseScore,
                expectedScore: result.baseMetricScore,
                name: 'baseScore',
              },
              {
                score: cvssV2.temporalScore,
                expectedScore: result.temporalMetricScore,
                name: 'temporalScore',
              },
              {
                score: cvssV2.environmentalScore,
                expectedScore: result.environmentalMetricScore,
                name: 'environmentalScore',
              },
            ]) {
              if (typeof score === 'number') {
                if (score !== Number(expectedScore)) {
                  isValid = false;
                  errors.push({
                    instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v2/${name}`,
                    message: 'invalid calculated value',
                  });
                }
              }
            }
          }
        }

        if (
          typeof score.cvss_v3?.vectorString === 'string' &&
          (score.cvss_v3.version === '3.1' || score.cvss_v3.version === '3.0')
        ) {
          /**
           * @typedef {object} CVSSV3
           * @property {string} vectorString
           * @property {'3.1' | '3.0'} version
           * @property {unknown} baseScore
           * @property {unknown} baseSeverity
           * @property {unknown} temporalScore
           * @property {unknown} temporalSeverity
           * @property {unknown} environmentalScore
           * @property {unknown} environmentalSeverity
           */

          /** @type {CVSSV3} */
          const cvssV3 = score.cvss_v3;

          const calculator = cvssV3.version === '3.0' ? cvss30 : cvss31;
          const result = calculator.calculateCVSSFromVector(cvssV3.vectorString);

          if (result.success) {
            for (const { score, expectedScore, name } of [
              {
                score: cvssV3.baseScore,
                expectedScore: result.baseMetricScore,
                name: 'baseScore',
              },
              {
                score: cvssV3.temporalScore,
                expectedScore: result.temporalMetricScore,
                name: 'temporalScore',
              },
              {
                score: cvssV3.environmentalScore,
                expectedScore: result.environmentalMetricScore,
                name: 'environmentalScore',
              },
            ]) {
              if (typeof score === 'number') {
                if (score !== Number(expectedScore)) {
                  isValid = false;
                  errors.push({
                    instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v3/${name}`,
                    message: 'invalid calculated value',
                  });
                }
              }
            }

            for (const { severity, expectedSeverity, name } of [
              {
                severity: cvssV3.baseSeverity,
                expectedSeverity: result.baseSeverity,
                name: 'baseSeverity',
              },
              {
                severity: cvssV3.temporalSeverity,
                expectedSeverity: result.temporalSeverity,
                name: 'temporalSeverity',
              },
              {
                severity: cvssV3.environmentalSeverity,
                expectedSeverity: result.environmentalSeverity,
                name: 'environmentalSeverity',
              },
            ]) {
              if (typeof severity === 'string') {
                if (severity !== expectedSeverity.toUpperCase()) {
                  isValid = false;
                  errors.push({
                    instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v3/${name}`,
                    message: 'invalid calculated value',
                  });
                }
              }
            }
          }
        }
      });
    });
  }

  return { errors, isValid }
}

/**
 * @param {string} vectorString
 * @returns
 */
function safelyParseCVSSV2Vector$1(vectorString) {
  try {
    return {
      success: true,
      baseMetricScore: cvss2js$1.getBaseScore(vectorString),
      temporalMetricScore: cvss2js$1.getTemporalScore(vectorString),
      environmentalMetricScore:
        getEnvironmentalScoreFromVectorString(vectorString),
    }
  } catch (e) {
    return {
      success: false,
      baseMetricScore: -1,
      temporalMetricScore: -1,
      environmentalMetricScore: -1,
    }
  }
}

const mapping = /** @type {const} */ ([
  // BASE SCORE
  [
    'attackVector',
    'AV',
    {
      NETWORK: 'N',
      ADJACENT_NETWORK: 'A',
      LOCAL: 'L',
      PHYSICAL: 'P',
    },
  ],
  [
    'attackComplexity',
    'AC',
    {
      HIGH: 'H',
      LOW: 'L',
    },
  ],
  [
    'privilegesRequired',
    'PR',
    {
      NONE: 'N',
      LOW: 'L',
      HIGH: 'H',
    },
  ],
  [
    'userInteraction',
    'UI',
    {
      NONE: 'N',
      REQUIRED: 'R',
    },
  ],
  [
    'scope',
    'S',
    {
      UNCHANGED: 'U',
      CHANGED: 'C',
    },
  ],
  [
    'confidentialityImpact',
    'C',
    {
      NONE: 'N',
      LOW: 'L',
      HIGH: 'H',
    },
  ],
  [
    'integrityImpact',
    'I',
    {
      NONE: 'N',
      LOW: 'L',
      HIGH: 'H',
    },
  ],
  [
    'availabilityImpact',
    'A',
    {
      NONE: 'N',
      LOW: 'L',
      HIGH: 'H',
    },
  ],

  // TEMPORAL SCORE
  [
    'exploitCodeMaturity',
    'E',
    {
      UNPROVEN: 'U',
      PROOF_OF_CONCEPT: 'P',
      FUNCTIONAL: 'F',
      HIGH: 'H',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'remediationLevel',
    'RL',
    {
      OFFICIAL_FIX: 'O',
      TEMPORARY_FIX: 'T',
      WORKAROUND: 'W',
      UNAVAILABLE: 'U',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'reportConfidence',
    'RC',
    {
      UNKNOWN: 'U',
      REASONABLE: 'R',
      CONFIRMED: 'C',
      NOT_DEFINED: 'X',
    },
  ],

  // ENVIRONMENTAL SCORE
  [
    'confidentialityRequirement',
    'CR',
    {
      LOW: 'L',
      MEDIUM: 'M',
      HIGH: 'H',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'integrityRequirement',
    'IR',
    {
      LOW: 'L',
      MEDIUM: 'M',
      HIGH: 'H',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'availabilityRequirement',
    'AR',
    {
      LOW: 'L',
      MEDIUM: 'M',
      HIGH: 'H',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedAttackVector',
    'MAV',
    {
      NETWORK: 'N',
      ADJACENT_NETWORK: 'A',
      LOCAL: 'L',
      PHYSICAL: 'P',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedAttackComplexity',
    'MAC',
    {
      HIGH: 'H',
      LOW: 'L',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedPrivilegesRequired',
    'MPR',
    {
      HIGH: 'H',
      LOW: 'L',
      NONE: 'N',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedUserInteraction',
    'MUI',
    {
      NONE: 'N',
      REQUIRED: 'R',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedScope',
    'MS',
    {
      UNCHANGED: 'U',
      CHANGED: 'C',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedConfidentialityImpact',
    'MC',
    {
      HIGH: 'H',
      LOW: 'L',
      NONE: 'N',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedIntegrityImpact',
    'MI',
    {
      HIGH: 'H',
      LOW: 'L',
      NONE: 'N',
      NOT_DEFINED: 'X',
    },
  ],
  [
    'modifiedAvailabilityImpact',
    'MA',
    {
      HIGH: 'H',
      LOW: 'L',
      NONE: 'N',
      NOT_DEFINED: 'X',
    },
  ],
]);

const cvssV3VectorStringMapping = mapping;

/** @type {ReadonlyArray<readonly [string, string, Record<string, string>]>} */
const cvssV2VectorStringMapping =
  /** @type {ReadonlyArray<readonly [string, string, Record<string, string>]>} */ (
    mapping$1.map((mapping) => [
      mapping[0],
      mapping[1],
      Object.fromEntries(
        Object.entries(mapping[2]).map(([key, value]) => [key, value.id])
      ),
    ])
  );

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_10(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (Array.isArray(doc.vulnerabilities)) {
    /** @type {Array<any>} */
    const vulnerabilities = doc.vulnerabilities;
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (!Array.isArray(vulnerability.scores)) return
      /** @type {Array<any>} */
      const scores = vulnerability.scores;
      scores.forEach((score, scoreIndex) => {
        if (typeof score.cvss_v2?.vectorString === 'string') {
          /** @type {Record<string, unknown>} */
          const cvssV2 = score.cvss_v2;
          const vectorString = /** @type {string} */ (cvssV2.vectorString);

          validateCVSSAttributes({
            vectorValues: vectorString.split('/'),
            vectorMapping: cvssV2VectorStringMapping,
            cvss: cvssV2,
            onError({ attributeKey }) {
              isValid = false;
              errors.push({
                instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v2/${attributeKey}`,
                message: 'value is not consistent with the vector string',
              });
            },
          });
        }

        if (
          typeof score.cvss_v3?.vectorString === 'string' &&
          (score.cvss_v3.version === '3.1' || score.cvss_v3.version === '3.0')
        ) {
          /** @type {Record<string, unknown>} */
          const cvssV3 = score.cvss_v3;
          const vectorString = /** @type {string} */ (cvssV3.vectorString);

          validateCVSSAttributes({
            vectorValues: vectorString.split('/').slice(1),
            vectorMapping: cvssV3VectorStringMapping,
            cvss: cvssV3,
            onError({ attributeKey }) {
              isValid = false;
              errors.push({
                instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v3/${attributeKey}`,
                message: 'value is not consistent with the vector string',
              });
            },
          });
        }
      });
    });
  }

  return { errors, isValid }
}

/**
 * @param {object} params
 * @param {string[]} params.vectorValues
 * @param {ReadonlyArray<readonly [string, string, { [key: string]: string }]>} params.vectorMapping
 * @param {Record<string, unknown>} params.cvss
 * @param {(params: { attributeKey: string }) => void} params.onError
 */
function validateCVSSAttributes({
  vectorValues,
  vectorMapping,
  cvss,
  onError,
}) {
  vectorValues.forEach((str) => {
    const [key, value] = str.split(':');
    const entry = vectorMapping.find((e) => e[1] === key);
    if (!entry) return
    const [attributeKey] = entry;

    const attributeValue = cvss[attributeKey];
    if (typeof attributeValue !== 'string') return

    const expectedAttributeValue = Object.entries(entry[2]).find(
      (e) => e[1] === value
    )?.[0];
    if (typeof expectedAttributeValue !== 'string') return

    if (attributeValue !== expectedAttributeValue) {
      onError({ attributeKey });
    }
  });
}

var cwec = /** @type {const} */ ({
  weaknesses: [
    { id: 'CWE-1004', name: "Sensitive Cookie Without 'HttpOnly' Flag" },
    {
      id: 'CWE-1007',
      name: 'Insufficient Visual Distinction of Homoglyphs Presented to User',
    },
    { id: 'CWE-102', name: 'Struts: Duplicate Validation Forms' },
    {
      id: 'CWE-1021',
      name: 'Improper Restriction of Rendered UI Layers or Frames',
    },
    {
      id: 'CWE-1022',
      name: 'Use of Web Link to Untrusted Target with window.opener Access',
    },
    { id: 'CWE-1023', name: 'Incomplete Comparison with Missing Factors' },
    { id: 'CWE-1024', name: 'Comparison of Incompatible Types' },
    { id: 'CWE-1025', name: 'Comparison Using Wrong Factors' },
    { id: 'CWE-103', name: 'Struts: Incomplete validate() Method Definition' },
    {
      id: 'CWE-1037',
      name: 'Processor Optimization Removal or Modification of Security-critical Code',
    },
    { id: 'CWE-1038', name: 'Insecure Automated Optimizations' },
    {
      id: 'CWE-1039',
      name: 'Automated Recognition Mechanism with Inadequate Detection or Handling of Adversarial Input Perturbations',
    },
    {
      id: 'CWE-104',
      name: 'Struts: Form Bean Does Not Extend Validation Class',
    },
    { id: 'CWE-1041', name: 'Use of Redundant Code' },
    {
      id: 'CWE-1042',
      name: 'Static Member Data Element outside of a Singleton Class Element',
    },
    {
      id: 'CWE-1043',
      name: 'Data Element Aggregating an Excessively Large Number of Non-Primitive Elements',
    },
    {
      id: 'CWE-1044',
      name: 'Architecture with Number of Horizontal Layers Outside of Expected Range',
    },
    {
      id: 'CWE-1045',
      name: 'Parent Class with a Virtual Destructor and a Child Class without a Virtual Destructor',
    },
    {
      id: 'CWE-1046',
      name: 'Creation of Immutable Text Using String Concatenation',
    },
    { id: 'CWE-1047', name: 'Modules with Circular Dependencies' },
    {
      id: 'CWE-1048',
      name: 'Invokable Control Element with Large Number of Outward Calls',
    },
    {
      id: 'CWE-1049',
      name: 'Excessive Data Query Operations in a Large Data Table',
    },
    { id: 'CWE-105', name: 'Struts: Form Field Without Validator' },
    {
      id: 'CWE-1050',
      name: 'Excessive Platform Resource Consumption within a Loop',
    },
    {
      id: 'CWE-1051',
      name: 'Initialization with Hard-Coded Network Resource Configuration Data',
    },
    {
      id: 'CWE-1052',
      name: 'Excessive Use of Hard-Coded Literals in Initialization',
    },
    { id: 'CWE-1053', name: 'Missing Documentation for Design' },
    {
      id: 'CWE-1054',
      name: 'Invocation of a Control Element at an Unnecessarily Deep Horizontal Layer',
    },
    { id: 'CWE-1055', name: 'Multiple Inheritance from Concrete Classes' },
    {
      id: 'CWE-1056',
      name: 'Invokable Control Element with Variadic Parameters',
    },
    {
      id: 'CWE-1057',
      name: 'Data Access Operations Outside of Expected Data Manager Component',
    },
    {
      id: 'CWE-1058',
      name: 'Invokable Control Element in Multi-Thread Context with non-Final Static Storable or Member Element',
    },
    { id: 'CWE-1059', name: 'Insufficient Technical Documentation' },
    { id: 'CWE-106', name: 'Struts: Plug-in Framework not in Use' },
    {
      id: 'CWE-1060',
      name: 'Excessive Number of Inefficient Server-Side Data Accesses',
    },
    { id: 'CWE-1061', name: 'Insufficient Encapsulation' },
    { id: 'CWE-1062', name: 'Parent Class with References to Child Class' },
    {
      id: 'CWE-1063',
      name: 'Creation of Class Instance within a Static Code Block',
    },
    {
      id: 'CWE-1064',
      name: 'Invokable Control Element with Signature Containing an Excessive Number of Parameters',
    },
    {
      id: 'CWE-1065',
      name: 'Runtime Resource Management Control Element in a Component Built to Run on Application Servers',
    },
    { id: 'CWE-1066', name: 'Missing Serialization Control Element' },
    {
      id: 'CWE-1067',
      name: 'Excessive Execution of Sequential Searches of Data Resource',
    },
    {
      id: 'CWE-1068',
      name: 'Inconsistency Between Implementation and Documented Design',
    },
    { id: 'CWE-1069', name: 'Empty Exception Block' },
    { id: 'CWE-107', name: 'Struts: Unused Validation Form' },
    {
      id: 'CWE-1070',
      name: 'Serializable Data Element Containing non-Serializable Item Elements',
    },
    { id: 'CWE-1071', name: 'Empty Code Block' },
    {
      id: 'CWE-1072',
      name: 'Data Resource Access without Use of Connection Pooling',
    },
    {
      id: 'CWE-1073',
      name: 'Non-SQL Invokable Control Element with Excessive Number of Data Resource Accesses',
    },
    { id: 'CWE-1074', name: 'Class with Excessively Deep Inheritance' },
    {
      id: 'CWE-1075',
      name: 'Unconditional Control Flow Transfer outside of Switch Block',
    },
    { id: 'CWE-1076', name: 'Insufficient Adherence to Expected Conventions' },
    {
      id: 'CWE-1077',
      name: 'Floating Point Comparison with Incorrect Operator',
    },
    { id: 'CWE-1078', name: 'Inappropriate Source Code Style or Formatting' },
    { id: 'CWE-1079', name: 'Parent Class without Virtual Destructor Method' },
    { id: 'CWE-108', name: 'Struts: Unvalidated Action Form' },
    {
      id: 'CWE-1080',
      name: 'Source Code File with Excessive Number of Lines of Code',
    },
    { id: 'CWE-1082', name: 'Class Instance Self Destruction Control Element' },
    {
      id: 'CWE-1083',
      name: 'Data Access from Outside Expected Data Manager Component',
    },
    {
      id: 'CWE-1084',
      name: 'Invokable Control Element with Excessive File or Data Access Operations',
    },
    {
      id: 'CWE-1085',
      name: 'Invokable Control Element with Excessive Volume of Commented-out Code',
    },
    { id: 'CWE-1086', name: 'Class with Excessive Number of Child Classes' },
    {
      id: 'CWE-1087',
      name: 'Class with Virtual Method without a Virtual Destructor',
    },
    {
      id: 'CWE-1088',
      name: 'Synchronous Access of Remote Resource without Timeout',
    },
    {
      id: 'CWE-1089',
      name: 'Large Data Table with Excessive Number of Indices',
    },
    { id: 'CWE-109', name: 'Struts: Validator Turned Off' },
    {
      id: 'CWE-1090',
      name: 'Method Containing Access of a Member Element from Another Class',
    },
    {
      id: 'CWE-1091',
      name: 'Use of Object without Invoking Destructor Method',
    },
    {
      id: 'CWE-1092',
      name: 'Use of Same Invokable Control Element in Multiple Architectural Layers',
    },
    { id: 'CWE-1093', name: 'Excessively Complex Data Representation' },
    { id: 'CWE-1094', name: 'Excessive Index Range Scan for a Data Resource' },
    { id: 'CWE-1095', name: 'Loop Condition Value Update within the Loop' },
    {
      id: 'CWE-1096',
      name: 'Singleton Class Instance Creation without Proper Locking or Synchronization',
    },
    {
      id: 'CWE-1097',
      name: 'Persistent Storable Data Element without Associated Comparison Control Element',
    },
    {
      id: 'CWE-1098',
      name: 'Data Element containing Pointer Item without Proper Copy Control Element',
    },
    { id: 'CWE-1099', name: 'Inconsistent Naming Conventions for Identifiers' },
    { id: 'CWE-11', name: 'ASP.NET Misconfiguration: Creating Debug Binary' },
    { id: 'CWE-110', name: 'Struts: Validator Without Form Field' },
    {
      id: 'CWE-1100',
      name: 'Insufficient Isolation of System-Dependent Functions',
    },
    { id: 'CWE-1101', name: 'Reliance on Runtime Component in Generated Code' },
    {
      id: 'CWE-1102',
      name: 'Reliance on Machine-Dependent Data Representation',
    },
    {
      id: 'CWE-1103',
      name: 'Use of Platform-Dependent Third Party Components',
    },
    { id: 'CWE-1104', name: 'Use of Unmaintained Third Party Components' },
    {
      id: 'CWE-1105',
      name: 'Insufficient Encapsulation of Machine-Dependent Functionality',
    },
    { id: 'CWE-1106', name: 'Insufficient Use of Symbolic Constants' },
    {
      id: 'CWE-1107',
      name: 'Insufficient Isolation of Symbolic Constant Definitions',
    },
    { id: 'CWE-1108', name: 'Excessive Reliance on Global Variables' },
    { id: 'CWE-1109', name: 'Use of Same Variable for Multiple Purposes' },
    { id: 'CWE-111', name: 'Direct Use of Unsafe JNI' },
    { id: 'CWE-1110', name: 'Incomplete Design Documentation' },
    { id: 'CWE-1111', name: 'Incomplete I/O Documentation' },
    { id: 'CWE-1112', name: 'Incomplete Documentation of Program Execution' },
    { id: 'CWE-1113', name: 'Inappropriate Comment Style' },
    { id: 'CWE-1114', name: 'Inappropriate Whitespace Style' },
    { id: 'CWE-1115', name: 'Source Code Element without Standard Prologue' },
    { id: 'CWE-1116', name: 'Inaccurate Comments' },
    { id: 'CWE-1117', name: 'Callable with Insufficient Behavioral Summary' },
    {
      id: 'CWE-1118',
      name: 'Insufficient Documentation of Error Handling Techniques',
    },
    { id: 'CWE-1119', name: 'Excessive Use of Unconditional Branching' },
    { id: 'CWE-112', name: 'Missing XML Validation' },
    { id: 'CWE-1120', name: 'Excessive Code Complexity' },
    { id: 'CWE-1121', name: 'Excessive McCabe Cyclomatic Complexity' },
    { id: 'CWE-1122', name: 'Excessive Halstead Complexity' },
    { id: 'CWE-1123', name: 'Excessive Use of Self-Modifying Code' },
    { id: 'CWE-1124', name: 'Excessively Deep Nesting' },
    { id: 'CWE-1125', name: 'Excessive Attack Surface' },
    {
      id: 'CWE-1126',
      name: 'Declaration of Variable with Unnecessarily Wide Scope',
    },
    {
      id: 'CWE-1127',
      name: 'Compilation with Insufficient Warnings or Errors',
    },
    {
      id: 'CWE-113',
      name: "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')",
    },
    { id: 'CWE-114', name: 'Process Control' },
    { id: 'CWE-115', name: 'Misinterpretation of Input' },
    { id: 'CWE-116', name: 'Improper Encoding or Escaping of Output' },
    { id: 'CWE-1164', name: 'Irrelevant Code' },
    { id: 'CWE-117', name: 'Improper Output Neutralization for Logs' },
    { id: 'CWE-1173', name: 'Improper Use of Validation Framework' },
    {
      id: 'CWE-1174',
      name: 'ASP.NET Misconfiguration: Improper Model Validation',
    },
    { id: 'CWE-1176', name: 'Inefficient CPU Computation' },
    { id: 'CWE-1177', name: 'Use of Prohibited Code' },
    {
      id: 'CWE-118',
      name: "Incorrect Access of Indexable Resource ('Range Error')",
    },
    { id: 'CWE-1187', name: 'DEPRECATED: Use of Uninitialized Resource' },
    { id: 'CWE-1188', name: 'Insecure Default Initialization of Resource' },
    {
      id: 'CWE-1189',
      name: 'Improper Isolation of Shared Resources on System-on-a-Chip (SoC)',
    },
    {
      id: 'CWE-119',
      name: 'Improper Restriction of Operations within the Bounds of a Memory Buffer',
    },
    { id: 'CWE-1190', name: 'DMA Device Enabled Too Early in Boot Phase' },
    {
      id: 'CWE-1191',
      name: 'On-Chip Debug and Test Interface With Improper Access Control',
    },
    {
      id: 'CWE-1192',
      name: 'System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers',
    },
    {
      id: 'CWE-1193',
      name: 'Power-On of Untrusted Execution Core Before Enabling Fabric Access Control',
    },
    {
      id: 'CWE-12',
      name: 'ASP.NET Misconfiguration: Missing Custom Error Page',
    },
    {
      id: 'CWE-120',
      name: "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
    },
    { id: 'CWE-1204', name: 'Generation of Weak Initialization Vector (IV)' },
    { id: 'CWE-1209', name: 'Failure to Disable Reserved Bits' },
    { id: 'CWE-121', name: 'Stack-based Buffer Overflow' },
    { id: 'CWE-122', name: 'Heap-based Buffer Overflow' },
    { id: 'CWE-1220', name: 'Insufficient Granularity of Access Control' },
    {
      id: 'CWE-1221',
      name: 'Incorrect Register Defaults or Module Parameters',
    },
    {
      id: 'CWE-1222',
      name: 'Insufficient Granularity of Address Regions Protected by Register Locks',
    },
    { id: 'CWE-1223', name: 'Race Condition for Write-Once Attributes' },
    { id: 'CWE-1224', name: 'Improper Restriction of Write-Once Bit Fields' },
    { id: 'CWE-1229', name: 'Creation of Emergent Resource' },
    { id: 'CWE-123', name: 'Write-what-where Condition' },
    {
      id: 'CWE-1230',
      name: 'Exposure of Sensitive Information Through Metadata',
    },
    { id: 'CWE-1231', name: 'Improper Prevention of Lock Bit Modification' },
    {
      id: 'CWE-1232',
      name: 'Improper Lock Behavior After Power State Transition',
    },
    {
      id: 'CWE-1233',
      name: 'Security-Sensitive Hardware Controls with Missing Lock Bit Protection',
    },
    {
      id: 'CWE-1234',
      name: 'Hardware Internal or Debug Modes Allow Override of Locks',
    },
    {
      id: 'CWE-1235',
      name: 'Incorrect Use of Autoboxing and Unboxing for Performance Critical Operations',
    },
    {
      id: 'CWE-1236',
      name: 'Improper Neutralization of Formula Elements in a CSV File',
    },
    { id: 'CWE-1239', name: 'Improper Zeroization of Hardware Register' },
    { id: 'CWE-124', name: "Buffer Underwrite ('Buffer Underflow')" },
    {
      id: 'CWE-1240',
      name: 'Use of a Cryptographic Primitive with a Risky Implementation',
    },
    {
      id: 'CWE-1241',
      name: 'Use of Predictable Algorithm in Random Number Generator',
    },
    {
      id: 'CWE-1242',
      name: 'Inclusion of Undocumented Features or Chicken Bits',
    },
    {
      id: 'CWE-1243',
      name: 'Sensitive Non-Volatile Information Not Protected During Debug',
    },
    {
      id: 'CWE-1244',
      name: 'Internal Asset Exposed to Unsafe Debug Access Level or State',
    },
    {
      id: 'CWE-1245',
      name: 'Improper Finite State Machines (FSMs) in Hardware Logic',
    },
    {
      id: 'CWE-1246',
      name: 'Improper Write Handling in Limited-write Non-Volatile Memories',
    },
    {
      id: 'CWE-1247',
      name: 'Improper Protection Against Voltage and Clock Glitches',
    },
    {
      id: 'CWE-1248',
      name: 'Semiconductor Defects in Hardware Logic with Security-Sensitive Implications',
    },
    {
      id: 'CWE-1249',
      name: 'Application-Level Admin Tool with Inconsistent View of Underlying Operating System',
    },
    { id: 'CWE-125', name: 'Out-of-bounds Read' },
    {
      id: 'CWE-1250',
      name: 'Improper Preservation of Consistency Between Independent Representations of Shared State',
    },
    { id: 'CWE-1251', name: 'Mirrored Regions with Different Values' },
    {
      id: 'CWE-1252',
      name: 'CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations',
    },
    { id: 'CWE-1253', name: 'Incorrect Selection of Fuse Values' },
    { id: 'CWE-1254', name: 'Incorrect Comparison Logic Granularity' },
    {
      id: 'CWE-1255',
      name: 'Comparison Logic is Vulnerable to Power Side-Channel Attacks',
    },
    {
      id: 'CWE-1256',
      name: 'Improper Restriction of Software Interfaces to Hardware Features',
    },
    {
      id: 'CWE-1257',
      name: 'Improper Access Control Applied to Mirrored or Aliased Memory Regions',
    },
    {
      id: 'CWE-1258',
      name: 'Exposure of Sensitive System Information Due to Uncleared Debug Information',
    },
    {
      id: 'CWE-1259',
      name: 'Improper Restriction of Security Token Assignment',
    },
    { id: 'CWE-126', name: 'Buffer Over-read' },
    {
      id: 'CWE-1260',
      name: 'Improper Handling of Overlap Between Protected Memory Ranges',
    },
    { id: 'CWE-1261', name: 'Improper Handling of Single Event Upsets' },
    { id: 'CWE-1262', name: 'Improper Access Control for Register Interface' },
    { id: 'CWE-1263', name: 'Improper Physical Access Control' },
    {
      id: 'CWE-1264',
      name: 'Hardware Logic with Insecure De-Synchronization between Control and Data Channels',
    },
    {
      id: 'CWE-1265',
      name: 'Unintended Reentrant Invocation of Non-reentrant Code Via Nested Calls',
    },
    {
      id: 'CWE-1266',
      name: 'Improper Scrubbing of Sensitive Data from Decommissioned Device',
    },
    { id: 'CWE-1267', name: 'Policy Uses Obsolete Encoding' },
    {
      id: 'CWE-1268',
      name: 'Policy Privileges are not Assigned Consistently Between Control and Data Agents',
    },
    { id: 'CWE-1269', name: 'Product Released in Non-Release Configuration' },
    { id: 'CWE-127', name: 'Buffer Under-read' },
    { id: 'CWE-1270', name: 'Generation of Incorrect Security Tokens' },
    {
      id: 'CWE-1271',
      name: 'Uninitialized Value on Reset for Registers Holding Security Settings',
    },
    {
      id: 'CWE-1272',
      name: 'Sensitive Information Uncleared Before Debug/Power State Transition',
    },
    { id: 'CWE-1273', name: 'Device Unlock Credential Sharing' },
    {
      id: 'CWE-1274',
      name: 'Improper Access Control for Volatile Memory Containing Boot Code',
    },
    {
      id: 'CWE-1275',
      name: 'Sensitive Cookie with Improper SameSite Attribute',
    },
    {
      id: 'CWE-1276',
      name: 'Hardware Child Block Incorrectly Connected to Parent System',
    },
    { id: 'CWE-1277', name: 'Firmware Not Updateable' },
    {
      id: 'CWE-1278',
      name: 'Missing Protection Against Hardware Reverse Engineering Using Integrated Circuit (IC) Imaging Techniques',
    },
    {
      id: 'CWE-1279',
      name: 'Cryptographic Operations are run Before Supporting Units are Ready',
    },
    { id: 'CWE-128', name: 'Wrap-around Error' },
    {
      id: 'CWE-1280',
      name: 'Access Control Check Implemented After Asset is Accessed',
    },
    {
      id: 'CWE-1281',
      name: 'Sequence of Processor Instructions Leads to Unexpected Behavior',
    },
    {
      id: 'CWE-1282',
      name: 'Assumed-Immutable Data is Stored in Writable Memory',
    },
    {
      id: 'CWE-1283',
      name: 'Mutable Attestation or Measurement Reporting Data',
    },
    {
      id: 'CWE-1284',
      name: 'Improper Validation of Specified Quantity in Input',
    },
    {
      id: 'CWE-1285',
      name: 'Improper Validation of Specified Index, Position, or Offset in Input',
    },
    {
      id: 'CWE-1286',
      name: 'Improper Validation of Syntactic Correctness of Input',
    },
    { id: 'CWE-1287', name: 'Improper Validation of Specified Type of Input' },
    { id: 'CWE-1288', name: 'Improper Validation of Consistency within Input' },
    {
      id: 'CWE-1289',
      name: 'Improper Validation of Unsafe Equivalence in Input',
    },
    { id: 'CWE-129', name: 'Improper Validation of Array Index' },
    { id: 'CWE-1290', name: 'Incorrect Decoding of Security Identifiers ' },
    {
      id: 'CWE-1291',
      name: 'Public Key Re-Use for Signing both Debug and Production Code',
    },
    { id: 'CWE-1292', name: 'Incorrect Conversion of Security Identifiers' },
    {
      id: 'CWE-1293',
      name: 'Missing Source Correlation of Multiple Independent Data',
    },
    { id: 'CWE-1294', name: 'Insecure Security Identifier Mechanism' },
    {
      id: 'CWE-1295',
      name: 'Debug Messages Revealing Unnecessary Information',
    },
    {
      id: 'CWE-1296',
      name: 'Incorrect Chaining or Granularity of Debug Components',
    },
    {
      id: 'CWE-1297',
      name: 'Unprotected Confidential Information on Device is Accessible by OSAT Vendors',
    },
    { id: 'CWE-1298', name: 'Hardware Logic Contains Race Conditions' },
    {
      id: 'CWE-1299',
      name: 'Missing Protection Mechanism for Alternate Hardware Interface',
    },
    {
      id: 'CWE-13',
      name: 'ASP.NET Misconfiguration: Password in Configuration File',
    },
    {
      id: 'CWE-130',
      name: 'Improper Handling of Length Parameter Inconsistency',
    },
    { id: 'CWE-1300', name: 'Improper Protection of Physical Side Channels' },
    {
      id: 'CWE-1301',
      name: 'Insufficient or Incomplete Data Removal within Hardware Component',
    },
    { id: 'CWE-1302', name: 'Missing Security Identifier' },
    {
      id: 'CWE-1303',
      name: 'Non-Transparent Sharing of Microarchitectural Resources',
    },
    {
      id: 'CWE-1304',
      name: 'Improperly Preserved Integrity of Hardware Configuration State During a Power Save/Restore Operation',
    },
    { id: 'CWE-131', name: 'Incorrect Calculation of Buffer Size' },
    { id: 'CWE-1310', name: 'Missing Ability to Patch ROM Code' },
    {
      id: 'CWE-1311',
      name: 'Improper Translation of Security Attributes by Fabric Bridge',
    },
    {
      id: 'CWE-1312',
      name: 'Missing Protection for Mirrored Regions in On-Chip Fabric Firewall',
    },
    {
      id: 'CWE-1313',
      name: 'Hardware Allows Activation of Test or Debug Logic at Runtime',
    },
    {
      id: 'CWE-1314',
      name: 'Missing Write Protection for Parametric Data Values',
    },
    {
      id: 'CWE-1315',
      name: 'Improper Setting of Bus Controlling Capability in Fabric End-point',
    },
    {
      id: 'CWE-1316',
      name: 'Fabric-Address Map Allows Programming of Unwarranted Overlaps of Protected and Unprotected Ranges',
    },
    { id: 'CWE-1317', name: 'Improper Access Control in Fabric Bridge' },
    {
      id: 'CWE-1318',
      name: 'Missing Support for Security Features in On-chip Fabrics or Buses',
    },
    {
      id: 'CWE-1319',
      name: 'Improper Protection against Electromagnetic Fault Injection (EM-FI)',
    },
    { id: 'CWE-132', name: 'DEPRECATED: Miscalculated Null Termination' },
    {
      id: 'CWE-1320',
      name: 'Improper Protection for Outbound Error Messages and Alert Signals',
    },
    {
      id: 'CWE-1321',
      name: "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')",
    },
    {
      id: 'CWE-1322',
      name: 'Use of Blocking Code in Single-threaded, Non-blocking Context',
    },
    { id: 'CWE-1323', name: 'Improper Management of Sensitive Trace Data' },
    {
      id: 'CWE-1324',
      name: 'DEPRECATED: Sensitive Information Accessible by Physical Probing of JTAG Interface',
    },
    {
      id: 'CWE-1325',
      name: 'Improperly Controlled Sequential Memory Allocation',
    },
    { id: 'CWE-1326', name: 'Missing Immutable Root of Trust in Hardware' },
    { id: 'CWE-1327', name: 'Binding to an Unrestricted IP Address' },
    {
      id: 'CWE-1328',
      name: 'Security Version Number Mutable to Older Versions',
    },
    { id: 'CWE-1329', name: 'Reliance on Component That is Not Updateable' },
    { id: 'CWE-1330', name: 'Remanent Data Readable after Memory Erase' },
    {
      id: 'CWE-1331',
      name: 'Improper Isolation of Shared Resources in Network On Chip (NoC)',
    },
    {
      id: 'CWE-1332',
      name: 'Improper Handling of Faults that Lead to Instruction Skips',
    },
    { id: 'CWE-1333', name: 'Inefficient Regular Expression Complexity' },
    {
      id: 'CWE-1334',
      name: 'Unauthorized Error Injection Can Degrade Hardware Redundancy',
    },
    { id: 'CWE-1335', name: 'Incorrect Bitwise Shift of Integer' },
    {
      id: 'CWE-1336',
      name: 'Improper Neutralization of Special Elements Used in a Template Engine',
    },
    {
      id: 'CWE-1338',
      name: 'Improper Protections Against Hardware Overheating',
    },
    {
      id: 'CWE-1339',
      name: 'Insufficient Precision or Accuracy of a Real Number',
    },
    { id: 'CWE-134', name: 'Use of Externally-Controlled Format String' },
    { id: 'CWE-1341', name: 'Multiple Releases of Same Resource or Handle' },
    {
      id: 'CWE-1342',
      name: 'Information Exposure through Microarchitectural State after Transient Execution',
    },
    {
      id: 'CWE-135',
      name: 'Incorrect Calculation of Multi-Byte String Length',
    },
    {
      id: 'CWE-1351',
      name: 'Improper Handling of Hardware Behavior in Exceptionally Cold Environments',
    },
    {
      id: 'CWE-1357',
      name: 'Reliance on Insufficiently Trustworthy Component',
    },
    { id: 'CWE-138', name: 'Improper Neutralization of Special Elements' },
    {
      id: 'CWE-1384',
      name: 'Improper Handling of Physical or Environmental Conditions',
    },
    { id: 'CWE-1385', name: 'Missing Origin Validation in WebSockets' },
    {
      id: 'CWE-1386',
      name: 'Insecure Operation on Windows Junction / Mount Point',
    },
    {
      id: 'CWE-1389',
      name: 'Incorrect Parsing of Numbers with Different Radices',
    },
    { id: 'CWE-1390', name: 'Weak Authentication' },
    { id: 'CWE-1391', name: 'Use of Weak Credentials' },
    { id: 'CWE-1392', name: 'Use of Default Credentials' },
    { id: 'CWE-1393', name: 'Use of Default Password' },
    { id: 'CWE-1394', name: 'Use of Default Cryptographic Key' },
    { id: 'CWE-1395', name: 'Dependency on Vulnerable Third-Party Component' },
    { id: 'CWE-14', name: 'Compiler Removal of Code to Clear Buffers' },
    { id: 'CWE-140', name: 'Improper Neutralization of Delimiters' },
    {
      id: 'CWE-141',
      name: 'Improper Neutralization of Parameter/Argument Delimiters',
    },
    { id: 'CWE-142', name: 'Improper Neutralization of Value Delimiters' },
    { id: 'CWE-143', name: 'Improper Neutralization of Record Delimiters' },
    { id: 'CWE-144', name: 'Improper Neutralization of Line Delimiters' },
    { id: 'CWE-145', name: 'Improper Neutralization of Section Delimiters' },
    {
      id: 'CWE-146',
      name: 'Improper Neutralization of Expression/Command Delimiters',
    },
    { id: 'CWE-147', name: 'Improper Neutralization of Input Terminators' },
    { id: 'CWE-148', name: 'Improper Neutralization of Input Leaders' },
    { id: 'CWE-149', name: 'Improper Neutralization of Quoting Syntax' },
    {
      id: 'CWE-15',
      name: 'External Control of System or Configuration Setting',
    },
    {
      id: 'CWE-150',
      name: 'Improper Neutralization of Escape, Meta, or Control Sequences',
    },
    { id: 'CWE-151', name: 'Improper Neutralization of Comment Delimiters' },
    { id: 'CWE-152', name: 'Improper Neutralization of Macro Symbols' },
    {
      id: 'CWE-153',
      name: 'Improper Neutralization of Substitution Characters',
    },
    {
      id: 'CWE-154',
      name: 'Improper Neutralization of Variable Name Delimiters',
    },
    {
      id: 'CWE-155',
      name: 'Improper Neutralization of Wildcards or Matching Symbols',
    },
    { id: 'CWE-156', name: 'Improper Neutralization of Whitespace' },
    { id: 'CWE-157', name: 'Failure to Sanitize Paired Delimiters' },
    {
      id: 'CWE-158',
      name: 'Improper Neutralization of Null Byte or NUL Character',
    },
    {
      id: 'CWE-159',
      name: 'Improper Handling of Invalid Use of Special Elements',
    },
    {
      id: 'CWE-160',
      name: 'Improper Neutralization of Leading Special Elements',
    },
    {
      id: 'CWE-161',
      name: 'Improper Neutralization of Multiple Leading Special Elements',
    },
    {
      id: 'CWE-162',
      name: 'Improper Neutralization of Trailing Special Elements',
    },
    {
      id: 'CWE-163',
      name: 'Improper Neutralization of Multiple Trailing Special Elements',
    },
    {
      id: 'CWE-164',
      name: 'Improper Neutralization of Internal Special Elements',
    },
    {
      id: 'CWE-165',
      name: 'Improper Neutralization of Multiple Internal Special Elements',
    },
    { id: 'CWE-166', name: 'Improper Handling of Missing Special Element' },
    { id: 'CWE-167', name: 'Improper Handling of Additional Special Element' },
    {
      id: 'CWE-168',
      name: 'Improper Handling of Inconsistent Special Elements',
    },
    { id: 'CWE-170', name: 'Improper Null Termination' },
    { id: 'CWE-172', name: 'Encoding Error' },
    { id: 'CWE-173', name: 'Improper Handling of Alternate Encoding' },
    { id: 'CWE-174', name: 'Double Decoding of the Same Data' },
    { id: 'CWE-175', name: 'Improper Handling of Mixed Encoding' },
    { id: 'CWE-176', name: 'Improper Handling of Unicode Encoding' },
    { id: 'CWE-177', name: 'Improper Handling of URL Encoding (Hex Encoding)' },
    { id: 'CWE-178', name: 'Improper Handling of Case Sensitivity' },
    { id: 'CWE-179', name: 'Incorrect Behavior Order: Early Validation' },
    {
      id: 'CWE-180',
      name: 'Incorrect Behavior Order: Validate Before Canonicalize',
    },
    { id: 'CWE-181', name: 'Incorrect Behavior Order: Validate Before Filter' },
    { id: 'CWE-182', name: 'Collapse of Data into Unsafe Value' },
    { id: 'CWE-183', name: 'Permissive List of Allowed Inputs' },
    { id: 'CWE-184', name: 'Incomplete List of Disallowed Inputs' },
    { id: 'CWE-185', name: 'Incorrect Regular Expression' },
    { id: 'CWE-186', name: 'Overly Restrictive Regular Expression' },
    { id: 'CWE-187', name: 'Partial String Comparison' },
    { id: 'CWE-188', name: 'Reliance on Data/Memory Layout' },
    { id: 'CWE-190', name: 'Integer Overflow or Wraparound' },
    { id: 'CWE-191', name: 'Integer Underflow (Wrap or Wraparound)' },
    { id: 'CWE-192', name: 'Integer Coercion Error' },
    { id: 'CWE-193', name: 'Off-by-one Error' },
    { id: 'CWE-194', name: 'Unexpected Sign Extension' },
    { id: 'CWE-195', name: 'Signed to Unsigned Conversion Error' },
    { id: 'CWE-196', name: 'Unsigned to Signed Conversion Error' },
    { id: 'CWE-197', name: 'Numeric Truncation Error' },
    { id: 'CWE-198', name: 'Use of Incorrect Byte Ordering' },
    { id: 'CWE-20', name: 'Improper Input Validation' },
    {
      id: 'CWE-200',
      name: 'Exposure of Sensitive Information to an Unauthorized Actor',
    },
    {
      id: 'CWE-201',
      name: 'Insertion of Sensitive Information Into Sent Data',
    },
    {
      id: 'CWE-202',
      name: 'Exposure of Sensitive Information Through Data Queries',
    },
    { id: 'CWE-203', name: 'Observable Discrepancy' },
    { id: 'CWE-204', name: 'Observable Response Discrepancy' },
    { id: 'CWE-205', name: 'Observable Behavioral Discrepancy' },
    { id: 'CWE-206', name: 'Observable Internal Behavioral Discrepancy' },
    {
      id: 'CWE-207',
      name: 'Observable Behavioral Discrepancy With Equivalent Products',
    },
    { id: 'CWE-208', name: 'Observable Timing Discrepancy' },
    {
      id: 'CWE-209',
      name: 'Generation of Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-210',
      name: 'Self-generated Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-211',
      name: 'Externally-Generated Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-212',
      name: 'Improper Removal of Sensitive Information Before Storage or Transfer',
    },
    {
      id: 'CWE-213',
      name: 'Exposure of Sensitive Information Due to Incompatible Policies',
    },
    {
      id: 'CWE-214',
      name: 'Invocation of Process Using Visible Sensitive Information',
    },
    {
      id: 'CWE-215',
      name: 'Insertion of Sensitive Information Into Debugging Code',
    },
    {
      id: 'CWE-216',
      name: 'DEPRECATED: Containment Errors (Container Errors)',
    },
    {
      id: 'CWE-217',
      name: 'DEPRECATED: Failure to Protect Stored Data from Modification',
    },
    {
      id: 'CWE-218',
      name: 'DEPRECATED: Failure to provide confidentiality for stored data',
    },
    {
      id: 'CWE-219',
      name: 'Storage of File with Sensitive Data Under Web Root',
    },
    {
      id: 'CWE-22',
      name: "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    },
    {
      id: 'CWE-220',
      name: 'Storage of File With Sensitive Data Under FTP Root',
    },
    { id: 'CWE-221', name: 'Information Loss or Omission' },
    { id: 'CWE-222', name: 'Truncation of Security-relevant Information' },
    { id: 'CWE-223', name: 'Omission of Security-relevant Information' },
    {
      id: 'CWE-224',
      name: 'Obscured Security-relevant Information by Alternate Name',
    },
    {
      id: 'CWE-225',
      name: 'DEPRECATED: General Information Management Problems',
    },
    {
      id: 'CWE-226',
      name: 'Sensitive Information in Resource Not Removed Before Reuse',
    },
    {
      id: 'CWE-228',
      name: 'Improper Handling of Syntactically Invalid Structure',
    },
    { id: 'CWE-229', name: 'Improper Handling of Values' },
    { id: 'CWE-23', name: 'Relative Path Traversal' },
    { id: 'CWE-230', name: 'Improper Handling of Missing Values' },
    { id: 'CWE-231', name: 'Improper Handling of Extra Values' },
    { id: 'CWE-232', name: 'Improper Handling of Undefined Values' },
    { id: 'CWE-233', name: 'Improper Handling of Parameters' },
    { id: 'CWE-234', name: 'Failure to Handle Missing Parameter' },
    { id: 'CWE-235', name: 'Improper Handling of Extra Parameters' },
    { id: 'CWE-236', name: 'Improper Handling of Undefined Parameters' },
    { id: 'CWE-237', name: 'Improper Handling of Structural Elements' },
    {
      id: 'CWE-238',
      name: 'Improper Handling of Incomplete Structural Elements',
    },
    { id: 'CWE-239', name: 'Failure to Handle Incomplete Element' },
    { id: 'CWE-24', name: "Path Traversal: '../filedir'" },
    {
      id: 'CWE-240',
      name: 'Improper Handling of Inconsistent Structural Elements',
    },
    { id: 'CWE-241', name: 'Improper Handling of Unexpected Data Type' },
    { id: 'CWE-242', name: 'Use of Inherently Dangerous Function' },
    {
      id: 'CWE-243',
      name: 'Creation of chroot Jail Without Changing Working Directory',
    },
    {
      id: 'CWE-244',
      name: "Improper Clearing of Heap Memory Before Release ('Heap Inspection')",
    },
    {
      id: 'CWE-245',
      name: 'J2EE Bad Practices: Direct Management of Connections',
    },
    { id: 'CWE-246', name: 'J2EE Bad Practices: Direct Use of Sockets' },
    {
      id: 'CWE-247',
      name: 'DEPRECATED: Reliance on DNS Lookups in a Security Decision',
    },
    { id: 'CWE-248', name: 'Uncaught Exception' },
    { id: 'CWE-249', name: 'DEPRECATED: Often Misused: Path Manipulation' },
    { id: 'CWE-25', name: "Path Traversal: '/../filedir'" },
    { id: 'CWE-250', name: 'Execution with Unnecessary Privileges' },
    { id: 'CWE-252', name: 'Unchecked Return Value' },
    { id: 'CWE-253', name: 'Incorrect Check of Function Return Value' },
    { id: 'CWE-256', name: 'Plaintext Storage of a Password' },
    { id: 'CWE-257', name: 'Storing Passwords in a Recoverable Format' },
    { id: 'CWE-258', name: 'Empty Password in Configuration File' },
    { id: 'CWE-259', name: 'Use of Hard-coded Password' },
    { id: 'CWE-26', name: "Path Traversal: '/dir/../filename'" },
    { id: 'CWE-260', name: 'Password in Configuration File' },
    { id: 'CWE-261', name: 'Weak Encoding for Password' },
    { id: 'CWE-262', name: 'Not Using Password Aging' },
    { id: 'CWE-263', name: 'Password Aging with Long Expiration' },
    { id: 'CWE-266', name: 'Incorrect Privilege Assignment' },
    { id: 'CWE-267', name: 'Privilege Defined With Unsafe Actions' },
    { id: 'CWE-268', name: 'Privilege Chaining' },
    { id: 'CWE-269', name: 'Improper Privilege Management' },
    { id: 'CWE-27', name: "Path Traversal: 'dir/../../filename'" },
    { id: 'CWE-270', name: 'Privilege Context Switching Error' },
    { id: 'CWE-271', name: 'Privilege Dropping / Lowering Errors' },
    { id: 'CWE-272', name: 'Least Privilege Violation' },
    { id: 'CWE-273', name: 'Improper Check for Dropped Privileges' },
    { id: 'CWE-274', name: 'Improper Handling of Insufficient Privileges' },
    { id: 'CWE-276', name: 'Incorrect Default Permissions' },
    { id: 'CWE-277', name: 'Insecure Inherited Permissions' },
    { id: 'CWE-278', name: 'Insecure Preserved Inherited Permissions' },
    { id: 'CWE-279', name: 'Incorrect Execution-Assigned Permissions' },
    { id: 'CWE-28', name: "Path Traversal: '..\\filedir'" },
    {
      id: 'CWE-280',
      name: 'Improper Handling of Insufficient Permissions or Privileges ',
    },
    { id: 'CWE-281', name: 'Improper Preservation of Permissions' },
    { id: 'CWE-282', name: 'Improper Ownership Management' },
    { id: 'CWE-283', name: 'Unverified Ownership' },
    { id: 'CWE-284', name: 'Improper Access Control' },
    { id: 'CWE-285', name: 'Improper Authorization' },
    { id: 'CWE-286', name: 'Incorrect User Management' },
    { id: 'CWE-287', name: 'Improper Authentication' },
    {
      id: 'CWE-288',
      name: 'Authentication Bypass Using an Alternate Path or Channel',
    },
    { id: 'CWE-289', name: 'Authentication Bypass by Alternate Name' },
    { id: 'CWE-29', name: "Path Traversal: '\\..\\filename'" },
    { id: 'CWE-290', name: 'Authentication Bypass by Spoofing' },
    { id: 'CWE-291', name: 'Reliance on IP Address for Authentication' },
    { id: 'CWE-292', name: 'DEPRECATED: Trusting Self-reported DNS Name' },
    { id: 'CWE-293', name: 'Using Referer Field for Authentication' },
    { id: 'CWE-294', name: 'Authentication Bypass by Capture-replay' },
    { id: 'CWE-295', name: 'Improper Certificate Validation' },
    {
      id: 'CWE-296',
      name: "Improper Following of a Certificate's Chain of Trust",
    },
    {
      id: 'CWE-297',
      name: 'Improper Validation of Certificate with Host Mismatch',
    },
    { id: 'CWE-298', name: 'Improper Validation of Certificate Expiration' },
    { id: 'CWE-299', name: 'Improper Check for Certificate Revocation' },
    { id: 'CWE-30', name: "Path Traversal: '\\dir\\..\\filename'" },
    { id: 'CWE-300', name: 'Channel Accessible by Non-Endpoint' },
    { id: 'CWE-301', name: 'Reflection Attack in an Authentication Protocol' },
    { id: 'CWE-302', name: 'Authentication Bypass by Assumed-Immutable Data' },
    {
      id: 'CWE-303',
      name: 'Incorrect Implementation of Authentication Algorithm',
    },
    { id: 'CWE-304', name: 'Missing Critical Step in Authentication' },
    { id: 'CWE-305', name: 'Authentication Bypass by Primary Weakness' },
    { id: 'CWE-306', name: 'Missing Authentication for Critical Function' },
    {
      id: 'CWE-307',
      name: 'Improper Restriction of Excessive Authentication Attempts',
    },
    { id: 'CWE-308', name: 'Use of Single-factor Authentication' },
    {
      id: 'CWE-309',
      name: 'Use of Password System for Primary Authentication',
    },
    { id: 'CWE-31', name: "Path Traversal: 'dir\\..\\..\\filename'" },
    { id: 'CWE-311', name: 'Missing Encryption of Sensitive Data' },
    { id: 'CWE-312', name: 'Cleartext Storage of Sensitive Information' },
    { id: 'CWE-313', name: 'Cleartext Storage in a File or on Disk' },
    { id: 'CWE-314', name: 'Cleartext Storage in the Registry' },
    {
      id: 'CWE-315',
      name: 'Cleartext Storage of Sensitive Information in a Cookie',
    },
    {
      id: 'CWE-316',
      name: 'Cleartext Storage of Sensitive Information in Memory',
    },
    {
      id: 'CWE-317',
      name: 'Cleartext Storage of Sensitive Information in GUI',
    },
    {
      id: 'CWE-318',
      name: 'Cleartext Storage of Sensitive Information in Executable',
    },
    { id: 'CWE-319', name: 'Cleartext Transmission of Sensitive Information' },
    { id: 'CWE-32', name: "Path Traversal: '...' (Triple Dot)" },
    { id: 'CWE-321', name: 'Use of Hard-coded Cryptographic Key' },
    { id: 'CWE-322', name: 'Key Exchange without Entity Authentication' },
    { id: 'CWE-323', name: 'Reusing a Nonce, Key Pair in Encryption' },
    { id: 'CWE-324', name: 'Use of a Key Past its Expiration Date' },
    { id: 'CWE-325', name: 'Missing Cryptographic Step' },
    { id: 'CWE-326', name: 'Inadequate Encryption Strength' },
    { id: 'CWE-327', name: 'Use of a Broken or Risky Cryptographic Algorithm' },
    { id: 'CWE-328', name: 'Use of Weak Hash' },
    { id: 'CWE-329', name: 'Generation of Predictable IV with CBC Mode' },
    { id: 'CWE-33', name: "Path Traversal: '....' (Multiple Dot)" },
    { id: 'CWE-330', name: 'Use of Insufficiently Random Values' },
    { id: 'CWE-331', name: 'Insufficient Entropy' },
    { id: 'CWE-332', name: 'Insufficient Entropy in PRNG' },
    {
      id: 'CWE-333',
      name: 'Improper Handling of Insufficient Entropy in TRNG',
    },
    { id: 'CWE-334', name: 'Small Space of Random Values' },
    {
      id: 'CWE-335',
      name: 'Incorrect Usage of Seeds in Pseudo-Random Number Generator (PRNG)',
    },
    {
      id: 'CWE-336',
      name: 'Same Seed in Pseudo-Random Number Generator (PRNG)',
    },
    {
      id: 'CWE-337',
      name: 'Predictable Seed in Pseudo-Random Number Generator (PRNG)',
    },
    {
      id: 'CWE-338',
      name: 'Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)',
    },
    { id: 'CWE-339', name: 'Small Seed Space in PRNG' },
    { id: 'CWE-34', name: "Path Traversal: '....//'" },
    { id: 'CWE-340', name: 'Generation of Predictable Numbers or Identifiers' },
    { id: 'CWE-341', name: 'Predictable from Observable State' },
    { id: 'CWE-342', name: 'Predictable Exact Value from Previous Values' },
    { id: 'CWE-343', name: 'Predictable Value Range from Previous Values' },
    {
      id: 'CWE-344',
      name: 'Use of Invariant Value in Dynamically Changing Context',
    },
    { id: 'CWE-345', name: 'Insufficient Verification of Data Authenticity' },
    { id: 'CWE-346', name: 'Origin Validation Error' },
    { id: 'CWE-347', name: 'Improper Verification of Cryptographic Signature' },
    { id: 'CWE-348', name: 'Use of Less Trusted Source' },
    {
      id: 'CWE-349',
      name: 'Acceptance of Extraneous Untrusted Data With Trusted Data',
    },
    { id: 'CWE-35', name: "Path Traversal: '.../...//'" },
    {
      id: 'CWE-350',
      name: 'Reliance on Reverse DNS Resolution for a Security-Critical Action',
    },
    { id: 'CWE-351', name: 'Insufficient Type Distinction' },
    { id: 'CWE-352', name: 'Cross-Site Request Forgery (CSRF)' },
    { id: 'CWE-353', name: 'Missing Support for Integrity Check' },
    { id: 'CWE-354', name: 'Improper Validation of Integrity Check Value' },
    { id: 'CWE-356', name: 'Product UI does not Warn User of Unsafe Actions' },
    { id: 'CWE-357', name: 'Insufficient UI Warning of Dangerous Operations' },
    {
      id: 'CWE-358',
      name: 'Improperly Implemented Security Check for Standard',
    },
    {
      id: 'CWE-359',
      name: 'Exposure of Private Personal Information to an Unauthorized Actor',
    },
    { id: 'CWE-36', name: 'Absolute Path Traversal' },
    { id: 'CWE-360', name: 'Trust of System Event Data' },
    {
      id: 'CWE-362',
      name: "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    },
    { id: 'CWE-363', name: 'Race Condition Enabling Link Following' },
    { id: 'CWE-364', name: 'Signal Handler Race Condition' },
    { id: 'CWE-365', name: 'DEPRECATED: Race Condition in Switch' },
    { id: 'CWE-366', name: 'Race Condition within a Thread' },
    {
      id: 'CWE-367',
      name: 'Time-of-check Time-of-use (TOCTOU) Race Condition',
    },
    { id: 'CWE-368', name: 'Context Switching Race Condition' },
    { id: 'CWE-369', name: 'Divide By Zero' },
    { id: 'CWE-37', name: "Path Traversal: '/absolute/pathname/here'" },
    {
      id: 'CWE-370',
      name: 'Missing Check for Certificate Revocation after Initial Check',
    },
    { id: 'CWE-372', name: 'Incomplete Internal State Distinction' },
    { id: 'CWE-373', name: 'DEPRECATED: State Synchronization Error' },
    { id: 'CWE-374', name: 'Passing Mutable Objects to an Untrusted Method' },
    {
      id: 'CWE-375',
      name: 'Returning a Mutable Object to an Untrusted Caller',
    },
    { id: 'CWE-377', name: 'Insecure Temporary File' },
    {
      id: 'CWE-378',
      name: 'Creation of Temporary File With Insecure Permissions',
    },
    {
      id: 'CWE-379',
      name: 'Creation of Temporary File in Directory with Insecure Permissions',
    },
    { id: 'CWE-38', name: "Path Traversal: '\\absolute\\pathname\\here'" },
    { id: 'CWE-382', name: 'J2EE Bad Practices: Use of System.exit()' },
    { id: 'CWE-383', name: 'J2EE Bad Practices: Direct Use of Threads' },
    { id: 'CWE-384', name: 'Session Fixation' },
    { id: 'CWE-385', name: 'Covert Timing Channel' },
    { id: 'CWE-386', name: 'Symbolic Name not Mapping to Correct Object' },
    { id: 'CWE-39', name: "Path Traversal: 'C:dirname'" },
    { id: 'CWE-390', name: 'Detection of Error Condition Without Action' },
    { id: 'CWE-391', name: 'Unchecked Error Condition' },
    { id: 'CWE-392', name: 'Missing Report of Error Condition' },
    { id: 'CWE-393', name: 'Return of Wrong Status Code' },
    { id: 'CWE-394', name: 'Unexpected Status Code or Return Value' },
    {
      id: 'CWE-395',
      name: 'Use of NullPointerException Catch to Detect NULL Pointer Dereference',
    },
    { id: 'CWE-396', name: 'Declaration of Catch for Generic Exception' },
    { id: 'CWE-397', name: 'Declaration of Throws for Generic Exception' },
    {
      id: 'CWE-40',
      name: "Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)",
    },
    { id: 'CWE-400', name: 'Uncontrolled Resource Consumption' },
    {
      id: 'CWE-401',
      name: 'Missing Release of Memory after Effective Lifetime',
    },
    {
      id: 'CWE-402',
      name: "Transmission of Private Resources into a New Sphere ('Resource Leak')",
    },
    {
      id: 'CWE-403',
      name: "Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak')",
    },
    { id: 'CWE-404', name: 'Improper Resource Shutdown or Release' },
    { id: 'CWE-405', name: 'Asymmetric Resource Consumption (Amplification)' },
    {
      id: 'CWE-406',
      name: 'Insufficient Control of Network Message Volume (Network Amplification)',
    },
    { id: 'CWE-407', name: 'Inefficient Algorithmic Complexity' },
    { id: 'CWE-408', name: 'Incorrect Behavior Order: Early Amplification' },
    {
      id: 'CWE-409',
      name: 'Improper Handling of Highly Compressed Data (Data Amplification)',
    },
    { id: 'CWE-41', name: 'Improper Resolution of Path Equivalence' },
    { id: 'CWE-410', name: 'Insufficient Resource Pool' },
    { id: 'CWE-412', name: 'Unrestricted Externally Accessible Lock' },
    { id: 'CWE-413', name: 'Improper Resource Locking' },
    { id: 'CWE-414', name: 'Missing Lock Check' },
    { id: 'CWE-415', name: 'Double Free' },
    { id: 'CWE-416', name: 'Use After Free' },
    { id: 'CWE-419', name: 'Unprotected Primary Channel' },
    { id: 'CWE-42', name: "Path Equivalence: 'filename.' (Trailing Dot)" },
    { id: 'CWE-420', name: 'Unprotected Alternate Channel' },
    {
      id: 'CWE-421',
      name: 'Race Condition During Access to Alternate Channel',
    },
    {
      id: 'CWE-422',
      name: "Unprotected Windows Messaging Channel ('Shatter')",
    },
    { id: 'CWE-423', name: 'DEPRECATED: Proxied Trusted Channel' },
    { id: 'CWE-424', name: 'Improper Protection of Alternate Path' },
    { id: 'CWE-425', name: "Direct Request ('Forced Browsing')" },
    { id: 'CWE-426', name: 'Untrusted Search Path' },
    { id: 'CWE-427', name: 'Uncontrolled Search Path Element' },
    { id: 'CWE-428', name: 'Unquoted Search Path or Element' },
    {
      id: 'CWE-43',
      name: "Path Equivalence: 'filename....' (Multiple Trailing Dot)",
    },
    { id: 'CWE-430', name: 'Deployment of Wrong Handler' },
    { id: 'CWE-431', name: 'Missing Handler' },
    {
      id: 'CWE-432',
      name: 'Dangerous Signal Handler not Disabled During Sensitive Operations',
    },
    { id: 'CWE-433', name: 'Unparsed Raw Web Content Delivery' },
    { id: 'CWE-434', name: 'Unrestricted Upload of File with Dangerous Type' },
    {
      id: 'CWE-435',
      name: 'Improper Interaction Between Multiple Correctly-Behaving Entities',
    },
    { id: 'CWE-436', name: 'Interpretation Conflict' },
    { id: 'CWE-437', name: 'Incomplete Model of Endpoint Features' },
    { id: 'CWE-439', name: 'Behavioral Change in New Version or Environment' },
    { id: 'CWE-44', name: "Path Equivalence: 'file.name' (Internal Dot)" },
    { id: 'CWE-440', name: 'Expected Behavior Violation' },
    {
      id: 'CWE-441',
      name: "Unintended Proxy or Intermediary ('Confused Deputy')",
    },
    { id: 'CWE-443', name: 'DEPRECATED: HTTP response splitting' },
    {
      id: 'CWE-444',
      name: "Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')",
    },
    { id: 'CWE-446', name: 'UI Discrepancy for Security Feature' },
    { id: 'CWE-447', name: 'Unimplemented or Unsupported Feature in UI' },
    { id: 'CWE-448', name: 'Obsolete Feature in UI' },
    { id: 'CWE-449', name: 'The UI Performs the Wrong Action' },
    {
      id: 'CWE-45',
      name: "Path Equivalence: 'file...name' (Multiple Internal Dot)",
    },
    { id: 'CWE-450', name: 'Multiple Interpretations of UI Input' },
    {
      id: 'CWE-451',
      name: 'User Interface (UI) Misrepresentation of Critical Information',
    },
    { id: 'CWE-453', name: 'Insecure Default Variable Initialization' },
    {
      id: 'CWE-454',
      name: 'External Initialization of Trusted Variables or Data Stores',
    },
    { id: 'CWE-455', name: 'Non-exit on Failed Initialization' },
    { id: 'CWE-456', name: 'Missing Initialization of a Variable' },
    { id: 'CWE-457', name: 'Use of Uninitialized Variable' },
    { id: 'CWE-458', name: 'DEPRECATED: Incorrect Initialization' },
    { id: 'CWE-459', name: 'Incomplete Cleanup' },
    { id: 'CWE-46', name: "Path Equivalence: 'filename ' (Trailing Space)" },
    { id: 'CWE-460', name: 'Improper Cleanup on Thrown Exception' },
    { id: 'CWE-462', name: 'Duplicate Key in Associative List (Alist)' },
    { id: 'CWE-463', name: 'Deletion of Data Structure Sentinel' },
    { id: 'CWE-464', name: 'Addition of Data Structure Sentinel' },
    {
      id: 'CWE-466',
      name: 'Return of Pointer Value Outside of Expected Range',
    },
    { id: 'CWE-467', name: 'Use of sizeof() on a Pointer Type' },
    { id: 'CWE-468', name: 'Incorrect Pointer Scaling' },
    { id: 'CWE-469', name: 'Use of Pointer Subtraction to Determine Size' },
    { id: 'CWE-47', name: "Path Equivalence: ' filename' (Leading Space)" },
    {
      id: 'CWE-470',
      name: "Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')",
    },
    { id: 'CWE-471', name: 'Modification of Assumed-Immutable Data (MAID)' },
    {
      id: 'CWE-472',
      name: 'External Control of Assumed-Immutable Web Parameter',
    },
    { id: 'CWE-473', name: 'PHP External Variable Modification' },
    {
      id: 'CWE-474',
      name: 'Use of Function with Inconsistent Implementations',
    },
    { id: 'CWE-475', name: 'Undefined Behavior for Input to API' },
    { id: 'CWE-476', name: 'NULL Pointer Dereference' },
    { id: 'CWE-477', name: 'Use of Obsolete Function' },
    {
      id: 'CWE-478',
      name: 'Missing Default Case in Multiple Condition Expression',
    },
    { id: 'CWE-479', name: 'Signal Handler Use of a Non-reentrant Function' },
    {
      id: 'CWE-48',
      name: "Path Equivalence: 'file name' (Internal Whitespace)",
    },
    { id: 'CWE-480', name: 'Use of Incorrect Operator' },
    { id: 'CWE-481', name: 'Assigning instead of Comparing' },
    { id: 'CWE-482', name: 'Comparing instead of Assigning' },
    { id: 'CWE-483', name: 'Incorrect Block Delimitation' },
    { id: 'CWE-484', name: 'Omitted Break Statement in Switch' },
    { id: 'CWE-486', name: 'Comparison of Classes by Name' },
    { id: 'CWE-487', name: 'Reliance on Package-level Scope' },
    { id: 'CWE-488', name: 'Exposure of Data Element to Wrong Session' },
    { id: 'CWE-489', name: 'Active Debug Code' },
    { id: 'CWE-49', name: "Path Equivalence: 'filename/' (Trailing Slash)" },
    {
      id: 'CWE-491',
      name: "Public cloneable() Method Without Final ('Object Hijack')",
    },
    { id: 'CWE-492', name: 'Use of Inner Class Containing Sensitive Data' },
    { id: 'CWE-493', name: 'Critical Public Variable Without Final Modifier' },
    { id: 'CWE-494', name: 'Download of Code Without Integrity Check' },
    {
      id: 'CWE-495',
      name: 'Private Data Structure Returned From A Public Method',
    },
    {
      id: 'CWE-496',
      name: 'Public Data Assigned to Private Array-Typed Field',
    },
    {
      id: 'CWE-497',
      name: 'Exposure of Sensitive System Information to an Unauthorized Control Sphere',
    },
    { id: 'CWE-498', name: 'Cloneable Class Containing Sensitive Information' },
    { id: 'CWE-499', name: 'Serializable Class Containing Sensitive Data' },
    {
      id: 'CWE-5',
      name: 'J2EE Misconfiguration: Data Transmission Without Encryption',
    },
    { id: 'CWE-50', name: "Path Equivalence: '//multiple/leading/slash'" },
    { id: 'CWE-500', name: 'Public Static Field Not Marked Final' },
    { id: 'CWE-501', name: 'Trust Boundary Violation' },
    { id: 'CWE-502', name: 'Deserialization of Untrusted Data' },
    { id: 'CWE-506', name: 'Embedded Malicious Code' },
    { id: 'CWE-507', name: 'Trojan Horse' },
    { id: 'CWE-508', name: 'Non-Replicating Malicious Code' },
    { id: 'CWE-509', name: 'Replicating Malicious Code (Virus or Worm)' },
    { id: 'CWE-51', name: "Path Equivalence: '/multiple//internal/slash'" },
    { id: 'CWE-510', name: 'Trapdoor' },
    { id: 'CWE-511', name: 'Logic/Time Bomb' },
    { id: 'CWE-512', name: 'Spyware' },
    { id: 'CWE-514', name: 'Covert Channel' },
    { id: 'CWE-515', name: 'Covert Storage Channel' },
    { id: 'CWE-516', name: 'DEPRECATED: Covert Timing Channel' },
    { id: 'CWE-52', name: "Path Equivalence: '/multiple/trailing/slash//'" },
    { id: 'CWE-520', name: '.NET Misconfiguration: Use of Impersonation' },
    { id: 'CWE-521', name: 'Weak Password Requirements' },
    { id: 'CWE-522', name: 'Insufficiently Protected Credentials' },
    { id: 'CWE-523', name: 'Unprotected Transport of Credentials' },
    { id: 'CWE-524', name: 'Use of Cache Containing Sensitive Information' },
    {
      id: 'CWE-525',
      name: 'Use of Web Browser Cache Containing Sensitive Information',
    },
    {
      id: 'CWE-526',
      name: 'Cleartext Storage of Sensitive Information in an Environment Variable',
    },
    {
      id: 'CWE-527',
      name: 'Exposure of Version-Control Repository to an Unauthorized Control Sphere',
    },
    {
      id: 'CWE-528',
      name: 'Exposure of Core Dump File to an Unauthorized Control Sphere',
    },
    {
      id: 'CWE-529',
      name: 'Exposure of Access Control List Files to an Unauthorized Control Sphere',
    },
    {
      id: 'CWE-53',
      name: "Path Equivalence: '\\multiple\\\\internal\\backslash'",
    },
    {
      id: 'CWE-530',
      name: 'Exposure of Backup File to an Unauthorized Control Sphere',
    },
    { id: 'CWE-531', name: 'Inclusion of Sensitive Information in Test Code' },
    { id: 'CWE-532', name: 'Insertion of Sensitive Information into Log File' },
    {
      id: 'CWE-533',
      name: 'DEPRECATED: Information Exposure Through Server Log Files',
    },
    {
      id: 'CWE-534',
      name: 'DEPRECATED: Information Exposure Through Debug Log Files',
    },
    {
      id: 'CWE-535',
      name: 'Exposure of Information Through Shell Error Message',
    },
    {
      id: 'CWE-536',
      name: 'Servlet Runtime Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-537',
      name: 'Java Runtime Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-538',
      name: 'Insertion of Sensitive Information into Externally-Accessible File or Directory',
    },
    {
      id: 'CWE-539',
      name: 'Use of Persistent Cookies Containing Sensitive Information',
    },
    {
      id: 'CWE-54',
      name: "Path Equivalence: 'filedir\\' (Trailing Backslash)",
    },
    {
      id: 'CWE-540',
      name: 'Inclusion of Sensitive Information in Source Code',
    },
    {
      id: 'CWE-541',
      name: 'Inclusion of Sensitive Information in an Include File',
    },
    {
      id: 'CWE-542',
      name: 'DEPRECATED: Information Exposure Through Cleanup Log Files',
    },
    {
      id: 'CWE-543',
      name: 'Use of Singleton Pattern Without Synchronization in a Multithreaded Context',
    },
    { id: 'CWE-544', name: 'Missing Standardized Error Handling Mechanism' },
    { id: 'CWE-545', name: 'DEPRECATED: Use of Dynamic Class Loading' },
    { id: 'CWE-546', name: 'Suspicious Comment' },
    { id: 'CWE-547', name: 'Use of Hard-coded, Security-relevant Constants' },
    {
      id: 'CWE-548',
      name: 'Exposure of Information Through Directory Listing',
    },
    { id: 'CWE-549', name: 'Missing Password Field Masking' },
    { id: 'CWE-55', name: "Path Equivalence: '/./' (Single Dot Directory)" },
    {
      id: 'CWE-550',
      name: 'Server-generated Error Message Containing Sensitive Information',
    },
    {
      id: 'CWE-551',
      name: 'Incorrect Behavior Order: Authorization Before Parsing and Canonicalization',
    },
    {
      id: 'CWE-552',
      name: 'Files or Directories Accessible to External Parties',
    },
    { id: 'CWE-553', name: 'Command Shell in Externally Accessible Directory' },
    {
      id: 'CWE-554',
      name: 'ASP.NET Misconfiguration: Not Using Input Validation Framework',
    },
    {
      id: 'CWE-555',
      name: 'J2EE Misconfiguration: Plaintext Password in Configuration File',
    },
    {
      id: 'CWE-556',
      name: 'ASP.NET Misconfiguration: Use of Identity Impersonation',
    },
    { id: 'CWE-558', name: 'Use of getlogin() in Multithreaded Application' },
    { id: 'CWE-56', name: "Path Equivalence: 'filedir*' (Wildcard)" },
    { id: 'CWE-560', name: 'Use of umask() with chmod-style Argument' },
    { id: 'CWE-561', name: 'Dead Code' },
    { id: 'CWE-562', name: 'Return of Stack Variable Address' },
    { id: 'CWE-563', name: 'Assignment to Variable without Use' },
    { id: 'CWE-564', name: 'SQL Injection: Hibernate' },
    {
      id: 'CWE-565',
      name: 'Reliance on Cookies without Validation and Integrity Checking',
    },
    {
      id: 'CWE-566',
      name: 'Authorization Bypass Through User-Controlled SQL Primary Key',
    },
    {
      id: 'CWE-567',
      name: 'Unsynchronized Access to Shared Data in a Multithreaded Context',
    },
    { id: 'CWE-568', name: 'finalize() Method Without super.finalize()' },
    { id: 'CWE-57', name: "Path Equivalence: 'fakedir/../realdir/filename'" },
    { id: 'CWE-570', name: 'Expression is Always False' },
    { id: 'CWE-571', name: 'Expression is Always True' },
    { id: 'CWE-572', name: 'Call to Thread run() instead of start()' },
    { id: 'CWE-573', name: 'Improper Following of Specification by Caller' },
    {
      id: 'CWE-574',
      name: 'EJB Bad Practices: Use of Synchronization Primitives',
    },
    { id: 'CWE-575', name: 'EJB Bad Practices: Use of AWT Swing' },
    { id: 'CWE-576', name: 'EJB Bad Practices: Use of Java I/O' },
    { id: 'CWE-577', name: 'EJB Bad Practices: Use of Sockets' },
    { id: 'CWE-578', name: 'EJB Bad Practices: Use of Class Loader' },
    {
      id: 'CWE-579',
      name: 'J2EE Bad Practices: Non-serializable Object Stored in Session',
    },
    { id: 'CWE-58', name: 'Path Equivalence: Windows 8.3 Filename' },
    { id: 'CWE-580', name: 'clone() Method Without super.clone()' },
    {
      id: 'CWE-581',
      name: 'Object Model Violation: Just One of Equals and Hashcode Defined',
    },
    { id: 'CWE-582', name: 'Array Declared Public, Final, and Static' },
    { id: 'CWE-583', name: 'finalize() Method Declared Public' },
    { id: 'CWE-584', name: 'Return Inside Finally Block' },
    { id: 'CWE-585', name: 'Empty Synchronized Block' },
    { id: 'CWE-586', name: 'Explicit Call to Finalize()' },
    { id: 'CWE-587', name: 'Assignment of a Fixed Address to a Pointer' },
    {
      id: 'CWE-588',
      name: 'Attempt to Access Child of a Non-structure Pointer',
    },
    { id: 'CWE-589', name: 'Call to Non-ubiquitous API' },
    {
      id: 'CWE-59',
      name: "Improper Link Resolution Before File Access ('Link Following')",
    },
    { id: 'CWE-590', name: 'Free of Memory not on the Heap' },
    {
      id: 'CWE-591',
      name: 'Sensitive Data Storage in Improperly Locked Memory',
    },
    { id: 'CWE-592', name: 'DEPRECATED: Authentication Bypass Issues' },
    {
      id: 'CWE-593',
      name: 'Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created',
    },
    {
      id: 'CWE-594',
      name: 'J2EE Framework: Saving Unserializable Objects to Disk',
    },
    {
      id: 'CWE-595',
      name: 'Comparison of Object References Instead of Object Contents',
    },
    { id: 'CWE-596', name: 'DEPRECATED: Incorrect Semantic Object Comparison' },
    { id: 'CWE-597', name: 'Use of Wrong Operator in String Comparison' },
    {
      id: 'CWE-598',
      name: 'Use of GET Request Method With Sensitive Query Strings',
    },
    { id: 'CWE-599', name: 'Missing Validation of OpenSSL Certificate' },
    {
      id: 'CWE-6',
      name: 'J2EE Misconfiguration: Insufficient Session-ID Length',
    },
    { id: 'CWE-600', name: 'Uncaught Exception in Servlet ' },
    {
      id: 'CWE-601',
      name: "URL Redirection to Untrusted Site ('Open Redirect')",
    },
    { id: 'CWE-602', name: 'Client-Side Enforcement of Server-Side Security' },
    { id: 'CWE-603', name: 'Use of Client-Side Authentication' },
    { id: 'CWE-605', name: 'Multiple Binds to the Same Port' },
    { id: 'CWE-606', name: 'Unchecked Input for Loop Condition' },
    {
      id: 'CWE-607',
      name: 'Public Static Final Field References Mutable Object',
    },
    { id: 'CWE-608', name: 'Struts: Non-private Field in ActionForm Class' },
    { id: 'CWE-609', name: 'Double-Checked Locking' },
    { id: 'CWE-61', name: 'UNIX Symbolic Link (Symlink) Following' },
    {
      id: 'CWE-610',
      name: 'Externally Controlled Reference to a Resource in Another Sphere',
    },
    {
      id: 'CWE-611',
      name: 'Improper Restriction of XML External Entity Reference',
    },
    {
      id: 'CWE-612',
      name: 'Improper Authorization of Index Containing Sensitive Information',
    },
    { id: 'CWE-613', name: 'Insufficient Session Expiration' },
    {
      id: 'CWE-614',
      name: "Sensitive Cookie in HTTPS Session Without 'Secure' Attribute",
    },
    {
      id: 'CWE-615',
      name: 'Inclusion of Sensitive Information in Source Code Comments',
    },
    {
      id: 'CWE-616',
      name: 'Incomplete Identification of Uploaded File Variables (PHP)',
    },
    { id: 'CWE-617', name: 'Reachable Assertion' },
    { id: 'CWE-618', name: 'Exposed Unsafe ActiveX Method' },
    { id: 'CWE-619', name: "Dangling Database Cursor ('Cursor Injection')" },
    { id: 'CWE-62', name: 'UNIX Hard Link' },
    { id: 'CWE-620', name: 'Unverified Password Change' },
    { id: 'CWE-621', name: 'Variable Extraction Error' },
    { id: 'CWE-622', name: 'Improper Validation of Function Hook Arguments' },
    { id: 'CWE-623', name: 'Unsafe ActiveX Control Marked Safe For Scripting' },
    { id: 'CWE-624', name: 'Executable Regular Expression Error' },
    { id: 'CWE-625', name: 'Permissive Regular Expression' },
    { id: 'CWE-626', name: 'Null Byte Interaction Error (Poison Null Byte)' },
    { id: 'CWE-627', name: 'Dynamic Variable Evaluation' },
    {
      id: 'CWE-628',
      name: 'Function Call with Incorrectly Specified Arguments',
    },
    { id: 'CWE-636', name: "Not Failing Securely ('Failing Open')" },
    {
      id: 'CWE-637',
      name: "Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')",
    },
    { id: 'CWE-638', name: 'Not Using Complete Mediation' },
    { id: 'CWE-639', name: 'Authorization Bypass Through User-Controlled Key' },
    { id: 'CWE-64', name: 'Windows Shortcut Following (.LNK)' },
    {
      id: 'CWE-640',
      name: 'Weak Password Recovery Mechanism for Forgotten Password',
    },
    {
      id: 'CWE-641',
      name: 'Improper Restriction of Names for Files and Other Resources',
    },
    { id: 'CWE-642', name: 'External Control of Critical State Data' },
    {
      id: 'CWE-643',
      name: "Improper Neutralization of Data within XPath Expressions ('XPath Injection')",
    },
    {
      id: 'CWE-644',
      name: 'Improper Neutralization of HTTP Headers for Scripting Syntax',
    },
    { id: 'CWE-645', name: 'Overly Restrictive Account Lockout Mechanism' },
    {
      id: 'CWE-646',
      name: 'Reliance on File Name or Extension of Externally-Supplied File',
    },
    {
      id: 'CWE-647',
      name: 'Use of Non-Canonical URL Paths for Authorization Decisions',
    },
    { id: 'CWE-648', name: 'Incorrect Use of Privileged APIs' },
    {
      id: 'CWE-649',
      name: 'Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking',
    },
    { id: 'CWE-65', name: 'Windows Hard Link' },
    {
      id: 'CWE-650',
      name: 'Trusting HTTP Permission Methods on the Server Side',
    },
    {
      id: 'CWE-651',
      name: 'Exposure of WSDL File Containing Sensitive Information',
    },
    {
      id: 'CWE-652',
      name: "Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')",
    },
    { id: 'CWE-653', name: 'Improper Isolation or Compartmentalization' },
    {
      id: 'CWE-654',
      name: 'Reliance on a Single Factor in a Security Decision',
    },
    { id: 'CWE-655', name: 'Insufficient Psychological Acceptability' },
    { id: 'CWE-656', name: 'Reliance on Security Through Obscurity' },
    { id: 'CWE-657', name: 'Violation of Secure Design Principles' },
    {
      id: 'CWE-66',
      name: 'Improper Handling of File Names that Identify Virtual Resources',
    },
    { id: 'CWE-662', name: 'Improper Synchronization' },
    {
      id: 'CWE-663',
      name: 'Use of a Non-reentrant Function in a Concurrent Context',
    },
    {
      id: 'CWE-664',
      name: 'Improper Control of a Resource Through its Lifetime',
    },
    { id: 'CWE-665', name: 'Improper Initialization' },
    { id: 'CWE-666', name: 'Operation on Resource in Wrong Phase of Lifetime' },
    { id: 'CWE-667', name: 'Improper Locking' },
    { id: 'CWE-668', name: 'Exposure of Resource to Wrong Sphere' },
    { id: 'CWE-669', name: 'Incorrect Resource Transfer Between Spheres' },
    { id: 'CWE-67', name: 'Improper Handling of Windows Device Names' },
    { id: 'CWE-670', name: 'Always-Incorrect Control Flow Implementation' },
    { id: 'CWE-671', name: 'Lack of Administrator Control over Security' },
    {
      id: 'CWE-672',
      name: 'Operation on a Resource after Expiration or Release',
    },
    { id: 'CWE-673', name: 'External Influence of Sphere Definition' },
    { id: 'CWE-674', name: 'Uncontrolled Recursion' },
    {
      id: 'CWE-675',
      name: 'Multiple Operations on Resource in Single-Operation Context',
    },
    { id: 'CWE-676', name: 'Use of Potentially Dangerous Function' },
    { id: 'CWE-680', name: 'Integer Overflow to Buffer Overflow' },
    { id: 'CWE-681', name: 'Incorrect Conversion between Numeric Types' },
    { id: 'CWE-682', name: 'Incorrect Calculation' },
    { id: 'CWE-683', name: 'Function Call With Incorrect Order of Arguments' },
    { id: 'CWE-684', name: 'Incorrect Provision of Specified Functionality' },
    { id: 'CWE-685', name: 'Function Call With Incorrect Number of Arguments' },
    { id: 'CWE-686', name: 'Function Call With Incorrect Argument Type' },
    {
      id: 'CWE-687',
      name: 'Function Call With Incorrectly Specified Argument Value',
    },
    {
      id: 'CWE-688',
      name: 'Function Call With Incorrect Variable or Reference as Argument',
    },
    { id: 'CWE-689', name: 'Permission Race Condition During Resource Copy' },
    {
      id: 'CWE-69',
      name: 'Improper Handling of Windows ::DATA Alternate Data Stream',
    },
    {
      id: 'CWE-690',
      name: 'Unchecked Return Value to NULL Pointer Dereference',
    },
    { id: 'CWE-691', name: 'Insufficient Control Flow Management' },
    { id: 'CWE-692', name: 'Incomplete Denylist to Cross-Site Scripting' },
    { id: 'CWE-693', name: 'Protection Mechanism Failure' },
    {
      id: 'CWE-694',
      name: 'Use of Multiple Resources with Duplicate Identifier',
    },
    { id: 'CWE-695', name: 'Use of Low-Level Functionality' },
    { id: 'CWE-696', name: 'Incorrect Behavior Order' },
    { id: 'CWE-697', name: 'Incorrect Comparison' },
    { id: 'CWE-698', name: 'Execution After Redirect (EAR)' },
    { id: 'CWE-7', name: 'J2EE Misconfiguration: Missing Custom Error Page' },
    {
      id: 'CWE-703',
      name: 'Improper Check or Handling of Exceptional Conditions',
    },
    { id: 'CWE-704', name: 'Incorrect Type Conversion or Cast' },
    { id: 'CWE-705', name: 'Incorrect Control Flow Scoping' },
    { id: 'CWE-706', name: 'Use of Incorrectly-Resolved Name or Reference' },
    { id: 'CWE-707', name: 'Improper Neutralization' },
    { id: 'CWE-708', name: 'Incorrect Ownership Assignment' },
    { id: 'CWE-71', name: "DEPRECATED: Apple '.DS_Store'" },
    { id: 'CWE-710', name: 'Improper Adherence to Coding Standards' },
    {
      id: 'CWE-72',
      name: 'Improper Handling of Apple HFS+ Alternate Data Stream Path',
    },
    { id: 'CWE-73', name: 'External Control of File Name or Path' },
    {
      id: 'CWE-732',
      name: 'Incorrect Permission Assignment for Critical Resource',
    },
    {
      id: 'CWE-733',
      name: 'Compiler Optimization Removal or Modification of Security-critical Code',
    },
    {
      id: 'CWE-74',
      name: "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
    },
    { id: 'CWE-749', name: 'Exposed Dangerous Method or Function' },
    {
      id: 'CWE-75',
      name: 'Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)',
    },
    {
      id: 'CWE-754',
      name: 'Improper Check for Unusual or Exceptional Conditions',
    },
    { id: 'CWE-755', name: 'Improper Handling of Exceptional Conditions' },
    { id: 'CWE-756', name: 'Missing Custom Error Page' },
    {
      id: 'CWE-757',
      name: "Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')",
    },
    {
      id: 'CWE-758',
      name: 'Reliance on Undefined, Unspecified, or Implementation-Defined Behavior',
    },
    { id: 'CWE-759', name: 'Use of a One-Way Hash without a Salt' },
    {
      id: 'CWE-76',
      name: 'Improper Neutralization of Equivalent Special Elements',
    },
    { id: 'CWE-760', name: 'Use of a One-Way Hash with a Predictable Salt' },
    { id: 'CWE-761', name: 'Free of Pointer not at Start of Buffer' },
    { id: 'CWE-762', name: 'Mismatched Memory Management Routines' },
    { id: 'CWE-763', name: 'Release of Invalid Pointer or Reference' },
    { id: 'CWE-764', name: 'Multiple Locks of a Critical Resource' },
    { id: 'CWE-765', name: 'Multiple Unlocks of a Critical Resource' },
    { id: 'CWE-766', name: 'Critical Data Element Declared Public' },
    {
      id: 'CWE-767',
      name: 'Access to Critical Private Variable via Public Method',
    },
    { id: 'CWE-768', name: 'Incorrect Short Circuit Evaluation' },
    {
      id: 'CWE-769',
      name: 'DEPRECATED: Uncontrolled File Descriptor Consumption',
    },
    {
      id: 'CWE-77',
      name: "Improper Neutralization of Special Elements used in a Command ('Command Injection')",
    },
    {
      id: 'CWE-770',
      name: 'Allocation of Resources Without Limits or Throttling',
    },
    { id: 'CWE-771', name: 'Missing Reference to Active Allocated Resource' },
    {
      id: 'CWE-772',
      name: 'Missing Release of Resource after Effective Lifetime',
    },
    {
      id: 'CWE-773',
      name: 'Missing Reference to Active File Descriptor or Handle',
    },
    {
      id: 'CWE-774',
      name: 'Allocation of File Descriptors or Handles Without Limits or Throttling',
    },
    {
      id: 'CWE-775',
      name: 'Missing Release of File Descriptor or Handle after Effective Lifetime',
    },
    {
      id: 'CWE-776',
      name: "Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')",
    },
    { id: 'CWE-777', name: 'Regular Expression without Anchors' },
    { id: 'CWE-778', name: 'Insufficient Logging' },
    { id: 'CWE-779', name: 'Logging of Excessive Data' },
    {
      id: 'CWE-78',
      name: "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
    },
    { id: 'CWE-780', name: 'Use of RSA Algorithm without OAEP' },
    {
      id: 'CWE-781',
      name: 'Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code',
    },
    { id: 'CWE-782', name: 'Exposed IOCTL with Insufficient Access Control' },
    { id: 'CWE-783', name: 'Operator Precedence Logic Error' },
    {
      id: 'CWE-784',
      name: 'Reliance on Cookies without Validation and Integrity Checking in a Security Decision',
    },
    {
      id: 'CWE-785',
      name: 'Use of Path Manipulation Function without Maximum-sized Buffer',
    },
    { id: 'CWE-786', name: 'Access of Memory Location Before Start of Buffer' },
    { id: 'CWE-787', name: 'Out-of-bounds Write' },
    { id: 'CWE-788', name: 'Access of Memory Location After End of Buffer' },
    { id: 'CWE-789', name: 'Memory Allocation with Excessive Size Value' },
    {
      id: 'CWE-79',
      name: "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
    },
    { id: 'CWE-790', name: 'Improper Filtering of Special Elements' },
    { id: 'CWE-791', name: 'Incomplete Filtering of Special Elements' },
    {
      id: 'CWE-792',
      name: 'Incomplete Filtering of One or More Instances of Special Elements',
    },
    { id: 'CWE-793', name: 'Only Filtering One Instance of a Special Element' },
    {
      id: 'CWE-794',
      name: 'Incomplete Filtering of Multiple Instances of Special Elements',
    },
    {
      id: 'CWE-795',
      name: 'Only Filtering Special Elements at a Specified Location',
    },
    {
      id: 'CWE-796',
      name: 'Only Filtering Special Elements Relative to a Marker',
    },
    {
      id: 'CWE-797',
      name: 'Only Filtering Special Elements at an Absolute Position',
    },
    { id: 'CWE-798', name: 'Use of Hard-coded Credentials' },
    { id: 'CWE-799', name: 'Improper Control of Interaction Frequency' },
    { id: 'CWE-8', name: 'J2EE Misconfiguration: Entity Bean Declared Remote' },
    {
      id: 'CWE-80',
      name: 'Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)',
    },
    { id: 'CWE-804', name: 'Guessable CAPTCHA' },
    { id: 'CWE-805', name: 'Buffer Access with Incorrect Length Value' },
    { id: 'CWE-806', name: 'Buffer Access Using Size of Source Buffer' },
    {
      id: 'CWE-807',
      name: 'Reliance on Untrusted Inputs in a Security Decision',
    },
    {
      id: 'CWE-81',
      name: 'Improper Neutralization of Script in an Error Message Web Page',
    },
    {
      id: 'CWE-82',
      name: 'Improper Neutralization of Script in Attributes of IMG Tags in a Web Page',
    },
    { id: 'CWE-820', name: 'Missing Synchronization' },
    { id: 'CWE-821', name: 'Incorrect Synchronization' },
    { id: 'CWE-822', name: 'Untrusted Pointer Dereference' },
    { id: 'CWE-823', name: 'Use of Out-of-range Pointer Offset' },
    { id: 'CWE-824', name: 'Access of Uninitialized Pointer' },
    { id: 'CWE-825', name: 'Expired Pointer Dereference' },
    {
      id: 'CWE-826',
      name: 'Premature Release of Resource During Expected Lifetime',
    },
    { id: 'CWE-827', name: 'Improper Control of Document Type Definition' },
    {
      id: 'CWE-828',
      name: 'Signal Handler with Functionality that is not Asynchronous-Safe',
    },
    {
      id: 'CWE-829',
      name: 'Inclusion of Functionality from Untrusted Control Sphere',
    },
    {
      id: 'CWE-83',
      name: 'Improper Neutralization of Script in Attributes in a Web Page',
    },
    {
      id: 'CWE-830',
      name: 'Inclusion of Web Functionality from an Untrusted Source',
    },
    {
      id: 'CWE-831',
      name: 'Signal Handler Function Associated with Multiple Signals',
    },
    { id: 'CWE-832', name: 'Unlock of a Resource that is not Locked' },
    { id: 'CWE-833', name: 'Deadlock' },
    { id: 'CWE-834', name: 'Excessive Iteration' },
    {
      id: 'CWE-835',
      name: "Loop with Unreachable Exit Condition ('Infinite Loop')",
    },
    {
      id: 'CWE-836',
      name: 'Use of Password Hash Instead of Password for Authentication',
    },
    { id: 'CWE-837', name: 'Improper Enforcement of a Single, Unique Action' },
    { id: 'CWE-838', name: 'Inappropriate Encoding for Output Context' },
    { id: 'CWE-839', name: 'Numeric Range Comparison Without Minimum Check' },
    {
      id: 'CWE-84',
      name: 'Improper Neutralization of Encoded URI Schemes in a Web Page',
    },
    { id: 'CWE-841', name: 'Improper Enforcement of Behavioral Workflow' },
    { id: 'CWE-842', name: 'Placement of User into Incorrect Group' },
    {
      id: 'CWE-843',
      name: "Access of Resource Using Incompatible Type ('Type Confusion')",
    },
    { id: 'CWE-85', name: 'Doubled Character XSS Manipulations' },
    {
      id: 'CWE-86',
      name: 'Improper Neutralization of Invalid Characters in Identifiers in Web Pages',
    },
    { id: 'CWE-862', name: 'Missing Authorization' },
    { id: 'CWE-863', name: 'Incorrect Authorization' },
    { id: 'CWE-87', name: 'Improper Neutralization of Alternate XSS Syntax' },
    {
      id: 'CWE-88',
      name: "Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')",
    },
    {
      id: 'CWE-89',
      name: "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
    },
    {
      id: 'CWE-9',
      name: 'J2EE Misconfiguration: Weak Access Permissions for EJB Methods',
    },
    {
      id: 'CWE-90',
      name: "Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')",
    },
    { id: 'CWE-908', name: 'Use of Uninitialized Resource' },
    { id: 'CWE-909', name: 'Missing Initialization of Resource' },
    { id: 'CWE-91', name: 'XML Injection (aka Blind XPath Injection)' },
    { id: 'CWE-910', name: 'Use of Expired File Descriptor' },
    { id: 'CWE-911', name: 'Improper Update of Reference Count' },
    { id: 'CWE-912', name: 'Hidden Functionality' },
    {
      id: 'CWE-913',
      name: 'Improper Control of Dynamically-Managed Code Resources',
    },
    {
      id: 'CWE-914',
      name: 'Improper Control of Dynamically-Identified Variables',
    },
    {
      id: 'CWE-915',
      name: 'Improperly Controlled Modification of Dynamically-Determined Object Attributes',
    },
    {
      id: 'CWE-916',
      name: 'Use of Password Hash With Insufficient Computational Effort',
    },
    {
      id: 'CWE-917',
      name: "Improper Neutralization of Special Elements used in an Expression Language Statement ('Expression Language Injection')",
    },
    { id: 'CWE-918', name: 'Server-Side Request Forgery (SSRF)' },
    {
      id: 'CWE-92',
      name: 'DEPRECATED: Improper Sanitization of Custom Special Characters',
    },
    { id: 'CWE-920', name: 'Improper Restriction of Power Consumption' },
    {
      id: 'CWE-921',
      name: 'Storage of Sensitive Data in a Mechanism without Access Control',
    },
    { id: 'CWE-922', name: 'Insecure Storage of Sensitive Information' },
    {
      id: 'CWE-923',
      name: 'Improper Restriction of Communication Channel to Intended Endpoints',
    },
    {
      id: 'CWE-924',
      name: 'Improper Enforcement of Message Integrity During Transmission in a Communication Channel',
    },
    {
      id: 'CWE-925',
      name: 'Improper Verification of Intent by Broadcast Receiver',
    },
    {
      id: 'CWE-926',
      name: 'Improper Export of Android Application Components',
    },
    {
      id: 'CWE-927',
      name: 'Use of Implicit Intent for Sensitive Communication',
    },
    {
      id: 'CWE-93',
      name: "Improper Neutralization of CRLF Sequences ('CRLF Injection')",
    },
    {
      id: 'CWE-939',
      name: 'Improper Authorization in Handler for Custom URL Scheme',
    },
    {
      id: 'CWE-94',
      name: "Improper Control of Generation of Code ('Code Injection')",
    },
    {
      id: 'CWE-940',
      name: 'Improper Verification of Source of a Communication Channel',
    },
    {
      id: 'CWE-941',
      name: 'Incorrectly Specified Destination in a Communication Channel',
    },
    {
      id: 'CWE-942',
      name: 'Permissive Cross-domain Policy with Untrusted Domains',
    },
    {
      id: 'CWE-943',
      name: 'Improper Neutralization of Special Elements in Data Query Logic',
    },
    {
      id: 'CWE-95',
      name: "Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')",
    },
    {
      id: 'CWE-96',
      name: "Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')",
    },
    {
      id: 'CWE-97',
      name: 'Improper Neutralization of Server-Side Includes (SSI) Within a Web Page',
    },
    {
      id: 'CWE-98',
      name: "Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')",
    },
    {
      id: 'CWE-99',
      name: "Improper Control of Resource Identifiers ('Resource Injection')",
    },
  ],
});

/**
 * @typedef {Object} FullProductName
 * @property {string} name
 * @property {string} product_id
 */

/**
 * @typedef {Object} Branch
 * @property {Array<Branch>} branches
 * @property {FullProductName} product
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_11(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (hasVulnerabilities(doc)) {
    for (let i = 0; i < doc.vulnerabilities.length; ++i) {
      const vulnerability = doc.vulnerabilities[i];
      if (vulnerabilityHasCWEFields(vulnerability)) {
        const entry = cwec.weaknesses.find((w) => w.id === vulnerability.cwe.id);
        if (!entry) {
          isValid = false;
          errors.push({
            instancePath: `/vulnerabilities/${i}/cwe/id`,
            message: 'no weakness with this id is recognized',
          });
          continue
        }
        if (entry.name !== vulnerability.cwe.name) {
          isValid = false;
          errors.push({
            instancePath: `/vulnerabilities/${i}/cwe/name`,
            message: 'the name does not match the weakness with the given id',
          });
          continue
        }
      }
    }
  }

  return { isValid, errors }
}

/**
 * @param {any} doc
 * @returns {doc is { vulnerabilities: Array<unknown> }}
 */
const hasVulnerabilities = (doc) =>
  doc && Array.isArray(doc.vulnerabilities) ? true : false;

/**
 * @param {any} vulnerability
 * @returns {vulnerability is { cwe: { id: string; name: string } }}
 */
const vulnerabilityHasCWEFields = (vulnerability) =>
  vulnerability &&
  vulnerability.cwe &&
  typeof vulnerability.cwe.id === 'string' &&
  typeof vulnerability.cwe.name === 'string'
    ? true
    : false;

var lib = {};

lib.parse = function (tag) {
  var re = /^(?:(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))$|^((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|\d{3}))?((?:-(?:[\da-z]{5,8}|\d[\da-z]{3}))*)?((?:-[\da-wy-z](?:-[\da-z]{2,8})+)*)?(-x(?:-[\da-z]{1,8})+)?$|^(x(?:-[\da-z]{1,8})+)$/i;

  /*
  /
  ^
    (?:
      (
        en-GB-oed | i-ami | i-bnn | i-default | i-enochian | i-hak | i-klingon |
        i-lux | i-mingo | i-navajo | i-pwn | i-tao | i-tay | i-tsu | sgn-BE-FR |
        sgn-BE-NL | sgn-CH-DE
      ) |
      (
        art-lojban | cel-gaulish | no-bok | no-nyn | zh-guoyu | zh-hakka |
        zh-min | zh-min-nan | zh-xiang
      )
    )
  $
  |
  ^
    (
      (?:
        [a-z]{2,3}
        (?:
          (?:
            -[a-z]{3}
          ){1,3}
        )?
      ) |
      [a-z]{4} |
      [a-z]{5,8}
    )
    (?:
      -
      (
        [a-z]{4}
      )
    )?
    (?:
      -
      (
        [a-z]{2} |
        \d{3}
      )
    )?
    (
      (?:
        -
        (?:
          [\da-z]{5,8} |
          \d[\da-z]{3}
        )
      )*
    )?
    (
      (?:
        -
        [\da-wy-z]
        (?:
          -[\da-z]{2,8}
        )+
      )*
    )?
    (
      -x
      (?:
        -[\da-z]{1,8}
      )+
    )?
  $
  |
  ^
    (
      x
      (?:
        -[\da-z]{1,8}
      )+
    )
  $
  /i
  */

  var res = re.exec(tag);
  if (!res) return null;

  res.shift();
  var t;

  // langtag language
  var language = null;
  var extlang = [];
  if (res[2]) {
    t = res[2].split('-');
    language = t.shift();
    extlang = t;
  }

  // langtag variant
  var variant = [];
  if (res[5]) {
    variant = res[5].split('-');
    variant.shift();
  }

  // langtag extension
  var extension = [];
  if (res[6]) {
    t = res[6].split('-');
    t.shift();

    var singleton;
    var ext = [];

    while (t.length) {
      var e = t.shift();
      if (e.length === 1) {
        if (singleton) {
          extension.push({
            singleton: singleton,
            extension: ext
          });
          singleton = e;
          ext = [];
        } else {
          singleton = e;
        }
      } else {
        ext.push(e);
      }
    }

    extension.push({
      singleton: singleton,
      extension: ext
    });
  }

  // langtag privateuse
  var langtagPrivateuse = [];
  if (res[7]) {
    langtagPrivateuse = res[7].split('-');
    langtagPrivateuse.shift();
    langtagPrivateuse.shift();
  }

  // privateuse
  var privateuse = [];
  if (res[8]) {
    privateuse = res[8].split('-');
    privateuse.shift();
  }

  return {
    langtag: {
      language: {
        language: language,
        extlang: extlang
      },
      script: res[3] || null,
      region: res[4] || null,
      variant: variant,
      extension: extension,
      privateuse: langtagPrivateuse
    },
    privateuse: privateuse,
    grandfathered: {
      irregular: res[0] || null,
      regular: res[1] || null
    }
  };
};

var extensions = /** @type {const} */ ([
  {
    identifier: 't',
  },
  {
    identifier: 'u',
  },
]);

var icann = /** @type {const} */ ({
  subtags: [
    { type: 'language', subtag: 'aa', prefix: [], scope: null },
    { type: 'language', subtag: 'ab', prefix: [], scope: null },
    { type: 'language', subtag: 'ae', prefix: [], scope: null },
    { type: 'language', subtag: 'af', prefix: [], scope: null },
    { type: 'language', subtag: 'ak', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'am', prefix: [], scope: null },
    { type: 'language', subtag: 'an', prefix: [], scope: null },
    { type: 'language', subtag: 'ar', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'as', prefix: [], scope: null },
    { type: 'language', subtag: 'av', prefix: [], scope: null },
    { type: 'language', subtag: 'ay', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'az', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ba', prefix: [], scope: null },
    { type: 'language', subtag: 'be', prefix: [], scope: null },
    { type: 'language', subtag: 'bg', prefix: [], scope: null },
    { type: 'language', subtag: 'bh', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'bi', prefix: [], scope: null },
    { type: 'language', subtag: 'bm', prefix: [], scope: null },
    { type: 'language', subtag: 'bn', prefix: [], scope: null },
    { type: 'language', subtag: 'bo', prefix: [], scope: null },
    { type: 'language', subtag: 'br', prefix: [], scope: null },
    { type: 'language', subtag: 'bs', prefix: [], scope: null },
    { type: 'language', subtag: 'ca', prefix: [], scope: null },
    { type: 'language', subtag: 'ce', prefix: [], scope: null },
    { type: 'language', subtag: 'ch', prefix: [], scope: null },
    { type: 'language', subtag: 'co', prefix: [], scope: null },
    { type: 'language', subtag: 'cr', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'cs', prefix: [], scope: null },
    { type: 'language', subtag: 'cu', prefix: [], scope: null },
    { type: 'language', subtag: 'cv', prefix: [], scope: null },
    { type: 'language', subtag: 'cy', prefix: [], scope: null },
    { type: 'language', subtag: 'da', prefix: [], scope: null },
    { type: 'language', subtag: 'de', prefix: [], scope: null },
    { type: 'language', subtag: 'dv', prefix: [], scope: null },
    { type: 'language', subtag: 'dz', prefix: [], scope: null },
    { type: 'language', subtag: 'ee', prefix: [], scope: null },
    { type: 'language', subtag: 'el', prefix: [], scope: null },
    { type: 'language', subtag: 'en', prefix: [], scope: null },
    { type: 'language', subtag: 'eo', prefix: [], scope: null },
    { type: 'language', subtag: 'es', prefix: [], scope: null },
    { type: 'language', subtag: 'et', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'eu', prefix: [], scope: null },
    { type: 'language', subtag: 'fa', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ff', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'fi', prefix: [], scope: null },
    { type: 'language', subtag: 'fj', prefix: [], scope: null },
    { type: 'language', subtag: 'fo', prefix: [], scope: null },
    { type: 'language', subtag: 'fr', prefix: [], scope: null },
    { type: 'language', subtag: 'fy', prefix: [], scope: null },
    { type: 'language', subtag: 'ga', prefix: [], scope: null },
    { type: 'language', subtag: 'gd', prefix: [], scope: null },
    { type: 'language', subtag: 'gl', prefix: [], scope: null },
    { type: 'language', subtag: 'gn', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'gu', prefix: [], scope: null },
    { type: 'language', subtag: 'gv', prefix: [], scope: null },
    { type: 'language', subtag: 'ha', prefix: [], scope: null },
    { type: 'language', subtag: 'he', prefix: [], scope: null },
    { type: 'language', subtag: 'hi', prefix: [], scope: null },
    { type: 'language', subtag: 'ho', prefix: [], scope: null },
    { type: 'language', subtag: 'hr', prefix: [], scope: null },
    { type: 'language', subtag: 'ht', prefix: [], scope: null },
    { type: 'language', subtag: 'hu', prefix: [], scope: null },
    { type: 'language', subtag: 'hy', prefix: [], scope: null },
    { type: 'language', subtag: 'hz', prefix: [], scope: null },
    { type: 'language', subtag: 'ia', prefix: [], scope: null },
    { type: 'language', subtag: 'id', prefix: [], scope: null },
    { type: 'language', subtag: 'ie', prefix: [], scope: null },
    { type: 'language', subtag: 'ig', prefix: [], scope: null },
    { type: 'language', subtag: 'ii', prefix: [], scope: null },
    { type: 'language', subtag: 'ik', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'in', prefix: [], scope: null },
    { type: 'language', subtag: 'io', prefix: [], scope: null },
    { type: 'language', subtag: 'is', prefix: [], scope: null },
    { type: 'language', subtag: 'it', prefix: [], scope: null },
    { type: 'language', subtag: 'iu', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'iw', prefix: [], scope: null },
    { type: 'language', subtag: 'ja', prefix: [], scope: null },
    { type: 'language', subtag: 'ji', prefix: [], scope: null },
    { type: 'language', subtag: 'jv', prefix: [], scope: null },
    { type: 'language', subtag: 'jw', prefix: [], scope: null },
    { type: 'language', subtag: 'ka', prefix: [], scope: null },
    { type: 'language', subtag: 'kg', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ki', prefix: [], scope: null },
    { type: 'language', subtag: 'kj', prefix: [], scope: null },
    { type: 'language', subtag: 'kk', prefix: [], scope: null },
    { type: 'language', subtag: 'kl', prefix: [], scope: null },
    { type: 'language', subtag: 'km', prefix: [], scope: null },
    { type: 'language', subtag: 'kn', prefix: [], scope: null },
    { type: 'language', subtag: 'ko', prefix: [], scope: null },
    { type: 'language', subtag: 'kr', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ks', prefix: [], scope: null },
    { type: 'language', subtag: 'ku', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'kv', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'kw', prefix: [], scope: null },
    { type: 'language', subtag: 'ky', prefix: [], scope: null },
    { type: 'language', subtag: 'la', prefix: [], scope: null },
    { type: 'language', subtag: 'lb', prefix: [], scope: null },
    { type: 'language', subtag: 'lg', prefix: [], scope: null },
    { type: 'language', subtag: 'li', prefix: [], scope: null },
    { type: 'language', subtag: 'ln', prefix: [], scope: null },
    { type: 'language', subtag: 'lo', prefix: [], scope: null },
    { type: 'language', subtag: 'lt', prefix: [], scope: null },
    { type: 'language', subtag: 'lu', prefix: [], scope: null },
    { type: 'language', subtag: 'lv', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'mg', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'mh', prefix: [], scope: null },
    { type: 'language', subtag: 'mi', prefix: [], scope: null },
    { type: 'language', subtag: 'mk', prefix: [], scope: null },
    { type: 'language', subtag: 'ml', prefix: [], scope: null },
    { type: 'language', subtag: 'mn', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'mo', prefix: [], scope: null },
    { type: 'language', subtag: 'mr', prefix: [], scope: null },
    { type: 'language', subtag: 'ms', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'mt', prefix: [], scope: null },
    { type: 'language', subtag: 'my', prefix: [], scope: null },
    { type: 'language', subtag: 'na', prefix: [], scope: null },
    { type: 'language', subtag: 'nb', prefix: [], scope: null },
    { type: 'language', subtag: 'nd', prefix: [], scope: null },
    { type: 'language', subtag: 'ne', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ng', prefix: [], scope: null },
    { type: 'language', subtag: 'nl', prefix: [], scope: null },
    { type: 'language', subtag: 'nn', prefix: [], scope: null },
    { type: 'language', subtag: 'no', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'nr', prefix: [], scope: null },
    { type: 'language', subtag: 'nv', prefix: [], scope: null },
    { type: 'language', subtag: 'ny', prefix: [], scope: null },
    { type: 'language', subtag: 'oc', prefix: [], scope: null },
    { type: 'language', subtag: 'oj', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'om', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'or', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'os', prefix: [], scope: null },
    { type: 'language', subtag: 'pa', prefix: [], scope: null },
    { type: 'language', subtag: 'pi', prefix: [], scope: null },
    { type: 'language', subtag: 'pl', prefix: [], scope: null },
    { type: 'language', subtag: 'ps', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'pt', prefix: [], scope: null },
    { type: 'language', subtag: 'qu', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'rm', prefix: [], scope: null },
    { type: 'language', subtag: 'rn', prefix: [], scope: null },
    { type: 'language', subtag: 'ro', prefix: [], scope: null },
    { type: 'language', subtag: 'ru', prefix: [], scope: null },
    { type: 'language', subtag: 'rw', prefix: [], scope: null },
    { type: 'language', subtag: 'sa', prefix: [], scope: null },
    { type: 'language', subtag: 'sc', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'sd', prefix: [], scope: null },
    { type: 'language', subtag: 'se', prefix: [], scope: null },
    { type: 'language', subtag: 'sg', prefix: [], scope: null },
    { type: 'language', subtag: 'sh', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'si', prefix: [], scope: null },
    { type: 'language', subtag: 'sk', prefix: [], scope: null },
    { type: 'language', subtag: 'sl', prefix: [], scope: null },
    { type: 'language', subtag: 'sm', prefix: [], scope: null },
    { type: 'language', subtag: 'sn', prefix: [], scope: null },
    { type: 'language', subtag: 'so', prefix: [], scope: null },
    { type: 'language', subtag: 'sq', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'sr', prefix: [], scope: null },
    { type: 'language', subtag: 'ss', prefix: [], scope: null },
    { type: 'language', subtag: 'st', prefix: [], scope: null },
    { type: 'language', subtag: 'su', prefix: [], scope: null },
    { type: 'language', subtag: 'sv', prefix: [], scope: null },
    { type: 'language', subtag: 'sw', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ta', prefix: [], scope: null },
    { type: 'language', subtag: 'te', prefix: [], scope: null },
    { type: 'language', subtag: 'tg', prefix: [], scope: null },
    { type: 'language', subtag: 'th', prefix: [], scope: null },
    { type: 'language', subtag: 'ti', prefix: [], scope: null },
    { type: 'language', subtag: 'tk', prefix: [], scope: null },
    { type: 'language', subtag: 'tl', prefix: [], scope: null },
    { type: 'language', subtag: 'tn', prefix: [], scope: null },
    { type: 'language', subtag: 'to', prefix: [], scope: null },
    { type: 'language', subtag: 'tr', prefix: [], scope: null },
    { type: 'language', subtag: 'ts', prefix: [], scope: null },
    { type: 'language', subtag: 'tt', prefix: [], scope: null },
    { type: 'language', subtag: 'tw', prefix: [], scope: null },
    { type: 'language', subtag: 'ty', prefix: [], scope: null },
    { type: 'language', subtag: 'ug', prefix: [], scope: null },
    { type: 'language', subtag: 'uk', prefix: [], scope: null },
    { type: 'language', subtag: 'ur', prefix: [], scope: null },
    { type: 'language', subtag: 'uz', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 've', prefix: [], scope: null },
    { type: 'language', subtag: 'vi', prefix: [], scope: null },
    { type: 'language', subtag: 'vo', prefix: [], scope: null },
    { type: 'language', subtag: 'wa', prefix: [], scope: null },
    { type: 'language', subtag: 'wo', prefix: [], scope: null },
    { type: 'language', subtag: 'xh', prefix: [], scope: null },
    { type: 'language', subtag: 'yi', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'yo', prefix: [], scope: null },
    { type: 'language', subtag: 'za', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'zh', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'zu', prefix: [], scope: null },
    { type: 'language', subtag: 'aaa', prefix: [], scope: null },
    { type: 'language', subtag: 'aab', prefix: [], scope: null },
    { type: 'language', subtag: 'aac', prefix: [], scope: null },
    { type: 'language', subtag: 'aad', prefix: [], scope: null },
    { type: 'language', subtag: 'aae', prefix: [], scope: null },
    { type: 'language', subtag: 'aaf', prefix: [], scope: null },
    { type: 'language', subtag: 'aag', prefix: [], scope: null },
    { type: 'language', subtag: 'aah', prefix: [], scope: null },
    { type: 'language', subtag: 'aai', prefix: [], scope: null },
    { type: 'language', subtag: 'aak', prefix: [], scope: null },
    { type: 'language', subtag: 'aal', prefix: [], scope: null },
    { type: 'language', subtag: 'aam', prefix: [], scope: null },
    { type: 'language', subtag: 'aan', prefix: [], scope: null },
    { type: 'language', subtag: 'aao', prefix: [], scope: null },
    { type: 'language', subtag: 'aap', prefix: [], scope: null },
    { type: 'language', subtag: 'aaq', prefix: [], scope: null },
    { type: 'language', subtag: 'aas', prefix: [], scope: null },
    { type: 'language', subtag: 'aat', prefix: [], scope: null },
    { type: 'language', subtag: 'aau', prefix: [], scope: null },
    { type: 'language', subtag: 'aav', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aaw', prefix: [], scope: null },
    { type: 'language', subtag: 'aax', prefix: [], scope: null },
    { type: 'language', subtag: 'aaz', prefix: [], scope: null },
    { type: 'language', subtag: 'aba', prefix: [], scope: null },
    { type: 'language', subtag: 'abb', prefix: [], scope: null },
    { type: 'language', subtag: 'abc', prefix: [], scope: null },
    { type: 'language', subtag: 'abd', prefix: [], scope: null },
    { type: 'language', subtag: 'abe', prefix: [], scope: null },
    { type: 'language', subtag: 'abf', prefix: [], scope: null },
    { type: 'language', subtag: 'abg', prefix: [], scope: null },
    { type: 'language', subtag: 'abh', prefix: [], scope: null },
    { type: 'language', subtag: 'abi', prefix: [], scope: null },
    { type: 'language', subtag: 'abj', prefix: [], scope: null },
    { type: 'language', subtag: 'abl', prefix: [], scope: null },
    { type: 'language', subtag: 'abm', prefix: [], scope: null },
    { type: 'language', subtag: 'abn', prefix: [], scope: null },
    { type: 'language', subtag: 'abo', prefix: [], scope: null },
    { type: 'language', subtag: 'abp', prefix: [], scope: null },
    { type: 'language', subtag: 'abq', prefix: [], scope: null },
    { type: 'language', subtag: 'abr', prefix: [], scope: null },
    { type: 'language', subtag: 'abs', prefix: [], scope: null },
    { type: 'language', subtag: 'abt', prefix: [], scope: null },
    { type: 'language', subtag: 'abu', prefix: [], scope: null },
    { type: 'language', subtag: 'abv', prefix: [], scope: null },
    { type: 'language', subtag: 'abw', prefix: [], scope: null },
    { type: 'language', subtag: 'abx', prefix: [], scope: null },
    { type: 'language', subtag: 'aby', prefix: [], scope: null },
    { type: 'language', subtag: 'abz', prefix: [], scope: null },
    { type: 'language', subtag: 'aca', prefix: [], scope: null },
    { type: 'language', subtag: 'acb', prefix: [], scope: null },
    { type: 'language', subtag: 'acd', prefix: [], scope: null },
    { type: 'language', subtag: 'ace', prefix: [], scope: null },
    { type: 'language', subtag: 'acf', prefix: [], scope: null },
    { type: 'language', subtag: 'ach', prefix: [], scope: null },
    { type: 'language', subtag: 'aci', prefix: [], scope: null },
    { type: 'language', subtag: 'ack', prefix: [], scope: null },
    { type: 'language', subtag: 'acl', prefix: [], scope: null },
    { type: 'language', subtag: 'acm', prefix: [], scope: null },
    { type: 'language', subtag: 'acn', prefix: [], scope: null },
    { type: 'language', subtag: 'acp', prefix: [], scope: null },
    { type: 'language', subtag: 'acq', prefix: [], scope: null },
    { type: 'language', subtag: 'acr', prefix: [], scope: null },
    { type: 'language', subtag: 'acs', prefix: [], scope: null },
    { type: 'language', subtag: 'act', prefix: [], scope: null },
    { type: 'language', subtag: 'acu', prefix: [], scope: null },
    { type: 'language', subtag: 'acv', prefix: [], scope: null },
    { type: 'language', subtag: 'acw', prefix: [], scope: null },
    { type: 'language', subtag: 'acx', prefix: [], scope: null },
    { type: 'language', subtag: 'acy', prefix: [], scope: null },
    { type: 'language', subtag: 'acz', prefix: [], scope: null },
    { type: 'language', subtag: 'ada', prefix: [], scope: null },
    { type: 'language', subtag: 'adb', prefix: [], scope: null },
    { type: 'language', subtag: 'add', prefix: [], scope: null },
    { type: 'language', subtag: 'ade', prefix: [], scope: null },
    { type: 'language', subtag: 'adf', prefix: [], scope: null },
    { type: 'language', subtag: 'adg', prefix: [], scope: null },
    { type: 'language', subtag: 'adh', prefix: [], scope: null },
    { type: 'language', subtag: 'adi', prefix: [], scope: null },
    { type: 'language', subtag: 'adj', prefix: [], scope: null },
    { type: 'language', subtag: 'adl', prefix: [], scope: null },
    { type: 'language', subtag: 'adn', prefix: [], scope: null },
    { type: 'language', subtag: 'ado', prefix: [], scope: null },
    { type: 'language', subtag: 'adp', prefix: [], scope: null },
    { type: 'language', subtag: 'adq', prefix: [], scope: null },
    { type: 'language', subtag: 'adr', prefix: [], scope: null },
    { type: 'language', subtag: 'ads', prefix: [], scope: null },
    { type: 'language', subtag: 'adt', prefix: [], scope: null },
    { type: 'language', subtag: 'adu', prefix: [], scope: null },
    { type: 'language', subtag: 'adw', prefix: [], scope: null },
    { type: 'language', subtag: 'adx', prefix: [], scope: null },
    { type: 'language', subtag: 'ady', prefix: [], scope: null },
    { type: 'language', subtag: 'adz', prefix: [], scope: null },
    { type: 'language', subtag: 'aea', prefix: [], scope: null },
    { type: 'language', subtag: 'aeb', prefix: [], scope: null },
    { type: 'language', subtag: 'aec', prefix: [], scope: null },
    { type: 'language', subtag: 'aed', prefix: [], scope: null },
    { type: 'language', subtag: 'aee', prefix: [], scope: null },
    { type: 'language', subtag: 'aek', prefix: [], scope: null },
    { type: 'language', subtag: 'ael', prefix: [], scope: null },
    { type: 'language', subtag: 'aem', prefix: [], scope: null },
    { type: 'language', subtag: 'aen', prefix: [], scope: null },
    { type: 'language', subtag: 'aeq', prefix: [], scope: null },
    { type: 'language', subtag: 'aer', prefix: [], scope: null },
    { type: 'language', subtag: 'aes', prefix: [], scope: null },
    { type: 'language', subtag: 'aeu', prefix: [], scope: null },
    { type: 'language', subtag: 'aew', prefix: [], scope: null },
    { type: 'language', subtag: 'aey', prefix: [], scope: null },
    { type: 'language', subtag: 'aez', prefix: [], scope: null },
    { type: 'language', subtag: 'afa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'afb', prefix: [], scope: null },
    { type: 'language', subtag: 'afd', prefix: [], scope: null },
    { type: 'language', subtag: 'afe', prefix: [], scope: null },
    { type: 'language', subtag: 'afg', prefix: [], scope: null },
    { type: 'language', subtag: 'afh', prefix: [], scope: null },
    { type: 'language', subtag: 'afi', prefix: [], scope: null },
    { type: 'language', subtag: 'afk', prefix: [], scope: null },
    { type: 'language', subtag: 'afn', prefix: [], scope: null },
    { type: 'language', subtag: 'afo', prefix: [], scope: null },
    { type: 'language', subtag: 'afp', prefix: [], scope: null },
    { type: 'language', subtag: 'afs', prefix: [], scope: null },
    { type: 'language', subtag: 'aft', prefix: [], scope: null },
    { type: 'language', subtag: 'afu', prefix: [], scope: null },
    { type: 'language', subtag: 'afz', prefix: [], scope: null },
    { type: 'language', subtag: 'aga', prefix: [], scope: null },
    { type: 'language', subtag: 'agb', prefix: [], scope: null },
    { type: 'language', subtag: 'agc', prefix: [], scope: null },
    { type: 'language', subtag: 'agd', prefix: [], scope: null },
    { type: 'language', subtag: 'age', prefix: [], scope: null },
    { type: 'language', subtag: 'agf', prefix: [], scope: null },
    { type: 'language', subtag: 'agg', prefix: [], scope: null },
    { type: 'language', subtag: 'agh', prefix: [], scope: null },
    { type: 'language', subtag: 'agi', prefix: [], scope: null },
    { type: 'language', subtag: 'agj', prefix: [], scope: null },
    { type: 'language', subtag: 'agk', prefix: [], scope: null },
    { type: 'language', subtag: 'agl', prefix: [], scope: null },
    { type: 'language', subtag: 'agm', prefix: [], scope: null },
    { type: 'language', subtag: 'agn', prefix: [], scope: null },
    { type: 'language', subtag: 'ago', prefix: [], scope: null },
    { type: 'language', subtag: 'agp', prefix: [], scope: null },
    { type: 'language', subtag: 'agq', prefix: [], scope: null },
    { type: 'language', subtag: 'agr', prefix: [], scope: null },
    { type: 'language', subtag: 'ags', prefix: [], scope: null },
    { type: 'language', subtag: 'agt', prefix: [], scope: null },
    { type: 'language', subtag: 'agu', prefix: [], scope: null },
    { type: 'language', subtag: 'agv', prefix: [], scope: null },
    { type: 'language', subtag: 'agw', prefix: [], scope: null },
    { type: 'language', subtag: 'agx', prefix: [], scope: null },
    { type: 'language', subtag: 'agy', prefix: [], scope: null },
    { type: 'language', subtag: 'agz', prefix: [], scope: null },
    { type: 'language', subtag: 'aha', prefix: [], scope: null },
    { type: 'language', subtag: 'ahb', prefix: [], scope: null },
    { type: 'language', subtag: 'ahg', prefix: [], scope: null },
    { type: 'language', subtag: 'ahh', prefix: [], scope: null },
    { type: 'language', subtag: 'ahi', prefix: [], scope: null },
    { type: 'language', subtag: 'ahk', prefix: [], scope: null },
    { type: 'language', subtag: 'ahl', prefix: [], scope: null },
    { type: 'language', subtag: 'ahm', prefix: [], scope: null },
    { type: 'language', subtag: 'ahn', prefix: [], scope: null },
    { type: 'language', subtag: 'aho', prefix: [], scope: null },
    { type: 'language', subtag: 'ahp', prefix: [], scope: null },
    { type: 'language', subtag: 'ahr', prefix: [], scope: null },
    { type: 'language', subtag: 'ahs', prefix: [], scope: null },
    { type: 'language', subtag: 'aht', prefix: [], scope: null },
    { type: 'language', subtag: 'aia', prefix: [], scope: null },
    { type: 'language', subtag: 'aib', prefix: [], scope: null },
    { type: 'language', subtag: 'aic', prefix: [], scope: null },
    { type: 'language', subtag: 'aid', prefix: [], scope: null },
    { type: 'language', subtag: 'aie', prefix: [], scope: null },
    { type: 'language', subtag: 'aif', prefix: [], scope: null },
    { type: 'language', subtag: 'aig', prefix: [], scope: null },
    { type: 'language', subtag: 'aih', prefix: [], scope: null },
    { type: 'language', subtag: 'aii', prefix: [], scope: null },
    { type: 'language', subtag: 'aij', prefix: [], scope: null },
    { type: 'language', subtag: 'aik', prefix: [], scope: null },
    { type: 'language', subtag: 'ail', prefix: [], scope: null },
    { type: 'language', subtag: 'aim', prefix: [], scope: null },
    { type: 'language', subtag: 'ain', prefix: [], scope: null },
    { type: 'language', subtag: 'aio', prefix: [], scope: null },
    { type: 'language', subtag: 'aip', prefix: [], scope: null },
    { type: 'language', subtag: 'aiq', prefix: [], scope: null },
    { type: 'language', subtag: 'air', prefix: [], scope: null },
    { type: 'language', subtag: 'ais', prefix: [], scope: null },
    { type: 'language', subtag: 'ait', prefix: [], scope: null },
    { type: 'language', subtag: 'aiw', prefix: [], scope: null },
    { type: 'language', subtag: 'aix', prefix: [], scope: null },
    { type: 'language', subtag: 'aiy', prefix: [], scope: null },
    { type: 'language', subtag: 'aja', prefix: [], scope: null },
    { type: 'language', subtag: 'ajg', prefix: [], scope: null },
    { type: 'language', subtag: 'aji', prefix: [], scope: null },
    { type: 'language', subtag: 'ajn', prefix: [], scope: null },
    { type: 'language', subtag: 'ajp', prefix: [], scope: null },
    { type: 'language', subtag: 'ajs', prefix: [], scope: null },
    { type: 'language', subtag: 'ajt', prefix: [], scope: null },
    { type: 'language', subtag: 'aju', prefix: [], scope: null },
    { type: 'language', subtag: 'ajw', prefix: [], scope: null },
    { type: 'language', subtag: 'ajz', prefix: [], scope: null },
    { type: 'language', subtag: 'akb', prefix: [], scope: null },
    { type: 'language', subtag: 'akc', prefix: [], scope: null },
    { type: 'language', subtag: 'akd', prefix: [], scope: null },
    { type: 'language', subtag: 'ake', prefix: [], scope: null },
    { type: 'language', subtag: 'akf', prefix: [], scope: null },
    { type: 'language', subtag: 'akg', prefix: [], scope: null },
    { type: 'language', subtag: 'akh', prefix: [], scope: null },
    { type: 'language', subtag: 'aki', prefix: [], scope: null },
    { type: 'language', subtag: 'akj', prefix: [], scope: null },
    { type: 'language', subtag: 'akk', prefix: [], scope: null },
    { type: 'language', subtag: 'akl', prefix: [], scope: null },
    { type: 'language', subtag: 'akm', prefix: [], scope: null },
    { type: 'language', subtag: 'ako', prefix: [], scope: null },
    { type: 'language', subtag: 'akp', prefix: [], scope: null },
    { type: 'language', subtag: 'akq', prefix: [], scope: null },
    { type: 'language', subtag: 'akr', prefix: [], scope: null },
    { type: 'language', subtag: 'aks', prefix: [], scope: null },
    { type: 'language', subtag: 'akt', prefix: [], scope: null },
    { type: 'language', subtag: 'aku', prefix: [], scope: null },
    { type: 'language', subtag: 'akv', prefix: [], scope: null },
    { type: 'language', subtag: 'akw', prefix: [], scope: null },
    { type: 'language', subtag: 'akx', prefix: [], scope: null },
    { type: 'language', subtag: 'aky', prefix: [], scope: null },
    { type: 'language', subtag: 'akz', prefix: [], scope: null },
    { type: 'language', subtag: 'ala', prefix: [], scope: null },
    { type: 'language', subtag: 'alc', prefix: [], scope: null },
    { type: 'language', subtag: 'ald', prefix: [], scope: null },
    { type: 'language', subtag: 'ale', prefix: [], scope: null },
    { type: 'language', subtag: 'alf', prefix: [], scope: null },
    { type: 'language', subtag: 'alg', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'alh', prefix: [], scope: null },
    { type: 'language', subtag: 'ali', prefix: [], scope: null },
    { type: 'language', subtag: 'alj', prefix: [], scope: null },
    { type: 'language', subtag: 'alk', prefix: [], scope: null },
    { type: 'language', subtag: 'all', prefix: [], scope: null },
    { type: 'language', subtag: 'alm', prefix: [], scope: null },
    { type: 'language', subtag: 'aln', prefix: [], scope: null },
    { type: 'language', subtag: 'alo', prefix: [], scope: null },
    { type: 'language', subtag: 'alp', prefix: [], scope: null },
    { type: 'language', subtag: 'alq', prefix: [], scope: null },
    { type: 'language', subtag: 'alr', prefix: [], scope: null },
    { type: 'language', subtag: 'als', prefix: [], scope: null },
    { type: 'language', subtag: 'alt', prefix: [], scope: null },
    { type: 'language', subtag: 'alu', prefix: [], scope: null },
    { type: 'language', subtag: 'alv', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'alw', prefix: [], scope: null },
    { type: 'language', subtag: 'alx', prefix: [], scope: null },
    { type: 'language', subtag: 'aly', prefix: [], scope: null },
    { type: 'language', subtag: 'alz', prefix: [], scope: null },
    { type: 'language', subtag: 'ama', prefix: [], scope: null },
    { type: 'language', subtag: 'amb', prefix: [], scope: null },
    { type: 'language', subtag: 'amc', prefix: [], scope: null },
    { type: 'language', subtag: 'ame', prefix: [], scope: null },
    { type: 'language', subtag: 'amf', prefix: [], scope: null },
    { type: 'language', subtag: 'amg', prefix: [], scope: null },
    { type: 'language', subtag: 'ami', prefix: [], scope: null },
    { type: 'language', subtag: 'amj', prefix: [], scope: null },
    { type: 'language', subtag: 'amk', prefix: [], scope: null },
    { type: 'language', subtag: 'aml', prefix: [], scope: null },
    { type: 'language', subtag: 'amm', prefix: [], scope: null },
    { type: 'language', subtag: 'amn', prefix: [], scope: null },
    { type: 'language', subtag: 'amo', prefix: [], scope: null },
    { type: 'language', subtag: 'amp', prefix: [], scope: null },
    { type: 'language', subtag: 'amq', prefix: [], scope: null },
    { type: 'language', subtag: 'amr', prefix: [], scope: null },
    { type: 'language', subtag: 'ams', prefix: [], scope: null },
    { type: 'language', subtag: 'amt', prefix: [], scope: null },
    { type: 'language', subtag: 'amu', prefix: [], scope: null },
    { type: 'language', subtag: 'amv', prefix: [], scope: null },
    { type: 'language', subtag: 'amw', prefix: [], scope: null },
    { type: 'language', subtag: 'amx', prefix: [], scope: null },
    { type: 'language', subtag: 'amy', prefix: [], scope: null },
    { type: 'language', subtag: 'amz', prefix: [], scope: null },
    { type: 'language', subtag: 'ana', prefix: [], scope: null },
    { type: 'language', subtag: 'anb', prefix: [], scope: null },
    { type: 'language', subtag: 'anc', prefix: [], scope: null },
    { type: 'language', subtag: 'and', prefix: [], scope: null },
    { type: 'language', subtag: 'ane', prefix: [], scope: null },
    { type: 'language', subtag: 'anf', prefix: [], scope: null },
    { type: 'language', subtag: 'ang', prefix: [], scope: null },
    { type: 'language', subtag: 'anh', prefix: [], scope: null },
    { type: 'language', subtag: 'ani', prefix: [], scope: null },
    { type: 'language', subtag: 'anj', prefix: [], scope: null },
    { type: 'language', subtag: 'ank', prefix: [], scope: null },
    { type: 'language', subtag: 'anl', prefix: [], scope: null },
    { type: 'language', subtag: 'anm', prefix: [], scope: null },
    { type: 'language', subtag: 'ann', prefix: [], scope: null },
    { type: 'language', subtag: 'ano', prefix: [], scope: null },
    { type: 'language', subtag: 'anp', prefix: [], scope: null },
    { type: 'language', subtag: 'anq', prefix: [], scope: null },
    { type: 'language', subtag: 'anr', prefix: [], scope: null },
    { type: 'language', subtag: 'ans', prefix: [], scope: null },
    { type: 'language', subtag: 'ant', prefix: [], scope: null },
    { type: 'language', subtag: 'anu', prefix: [], scope: null },
    { type: 'language', subtag: 'anv', prefix: [], scope: null },
    { type: 'language', subtag: 'anw', prefix: [], scope: null },
    { type: 'language', subtag: 'anx', prefix: [], scope: null },
    { type: 'language', subtag: 'any', prefix: [], scope: null },
    { type: 'language', subtag: 'anz', prefix: [], scope: null },
    { type: 'language', subtag: 'aoa', prefix: [], scope: null },
    { type: 'language', subtag: 'aob', prefix: [], scope: null },
    { type: 'language', subtag: 'aoc', prefix: [], scope: null },
    { type: 'language', subtag: 'aod', prefix: [], scope: null },
    { type: 'language', subtag: 'aoe', prefix: [], scope: null },
    { type: 'language', subtag: 'aof', prefix: [], scope: null },
    { type: 'language', subtag: 'aog', prefix: [], scope: null },
    { type: 'language', subtag: 'aoh', prefix: [], scope: null },
    { type: 'language', subtag: 'aoi', prefix: [], scope: null },
    { type: 'language', subtag: 'aoj', prefix: [], scope: null },
    { type: 'language', subtag: 'aok', prefix: [], scope: null },
    { type: 'language', subtag: 'aol', prefix: [], scope: null },
    { type: 'language', subtag: 'aom', prefix: [], scope: null },
    { type: 'language', subtag: 'aon', prefix: [], scope: null },
    { type: 'language', subtag: 'aor', prefix: [], scope: null },
    { type: 'language', subtag: 'aos', prefix: [], scope: null },
    { type: 'language', subtag: 'aot', prefix: [], scope: null },
    { type: 'language', subtag: 'aou', prefix: [], scope: null },
    { type: 'language', subtag: 'aox', prefix: [], scope: null },
    { type: 'language', subtag: 'aoz', prefix: [], scope: null },
    { type: 'language', subtag: 'apa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'apb', prefix: [], scope: null },
    { type: 'language', subtag: 'apc', prefix: [], scope: null },
    { type: 'language', subtag: 'apd', prefix: [], scope: null },
    { type: 'language', subtag: 'ape', prefix: [], scope: null },
    { type: 'language', subtag: 'apf', prefix: [], scope: null },
    { type: 'language', subtag: 'apg', prefix: [], scope: null },
    { type: 'language', subtag: 'aph', prefix: [], scope: null },
    { type: 'language', subtag: 'api', prefix: [], scope: null },
    { type: 'language', subtag: 'apj', prefix: [], scope: null },
    { type: 'language', subtag: 'apk', prefix: [], scope: null },
    { type: 'language', subtag: 'apl', prefix: [], scope: null },
    { type: 'language', subtag: 'apm', prefix: [], scope: null },
    { type: 'language', subtag: 'apn', prefix: [], scope: null },
    { type: 'language', subtag: 'apo', prefix: [], scope: null },
    { type: 'language', subtag: 'app', prefix: [], scope: null },
    { type: 'language', subtag: 'apq', prefix: [], scope: null },
    { type: 'language', subtag: 'apr', prefix: [], scope: null },
    { type: 'language', subtag: 'aps', prefix: [], scope: null },
    { type: 'language', subtag: 'apt', prefix: [], scope: null },
    { type: 'language', subtag: 'apu', prefix: [], scope: null },
    { type: 'language', subtag: 'apv', prefix: [], scope: null },
    { type: 'language', subtag: 'apw', prefix: [], scope: null },
    { type: 'language', subtag: 'apx', prefix: [], scope: null },
    { type: 'language', subtag: 'apy', prefix: [], scope: null },
    { type: 'language', subtag: 'apz', prefix: [], scope: null },
    { type: 'language', subtag: 'aqa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aqc', prefix: [], scope: null },
    { type: 'language', subtag: 'aqd', prefix: [], scope: null },
    { type: 'language', subtag: 'aqg', prefix: [], scope: null },
    { type: 'language', subtag: 'aqk', prefix: [], scope: null },
    { type: 'language', subtag: 'aql', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aqm', prefix: [], scope: null },
    { type: 'language', subtag: 'aqn', prefix: [], scope: null },
    { type: 'language', subtag: 'aqp', prefix: [], scope: null },
    { type: 'language', subtag: 'aqr', prefix: [], scope: null },
    { type: 'language', subtag: 'aqt', prefix: [], scope: null },
    { type: 'language', subtag: 'aqz', prefix: [], scope: null },
    { type: 'language', subtag: 'arb', prefix: [], scope: null },
    { type: 'language', subtag: 'arc', prefix: [], scope: null },
    { type: 'language', subtag: 'ard', prefix: [], scope: null },
    { type: 'language', subtag: 'are', prefix: [], scope: null },
    { type: 'language', subtag: 'arh', prefix: [], scope: null },
    { type: 'language', subtag: 'ari', prefix: [], scope: null },
    { type: 'language', subtag: 'arj', prefix: [], scope: null },
    { type: 'language', subtag: 'ark', prefix: [], scope: null },
    { type: 'language', subtag: 'arl', prefix: [], scope: null },
    { type: 'language', subtag: 'arn', prefix: [], scope: null },
    { type: 'language', subtag: 'aro', prefix: [], scope: null },
    { type: 'language', subtag: 'arp', prefix: [], scope: null },
    { type: 'language', subtag: 'arq', prefix: [], scope: null },
    { type: 'language', subtag: 'arr', prefix: [], scope: null },
    { type: 'language', subtag: 'ars', prefix: [], scope: null },
    { type: 'language', subtag: 'art', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aru', prefix: [], scope: null },
    { type: 'language', subtag: 'arv', prefix: [], scope: null },
    { type: 'language', subtag: 'arw', prefix: [], scope: null },
    { type: 'language', subtag: 'arx', prefix: [], scope: null },
    { type: 'language', subtag: 'ary', prefix: [], scope: null },
    { type: 'language', subtag: 'arz', prefix: [], scope: null },
    { type: 'language', subtag: 'asa', prefix: [], scope: null },
    { type: 'language', subtag: 'asb', prefix: [], scope: null },
    { type: 'language', subtag: 'asc', prefix: [], scope: null },
    { type: 'language', subtag: 'asd', prefix: [], scope: null },
    { type: 'language', subtag: 'ase', prefix: [], scope: null },
    { type: 'language', subtag: 'asf', prefix: [], scope: null },
    { type: 'language', subtag: 'asg', prefix: [], scope: null },
    { type: 'language', subtag: 'ash', prefix: [], scope: null },
    { type: 'language', subtag: 'asi', prefix: [], scope: null },
    { type: 'language', subtag: 'asj', prefix: [], scope: null },
    { type: 'language', subtag: 'ask', prefix: [], scope: null },
    { type: 'language', subtag: 'asl', prefix: [], scope: null },
    { type: 'language', subtag: 'asn', prefix: [], scope: null },
    { type: 'language', subtag: 'aso', prefix: [], scope: null },
    { type: 'language', subtag: 'asp', prefix: [], scope: null },
    { type: 'language', subtag: 'asq', prefix: [], scope: null },
    { type: 'language', subtag: 'asr', prefix: [], scope: null },
    { type: 'language', subtag: 'ass', prefix: [], scope: null },
    { type: 'language', subtag: 'ast', prefix: [], scope: null },
    { type: 'language', subtag: 'asu', prefix: [], scope: null },
    { type: 'language', subtag: 'asv', prefix: [], scope: null },
    { type: 'language', subtag: 'asw', prefix: [], scope: null },
    { type: 'language', subtag: 'asx', prefix: [], scope: null },
    { type: 'language', subtag: 'asy', prefix: [], scope: null },
    { type: 'language', subtag: 'asz', prefix: [], scope: null },
    { type: 'language', subtag: 'ata', prefix: [], scope: null },
    { type: 'language', subtag: 'atb', prefix: [], scope: null },
    { type: 'language', subtag: 'atc', prefix: [], scope: null },
    { type: 'language', subtag: 'atd', prefix: [], scope: null },
    { type: 'language', subtag: 'ate', prefix: [], scope: null },
    { type: 'language', subtag: 'atg', prefix: [], scope: null },
    { type: 'language', subtag: 'ath', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ati', prefix: [], scope: null },
    { type: 'language', subtag: 'atj', prefix: [], scope: null },
    { type: 'language', subtag: 'atk', prefix: [], scope: null },
    { type: 'language', subtag: 'atl', prefix: [], scope: null },
    { type: 'language', subtag: 'atm', prefix: [], scope: null },
    { type: 'language', subtag: 'atn', prefix: [], scope: null },
    { type: 'language', subtag: 'ato', prefix: [], scope: null },
    { type: 'language', subtag: 'atp', prefix: [], scope: null },
    { type: 'language', subtag: 'atq', prefix: [], scope: null },
    { type: 'language', subtag: 'atr', prefix: [], scope: null },
    { type: 'language', subtag: 'ats', prefix: [], scope: null },
    { type: 'language', subtag: 'att', prefix: [], scope: null },
    { type: 'language', subtag: 'atu', prefix: [], scope: null },
    { type: 'language', subtag: 'atv', prefix: [], scope: null },
    { type: 'language', subtag: 'atw', prefix: [], scope: null },
    { type: 'language', subtag: 'atx', prefix: [], scope: null },
    { type: 'language', subtag: 'aty', prefix: [], scope: null },
    { type: 'language', subtag: 'atz', prefix: [], scope: null },
    { type: 'language', subtag: 'aua', prefix: [], scope: null },
    { type: 'language', subtag: 'aub', prefix: [], scope: null },
    { type: 'language', subtag: 'auc', prefix: [], scope: null },
    { type: 'language', subtag: 'aud', prefix: [], scope: null },
    { type: 'language', subtag: 'aue', prefix: [], scope: null },
    { type: 'language', subtag: 'auf', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aug', prefix: [], scope: null },
    { type: 'language', subtag: 'auh', prefix: [], scope: null },
    { type: 'language', subtag: 'aui', prefix: [], scope: null },
    { type: 'language', subtag: 'auj', prefix: [], scope: null },
    { type: 'language', subtag: 'auk', prefix: [], scope: null },
    { type: 'language', subtag: 'aul', prefix: [], scope: null },
    { type: 'language', subtag: 'aum', prefix: [], scope: null },
    { type: 'language', subtag: 'aun', prefix: [], scope: null },
    { type: 'language', subtag: 'auo', prefix: [], scope: null },
    { type: 'language', subtag: 'aup', prefix: [], scope: null },
    { type: 'language', subtag: 'auq', prefix: [], scope: null },
    { type: 'language', subtag: 'aur', prefix: [], scope: null },
    { type: 'language', subtag: 'aus', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'aut', prefix: [], scope: null },
    { type: 'language', subtag: 'auu', prefix: [], scope: null },
    { type: 'language', subtag: 'auw', prefix: [], scope: null },
    { type: 'language', subtag: 'aux', prefix: [], scope: null },
    { type: 'language', subtag: 'auy', prefix: [], scope: null },
    { type: 'language', subtag: 'auz', prefix: [], scope: null },
    { type: 'language', subtag: 'avb', prefix: [], scope: null },
    { type: 'language', subtag: 'avd', prefix: [], scope: null },
    { type: 'language', subtag: 'avi', prefix: [], scope: null },
    { type: 'language', subtag: 'avk', prefix: [], scope: null },
    { type: 'language', subtag: 'avl', prefix: [], scope: null },
    { type: 'language', subtag: 'avm', prefix: [], scope: null },
    { type: 'language', subtag: 'avn', prefix: [], scope: null },
    { type: 'language', subtag: 'avo', prefix: [], scope: null },
    { type: 'language', subtag: 'avs', prefix: [], scope: null },
    { type: 'language', subtag: 'avt', prefix: [], scope: null },
    { type: 'language', subtag: 'avu', prefix: [], scope: null },
    { type: 'language', subtag: 'avv', prefix: [], scope: null },
    { type: 'language', subtag: 'awa', prefix: [], scope: null },
    { type: 'language', subtag: 'awb', prefix: [], scope: null },
    { type: 'language', subtag: 'awc', prefix: [], scope: null },
    { type: 'language', subtag: 'awd', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'awe', prefix: [], scope: null },
    { type: 'language', subtag: 'awg', prefix: [], scope: null },
    { type: 'language', subtag: 'awh', prefix: [], scope: null },
    { type: 'language', subtag: 'awi', prefix: [], scope: null },
    { type: 'language', subtag: 'awk', prefix: [], scope: null },
    { type: 'language', subtag: 'awm', prefix: [], scope: null },
    { type: 'language', subtag: 'awn', prefix: [], scope: null },
    { type: 'language', subtag: 'awo', prefix: [], scope: null },
    { type: 'language', subtag: 'awr', prefix: [], scope: null },
    { type: 'language', subtag: 'aws', prefix: [], scope: null },
    { type: 'language', subtag: 'awt', prefix: [], scope: null },
    { type: 'language', subtag: 'awu', prefix: [], scope: null },
    { type: 'language', subtag: 'awv', prefix: [], scope: null },
    { type: 'language', subtag: 'aww', prefix: [], scope: null },
    { type: 'language', subtag: 'awx', prefix: [], scope: null },
    { type: 'language', subtag: 'awy', prefix: [], scope: null },
    { type: 'language', subtag: 'axb', prefix: [], scope: null },
    { type: 'language', subtag: 'axe', prefix: [], scope: null },
    { type: 'language', subtag: 'axg', prefix: [], scope: null },
    { type: 'language', subtag: 'axk', prefix: [], scope: null },
    { type: 'language', subtag: 'axl', prefix: [], scope: null },
    { type: 'language', subtag: 'axm', prefix: [], scope: null },
    { type: 'language', subtag: 'axx', prefix: [], scope: null },
    { type: 'language', subtag: 'aya', prefix: [], scope: null },
    { type: 'language', subtag: 'ayb', prefix: [], scope: null },
    { type: 'language', subtag: 'ayc', prefix: [], scope: null },
    { type: 'language', subtag: 'ayd', prefix: [], scope: null },
    { type: 'language', subtag: 'aye', prefix: [], scope: null },
    { type: 'language', subtag: 'ayg', prefix: [], scope: null },
    { type: 'language', subtag: 'ayh', prefix: [], scope: null },
    { type: 'language', subtag: 'ayi', prefix: [], scope: null },
    { type: 'language', subtag: 'ayk', prefix: [], scope: null },
    { type: 'language', subtag: 'ayl', prefix: [], scope: null },
    { type: 'language', subtag: 'ayn', prefix: [], scope: null },
    { type: 'language', subtag: 'ayo', prefix: [], scope: null },
    { type: 'language', subtag: 'ayp', prefix: [], scope: null },
    { type: 'language', subtag: 'ayq', prefix: [], scope: null },
    { type: 'language', subtag: 'ayr', prefix: [], scope: null },
    { type: 'language', subtag: 'ays', prefix: [], scope: null },
    { type: 'language', subtag: 'ayt', prefix: [], scope: null },
    { type: 'language', subtag: 'ayu', prefix: [], scope: null },
    { type: 'language', subtag: 'ayx', prefix: [], scope: null },
    { type: 'language', subtag: 'ayy', prefix: [], scope: null },
    { type: 'language', subtag: 'ayz', prefix: [], scope: null },
    { type: 'language', subtag: 'aza', prefix: [], scope: null },
    { type: 'language', subtag: 'azb', prefix: [], scope: null },
    { type: 'language', subtag: 'azc', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'azd', prefix: [], scope: null },
    { type: 'language', subtag: 'azg', prefix: [], scope: null },
    { type: 'language', subtag: 'azj', prefix: [], scope: null },
    { type: 'language', subtag: 'azm', prefix: [], scope: null },
    { type: 'language', subtag: 'azn', prefix: [], scope: null },
    { type: 'language', subtag: 'azo', prefix: [], scope: null },
    { type: 'language', subtag: 'azt', prefix: [], scope: null },
    { type: 'language', subtag: 'azz', prefix: [], scope: null },
    { type: 'language', subtag: 'baa', prefix: [], scope: null },
    { type: 'language', subtag: 'bab', prefix: [], scope: null },
    { type: 'language', subtag: 'bac', prefix: [], scope: null },
    { type: 'language', subtag: 'bad', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'bae', prefix: [], scope: null },
    { type: 'language', subtag: 'baf', prefix: [], scope: null },
    { type: 'language', subtag: 'bag', prefix: [], scope: null },
    { type: 'language', subtag: 'bah', prefix: [], scope: null },
    { type: 'language', subtag: 'bai', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'baj', prefix: [], scope: null },
    { type: 'language', subtag: 'bal', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'ban', prefix: [], scope: null },
    { type: 'language', subtag: 'bao', prefix: [], scope: null },
    { type: 'language', subtag: 'bap', prefix: [], scope: null },
    { type: 'language', subtag: 'bar', prefix: [], scope: null },
    { type: 'language', subtag: 'bas', prefix: [], scope: null },
    { type: 'language', subtag: 'bat', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'bau', prefix: [], scope: null },
    { type: 'language', subtag: 'bav', prefix: [], scope: null },
    { type: 'language', subtag: 'baw', prefix: [], scope: null },
    { type: 'language', subtag: 'bax', prefix: [], scope: null },
    { type: 'language', subtag: 'bay', prefix: [], scope: null },
    { type: 'language', subtag: 'baz', prefix: [], scope: null },
    { type: 'language', subtag: 'bba', prefix: [], scope: null },
    { type: 'language', subtag: 'bbb', prefix: [], scope: null },
    { type: 'language', subtag: 'bbc', prefix: [], scope: null },
    { type: 'language', subtag: 'bbd', prefix: [], scope: null },
    { type: 'language', subtag: 'bbe', prefix: [], scope: null },
    { type: 'language', subtag: 'bbf', prefix: [], scope: null },
    { type: 'language', subtag: 'bbg', prefix: [], scope: null },
    { type: 'language', subtag: 'bbh', prefix: [], scope: null },
    { type: 'language', subtag: 'bbi', prefix: [], scope: null },
    { type: 'language', subtag: 'bbj', prefix: [], scope: null },
    { type: 'language', subtag: 'bbk', prefix: [], scope: null },
    { type: 'language', subtag: 'bbl', prefix: [], scope: null },
    { type: 'language', subtag: 'bbm', prefix: [], scope: null },
    { type: 'language', subtag: 'bbn', prefix: [], scope: null },
    { type: 'language', subtag: 'bbo', prefix: [], scope: null },
    { type: 'language', subtag: 'bbp', prefix: [], scope: null },
    { type: 'language', subtag: 'bbq', prefix: [], scope: null },
    { type: 'language', subtag: 'bbr', prefix: [], scope: null },
    { type: 'language', subtag: 'bbs', prefix: [], scope: null },
    { type: 'language', subtag: 'bbt', prefix: [], scope: null },
    { type: 'language', subtag: 'bbu', prefix: [], scope: null },
    { type: 'language', subtag: 'bbv', prefix: [], scope: null },
    { type: 'language', subtag: 'bbw', prefix: [], scope: null },
    { type: 'language', subtag: 'bbx', prefix: [], scope: null },
    { type: 'language', subtag: 'bby', prefix: [], scope: null },
    { type: 'language', subtag: 'bbz', prefix: [], scope: null },
    { type: 'language', subtag: 'bca', prefix: [], scope: null },
    { type: 'language', subtag: 'bcb', prefix: [], scope: null },
    { type: 'language', subtag: 'bcc', prefix: [], scope: null },
    { type: 'language', subtag: 'bcd', prefix: [], scope: null },
    { type: 'language', subtag: 'bce', prefix: [], scope: null },
    { type: 'language', subtag: 'bcf', prefix: [], scope: null },
    { type: 'language', subtag: 'bcg', prefix: [], scope: null },
    { type: 'language', subtag: 'bch', prefix: [], scope: null },
    { type: 'language', subtag: 'bci', prefix: [], scope: null },
    { type: 'language', subtag: 'bcj', prefix: [], scope: null },
    { type: 'language', subtag: 'bck', prefix: [], scope: null },
    { type: 'language', subtag: 'bcl', prefix: [], scope: null },
    { type: 'language', subtag: 'bcm', prefix: [], scope: null },
    { type: 'language', subtag: 'bcn', prefix: [], scope: null },
    { type: 'language', subtag: 'bco', prefix: [], scope: null },
    { type: 'language', subtag: 'bcp', prefix: [], scope: null },
    { type: 'language', subtag: 'bcq', prefix: [], scope: null },
    { type: 'language', subtag: 'bcr', prefix: [], scope: null },
    { type: 'language', subtag: 'bcs', prefix: [], scope: null },
    { type: 'language', subtag: 'bct', prefix: [], scope: null },
    { type: 'language', subtag: 'bcu', prefix: [], scope: null },
    { type: 'language', subtag: 'bcv', prefix: [], scope: null },
    { type: 'language', subtag: 'bcw', prefix: [], scope: null },
    { type: 'language', subtag: 'bcy', prefix: [], scope: null },
    { type: 'language', subtag: 'bcz', prefix: [], scope: null },
    { type: 'language', subtag: 'bda', prefix: [], scope: null },
    { type: 'language', subtag: 'bdb', prefix: [], scope: null },
    { type: 'language', subtag: 'bdc', prefix: [], scope: null },
    { type: 'language', subtag: 'bdd', prefix: [], scope: null },
    { type: 'language', subtag: 'bde', prefix: [], scope: null },
    { type: 'language', subtag: 'bdf', prefix: [], scope: null },
    { type: 'language', subtag: 'bdg', prefix: [], scope: null },
    { type: 'language', subtag: 'bdh', prefix: [], scope: null },
    { type: 'language', subtag: 'bdi', prefix: [], scope: null },
    { type: 'language', subtag: 'bdj', prefix: [], scope: null },
    { type: 'language', subtag: 'bdk', prefix: [], scope: null },
    { type: 'language', subtag: 'bdl', prefix: [], scope: null },
    { type: 'language', subtag: 'bdm', prefix: [], scope: null },
    { type: 'language', subtag: 'bdn', prefix: [], scope: null },
    { type: 'language', subtag: 'bdo', prefix: [], scope: null },
    { type: 'language', subtag: 'bdp', prefix: [], scope: null },
    { type: 'language', subtag: 'bdq', prefix: [], scope: null },
    { type: 'language', subtag: 'bdr', prefix: [], scope: null },
    { type: 'language', subtag: 'bds', prefix: [], scope: null },
    { type: 'language', subtag: 'bdt', prefix: [], scope: null },
    { type: 'language', subtag: 'bdu', prefix: [], scope: null },
    { type: 'language', subtag: 'bdv', prefix: [], scope: null },
    { type: 'language', subtag: 'bdw', prefix: [], scope: null },
    { type: 'language', subtag: 'bdx', prefix: [], scope: null },
    { type: 'language', subtag: 'bdy', prefix: [], scope: null },
    { type: 'language', subtag: 'bdz', prefix: [], scope: null },
    { type: 'language', subtag: 'bea', prefix: [], scope: null },
    { type: 'language', subtag: 'beb', prefix: [], scope: null },
    { type: 'language', subtag: 'bec', prefix: [], scope: null },
    { type: 'language', subtag: 'bed', prefix: [], scope: null },
    { type: 'language', subtag: 'bee', prefix: [], scope: null },
    { type: 'language', subtag: 'bef', prefix: [], scope: null },
    { type: 'language', subtag: 'beg', prefix: [], scope: null },
    { type: 'language', subtag: 'beh', prefix: [], scope: null },
    { type: 'language', subtag: 'bei', prefix: [], scope: null },
    { type: 'language', subtag: 'bej', prefix: [], scope: null },
    { type: 'language', subtag: 'bek', prefix: [], scope: null },
    { type: 'language', subtag: 'bem', prefix: [], scope: null },
    { type: 'language', subtag: 'beo', prefix: [], scope: null },
    { type: 'language', subtag: 'bep', prefix: [], scope: null },
    { type: 'language', subtag: 'beq', prefix: [], scope: null },
    { type: 'language', subtag: 'ber', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'bes', prefix: [], scope: null },
    { type: 'language', subtag: 'bet', prefix: [], scope: null },
    { type: 'language', subtag: 'beu', prefix: [], scope: null },
    { type: 'language', subtag: 'bev', prefix: [], scope: null },
    { type: 'language', subtag: 'bew', prefix: [], scope: null },
    { type: 'language', subtag: 'bex', prefix: [], scope: null },
    { type: 'language', subtag: 'bey', prefix: [], scope: null },
    { type: 'language', subtag: 'bez', prefix: [], scope: null },
    { type: 'language', subtag: 'bfa', prefix: [], scope: null },
    { type: 'language', subtag: 'bfb', prefix: [], scope: null },
    { type: 'language', subtag: 'bfc', prefix: [], scope: null },
    { type: 'language', subtag: 'bfd', prefix: [], scope: null },
    { type: 'language', subtag: 'bfe', prefix: [], scope: null },
    { type: 'language', subtag: 'bff', prefix: [], scope: null },
    { type: 'language', subtag: 'bfg', prefix: [], scope: null },
    { type: 'language', subtag: 'bfh', prefix: [], scope: null },
    { type: 'language', subtag: 'bfi', prefix: [], scope: null },
    { type: 'language', subtag: 'bfj', prefix: [], scope: null },
    { type: 'language', subtag: 'bfk', prefix: [], scope: null },
    { type: 'language', subtag: 'bfl', prefix: [], scope: null },
    { type: 'language', subtag: 'bfm', prefix: [], scope: null },
    { type: 'language', subtag: 'bfn', prefix: [], scope: null },
    { type: 'language', subtag: 'bfo', prefix: [], scope: null },
    { type: 'language', subtag: 'bfp', prefix: [], scope: null },
    { type: 'language', subtag: 'bfq', prefix: [], scope: null },
    { type: 'language', subtag: 'bfr', prefix: [], scope: null },
    { type: 'language', subtag: 'bfs', prefix: [], scope: null },
    { type: 'language', subtag: 'bft', prefix: [], scope: null },
    { type: 'language', subtag: 'bfu', prefix: [], scope: null },
    { type: 'language', subtag: 'bfw', prefix: [], scope: null },
    { type: 'language', subtag: 'bfx', prefix: [], scope: null },
    { type: 'language', subtag: 'bfy', prefix: [], scope: null },
    { type: 'language', subtag: 'bfz', prefix: [], scope: null },
    { type: 'language', subtag: 'bga', prefix: [], scope: null },
    { type: 'language', subtag: 'bgb', prefix: [], scope: null },
    { type: 'language', subtag: 'bgc', prefix: [], scope: null },
    { type: 'language', subtag: 'bgd', prefix: [], scope: null },
    { type: 'language', subtag: 'bge', prefix: [], scope: null },
    { type: 'language', subtag: 'bgf', prefix: [], scope: null },
    { type: 'language', subtag: 'bgg', prefix: [], scope: null },
    { type: 'language', subtag: 'bgi', prefix: [], scope: null },
    { type: 'language', subtag: 'bgj', prefix: [], scope: null },
    { type: 'language', subtag: 'bgk', prefix: [], scope: null },
    { type: 'language', subtag: 'bgl', prefix: [], scope: null },
    { type: 'language', subtag: 'bgm', prefix: [], scope: null },
    { type: 'language', subtag: 'bgn', prefix: [], scope: null },
    { type: 'language', subtag: 'bgo', prefix: [], scope: null },
    { type: 'language', subtag: 'bgp', prefix: [], scope: null },
    { type: 'language', subtag: 'bgq', prefix: [], scope: null },
    { type: 'language', subtag: 'bgr', prefix: [], scope: null },
    { type: 'language', subtag: 'bgs', prefix: [], scope: null },
    { type: 'language', subtag: 'bgt', prefix: [], scope: null },
    { type: 'language', subtag: 'bgu', prefix: [], scope: null },
    { type: 'language', subtag: 'bgv', prefix: [], scope: null },
    { type: 'language', subtag: 'bgw', prefix: [], scope: null },
    { type: 'language', subtag: 'bgx', prefix: [], scope: null },
    { type: 'language', subtag: 'bgy', prefix: [], scope: null },
    { type: 'language', subtag: 'bgz', prefix: [], scope: null },
    { type: 'language', subtag: 'bha', prefix: [], scope: null },
    { type: 'language', subtag: 'bhb', prefix: [], scope: null },
    { type: 'language', subtag: 'bhc', prefix: [], scope: null },
    { type: 'language', subtag: 'bhd', prefix: [], scope: null },
    { type: 'language', subtag: 'bhe', prefix: [], scope: null },
    { type: 'language', subtag: 'bhf', prefix: [], scope: null },
    { type: 'language', subtag: 'bhg', prefix: [], scope: null },
    { type: 'language', subtag: 'bhh', prefix: [], scope: null },
    { type: 'language', subtag: 'bhi', prefix: [], scope: null },
    { type: 'language', subtag: 'bhj', prefix: [], scope: null },
    { type: 'language', subtag: 'bhk', prefix: [], scope: null },
    { type: 'language', subtag: 'bhl', prefix: [], scope: null },
    { type: 'language', subtag: 'bhm', prefix: [], scope: null },
    { type: 'language', subtag: 'bhn', prefix: [], scope: null },
    { type: 'language', subtag: 'bho', prefix: [], scope: null },
    { type: 'language', subtag: 'bhp', prefix: [], scope: null },
    { type: 'language', subtag: 'bhq', prefix: [], scope: null },
    { type: 'language', subtag: 'bhr', prefix: [], scope: null },
    { type: 'language', subtag: 'bhs', prefix: [], scope: null },
    { type: 'language', subtag: 'bht', prefix: [], scope: null },
    { type: 'language', subtag: 'bhu', prefix: [], scope: null },
    { type: 'language', subtag: 'bhv', prefix: [], scope: null },
    { type: 'language', subtag: 'bhw', prefix: [], scope: null },
    { type: 'language', subtag: 'bhx', prefix: [], scope: null },
    { type: 'language', subtag: 'bhy', prefix: [], scope: null },
    { type: 'language', subtag: 'bhz', prefix: [], scope: null },
    { type: 'language', subtag: 'bia', prefix: [], scope: null },
    { type: 'language', subtag: 'bib', prefix: [], scope: null },
    { type: 'language', subtag: 'bic', prefix: [], scope: null },
    { type: 'language', subtag: 'bid', prefix: [], scope: null },
    { type: 'language', subtag: 'bie', prefix: [], scope: null },
    { type: 'language', subtag: 'bif', prefix: [], scope: null },
    { type: 'language', subtag: 'big', prefix: [], scope: null },
    { type: 'language', subtag: 'bij', prefix: [], scope: null },
    { type: 'language', subtag: 'bik', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'bil', prefix: [], scope: null },
    { type: 'language', subtag: 'bim', prefix: [], scope: null },
    { type: 'language', subtag: 'bin', prefix: [], scope: null },
    { type: 'language', subtag: 'bio', prefix: [], scope: null },
    { type: 'language', subtag: 'bip', prefix: [], scope: null },
    { type: 'language', subtag: 'biq', prefix: [], scope: null },
    { type: 'language', subtag: 'bir', prefix: [], scope: null },
    { type: 'language', subtag: 'bit', prefix: [], scope: null },
    { type: 'language', subtag: 'biu', prefix: [], scope: null },
    { type: 'language', subtag: 'biv', prefix: [], scope: null },
    { type: 'language', subtag: 'biw', prefix: [], scope: null },
    { type: 'language', subtag: 'bix', prefix: [], scope: null },
    { type: 'language', subtag: 'biy', prefix: [], scope: null },
    { type: 'language', subtag: 'biz', prefix: [], scope: null },
    { type: 'language', subtag: 'bja', prefix: [], scope: null },
    { type: 'language', subtag: 'bjb', prefix: [], scope: null },
    { type: 'language', subtag: 'bjc', prefix: [], scope: null },
    { type: 'language', subtag: 'bjd', prefix: [], scope: null },
    { type: 'language', subtag: 'bje', prefix: [], scope: null },
    { type: 'language', subtag: 'bjf', prefix: [], scope: null },
    { type: 'language', subtag: 'bjg', prefix: [], scope: null },
    { type: 'language', subtag: 'bjh', prefix: [], scope: null },
    { type: 'language', subtag: 'bji', prefix: [], scope: null },
    { type: 'language', subtag: 'bjj', prefix: [], scope: null },
    { type: 'language', subtag: 'bjk', prefix: [], scope: null },
    { type: 'language', subtag: 'bjl', prefix: [], scope: null },
    { type: 'language', subtag: 'bjm', prefix: [], scope: null },
    { type: 'language', subtag: 'bjn', prefix: [], scope: null },
    { type: 'language', subtag: 'bjo', prefix: [], scope: null },
    { type: 'language', subtag: 'bjp', prefix: [], scope: null },
    { type: 'language', subtag: 'bjq', prefix: [], scope: null },
    { type: 'language', subtag: 'bjr', prefix: [], scope: null },
    { type: 'language', subtag: 'bjs', prefix: [], scope: null },
    { type: 'language', subtag: 'bjt', prefix: [], scope: null },
    { type: 'language', subtag: 'bju', prefix: [], scope: null },
    { type: 'language', subtag: 'bjv', prefix: [], scope: null },
    { type: 'language', subtag: 'bjw', prefix: [], scope: null },
    { type: 'language', subtag: 'bjx', prefix: [], scope: null },
    { type: 'language', subtag: 'bjy', prefix: [], scope: null },
    { type: 'language', subtag: 'bjz', prefix: [], scope: null },
    { type: 'language', subtag: 'bka', prefix: [], scope: null },
    { type: 'language', subtag: 'bkb', prefix: [], scope: null },
    { type: 'language', subtag: 'bkc', prefix: [], scope: null },
    { type: 'language', subtag: 'bkd', prefix: [], scope: null },
    { type: 'language', subtag: 'bkf', prefix: [], scope: null },
    { type: 'language', subtag: 'bkg', prefix: [], scope: null },
    { type: 'language', subtag: 'bkh', prefix: [], scope: null },
    { type: 'language', subtag: 'bki', prefix: [], scope: null },
    { type: 'language', subtag: 'bkj', prefix: [], scope: null },
    { type: 'language', subtag: 'bkk', prefix: [], scope: null },
    { type: 'language', subtag: 'bkl', prefix: [], scope: null },
    { type: 'language', subtag: 'bkm', prefix: [], scope: null },
    { type: 'language', subtag: 'bkn', prefix: [], scope: null },
    { type: 'language', subtag: 'bko', prefix: [], scope: null },
    { type: 'language', subtag: 'bkp', prefix: [], scope: null },
    { type: 'language', subtag: 'bkq', prefix: [], scope: null },
    { type: 'language', subtag: 'bkr', prefix: [], scope: null },
    { type: 'language', subtag: 'bks', prefix: [], scope: null },
    { type: 'language', subtag: 'bkt', prefix: [], scope: null },
    { type: 'language', subtag: 'bku', prefix: [], scope: null },
    { type: 'language', subtag: 'bkv', prefix: [], scope: null },
    { type: 'language', subtag: 'bkw', prefix: [], scope: null },
    { type: 'language', subtag: 'bkx', prefix: [], scope: null },
    { type: 'language', subtag: 'bky', prefix: [], scope: null },
    { type: 'language', subtag: 'bkz', prefix: [], scope: null },
    { type: 'language', subtag: 'bla', prefix: [], scope: null },
    { type: 'language', subtag: 'blb', prefix: [], scope: null },
    { type: 'language', subtag: 'blc', prefix: [], scope: null },
    { type: 'language', subtag: 'bld', prefix: [], scope: null },
    { type: 'language', subtag: 'ble', prefix: [], scope: null },
    { type: 'language', subtag: 'blf', prefix: [], scope: null },
    { type: 'language', subtag: 'blg', prefix: [], scope: null },
    { type: 'language', subtag: 'blh', prefix: [], scope: null },
    { type: 'language', subtag: 'bli', prefix: [], scope: null },
    { type: 'language', subtag: 'blj', prefix: [], scope: null },
    { type: 'language', subtag: 'blk', prefix: [], scope: null },
    { type: 'language', subtag: 'bll', prefix: [], scope: null },
    { type: 'language', subtag: 'blm', prefix: [], scope: null },
    { type: 'language', subtag: 'bln', prefix: [], scope: null },
    { type: 'language', subtag: 'blo', prefix: [], scope: null },
    { type: 'language', subtag: 'blp', prefix: [], scope: null },
    { type: 'language', subtag: 'blq', prefix: [], scope: null },
    { type: 'language', subtag: 'blr', prefix: [], scope: null },
    { type: 'language', subtag: 'bls', prefix: [], scope: null },
    { type: 'language', subtag: 'blt', prefix: [], scope: null },
    { type: 'language', subtag: 'blv', prefix: [], scope: null },
    { type: 'language', subtag: 'blw', prefix: [], scope: null },
    { type: 'language', subtag: 'blx', prefix: [], scope: null },
    { type: 'language', subtag: 'bly', prefix: [], scope: null },
    { type: 'language', subtag: 'blz', prefix: [], scope: null },
    { type: 'language', subtag: 'bma', prefix: [], scope: null },
    { type: 'language', subtag: 'bmb', prefix: [], scope: null },
    { type: 'language', subtag: 'bmc', prefix: [], scope: null },
    { type: 'language', subtag: 'bmd', prefix: [], scope: null },
    { type: 'language', subtag: 'bme', prefix: [], scope: null },
    { type: 'language', subtag: 'bmf', prefix: [], scope: null },
    { type: 'language', subtag: 'bmg', prefix: [], scope: null },
    { type: 'language', subtag: 'bmh', prefix: [], scope: null },
    { type: 'language', subtag: 'bmi', prefix: [], scope: null },
    { type: 'language', subtag: 'bmj', prefix: [], scope: null },
    { type: 'language', subtag: 'bmk', prefix: [], scope: null },
    { type: 'language', subtag: 'bml', prefix: [], scope: null },
    { type: 'language', subtag: 'bmm', prefix: [], scope: null },
    { type: 'language', subtag: 'bmn', prefix: [], scope: null },
    { type: 'language', subtag: 'bmo', prefix: [], scope: null },
    { type: 'language', subtag: 'bmp', prefix: [], scope: null },
    { type: 'language', subtag: 'bmq', prefix: [], scope: null },
    { type: 'language', subtag: 'bmr', prefix: [], scope: null },
    { type: 'language', subtag: 'bms', prefix: [], scope: null },
    { type: 'language', subtag: 'bmt', prefix: [], scope: null },
    { type: 'language', subtag: 'bmu', prefix: [], scope: null },
    { type: 'language', subtag: 'bmv', prefix: [], scope: null },
    { type: 'language', subtag: 'bmw', prefix: [], scope: null },
    { type: 'language', subtag: 'bmx', prefix: [], scope: null },
    { type: 'language', subtag: 'bmy', prefix: [], scope: null },
    { type: 'language', subtag: 'bmz', prefix: [], scope: null },
    { type: 'language', subtag: 'bna', prefix: [], scope: null },
    { type: 'language', subtag: 'bnb', prefix: [], scope: null },
    { type: 'language', subtag: 'bnc', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'bnd', prefix: [], scope: null },
    { type: 'language', subtag: 'bne', prefix: [], scope: null },
    { type: 'language', subtag: 'bnf', prefix: [], scope: null },
    { type: 'language', subtag: 'bng', prefix: [], scope: null },
    { type: 'language', subtag: 'bni', prefix: [], scope: null },
    { type: 'language', subtag: 'bnj', prefix: [], scope: null },
    { type: 'language', subtag: 'bnk', prefix: [], scope: null },
    { type: 'language', subtag: 'bnl', prefix: [], scope: null },
    { type: 'language', subtag: 'bnm', prefix: [], scope: null },
    { type: 'language', subtag: 'bnn', prefix: [], scope: null },
    { type: 'language', subtag: 'bno', prefix: [], scope: null },
    { type: 'language', subtag: 'bnp', prefix: [], scope: null },
    { type: 'language', subtag: 'bnq', prefix: [], scope: null },
    { type: 'language', subtag: 'bnr', prefix: [], scope: null },
    { type: 'language', subtag: 'bns', prefix: [], scope: null },
    { type: 'language', subtag: 'bnt', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'bnu', prefix: [], scope: null },
    { type: 'language', subtag: 'bnv', prefix: [], scope: null },
    { type: 'language', subtag: 'bnw', prefix: [], scope: null },
    { type: 'language', subtag: 'bnx', prefix: [], scope: null },
    { type: 'language', subtag: 'bny', prefix: [], scope: null },
    { type: 'language', subtag: 'bnz', prefix: [], scope: null },
    { type: 'language', subtag: 'boa', prefix: [], scope: null },
    { type: 'language', subtag: 'bob', prefix: [], scope: null },
    { type: 'language', subtag: 'boe', prefix: [], scope: null },
    { type: 'language', subtag: 'bof', prefix: [], scope: null },
    { type: 'language', subtag: 'bog', prefix: [], scope: null },
    { type: 'language', subtag: 'boh', prefix: [], scope: null },
    { type: 'language', subtag: 'boi', prefix: [], scope: null },
    { type: 'language', subtag: 'boj', prefix: [], scope: null },
    { type: 'language', subtag: 'bok', prefix: [], scope: null },
    { type: 'language', subtag: 'bol', prefix: [], scope: null },
    { type: 'language', subtag: 'bom', prefix: [], scope: null },
    { type: 'language', subtag: 'bon', prefix: [], scope: null },
    { type: 'language', subtag: 'boo', prefix: [], scope: null },
    { type: 'language', subtag: 'bop', prefix: [], scope: null },
    { type: 'language', subtag: 'boq', prefix: [], scope: null },
    { type: 'language', subtag: 'bor', prefix: [], scope: null },
    { type: 'language', subtag: 'bot', prefix: [], scope: null },
    { type: 'language', subtag: 'bou', prefix: [], scope: null },
    { type: 'language', subtag: 'bov', prefix: [], scope: null },
    { type: 'language', subtag: 'bow', prefix: [], scope: null },
    { type: 'language', subtag: 'box', prefix: [], scope: null },
    { type: 'language', subtag: 'boy', prefix: [], scope: null },
    { type: 'language', subtag: 'boz', prefix: [], scope: null },
    { type: 'language', subtag: 'bpa', prefix: [], scope: null },
    { type: 'language', subtag: 'bpb', prefix: [], scope: null },
    { type: 'language', subtag: 'bpc', prefix: [], scope: null },
    { type: 'language', subtag: 'bpd', prefix: [], scope: null },
    { type: 'language', subtag: 'bpe', prefix: [], scope: null },
    { type: 'language', subtag: 'bpg', prefix: [], scope: null },
    { type: 'language', subtag: 'bph', prefix: [], scope: null },
    { type: 'language', subtag: 'bpi', prefix: [], scope: null },
    { type: 'language', subtag: 'bpj', prefix: [], scope: null },
    { type: 'language', subtag: 'bpk', prefix: [], scope: null },
    { type: 'language', subtag: 'bpl', prefix: [], scope: null },
    { type: 'language', subtag: 'bpm', prefix: [], scope: null },
    { type: 'language', subtag: 'bpn', prefix: [], scope: null },
    { type: 'language', subtag: 'bpo', prefix: [], scope: null },
    { type: 'language', subtag: 'bpp', prefix: [], scope: null },
    { type: 'language', subtag: 'bpq', prefix: [], scope: null },
    { type: 'language', subtag: 'bpr', prefix: [], scope: null },
    { type: 'language', subtag: 'bps', prefix: [], scope: null },
    { type: 'language', subtag: 'bpt', prefix: [], scope: null },
    { type: 'language', subtag: 'bpu', prefix: [], scope: null },
    { type: 'language', subtag: 'bpv', prefix: [], scope: null },
    { type: 'language', subtag: 'bpw', prefix: [], scope: null },
    { type: 'language', subtag: 'bpx', prefix: [], scope: null },
    { type: 'language', subtag: 'bpy', prefix: [], scope: null },
    { type: 'language', subtag: 'bpz', prefix: [], scope: null },
    { type: 'language', subtag: 'bqa', prefix: [], scope: null },
    { type: 'language', subtag: 'bqb', prefix: [], scope: null },
    { type: 'language', subtag: 'bqc', prefix: [], scope: null },
    { type: 'language', subtag: 'bqd', prefix: [], scope: null },
    { type: 'language', subtag: 'bqf', prefix: [], scope: null },
    { type: 'language', subtag: 'bqg', prefix: [], scope: null },
    { type: 'language', subtag: 'bqh', prefix: [], scope: null },
    { type: 'language', subtag: 'bqi', prefix: [], scope: null },
    { type: 'language', subtag: 'bqj', prefix: [], scope: null },
    { type: 'language', subtag: 'bqk', prefix: [], scope: null },
    { type: 'language', subtag: 'bql', prefix: [], scope: null },
    { type: 'language', subtag: 'bqm', prefix: [], scope: null },
    { type: 'language', subtag: 'bqn', prefix: [], scope: null },
    { type: 'language', subtag: 'bqo', prefix: [], scope: null },
    { type: 'language', subtag: 'bqp', prefix: [], scope: null },
    { type: 'language', subtag: 'bqq', prefix: [], scope: null },
    { type: 'language', subtag: 'bqr', prefix: [], scope: null },
    { type: 'language', subtag: 'bqs', prefix: [], scope: null },
    { type: 'language', subtag: 'bqt', prefix: [], scope: null },
    { type: 'language', subtag: 'bqu', prefix: [], scope: null },
    { type: 'language', subtag: 'bqv', prefix: [], scope: null },
    { type: 'language', subtag: 'bqw', prefix: [], scope: null },
    { type: 'language', subtag: 'bqx', prefix: [], scope: null },
    { type: 'language', subtag: 'bqy', prefix: [], scope: null },
    { type: 'language', subtag: 'bqz', prefix: [], scope: null },
    { type: 'language', subtag: 'bra', prefix: [], scope: null },
    { type: 'language', subtag: 'brb', prefix: [], scope: null },
    { type: 'language', subtag: 'brc', prefix: [], scope: null },
    { type: 'language', subtag: 'brd', prefix: [], scope: null },
    { type: 'language', subtag: 'brf', prefix: [], scope: null },
    { type: 'language', subtag: 'brg', prefix: [], scope: null },
    { type: 'language', subtag: 'brh', prefix: [], scope: null },
    { type: 'language', subtag: 'bri', prefix: [], scope: null },
    { type: 'language', subtag: 'brj', prefix: [], scope: null },
    { type: 'language', subtag: 'brk', prefix: [], scope: null },
    { type: 'language', subtag: 'brl', prefix: [], scope: null },
    { type: 'language', subtag: 'brm', prefix: [], scope: null },
    { type: 'language', subtag: 'brn', prefix: [], scope: null },
    { type: 'language', subtag: 'bro', prefix: [], scope: null },
    { type: 'language', subtag: 'brp', prefix: [], scope: null },
    { type: 'language', subtag: 'brq', prefix: [], scope: null },
    { type: 'language', subtag: 'brr', prefix: [], scope: null },
    { type: 'language', subtag: 'brs', prefix: [], scope: null },
    { type: 'language', subtag: 'brt', prefix: [], scope: null },
    { type: 'language', subtag: 'bru', prefix: [], scope: null },
    { type: 'language', subtag: 'brv', prefix: [], scope: null },
    { type: 'language', subtag: 'brw', prefix: [], scope: null },
    { type: 'language', subtag: 'brx', prefix: [], scope: null },
    { type: 'language', subtag: 'bry', prefix: [], scope: null },
    { type: 'language', subtag: 'brz', prefix: [], scope: null },
    { type: 'language', subtag: 'bsa', prefix: [], scope: null },
    { type: 'language', subtag: 'bsb', prefix: [], scope: null },
    { type: 'language', subtag: 'bsc', prefix: [], scope: null },
    { type: 'language', subtag: 'bse', prefix: [], scope: null },
    { type: 'language', subtag: 'bsf', prefix: [], scope: null },
    { type: 'language', subtag: 'bsg', prefix: [], scope: null },
    { type: 'language', subtag: 'bsh', prefix: [], scope: null },
    { type: 'language', subtag: 'bsi', prefix: [], scope: null },
    { type: 'language', subtag: 'bsj', prefix: [], scope: null },
    { type: 'language', subtag: 'bsk', prefix: [], scope: null },
    { type: 'language', subtag: 'bsl', prefix: [], scope: null },
    { type: 'language', subtag: 'bsm', prefix: [], scope: null },
    { type: 'language', subtag: 'bsn', prefix: [], scope: null },
    { type: 'language', subtag: 'bso', prefix: [], scope: null },
    { type: 'language', subtag: 'bsp', prefix: [], scope: null },
    { type: 'language', subtag: 'bsq', prefix: [], scope: null },
    { type: 'language', subtag: 'bsr', prefix: [], scope: null },
    { type: 'language', subtag: 'bss', prefix: [], scope: null },
    { type: 'language', subtag: 'bst', prefix: [], scope: null },
    { type: 'language', subtag: 'bsu', prefix: [], scope: null },
    { type: 'language', subtag: 'bsv', prefix: [], scope: null },
    { type: 'language', subtag: 'bsw', prefix: [], scope: null },
    { type: 'language', subtag: 'bsx', prefix: [], scope: null },
    { type: 'language', subtag: 'bsy', prefix: [], scope: null },
    { type: 'language', subtag: 'bta', prefix: [], scope: null },
    { type: 'language', subtag: 'btb', prefix: [], scope: null },
    { type: 'language', subtag: 'btc', prefix: [], scope: null },
    { type: 'language', subtag: 'btd', prefix: [], scope: null },
    { type: 'language', subtag: 'bte', prefix: [], scope: null },
    { type: 'language', subtag: 'btf', prefix: [], scope: null },
    { type: 'language', subtag: 'btg', prefix: [], scope: null },
    { type: 'language', subtag: 'bth', prefix: [], scope: null },
    { type: 'language', subtag: 'bti', prefix: [], scope: null },
    { type: 'language', subtag: 'btj', prefix: [], scope: null },
    { type: 'language', subtag: 'btk', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'btl', prefix: [], scope: null },
    { type: 'language', subtag: 'btm', prefix: [], scope: null },
    { type: 'language', subtag: 'btn', prefix: [], scope: null },
    { type: 'language', subtag: 'bto', prefix: [], scope: null },
    { type: 'language', subtag: 'btp', prefix: [], scope: null },
    { type: 'language', subtag: 'btq', prefix: [], scope: null },
    { type: 'language', subtag: 'btr', prefix: [], scope: null },
    { type: 'language', subtag: 'bts', prefix: [], scope: null },
    { type: 'language', subtag: 'btt', prefix: [], scope: null },
    { type: 'language', subtag: 'btu', prefix: [], scope: null },
    { type: 'language', subtag: 'btv', prefix: [], scope: null },
    { type: 'language', subtag: 'btw', prefix: [], scope: null },
    { type: 'language', subtag: 'btx', prefix: [], scope: null },
    { type: 'language', subtag: 'bty', prefix: [], scope: null },
    { type: 'language', subtag: 'btz', prefix: [], scope: null },
    { type: 'language', subtag: 'bua', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'bub', prefix: [], scope: null },
    { type: 'language', subtag: 'buc', prefix: [], scope: null },
    { type: 'language', subtag: 'bud', prefix: [], scope: null },
    { type: 'language', subtag: 'bue', prefix: [], scope: null },
    { type: 'language', subtag: 'buf', prefix: [], scope: null },
    { type: 'language', subtag: 'bug', prefix: [], scope: null },
    { type: 'language', subtag: 'buh', prefix: [], scope: null },
    { type: 'language', subtag: 'bui', prefix: [], scope: null },
    { type: 'language', subtag: 'buj', prefix: [], scope: null },
    { type: 'language', subtag: 'buk', prefix: [], scope: null },
    { type: 'language', subtag: 'bum', prefix: [], scope: null },
    { type: 'language', subtag: 'bun', prefix: [], scope: null },
    { type: 'language', subtag: 'buo', prefix: [], scope: null },
    { type: 'language', subtag: 'bup', prefix: [], scope: null },
    { type: 'language', subtag: 'buq', prefix: [], scope: null },
    { type: 'language', subtag: 'bus', prefix: [], scope: null },
    { type: 'language', subtag: 'but', prefix: [], scope: null },
    { type: 'language', subtag: 'buu', prefix: [], scope: null },
    { type: 'language', subtag: 'buv', prefix: [], scope: null },
    { type: 'language', subtag: 'buw', prefix: [], scope: null },
    { type: 'language', subtag: 'bux', prefix: [], scope: null },
    { type: 'language', subtag: 'buy', prefix: [], scope: null },
    { type: 'language', subtag: 'buz', prefix: [], scope: null },
    { type: 'language', subtag: 'bva', prefix: [], scope: null },
    { type: 'language', subtag: 'bvb', prefix: [], scope: null },
    { type: 'language', subtag: 'bvc', prefix: [], scope: null },
    { type: 'language', subtag: 'bvd', prefix: [], scope: null },
    { type: 'language', subtag: 'bve', prefix: [], scope: null },
    { type: 'language', subtag: 'bvf', prefix: [], scope: null },
    { type: 'language', subtag: 'bvg', prefix: [], scope: null },
    { type: 'language', subtag: 'bvh', prefix: [], scope: null },
    { type: 'language', subtag: 'bvi', prefix: [], scope: null },
    { type: 'language', subtag: 'bvj', prefix: [], scope: null },
    { type: 'language', subtag: 'bvk', prefix: [], scope: null },
    { type: 'language', subtag: 'bvl', prefix: [], scope: null },
    { type: 'language', subtag: 'bvm', prefix: [], scope: null },
    { type: 'language', subtag: 'bvn', prefix: [], scope: null },
    { type: 'language', subtag: 'bvo', prefix: [], scope: null },
    { type: 'language', subtag: 'bvp', prefix: [], scope: null },
    { type: 'language', subtag: 'bvq', prefix: [], scope: null },
    { type: 'language', subtag: 'bvr', prefix: [], scope: null },
    { type: 'language', subtag: 'bvt', prefix: [], scope: null },
    { type: 'language', subtag: 'bvu', prefix: [], scope: null },
    { type: 'language', subtag: 'bvv', prefix: [], scope: null },
    { type: 'language', subtag: 'bvw', prefix: [], scope: null },
    { type: 'language', subtag: 'bvx', prefix: [], scope: null },
    { type: 'language', subtag: 'bvy', prefix: [], scope: null },
    { type: 'language', subtag: 'bvz', prefix: [], scope: null },
    { type: 'language', subtag: 'bwa', prefix: [], scope: null },
    { type: 'language', subtag: 'bwb', prefix: [], scope: null },
    { type: 'language', subtag: 'bwc', prefix: [], scope: null },
    { type: 'language', subtag: 'bwd', prefix: [], scope: null },
    { type: 'language', subtag: 'bwe', prefix: [], scope: null },
    { type: 'language', subtag: 'bwf', prefix: [], scope: null },
    { type: 'language', subtag: 'bwg', prefix: [], scope: null },
    { type: 'language', subtag: 'bwh', prefix: [], scope: null },
    { type: 'language', subtag: 'bwi', prefix: [], scope: null },
    { type: 'language', subtag: 'bwj', prefix: [], scope: null },
    { type: 'language', subtag: 'bwk', prefix: [], scope: null },
    { type: 'language', subtag: 'bwl', prefix: [], scope: null },
    { type: 'language', subtag: 'bwm', prefix: [], scope: null },
    { type: 'language', subtag: 'bwn', prefix: [], scope: null },
    { type: 'language', subtag: 'bwo', prefix: [], scope: null },
    { type: 'language', subtag: 'bwp', prefix: [], scope: null },
    { type: 'language', subtag: 'bwq', prefix: [], scope: null },
    { type: 'language', subtag: 'bwr', prefix: [], scope: null },
    { type: 'language', subtag: 'bws', prefix: [], scope: null },
    { type: 'language', subtag: 'bwt', prefix: [], scope: null },
    { type: 'language', subtag: 'bwu', prefix: [], scope: null },
    { type: 'language', subtag: 'bww', prefix: [], scope: null },
    { type: 'language', subtag: 'bwx', prefix: [], scope: null },
    { type: 'language', subtag: 'bwy', prefix: [], scope: null },
    { type: 'language', subtag: 'bwz', prefix: [], scope: null },
    { type: 'language', subtag: 'bxa', prefix: [], scope: null },
    { type: 'language', subtag: 'bxb', prefix: [], scope: null },
    { type: 'language', subtag: 'bxc', prefix: [], scope: null },
    { type: 'language', subtag: 'bxd', prefix: [], scope: null },
    { type: 'language', subtag: 'bxe', prefix: [], scope: null },
    { type: 'language', subtag: 'bxf', prefix: [], scope: null },
    { type: 'language', subtag: 'bxg', prefix: [], scope: null },
    { type: 'language', subtag: 'bxh', prefix: [], scope: null },
    { type: 'language', subtag: 'bxi', prefix: [], scope: null },
    { type: 'language', subtag: 'bxj', prefix: [], scope: null },
    { type: 'language', subtag: 'bxk', prefix: [], scope: null },
    { type: 'language', subtag: 'bxl', prefix: [], scope: null },
    { type: 'language', subtag: 'bxm', prefix: [], scope: null },
    { type: 'language', subtag: 'bxn', prefix: [], scope: null },
    { type: 'language', subtag: 'bxo', prefix: [], scope: null },
    { type: 'language', subtag: 'bxp', prefix: [], scope: null },
    { type: 'language', subtag: 'bxq', prefix: [], scope: null },
    { type: 'language', subtag: 'bxr', prefix: [], scope: null },
    { type: 'language', subtag: 'bxs', prefix: [], scope: null },
    { type: 'language', subtag: 'bxu', prefix: [], scope: null },
    { type: 'language', subtag: 'bxv', prefix: [], scope: null },
    { type: 'language', subtag: 'bxw', prefix: [], scope: null },
    { type: 'language', subtag: 'bxx', prefix: [], scope: null },
    { type: 'language', subtag: 'bxz', prefix: [], scope: null },
    { type: 'language', subtag: 'bya', prefix: [], scope: null },
    { type: 'language', subtag: 'byb', prefix: [], scope: null },
    { type: 'language', subtag: 'byc', prefix: [], scope: null },
    { type: 'language', subtag: 'byd', prefix: [], scope: null },
    { type: 'language', subtag: 'bye', prefix: [], scope: null },
    { type: 'language', subtag: 'byf', prefix: [], scope: null },
    { type: 'language', subtag: 'byg', prefix: [], scope: null },
    { type: 'language', subtag: 'byh', prefix: [], scope: null },
    { type: 'language', subtag: 'byi', prefix: [], scope: null },
    { type: 'language', subtag: 'byj', prefix: [], scope: null },
    { type: 'language', subtag: 'byk', prefix: [], scope: null },
    { type: 'language', subtag: 'byl', prefix: [], scope: null },
    { type: 'language', subtag: 'bym', prefix: [], scope: null },
    { type: 'language', subtag: 'byn', prefix: [], scope: null },
    { type: 'language', subtag: 'byo', prefix: [], scope: null },
    { type: 'language', subtag: 'byp', prefix: [], scope: null },
    { type: 'language', subtag: 'byq', prefix: [], scope: null },
    { type: 'language', subtag: 'byr', prefix: [], scope: null },
    { type: 'language', subtag: 'bys', prefix: [], scope: null },
    { type: 'language', subtag: 'byt', prefix: [], scope: null },
    { type: 'language', subtag: 'byv', prefix: [], scope: null },
    { type: 'language', subtag: 'byw', prefix: [], scope: null },
    { type: 'language', subtag: 'byx', prefix: [], scope: null },
    { type: 'language', subtag: 'byy', prefix: [], scope: null },
    { type: 'language', subtag: 'byz', prefix: [], scope: null },
    { type: 'language', subtag: 'bza', prefix: [], scope: null },
    { type: 'language', subtag: 'bzb', prefix: [], scope: null },
    { type: 'language', subtag: 'bzc', prefix: [], scope: null },
    { type: 'language', subtag: 'bzd', prefix: [], scope: null },
    { type: 'language', subtag: 'bze', prefix: [], scope: null },
    { type: 'language', subtag: 'bzf', prefix: [], scope: null },
    { type: 'language', subtag: 'bzg', prefix: [], scope: null },
    { type: 'language', subtag: 'bzh', prefix: [], scope: null },
    { type: 'language', subtag: 'bzi', prefix: [], scope: null },
    { type: 'language', subtag: 'bzj', prefix: [], scope: null },
    { type: 'language', subtag: 'bzk', prefix: [], scope: null },
    { type: 'language', subtag: 'bzl', prefix: [], scope: null },
    { type: 'language', subtag: 'bzm', prefix: [], scope: null },
    { type: 'language', subtag: 'bzn', prefix: [], scope: null },
    { type: 'language', subtag: 'bzo', prefix: [], scope: null },
    { type: 'language', subtag: 'bzp', prefix: [], scope: null },
    { type: 'language', subtag: 'bzq', prefix: [], scope: null },
    { type: 'language', subtag: 'bzr', prefix: [], scope: null },
    { type: 'language', subtag: 'bzs', prefix: [], scope: null },
    { type: 'language', subtag: 'bzt', prefix: [], scope: null },
    { type: 'language', subtag: 'bzu', prefix: [], scope: null },
    { type: 'language', subtag: 'bzv', prefix: [], scope: null },
    { type: 'language', subtag: 'bzw', prefix: [], scope: null },
    { type: 'language', subtag: 'bzx', prefix: [], scope: null },
    { type: 'language', subtag: 'bzy', prefix: [], scope: null },
    { type: 'language', subtag: 'bzz', prefix: [], scope: null },
    { type: 'language', subtag: 'caa', prefix: [], scope: null },
    { type: 'language', subtag: 'cab', prefix: [], scope: null },
    { type: 'language', subtag: 'cac', prefix: [], scope: null },
    { type: 'language', subtag: 'cad', prefix: [], scope: null },
    { type: 'language', subtag: 'cae', prefix: [], scope: null },
    { type: 'language', subtag: 'caf', prefix: [], scope: null },
    { type: 'language', subtag: 'cag', prefix: [], scope: null },
    { type: 'language', subtag: 'cah', prefix: [], scope: null },
    { type: 'language', subtag: 'cai', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'caj', prefix: [], scope: null },
    { type: 'language', subtag: 'cak', prefix: [], scope: null },
    { type: 'language', subtag: 'cal', prefix: [], scope: null },
    { type: 'language', subtag: 'cam', prefix: [], scope: null },
    { type: 'language', subtag: 'can', prefix: [], scope: null },
    { type: 'language', subtag: 'cao', prefix: [], scope: null },
    { type: 'language', subtag: 'cap', prefix: [], scope: null },
    { type: 'language', subtag: 'caq', prefix: [], scope: null },
    { type: 'language', subtag: 'car', prefix: [], scope: null },
    { type: 'language', subtag: 'cas', prefix: [], scope: null },
    { type: 'language', subtag: 'cau', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cav', prefix: [], scope: null },
    { type: 'language', subtag: 'caw', prefix: [], scope: null },
    { type: 'language', subtag: 'cax', prefix: [], scope: null },
    { type: 'language', subtag: 'cay', prefix: [], scope: null },
    { type: 'language', subtag: 'caz', prefix: [], scope: null },
    { type: 'language', subtag: 'cba', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cbb', prefix: [], scope: null },
    { type: 'language', subtag: 'cbc', prefix: [], scope: null },
    { type: 'language', subtag: 'cbd', prefix: [], scope: null },
    { type: 'language', subtag: 'cbe', prefix: [], scope: null },
    { type: 'language', subtag: 'cbg', prefix: [], scope: null },
    { type: 'language', subtag: 'cbh', prefix: [], scope: null },
    { type: 'language', subtag: 'cbi', prefix: [], scope: null },
    { type: 'language', subtag: 'cbj', prefix: [], scope: null },
    { type: 'language', subtag: 'cbk', prefix: [], scope: null },
    { type: 'language', subtag: 'cbl', prefix: [], scope: null },
    { type: 'language', subtag: 'cbn', prefix: [], scope: null },
    { type: 'language', subtag: 'cbo', prefix: [], scope: null },
    { type: 'language', subtag: 'cbq', prefix: [], scope: null },
    { type: 'language', subtag: 'cbr', prefix: [], scope: null },
    { type: 'language', subtag: 'cbs', prefix: [], scope: null },
    { type: 'language', subtag: 'cbt', prefix: [], scope: null },
    { type: 'language', subtag: 'cbu', prefix: [], scope: null },
    { type: 'language', subtag: 'cbv', prefix: [], scope: null },
    { type: 'language', subtag: 'cbw', prefix: [], scope: null },
    { type: 'language', subtag: 'cby', prefix: [], scope: null },
    { type: 'language', subtag: 'cca', prefix: [], scope: null },
    { type: 'language', subtag: 'ccc', prefix: [], scope: null },
    { type: 'language', subtag: 'ccd', prefix: [], scope: null },
    { type: 'language', subtag: 'cce', prefix: [], scope: null },
    { type: 'language', subtag: 'ccg', prefix: [], scope: null },
    { type: 'language', subtag: 'cch', prefix: [], scope: null },
    { type: 'language', subtag: 'ccj', prefix: [], scope: null },
    { type: 'language', subtag: 'ccl', prefix: [], scope: null },
    { type: 'language', subtag: 'ccm', prefix: [], scope: null },
    { type: 'language', subtag: 'ccn', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cco', prefix: [], scope: null },
    { type: 'language', subtag: 'ccp', prefix: [], scope: null },
    { type: 'language', subtag: 'ccq', prefix: [], scope: null },
    { type: 'language', subtag: 'ccr', prefix: [], scope: null },
    { type: 'language', subtag: 'ccs', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cda', prefix: [], scope: null },
    { type: 'language', subtag: 'cdc', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cdd', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cde', prefix: [], scope: null },
    { type: 'language', subtag: 'cdf', prefix: [], scope: null },
    { type: 'language', subtag: 'cdg', prefix: [], scope: null },
    { type: 'language', subtag: 'cdh', prefix: [], scope: null },
    { type: 'language', subtag: 'cdi', prefix: [], scope: null },
    { type: 'language', subtag: 'cdj', prefix: [], scope: null },
    { type: 'language', subtag: 'cdm', prefix: [], scope: null },
    { type: 'language', subtag: 'cdn', prefix: [], scope: null },
    { type: 'language', subtag: 'cdo', prefix: [], scope: null },
    { type: 'language', subtag: 'cdr', prefix: [], scope: null },
    { type: 'language', subtag: 'cds', prefix: [], scope: null },
    { type: 'language', subtag: 'cdy', prefix: [], scope: null },
    { type: 'language', subtag: 'cdz', prefix: [], scope: null },
    { type: 'language', subtag: 'cea', prefix: [], scope: null },
    { type: 'language', subtag: 'ceb', prefix: [], scope: null },
    { type: 'language', subtag: 'ceg', prefix: [], scope: null },
    { type: 'language', subtag: 'cek', prefix: [], scope: null },
    { type: 'language', subtag: 'cel', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cen', prefix: [], scope: null },
    { type: 'language', subtag: 'cet', prefix: [], scope: null },
    { type: 'language', subtag: 'cey', prefix: [], scope: null },
    { type: 'language', subtag: 'cfa', prefix: [], scope: null },
    { type: 'language', subtag: 'cfd', prefix: [], scope: null },
    { type: 'language', subtag: 'cfg', prefix: [], scope: null },
    { type: 'language', subtag: 'cfm', prefix: [], scope: null },
    { type: 'language', subtag: 'cga', prefix: [], scope: null },
    { type: 'language', subtag: 'cgc', prefix: [], scope: null },
    { type: 'language', subtag: 'cgg', prefix: [], scope: null },
    { type: 'language', subtag: 'cgk', prefix: [], scope: null },
    { type: 'language', subtag: 'chb', prefix: [], scope: null },
    { type: 'language', subtag: 'chc', prefix: [], scope: null },
    { type: 'language', subtag: 'chd', prefix: [], scope: null },
    { type: 'language', subtag: 'chf', prefix: [], scope: null },
    { type: 'language', subtag: 'chg', prefix: [], scope: null },
    { type: 'language', subtag: 'chh', prefix: [], scope: null },
    { type: 'language', subtag: 'chj', prefix: [], scope: null },
    { type: 'language', subtag: 'chk', prefix: [], scope: null },
    { type: 'language', subtag: 'chl', prefix: [], scope: null },
    { type: 'language', subtag: 'chm', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'chn', prefix: [], scope: null },
    { type: 'language', subtag: 'cho', prefix: [], scope: null },
    { type: 'language', subtag: 'chp', prefix: [], scope: null },
    { type: 'language', subtag: 'chq', prefix: [], scope: null },
    { type: 'language', subtag: 'chr', prefix: [], scope: null },
    { type: 'language', subtag: 'cht', prefix: [], scope: null },
    { type: 'language', subtag: 'chw', prefix: [], scope: null },
    { type: 'language', subtag: 'chx', prefix: [], scope: null },
    { type: 'language', subtag: 'chy', prefix: [], scope: null },
    { type: 'language', subtag: 'chz', prefix: [], scope: null },
    { type: 'language', subtag: 'cia', prefix: [], scope: null },
    { type: 'language', subtag: 'cib', prefix: [], scope: null },
    { type: 'language', subtag: 'cic', prefix: [], scope: null },
    { type: 'language', subtag: 'cid', prefix: [], scope: null },
    { type: 'language', subtag: 'cie', prefix: [], scope: null },
    { type: 'language', subtag: 'cih', prefix: [], scope: null },
    { type: 'language', subtag: 'cik', prefix: [], scope: null },
    { type: 'language', subtag: 'cim', prefix: [], scope: null },
    { type: 'language', subtag: 'cin', prefix: [], scope: null },
    { type: 'language', subtag: 'cip', prefix: [], scope: null },
    { type: 'language', subtag: 'cir', prefix: [], scope: null },
    { type: 'language', subtag: 'ciw', prefix: [], scope: null },
    { type: 'language', subtag: 'ciy', prefix: [], scope: null },
    { type: 'language', subtag: 'cja', prefix: [], scope: null },
    { type: 'language', subtag: 'cje', prefix: [], scope: null },
    { type: 'language', subtag: 'cjh', prefix: [], scope: null },
    { type: 'language', subtag: 'cji', prefix: [], scope: null },
    { type: 'language', subtag: 'cjk', prefix: [], scope: null },
    { type: 'language', subtag: 'cjm', prefix: [], scope: null },
    { type: 'language', subtag: 'cjn', prefix: [], scope: null },
    { type: 'language', subtag: 'cjo', prefix: [], scope: null },
    { type: 'language', subtag: 'cjp', prefix: [], scope: null },
    { type: 'language', subtag: 'cjr', prefix: [], scope: null },
    { type: 'language', subtag: 'cjs', prefix: [], scope: null },
    { type: 'language', subtag: 'cjv', prefix: [], scope: null },
    { type: 'language', subtag: 'cjy', prefix: [], scope: null },
    { type: 'language', subtag: 'cka', prefix: [], scope: null },
    { type: 'language', subtag: 'ckb', prefix: [], scope: null },
    { type: 'language', subtag: 'ckh', prefix: [], scope: null },
    { type: 'language', subtag: 'ckl', prefix: [], scope: null },
    { type: 'language', subtag: 'ckm', prefix: [], scope: null },
    { type: 'language', subtag: 'ckn', prefix: [], scope: null },
    { type: 'language', subtag: 'cko', prefix: [], scope: null },
    { type: 'language', subtag: 'ckq', prefix: [], scope: null },
    { type: 'language', subtag: 'ckr', prefix: [], scope: null },
    { type: 'language', subtag: 'cks', prefix: [], scope: null },
    { type: 'language', subtag: 'ckt', prefix: [], scope: null },
    { type: 'language', subtag: 'cku', prefix: [], scope: null },
    { type: 'language', subtag: 'ckv', prefix: [], scope: null },
    { type: 'language', subtag: 'ckx', prefix: [], scope: null },
    { type: 'language', subtag: 'cky', prefix: [], scope: null },
    { type: 'language', subtag: 'ckz', prefix: [], scope: null },
    { type: 'language', subtag: 'cla', prefix: [], scope: null },
    { type: 'language', subtag: 'clc', prefix: [], scope: null },
    { type: 'language', subtag: 'cld', prefix: [], scope: null },
    { type: 'language', subtag: 'cle', prefix: [], scope: null },
    { type: 'language', subtag: 'clh', prefix: [], scope: null },
    { type: 'language', subtag: 'cli', prefix: [], scope: null },
    { type: 'language', subtag: 'clj', prefix: [], scope: null },
    { type: 'language', subtag: 'clk', prefix: [], scope: null },
    { type: 'language', subtag: 'cll', prefix: [], scope: null },
    { type: 'language', subtag: 'clm', prefix: [], scope: null },
    { type: 'language', subtag: 'clo', prefix: [], scope: null },
    { type: 'language', subtag: 'clt', prefix: [], scope: null },
    { type: 'language', subtag: 'clu', prefix: [], scope: null },
    { type: 'language', subtag: 'clw', prefix: [], scope: null },
    { type: 'language', subtag: 'cly', prefix: [], scope: null },
    { type: 'language', subtag: 'cma', prefix: [], scope: null },
    { type: 'language', subtag: 'cmc', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cme', prefix: [], scope: null },
    { type: 'language', subtag: 'cmg', prefix: [], scope: null },
    { type: 'language', subtag: 'cmi', prefix: [], scope: null },
    { type: 'language', subtag: 'cmk', prefix: [], scope: null },
    { type: 'language', subtag: 'cml', prefix: [], scope: null },
    { type: 'language', subtag: 'cmm', prefix: [], scope: null },
    { type: 'language', subtag: 'cmn', prefix: [], scope: null },
    { type: 'language', subtag: 'cmo', prefix: [], scope: null },
    { type: 'language', subtag: 'cmr', prefix: [], scope: null },
    { type: 'language', subtag: 'cms', prefix: [], scope: null },
    { type: 'language', subtag: 'cmt', prefix: [], scope: null },
    { type: 'language', subtag: 'cna', prefix: [], scope: null },
    { type: 'language', subtag: 'cnb', prefix: [], scope: null },
    { type: 'language', subtag: 'cnc', prefix: [], scope: null },
    { type: 'language', subtag: 'cng', prefix: [], scope: null },
    { type: 'language', subtag: 'cnh', prefix: [], scope: null },
    { type: 'language', subtag: 'cni', prefix: [], scope: null },
    { type: 'language', subtag: 'cnk', prefix: [], scope: null },
    { type: 'language', subtag: 'cnl', prefix: [], scope: null },
    { type: 'language', subtag: 'cno', prefix: [], scope: null },
    { type: 'language', subtag: 'cnp', prefix: [], scope: null },
    { type: 'language', subtag: 'cnq', prefix: [], scope: null },
    { type: 'language', subtag: 'cnr', prefix: [], scope: null },
    { type: 'language', subtag: 'cns', prefix: [], scope: null },
    { type: 'language', subtag: 'cnt', prefix: [], scope: null },
    { type: 'language', subtag: 'cnu', prefix: [], scope: null },
    { type: 'language', subtag: 'cnw', prefix: [], scope: null },
    { type: 'language', subtag: 'cnx', prefix: [], scope: null },
    { type: 'language', subtag: 'coa', prefix: [], scope: null },
    { type: 'language', subtag: 'cob', prefix: [], scope: null },
    { type: 'language', subtag: 'coc', prefix: [], scope: null },
    { type: 'language', subtag: 'cod', prefix: [], scope: null },
    { type: 'language', subtag: 'coe', prefix: [], scope: null },
    { type: 'language', subtag: 'cof', prefix: [], scope: null },
    { type: 'language', subtag: 'cog', prefix: [], scope: null },
    { type: 'language', subtag: 'coh', prefix: [], scope: null },
    { type: 'language', subtag: 'coj', prefix: [], scope: null },
    { type: 'language', subtag: 'cok', prefix: [], scope: null },
    { type: 'language', subtag: 'col', prefix: [], scope: null },
    { type: 'language', subtag: 'com', prefix: [], scope: null },
    { type: 'language', subtag: 'con', prefix: [], scope: null },
    { type: 'language', subtag: 'coo', prefix: [], scope: null },
    { type: 'language', subtag: 'cop', prefix: [], scope: null },
    { type: 'language', subtag: 'coq', prefix: [], scope: null },
    { type: 'language', subtag: 'cot', prefix: [], scope: null },
    { type: 'language', subtag: 'cou', prefix: [], scope: null },
    { type: 'language', subtag: 'cov', prefix: [], scope: null },
    { type: 'language', subtag: 'cow', prefix: [], scope: null },
    { type: 'language', subtag: 'cox', prefix: [], scope: null },
    { type: 'language', subtag: 'coy', prefix: [], scope: null },
    { type: 'language', subtag: 'coz', prefix: [], scope: null },
    { type: 'language', subtag: 'cpa', prefix: [], scope: null },
    { type: 'language', subtag: 'cpb', prefix: [], scope: null },
    { type: 'language', subtag: 'cpc', prefix: [], scope: null },
    { type: 'language', subtag: 'cpe', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cpf', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cpg', prefix: [], scope: null },
    { type: 'language', subtag: 'cpi', prefix: [], scope: null },
    { type: 'language', subtag: 'cpn', prefix: [], scope: null },
    { type: 'language', subtag: 'cpo', prefix: [], scope: null },
    { type: 'language', subtag: 'cpp', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cps', prefix: [], scope: null },
    { type: 'language', subtag: 'cpu', prefix: [], scope: null },
    { type: 'language', subtag: 'cpx', prefix: [], scope: null },
    { type: 'language', subtag: 'cpy', prefix: [], scope: null },
    { type: 'language', subtag: 'cqd', prefix: [], scope: null },
    { type: 'language', subtag: 'cqu', prefix: [], scope: null },
    { type: 'language', subtag: 'cra', prefix: [], scope: null },
    { type: 'language', subtag: 'crb', prefix: [], scope: null },
    { type: 'language', subtag: 'crc', prefix: [], scope: null },
    { type: 'language', subtag: 'crd', prefix: [], scope: null },
    { type: 'language', subtag: 'crf', prefix: [], scope: null },
    { type: 'language', subtag: 'crg', prefix: [], scope: null },
    { type: 'language', subtag: 'crh', prefix: [], scope: null },
    { type: 'language', subtag: 'cri', prefix: [], scope: null },
    { type: 'language', subtag: 'crj', prefix: [], scope: null },
    { type: 'language', subtag: 'crk', prefix: [], scope: null },
    { type: 'language', subtag: 'crl', prefix: [], scope: null },
    { type: 'language', subtag: 'crm', prefix: [], scope: null },
    { type: 'language', subtag: 'crn', prefix: [], scope: null },
    { type: 'language', subtag: 'cro', prefix: [], scope: null },
    { type: 'language', subtag: 'crp', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'crq', prefix: [], scope: null },
    { type: 'language', subtag: 'crr', prefix: [], scope: null },
    { type: 'language', subtag: 'crs', prefix: [], scope: null },
    { type: 'language', subtag: 'crt', prefix: [], scope: null },
    { type: 'language', subtag: 'crv', prefix: [], scope: null },
    { type: 'language', subtag: 'crw', prefix: [], scope: null },
    { type: 'language', subtag: 'crx', prefix: [], scope: null },
    { type: 'language', subtag: 'cry', prefix: [], scope: null },
    { type: 'language', subtag: 'crz', prefix: [], scope: null },
    { type: 'language', subtag: 'csa', prefix: [], scope: null },
    { type: 'language', subtag: 'csb', prefix: [], scope: null },
    { type: 'language', subtag: 'csc', prefix: [], scope: null },
    { type: 'language', subtag: 'csd', prefix: [], scope: null },
    { type: 'language', subtag: 'cse', prefix: [], scope: null },
    { type: 'language', subtag: 'csf', prefix: [], scope: null },
    { type: 'language', subtag: 'csg', prefix: [], scope: null },
    { type: 'language', subtag: 'csh', prefix: [], scope: null },
    { type: 'language', subtag: 'csi', prefix: [], scope: null },
    { type: 'language', subtag: 'csj', prefix: [], scope: null },
    { type: 'language', subtag: 'csk', prefix: [], scope: null },
    { type: 'language', subtag: 'csl', prefix: [], scope: null },
    { type: 'language', subtag: 'csm', prefix: [], scope: null },
    { type: 'language', subtag: 'csn', prefix: [], scope: null },
    { type: 'language', subtag: 'cso', prefix: [], scope: null },
    { type: 'language', subtag: 'csp', prefix: [], scope: null },
    { type: 'language', subtag: 'csq', prefix: [], scope: null },
    { type: 'language', subtag: 'csr', prefix: [], scope: null },
    { type: 'language', subtag: 'css', prefix: [], scope: null },
    { type: 'language', subtag: 'cst', prefix: [], scope: null },
    { type: 'language', subtag: 'csu', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'csv', prefix: [], scope: null },
    { type: 'language', subtag: 'csw', prefix: [], scope: null },
    { type: 'language', subtag: 'csx', prefix: [], scope: null },
    { type: 'language', subtag: 'csy', prefix: [], scope: null },
    { type: 'language', subtag: 'csz', prefix: [], scope: null },
    { type: 'language', subtag: 'cta', prefix: [], scope: null },
    { type: 'language', subtag: 'ctc', prefix: [], scope: null },
    { type: 'language', subtag: 'ctd', prefix: [], scope: null },
    { type: 'language', subtag: 'cte', prefix: [], scope: null },
    { type: 'language', subtag: 'ctg', prefix: [], scope: null },
    { type: 'language', subtag: 'cth', prefix: [], scope: null },
    { type: 'language', subtag: 'ctl', prefix: [], scope: null },
    { type: 'language', subtag: 'ctm', prefix: [], scope: null },
    { type: 'language', subtag: 'ctn', prefix: [], scope: null },
    { type: 'language', subtag: 'cto', prefix: [], scope: null },
    { type: 'language', subtag: 'ctp', prefix: [], scope: null },
    { type: 'language', subtag: 'cts', prefix: [], scope: null },
    { type: 'language', subtag: 'ctt', prefix: [], scope: null },
    { type: 'language', subtag: 'ctu', prefix: [], scope: null },
    { type: 'language', subtag: 'cty', prefix: [], scope: null },
    { type: 'language', subtag: 'ctz', prefix: [], scope: null },
    { type: 'language', subtag: 'cua', prefix: [], scope: null },
    { type: 'language', subtag: 'cub', prefix: [], scope: null },
    { type: 'language', subtag: 'cuc', prefix: [], scope: null },
    { type: 'language', subtag: 'cug', prefix: [], scope: null },
    { type: 'language', subtag: 'cuh', prefix: [], scope: null },
    { type: 'language', subtag: 'cui', prefix: [], scope: null },
    { type: 'language', subtag: 'cuj', prefix: [], scope: null },
    { type: 'language', subtag: 'cuk', prefix: [], scope: null },
    { type: 'language', subtag: 'cul', prefix: [], scope: null },
    { type: 'language', subtag: 'cum', prefix: [], scope: null },
    { type: 'language', subtag: 'cuo', prefix: [], scope: null },
    { type: 'language', subtag: 'cup', prefix: [], scope: null },
    { type: 'language', subtag: 'cuq', prefix: [], scope: null },
    { type: 'language', subtag: 'cur', prefix: [], scope: null },
    { type: 'language', subtag: 'cus', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'cut', prefix: [], scope: null },
    { type: 'language', subtag: 'cuu', prefix: [], scope: null },
    { type: 'language', subtag: 'cuv', prefix: [], scope: null },
    { type: 'language', subtag: 'cuw', prefix: [], scope: null },
    { type: 'language', subtag: 'cux', prefix: [], scope: null },
    { type: 'language', subtag: 'cuy', prefix: [], scope: null },
    { type: 'language', subtag: 'cvg', prefix: [], scope: null },
    { type: 'language', subtag: 'cvn', prefix: [], scope: null },
    { type: 'language', subtag: 'cwa', prefix: [], scope: null },
    { type: 'language', subtag: 'cwb', prefix: [], scope: null },
    { type: 'language', subtag: 'cwd', prefix: [], scope: null },
    { type: 'language', subtag: 'cwe', prefix: [], scope: null },
    { type: 'language', subtag: 'cwg', prefix: [], scope: null },
    { type: 'language', subtag: 'cwt', prefix: [], scope: null },
    { type: 'language', subtag: 'cya', prefix: [], scope: null },
    { type: 'language', subtag: 'cyb', prefix: [], scope: null },
    { type: 'language', subtag: 'cyo', prefix: [], scope: null },
    { type: 'language', subtag: 'czh', prefix: [], scope: null },
    { type: 'language', subtag: 'czk', prefix: [], scope: null },
    { type: 'language', subtag: 'czn', prefix: [], scope: null },
    { type: 'language', subtag: 'czo', prefix: [], scope: null },
    { type: 'language', subtag: 'czt', prefix: [], scope: null },
    { type: 'language', subtag: 'daa', prefix: [], scope: null },
    { type: 'language', subtag: 'dac', prefix: [], scope: null },
    { type: 'language', subtag: 'dad', prefix: [], scope: null },
    { type: 'language', subtag: 'dae', prefix: [], scope: null },
    { type: 'language', subtag: 'daf', prefix: [], scope: null },
    { type: 'language', subtag: 'dag', prefix: [], scope: null },
    { type: 'language', subtag: 'dah', prefix: [], scope: null },
    { type: 'language', subtag: 'dai', prefix: [], scope: null },
    { type: 'language', subtag: 'daj', prefix: [], scope: null },
    { type: 'language', subtag: 'dak', prefix: [], scope: null },
    { type: 'language', subtag: 'dal', prefix: [], scope: null },
    { type: 'language', subtag: 'dam', prefix: [], scope: null },
    { type: 'language', subtag: 'dao', prefix: [], scope: null },
    { type: 'language', subtag: 'dap', prefix: [], scope: null },
    { type: 'language', subtag: 'daq', prefix: [], scope: null },
    { type: 'language', subtag: 'dar', prefix: [], scope: null },
    { type: 'language', subtag: 'das', prefix: [], scope: null },
    { type: 'language', subtag: 'dau', prefix: [], scope: null },
    { type: 'language', subtag: 'dav', prefix: [], scope: null },
    { type: 'language', subtag: 'daw', prefix: [], scope: null },
    { type: 'language', subtag: 'dax', prefix: [], scope: null },
    { type: 'language', subtag: 'day', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'daz', prefix: [], scope: null },
    { type: 'language', subtag: 'dba', prefix: [], scope: null },
    { type: 'language', subtag: 'dbb', prefix: [], scope: null },
    { type: 'language', subtag: 'dbd', prefix: [], scope: null },
    { type: 'language', subtag: 'dbe', prefix: [], scope: null },
    { type: 'language', subtag: 'dbf', prefix: [], scope: null },
    { type: 'language', subtag: 'dbg', prefix: [], scope: null },
    { type: 'language', subtag: 'dbi', prefix: [], scope: null },
    { type: 'language', subtag: 'dbj', prefix: [], scope: null },
    { type: 'language', subtag: 'dbl', prefix: [], scope: null },
    { type: 'language', subtag: 'dbm', prefix: [], scope: null },
    { type: 'language', subtag: 'dbn', prefix: [], scope: null },
    { type: 'language', subtag: 'dbo', prefix: [], scope: null },
    { type: 'language', subtag: 'dbp', prefix: [], scope: null },
    { type: 'language', subtag: 'dbq', prefix: [], scope: null },
    { type: 'language', subtag: 'dbr', prefix: [], scope: null },
    { type: 'language', subtag: 'dbt', prefix: [], scope: null },
    { type: 'language', subtag: 'dbu', prefix: [], scope: null },
    { type: 'language', subtag: 'dbv', prefix: [], scope: null },
    { type: 'language', subtag: 'dbw', prefix: [], scope: null },
    { type: 'language', subtag: 'dby', prefix: [], scope: null },
    { type: 'language', subtag: 'dcc', prefix: [], scope: null },
    { type: 'language', subtag: 'dcr', prefix: [], scope: null },
    { type: 'language', subtag: 'dda', prefix: [], scope: null },
    { type: 'language', subtag: 'ddd', prefix: [], scope: null },
    { type: 'language', subtag: 'dde', prefix: [], scope: null },
    { type: 'language', subtag: 'ddg', prefix: [], scope: null },
    { type: 'language', subtag: 'ddi', prefix: [], scope: null },
    { type: 'language', subtag: 'ddj', prefix: [], scope: null },
    { type: 'language', subtag: 'ddn', prefix: [], scope: null },
    { type: 'language', subtag: 'ddo', prefix: [], scope: null },
    { type: 'language', subtag: 'ddr', prefix: [], scope: null },
    { type: 'language', subtag: 'dds', prefix: [], scope: null },
    { type: 'language', subtag: 'ddw', prefix: [], scope: null },
    { type: 'language', subtag: 'dec', prefix: [], scope: null },
    { type: 'language', subtag: 'ded', prefix: [], scope: null },
    { type: 'language', subtag: 'dee', prefix: [], scope: null },
    { type: 'language', subtag: 'def', prefix: [], scope: null },
    { type: 'language', subtag: 'deg', prefix: [], scope: null },
    { type: 'language', subtag: 'deh', prefix: [], scope: null },
    { type: 'language', subtag: 'dei', prefix: [], scope: null },
    { type: 'language', subtag: 'dek', prefix: [], scope: null },
    { type: 'language', subtag: 'del', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'dem', prefix: [], scope: null },
    { type: 'language', subtag: 'den', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'dep', prefix: [], scope: null },
    { type: 'language', subtag: 'deq', prefix: [], scope: null },
    { type: 'language', subtag: 'der', prefix: [], scope: null },
    { type: 'language', subtag: 'des', prefix: [], scope: null },
    { type: 'language', subtag: 'dev', prefix: [], scope: null },
    { type: 'language', subtag: 'dez', prefix: [], scope: null },
    { type: 'language', subtag: 'dga', prefix: [], scope: null },
    { type: 'language', subtag: 'dgb', prefix: [], scope: null },
    { type: 'language', subtag: 'dgc', prefix: [], scope: null },
    { type: 'language', subtag: 'dgd', prefix: [], scope: null },
    { type: 'language', subtag: 'dge', prefix: [], scope: null },
    { type: 'language', subtag: 'dgg', prefix: [], scope: null },
    { type: 'language', subtag: 'dgh', prefix: [], scope: null },
    { type: 'language', subtag: 'dgi', prefix: [], scope: null },
    { type: 'language', subtag: 'dgk', prefix: [], scope: null },
    { type: 'language', subtag: 'dgl', prefix: [], scope: null },
    { type: 'language', subtag: 'dgn', prefix: [], scope: null },
    { type: 'language', subtag: 'dgo', prefix: [], scope: null },
    { type: 'language', subtag: 'dgr', prefix: [], scope: null },
    { type: 'language', subtag: 'dgs', prefix: [], scope: null },
    { type: 'language', subtag: 'dgt', prefix: [], scope: null },
    { type: 'language', subtag: 'dgu', prefix: [], scope: null },
    { type: 'language', subtag: 'dgw', prefix: [], scope: null },
    { type: 'language', subtag: 'dgx', prefix: [], scope: null },
    { type: 'language', subtag: 'dgz', prefix: [], scope: null },
    { type: 'language', subtag: 'dha', prefix: [], scope: null },
    { type: 'language', subtag: 'dhd', prefix: [], scope: null },
    { type: 'language', subtag: 'dhg', prefix: [], scope: null },
    { type: 'language', subtag: 'dhi', prefix: [], scope: null },
    { type: 'language', subtag: 'dhl', prefix: [], scope: null },
    { type: 'language', subtag: 'dhm', prefix: [], scope: null },
    { type: 'language', subtag: 'dhn', prefix: [], scope: null },
    { type: 'language', subtag: 'dho', prefix: [], scope: null },
    { type: 'language', subtag: 'dhr', prefix: [], scope: null },
    { type: 'language', subtag: 'dhs', prefix: [], scope: null },
    { type: 'language', subtag: 'dhu', prefix: [], scope: null },
    { type: 'language', subtag: 'dhv', prefix: [], scope: null },
    { type: 'language', subtag: 'dhw', prefix: [], scope: null },
    { type: 'language', subtag: 'dhx', prefix: [], scope: null },
    { type: 'language', subtag: 'dia', prefix: [], scope: null },
    { type: 'language', subtag: 'dib', prefix: [], scope: null },
    { type: 'language', subtag: 'dic', prefix: [], scope: null },
    { type: 'language', subtag: 'did', prefix: [], scope: null },
    { type: 'language', subtag: 'dif', prefix: [], scope: null },
    { type: 'language', subtag: 'dig', prefix: [], scope: null },
    { type: 'language', subtag: 'dih', prefix: [], scope: null },
    { type: 'language', subtag: 'dii', prefix: [], scope: null },
    { type: 'language', subtag: 'dij', prefix: [], scope: null },
    { type: 'language', subtag: 'dik', prefix: [], scope: null },
    { type: 'language', subtag: 'dil', prefix: [], scope: null },
    { type: 'language', subtag: 'dim', prefix: [], scope: null },
    { type: 'language', subtag: 'din', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'dio', prefix: [], scope: null },
    { type: 'language', subtag: 'dip', prefix: [], scope: null },
    { type: 'language', subtag: 'diq', prefix: [], scope: null },
    { type: 'language', subtag: 'dir', prefix: [], scope: null },
    { type: 'language', subtag: 'dis', prefix: [], scope: null },
    { type: 'language', subtag: 'dit', prefix: [], scope: null },
    { type: 'language', subtag: 'diu', prefix: [], scope: null },
    { type: 'language', subtag: 'diw', prefix: [], scope: null },
    { type: 'language', subtag: 'dix', prefix: [], scope: null },
    { type: 'language', subtag: 'diy', prefix: [], scope: null },
    { type: 'language', subtag: 'diz', prefix: [], scope: null },
    { type: 'language', subtag: 'dja', prefix: [], scope: null },
    { type: 'language', subtag: 'djb', prefix: [], scope: null },
    { type: 'language', subtag: 'djc', prefix: [], scope: null },
    { type: 'language', subtag: 'djd', prefix: [], scope: null },
    { type: 'language', subtag: 'dje', prefix: [], scope: null },
    { type: 'language', subtag: 'djf', prefix: [], scope: null },
    { type: 'language', subtag: 'dji', prefix: [], scope: null },
    { type: 'language', subtag: 'djj', prefix: [], scope: null },
    { type: 'language', subtag: 'djk', prefix: [], scope: null },
    { type: 'language', subtag: 'djl', prefix: [], scope: null },
    { type: 'language', subtag: 'djm', prefix: [], scope: null },
    { type: 'language', subtag: 'djn', prefix: [], scope: null },
    { type: 'language', subtag: 'djo', prefix: [], scope: null },
    { type: 'language', subtag: 'djr', prefix: [], scope: null },
    { type: 'language', subtag: 'dju', prefix: [], scope: null },
    { type: 'language', subtag: 'djw', prefix: [], scope: null },
    { type: 'language', subtag: 'dka', prefix: [], scope: null },
    { type: 'language', subtag: 'dkg', prefix: [], scope: null },
    { type: 'language', subtag: 'dkk', prefix: [], scope: null },
    { type: 'language', subtag: 'dkl', prefix: [], scope: null },
    { type: 'language', subtag: 'dkr', prefix: [], scope: null },
    { type: 'language', subtag: 'dks', prefix: [], scope: null },
    { type: 'language', subtag: 'dkx', prefix: [], scope: null },
    { type: 'language', subtag: 'dlg', prefix: [], scope: null },
    { type: 'language', subtag: 'dlk', prefix: [], scope: null },
    { type: 'language', subtag: 'dlm', prefix: [], scope: null },
    { type: 'language', subtag: 'dln', prefix: [], scope: null },
    { type: 'language', subtag: 'dma', prefix: [], scope: null },
    { type: 'language', subtag: 'dmb', prefix: [], scope: null },
    { type: 'language', subtag: 'dmc', prefix: [], scope: null },
    { type: 'language', subtag: 'dmd', prefix: [], scope: null },
    { type: 'language', subtag: 'dme', prefix: [], scope: null },
    { type: 'language', subtag: 'dmf', prefix: [], scope: null },
    { type: 'language', subtag: 'dmg', prefix: [], scope: null },
    { type: 'language', subtag: 'dmk', prefix: [], scope: null },
    { type: 'language', subtag: 'dml', prefix: [], scope: null },
    { type: 'language', subtag: 'dmm', prefix: [], scope: null },
    { type: 'language', subtag: 'dmn', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'dmo', prefix: [], scope: null },
    { type: 'language', subtag: 'dmr', prefix: [], scope: null },
    { type: 'language', subtag: 'dms', prefix: [], scope: null },
    { type: 'language', subtag: 'dmu', prefix: [], scope: null },
    { type: 'language', subtag: 'dmv', prefix: [], scope: null },
    { type: 'language', subtag: 'dmw', prefix: [], scope: null },
    { type: 'language', subtag: 'dmx', prefix: [], scope: null },
    { type: 'language', subtag: 'dmy', prefix: [], scope: null },
    { type: 'language', subtag: 'dna', prefix: [], scope: null },
    { type: 'language', subtag: 'dnd', prefix: [], scope: null },
    { type: 'language', subtag: 'dne', prefix: [], scope: null },
    { type: 'language', subtag: 'dng', prefix: [], scope: null },
    { type: 'language', subtag: 'dni', prefix: [], scope: null },
    { type: 'language', subtag: 'dnj', prefix: [], scope: null },
    { type: 'language', subtag: 'dnk', prefix: [], scope: null },
    { type: 'language', subtag: 'dnn', prefix: [], scope: null },
    { type: 'language', subtag: 'dno', prefix: [], scope: null },
    { type: 'language', subtag: 'dnr', prefix: [], scope: null },
    { type: 'language', subtag: 'dnt', prefix: [], scope: null },
    { type: 'language', subtag: 'dnu', prefix: [], scope: null },
    { type: 'language', subtag: 'dnv', prefix: [], scope: null },
    { type: 'language', subtag: 'dnw', prefix: [], scope: null },
    { type: 'language', subtag: 'dny', prefix: [], scope: null },
    { type: 'language', subtag: 'doa', prefix: [], scope: null },
    { type: 'language', subtag: 'dob', prefix: [], scope: null },
    { type: 'language', subtag: 'doc', prefix: [], scope: null },
    { type: 'language', subtag: 'doe', prefix: [], scope: null },
    { type: 'language', subtag: 'dof', prefix: [], scope: null },
    { type: 'language', subtag: 'doh', prefix: [], scope: null },
    { type: 'language', subtag: 'doi', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'dok', prefix: [], scope: null },
    { type: 'language', subtag: 'dol', prefix: [], scope: null },
    { type: 'language', subtag: 'don', prefix: [], scope: null },
    { type: 'language', subtag: 'doo', prefix: [], scope: null },
    { type: 'language', subtag: 'dop', prefix: [], scope: null },
    { type: 'language', subtag: 'doq', prefix: [], scope: null },
    { type: 'language', subtag: 'dor', prefix: [], scope: null },
    { type: 'language', subtag: 'dos', prefix: [], scope: null },
    { type: 'language', subtag: 'dot', prefix: [], scope: null },
    { type: 'language', subtag: 'dov', prefix: [], scope: null },
    { type: 'language', subtag: 'dow', prefix: [], scope: null },
    { type: 'language', subtag: 'dox', prefix: [], scope: null },
    { type: 'language', subtag: 'doy', prefix: [], scope: null },
    { type: 'language', subtag: 'doz', prefix: [], scope: null },
    { type: 'language', subtag: 'dpp', prefix: [], scope: null },
    { type: 'language', subtag: 'dra', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'drb', prefix: [], scope: null },
    { type: 'language', subtag: 'drc', prefix: [], scope: null },
    { type: 'language', subtag: 'drd', prefix: [], scope: null },
    { type: 'language', subtag: 'dre', prefix: [], scope: null },
    { type: 'language', subtag: 'drg', prefix: [], scope: null },
    { type: 'language', subtag: 'drh', prefix: [], scope: null },
    { type: 'language', subtag: 'dri', prefix: [], scope: null },
    { type: 'language', subtag: 'drl', prefix: [], scope: null },
    { type: 'language', subtag: 'drn', prefix: [], scope: null },
    { type: 'language', subtag: 'dro', prefix: [], scope: null },
    { type: 'language', subtag: 'drq', prefix: [], scope: null },
    { type: 'language', subtag: 'drr', prefix: [], scope: null },
    { type: 'language', subtag: 'drs', prefix: [], scope: null },
    { type: 'language', subtag: 'drt', prefix: [], scope: null },
    { type: 'language', subtag: 'dru', prefix: [], scope: null },
    { type: 'language', subtag: 'drw', prefix: [], scope: null },
    { type: 'language', subtag: 'dry', prefix: [], scope: null },
    { type: 'language', subtag: 'dsb', prefix: [], scope: null },
    { type: 'language', subtag: 'dse', prefix: [], scope: null },
    { type: 'language', subtag: 'dsh', prefix: [], scope: null },
    { type: 'language', subtag: 'dsi', prefix: [], scope: null },
    { type: 'language', subtag: 'dsl', prefix: [], scope: null },
    { type: 'language', subtag: 'dsn', prefix: [], scope: null },
    { type: 'language', subtag: 'dso', prefix: [], scope: null },
    { type: 'language', subtag: 'dsq', prefix: [], scope: null },
    { type: 'language', subtag: 'dsz', prefix: [], scope: null },
    { type: 'language', subtag: 'dta', prefix: [], scope: null },
    { type: 'language', subtag: 'dtb', prefix: [], scope: null },
    { type: 'language', subtag: 'dtd', prefix: [], scope: null },
    { type: 'language', subtag: 'dth', prefix: [], scope: null },
    { type: 'language', subtag: 'dti', prefix: [], scope: null },
    { type: 'language', subtag: 'dtk', prefix: [], scope: null },
    { type: 'language', subtag: 'dtm', prefix: [], scope: null },
    { type: 'language', subtag: 'dtn', prefix: [], scope: null },
    { type: 'language', subtag: 'dto', prefix: [], scope: null },
    { type: 'language', subtag: 'dtp', prefix: [], scope: null },
    { type: 'language', subtag: 'dtr', prefix: [], scope: null },
    { type: 'language', subtag: 'dts', prefix: [], scope: null },
    { type: 'language', subtag: 'dtt', prefix: [], scope: null },
    { type: 'language', subtag: 'dtu', prefix: [], scope: null },
    { type: 'language', subtag: 'dty', prefix: [], scope: null },
    { type: 'language', subtag: 'dua', prefix: [], scope: null },
    { type: 'language', subtag: 'dub', prefix: [], scope: null },
    { type: 'language', subtag: 'duc', prefix: [], scope: null },
    { type: 'language', subtag: 'dud', prefix: [], scope: null },
    { type: 'language', subtag: 'due', prefix: [], scope: null },
    { type: 'language', subtag: 'duf', prefix: [], scope: null },
    { type: 'language', subtag: 'dug', prefix: [], scope: null },
    { type: 'language', subtag: 'duh', prefix: [], scope: null },
    { type: 'language', subtag: 'dui', prefix: [], scope: null },
    { type: 'language', subtag: 'duj', prefix: [], scope: null },
    { type: 'language', subtag: 'duk', prefix: [], scope: null },
    { type: 'language', subtag: 'dul', prefix: [], scope: null },
    { type: 'language', subtag: 'dum', prefix: [], scope: null },
    { type: 'language', subtag: 'dun', prefix: [], scope: null },
    { type: 'language', subtag: 'duo', prefix: [], scope: null },
    { type: 'language', subtag: 'dup', prefix: [], scope: null },
    { type: 'language', subtag: 'duq', prefix: [], scope: null },
    { type: 'language', subtag: 'dur', prefix: [], scope: null },
    { type: 'language', subtag: 'dus', prefix: [], scope: null },
    { type: 'language', subtag: 'duu', prefix: [], scope: null },
    { type: 'language', subtag: 'duv', prefix: [], scope: null },
    { type: 'language', subtag: 'duw', prefix: [], scope: null },
    { type: 'language', subtag: 'dux', prefix: [], scope: null },
    { type: 'language', subtag: 'duy', prefix: [], scope: null },
    { type: 'language', subtag: 'duz', prefix: [], scope: null },
    { type: 'language', subtag: 'dva', prefix: [], scope: null },
    { type: 'language', subtag: 'dwa', prefix: [], scope: null },
    { type: 'language', subtag: 'dwk', prefix: [], scope: null },
    { type: 'language', subtag: 'dwl', prefix: [], scope: null },
    { type: 'language', subtag: 'dwr', prefix: [], scope: null },
    { type: 'language', subtag: 'dws', prefix: [], scope: null },
    { type: 'language', subtag: 'dwu', prefix: [], scope: null },
    { type: 'language', subtag: 'dww', prefix: [], scope: null },
    { type: 'language', subtag: 'dwy', prefix: [], scope: null },
    { type: 'language', subtag: 'dwz', prefix: [], scope: null },
    { type: 'language', subtag: 'dya', prefix: [], scope: null },
    { type: 'language', subtag: 'dyb', prefix: [], scope: null },
    { type: 'language', subtag: 'dyd', prefix: [], scope: null },
    { type: 'language', subtag: 'dyg', prefix: [], scope: null },
    { type: 'language', subtag: 'dyi', prefix: [], scope: null },
    { type: 'language', subtag: 'dym', prefix: [], scope: null },
    { type: 'language', subtag: 'dyn', prefix: [], scope: null },
    { type: 'language', subtag: 'dyo', prefix: [], scope: null },
    { type: 'language', subtag: 'dyu', prefix: [], scope: null },
    { type: 'language', subtag: 'dyy', prefix: [], scope: null },
    { type: 'language', subtag: 'dza', prefix: [], scope: null },
    { type: 'language', subtag: 'dzd', prefix: [], scope: null },
    { type: 'language', subtag: 'dze', prefix: [], scope: null },
    { type: 'language', subtag: 'dzg', prefix: [], scope: null },
    { type: 'language', subtag: 'dzl', prefix: [], scope: null },
    { type: 'language', subtag: 'dzn', prefix: [], scope: null },
    { type: 'language', subtag: 'eaa', prefix: [], scope: null },
    { type: 'language', subtag: 'ebc', prefix: [], scope: null },
    { type: 'language', subtag: 'ebg', prefix: [], scope: null },
    { type: 'language', subtag: 'ebk', prefix: [], scope: null },
    { type: 'language', subtag: 'ebo', prefix: [], scope: null },
    { type: 'language', subtag: 'ebr', prefix: [], scope: null },
    { type: 'language', subtag: 'ebu', prefix: [], scope: null },
    { type: 'language', subtag: 'ecr', prefix: [], scope: null },
    { type: 'language', subtag: 'ecs', prefix: [], scope: null },
    { type: 'language', subtag: 'ecy', prefix: [], scope: null },
    { type: 'language', subtag: 'eee', prefix: [], scope: null },
    { type: 'language', subtag: 'efa', prefix: [], scope: null },
    { type: 'language', subtag: 'efe', prefix: [], scope: null },
    { type: 'language', subtag: 'efi', prefix: [], scope: null },
    { type: 'language', subtag: 'ega', prefix: [], scope: null },
    { type: 'language', subtag: 'egl', prefix: [], scope: null },
    { type: 'language', subtag: 'egm', prefix: [], scope: null },
    { type: 'language', subtag: 'ego', prefix: [], scope: null },
    { type: 'language', subtag: 'egx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'egy', prefix: [], scope: null },
    { type: 'language', subtag: 'ehs', prefix: [], scope: null },
    { type: 'language', subtag: 'ehu', prefix: [], scope: null },
    { type: 'language', subtag: 'eip', prefix: [], scope: null },
    { type: 'language', subtag: 'eit', prefix: [], scope: null },
    { type: 'language', subtag: 'eiv', prefix: [], scope: null },
    { type: 'language', subtag: 'eja', prefix: [], scope: null },
    { type: 'language', subtag: 'eka', prefix: [], scope: null },
    { type: 'language', subtag: 'ekc', prefix: [], scope: null },
    { type: 'language', subtag: 'eke', prefix: [], scope: null },
    { type: 'language', subtag: 'ekg', prefix: [], scope: null },
    { type: 'language', subtag: 'eki', prefix: [], scope: null },
    { type: 'language', subtag: 'ekk', prefix: [], scope: null },
    { type: 'language', subtag: 'ekl', prefix: [], scope: null },
    { type: 'language', subtag: 'ekm', prefix: [], scope: null },
    { type: 'language', subtag: 'eko', prefix: [], scope: null },
    { type: 'language', subtag: 'ekp', prefix: [], scope: null },
    { type: 'language', subtag: 'ekr', prefix: [], scope: null },
    { type: 'language', subtag: 'eky', prefix: [], scope: null },
    { type: 'language', subtag: 'ele', prefix: [], scope: null },
    { type: 'language', subtag: 'elh', prefix: [], scope: null },
    { type: 'language', subtag: 'eli', prefix: [], scope: null },
    { type: 'language', subtag: 'elk', prefix: [], scope: null },
    { type: 'language', subtag: 'elm', prefix: [], scope: null },
    { type: 'language', subtag: 'elo', prefix: [], scope: null },
    { type: 'language', subtag: 'elp', prefix: [], scope: null },
    { type: 'language', subtag: 'elu', prefix: [], scope: null },
    { type: 'language', subtag: 'elx', prefix: [], scope: null },
    { type: 'language', subtag: 'ema', prefix: [], scope: null },
    { type: 'language', subtag: 'emb', prefix: [], scope: null },
    { type: 'language', subtag: 'eme', prefix: [], scope: null },
    { type: 'language', subtag: 'emg', prefix: [], scope: null },
    { type: 'language', subtag: 'emi', prefix: [], scope: null },
    { type: 'language', subtag: 'emk', prefix: [], scope: null },
    { type: 'language', subtag: 'emm', prefix: [], scope: null },
    { type: 'language', subtag: 'emn', prefix: [], scope: null },
    { type: 'language', subtag: 'emo', prefix: [], scope: null },
    { type: 'language', subtag: 'emp', prefix: [], scope: null },
    { type: 'language', subtag: 'emq', prefix: [], scope: null },
    { type: 'language', subtag: 'ems', prefix: [], scope: null },
    { type: 'language', subtag: 'emu', prefix: [], scope: null },
    { type: 'language', subtag: 'emw', prefix: [], scope: null },
    { type: 'language', subtag: 'emx', prefix: [], scope: null },
    { type: 'language', subtag: 'emy', prefix: [], scope: null },
    { type: 'language', subtag: 'emz', prefix: [], scope: null },
    { type: 'language', subtag: 'ena', prefix: [], scope: null },
    { type: 'language', subtag: 'enb', prefix: [], scope: null },
    { type: 'language', subtag: 'enc', prefix: [], scope: null },
    { type: 'language', subtag: 'end', prefix: [], scope: null },
    { type: 'language', subtag: 'enf', prefix: [], scope: null },
    { type: 'language', subtag: 'enh', prefix: [], scope: null },
    { type: 'language', subtag: 'enl', prefix: [], scope: null },
    { type: 'language', subtag: 'enm', prefix: [], scope: null },
    { type: 'language', subtag: 'enn', prefix: [], scope: null },
    { type: 'language', subtag: 'eno', prefix: [], scope: null },
    { type: 'language', subtag: 'enq', prefix: [], scope: null },
    { type: 'language', subtag: 'enr', prefix: [], scope: null },
    { type: 'language', subtag: 'enu', prefix: [], scope: null },
    { type: 'language', subtag: 'env', prefix: [], scope: null },
    { type: 'language', subtag: 'enw', prefix: [], scope: null },
    { type: 'language', subtag: 'enx', prefix: [], scope: null },
    { type: 'language', subtag: 'eot', prefix: [], scope: null },
    { type: 'language', subtag: 'epi', prefix: [], scope: null },
    { type: 'language', subtag: 'era', prefix: [], scope: null },
    { type: 'language', subtag: 'erg', prefix: [], scope: null },
    { type: 'language', subtag: 'erh', prefix: [], scope: null },
    { type: 'language', subtag: 'eri', prefix: [], scope: null },
    { type: 'language', subtag: 'erk', prefix: [], scope: null },
    { type: 'language', subtag: 'ero', prefix: [], scope: null },
    { type: 'language', subtag: 'err', prefix: [], scope: null },
    { type: 'language', subtag: 'ers', prefix: [], scope: null },
    { type: 'language', subtag: 'ert', prefix: [], scope: null },
    { type: 'language', subtag: 'erw', prefix: [], scope: null },
    { type: 'language', subtag: 'ese', prefix: [], scope: null },
    { type: 'language', subtag: 'esg', prefix: [], scope: null },
    { type: 'language', subtag: 'esh', prefix: [], scope: null },
    { type: 'language', subtag: 'esi', prefix: [], scope: null },
    { type: 'language', subtag: 'esk', prefix: [], scope: null },
    { type: 'language', subtag: 'esl', prefix: [], scope: null },
    { type: 'language', subtag: 'esm', prefix: [], scope: null },
    { type: 'language', subtag: 'esn', prefix: [], scope: null },
    { type: 'language', subtag: 'eso', prefix: [], scope: null },
    { type: 'language', subtag: 'esq', prefix: [], scope: null },
    { type: 'language', subtag: 'ess', prefix: [], scope: null },
    { type: 'language', subtag: 'esu', prefix: [], scope: null },
    { type: 'language', subtag: 'esx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'esy', prefix: [], scope: null },
    { type: 'language', subtag: 'etb', prefix: [], scope: null },
    { type: 'language', subtag: 'etc', prefix: [], scope: null },
    { type: 'language', subtag: 'eth', prefix: [], scope: null },
    { type: 'language', subtag: 'etn', prefix: [], scope: null },
    { type: 'language', subtag: 'eto', prefix: [], scope: null },
    { type: 'language', subtag: 'etr', prefix: [], scope: null },
    { type: 'language', subtag: 'ets', prefix: [], scope: null },
    { type: 'language', subtag: 'ett', prefix: [], scope: null },
    { type: 'language', subtag: 'etu', prefix: [], scope: null },
    { type: 'language', subtag: 'etx', prefix: [], scope: null },
    { type: 'language', subtag: 'etz', prefix: [], scope: null },
    { type: 'language', subtag: 'euq', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'eve', prefix: [], scope: null },
    { type: 'language', subtag: 'evh', prefix: [], scope: null },
    { type: 'language', subtag: 'evn', prefix: [], scope: null },
    { type: 'language', subtag: 'ewo', prefix: [], scope: null },
    { type: 'language', subtag: 'ext', prefix: [], scope: null },
    { type: 'language', subtag: 'eya', prefix: [], scope: null },
    { type: 'language', subtag: 'eyo', prefix: [], scope: null },
    { type: 'language', subtag: 'eza', prefix: [], scope: null },
    { type: 'language', subtag: 'eze', prefix: [], scope: null },
    { type: 'language', subtag: 'faa', prefix: [], scope: null },
    { type: 'language', subtag: 'fab', prefix: [], scope: null },
    { type: 'language', subtag: 'fad', prefix: [], scope: null },
    { type: 'language', subtag: 'faf', prefix: [], scope: null },
    { type: 'language', subtag: 'fag', prefix: [], scope: null },
    { type: 'language', subtag: 'fah', prefix: [], scope: null },
    { type: 'language', subtag: 'fai', prefix: [], scope: null },
    { type: 'language', subtag: 'faj', prefix: [], scope: null },
    { type: 'language', subtag: 'fak', prefix: [], scope: null },
    { type: 'language', subtag: 'fal', prefix: [], scope: null },
    { type: 'language', subtag: 'fam', prefix: [], scope: null },
    { type: 'language', subtag: 'fan', prefix: [], scope: null },
    { type: 'language', subtag: 'fap', prefix: [], scope: null },
    { type: 'language', subtag: 'far', prefix: [], scope: null },
    { type: 'language', subtag: 'fat', prefix: [], scope: null },
    { type: 'language', subtag: 'fau', prefix: [], scope: null },
    { type: 'language', subtag: 'fax', prefix: [], scope: null },
    { type: 'language', subtag: 'fay', prefix: [], scope: null },
    { type: 'language', subtag: 'faz', prefix: [], scope: null },
    { type: 'language', subtag: 'fbl', prefix: [], scope: null },
    { type: 'language', subtag: 'fcs', prefix: [], scope: null },
    { type: 'language', subtag: 'fer', prefix: [], scope: null },
    { type: 'language', subtag: 'ffi', prefix: [], scope: null },
    { type: 'language', subtag: 'ffm', prefix: [], scope: null },
    { type: 'language', subtag: 'fgr', prefix: [], scope: null },
    { type: 'language', subtag: 'fia', prefix: [], scope: null },
    { type: 'language', subtag: 'fie', prefix: [], scope: null },
    { type: 'language', subtag: 'fif', prefix: [], scope: null },
    { type: 'language', subtag: 'fil', prefix: [], scope: null },
    { type: 'language', subtag: 'fip', prefix: [], scope: null },
    { type: 'language', subtag: 'fir', prefix: [], scope: null },
    { type: 'language', subtag: 'fit', prefix: [], scope: null },
    { type: 'language', subtag: 'fiu', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'fiw', prefix: [], scope: null },
    { type: 'language', subtag: 'fkk', prefix: [], scope: null },
    { type: 'language', subtag: 'fkv', prefix: [], scope: null },
    { type: 'language', subtag: 'fla', prefix: [], scope: null },
    { type: 'language', subtag: 'flh', prefix: [], scope: null },
    { type: 'language', subtag: 'fli', prefix: [], scope: null },
    { type: 'language', subtag: 'fll', prefix: [], scope: null },
    { type: 'language', subtag: 'fln', prefix: [], scope: null },
    { type: 'language', subtag: 'flr', prefix: [], scope: null },
    { type: 'language', subtag: 'fly', prefix: [], scope: null },
    { type: 'language', subtag: 'fmp', prefix: [], scope: null },
    { type: 'language', subtag: 'fmu', prefix: [], scope: null },
    { type: 'language', subtag: 'fnb', prefix: [], scope: null },
    { type: 'language', subtag: 'fng', prefix: [], scope: null },
    { type: 'language', subtag: 'fni', prefix: [], scope: null },
    { type: 'language', subtag: 'fod', prefix: [], scope: null },
    { type: 'language', subtag: 'foi', prefix: [], scope: null },
    { type: 'language', subtag: 'fom', prefix: [], scope: null },
    { type: 'language', subtag: 'fon', prefix: [], scope: null },
    { type: 'language', subtag: 'for', prefix: [], scope: null },
    { type: 'language', subtag: 'fos', prefix: [], scope: null },
    { type: 'language', subtag: 'fox', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'fpe', prefix: [], scope: null },
    { type: 'language', subtag: 'fqs', prefix: [], scope: null },
    { type: 'language', subtag: 'frc', prefix: [], scope: null },
    { type: 'language', subtag: 'frd', prefix: [], scope: null },
    { type: 'language', subtag: 'frk', prefix: [], scope: null },
    { type: 'language', subtag: 'frm', prefix: [], scope: null },
    { type: 'language', subtag: 'fro', prefix: [], scope: null },
    { type: 'language', subtag: 'frp', prefix: [], scope: null },
    { type: 'language', subtag: 'frq', prefix: [], scope: null },
    { type: 'language', subtag: 'frr', prefix: [], scope: null },
    { type: 'language', subtag: 'frs', prefix: [], scope: null },
    { type: 'language', subtag: 'frt', prefix: [], scope: null },
    { type: 'language', subtag: 'fse', prefix: [], scope: null },
    { type: 'language', subtag: 'fsl', prefix: [], scope: null },
    { type: 'language', subtag: 'fss', prefix: [], scope: null },
    { type: 'language', subtag: 'fub', prefix: [], scope: null },
    { type: 'language', subtag: 'fuc', prefix: [], scope: null },
    { type: 'language', subtag: 'fud', prefix: [], scope: null },
    { type: 'language', subtag: 'fue', prefix: [], scope: null },
    { type: 'language', subtag: 'fuf', prefix: [], scope: null },
    { type: 'language', subtag: 'fuh', prefix: [], scope: null },
    { type: 'language', subtag: 'fui', prefix: [], scope: null },
    { type: 'language', subtag: 'fuj', prefix: [], scope: null },
    { type: 'language', subtag: 'fum', prefix: [], scope: null },
    { type: 'language', subtag: 'fun', prefix: [], scope: null },
    { type: 'language', subtag: 'fuq', prefix: [], scope: null },
    { type: 'language', subtag: 'fur', prefix: [], scope: null },
    { type: 'language', subtag: 'fut', prefix: [], scope: null },
    { type: 'language', subtag: 'fuu', prefix: [], scope: null },
    { type: 'language', subtag: 'fuv', prefix: [], scope: null },
    { type: 'language', subtag: 'fuy', prefix: [], scope: null },
    { type: 'language', subtag: 'fvr', prefix: [], scope: null },
    { type: 'language', subtag: 'fwa', prefix: [], scope: null },
    { type: 'language', subtag: 'fwe', prefix: [], scope: null },
    { type: 'language', subtag: 'gaa', prefix: [], scope: null },
    { type: 'language', subtag: 'gab', prefix: [], scope: null },
    { type: 'language', subtag: 'gac', prefix: [], scope: null },
    { type: 'language', subtag: 'gad', prefix: [], scope: null },
    { type: 'language', subtag: 'gae', prefix: [], scope: null },
    { type: 'language', subtag: 'gaf', prefix: [], scope: null },
    { type: 'language', subtag: 'gag', prefix: [], scope: null },
    { type: 'language', subtag: 'gah', prefix: [], scope: null },
    { type: 'language', subtag: 'gai', prefix: [], scope: null },
    { type: 'language', subtag: 'gaj', prefix: [], scope: null },
    { type: 'language', subtag: 'gak', prefix: [], scope: null },
    { type: 'language', subtag: 'gal', prefix: [], scope: null },
    { type: 'language', subtag: 'gam', prefix: [], scope: null },
    { type: 'language', subtag: 'gan', prefix: [], scope: null },
    { type: 'language', subtag: 'gao', prefix: [], scope: null },
    { type: 'language', subtag: 'gap', prefix: [], scope: null },
    { type: 'language', subtag: 'gaq', prefix: [], scope: null },
    { type: 'language', subtag: 'gar', prefix: [], scope: null },
    { type: 'language', subtag: 'gas', prefix: [], scope: null },
    { type: 'language', subtag: 'gat', prefix: [], scope: null },
    { type: 'language', subtag: 'gau', prefix: [], scope: null },
    { type: 'language', subtag: 'gav', prefix: [], scope: null },
    { type: 'language', subtag: 'gaw', prefix: [], scope: null },
    { type: 'language', subtag: 'gax', prefix: [], scope: null },
    { type: 'language', subtag: 'gay', prefix: [], scope: null },
    { type: 'language', subtag: 'gaz', prefix: [], scope: null },
    { type: 'language', subtag: 'gba', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'gbb', prefix: [], scope: null },
    { type: 'language', subtag: 'gbc', prefix: [], scope: null },
    { type: 'language', subtag: 'gbd', prefix: [], scope: null },
    { type: 'language', subtag: 'gbe', prefix: [], scope: null },
    { type: 'language', subtag: 'gbf', prefix: [], scope: null },
    { type: 'language', subtag: 'gbg', prefix: [], scope: null },
    { type: 'language', subtag: 'gbh', prefix: [], scope: null },
    { type: 'language', subtag: 'gbi', prefix: [], scope: null },
    { type: 'language', subtag: 'gbj', prefix: [], scope: null },
    { type: 'language', subtag: 'gbk', prefix: [], scope: null },
    { type: 'language', subtag: 'gbl', prefix: [], scope: null },
    { type: 'language', subtag: 'gbm', prefix: [], scope: null },
    { type: 'language', subtag: 'gbn', prefix: [], scope: null },
    { type: 'language', subtag: 'gbo', prefix: [], scope: null },
    { type: 'language', subtag: 'gbp', prefix: [], scope: null },
    { type: 'language', subtag: 'gbq', prefix: [], scope: null },
    { type: 'language', subtag: 'gbr', prefix: [], scope: null },
    { type: 'language', subtag: 'gbs', prefix: [], scope: null },
    { type: 'language', subtag: 'gbu', prefix: [], scope: null },
    { type: 'language', subtag: 'gbv', prefix: [], scope: null },
    { type: 'language', subtag: 'gbw', prefix: [], scope: null },
    { type: 'language', subtag: 'gbx', prefix: [], scope: null },
    { type: 'language', subtag: 'gby', prefix: [], scope: null },
    { type: 'language', subtag: 'gbz', prefix: [], scope: null },
    { type: 'language', subtag: 'gcc', prefix: [], scope: null },
    { type: 'language', subtag: 'gcd', prefix: [], scope: null },
    { type: 'language', subtag: 'gce', prefix: [], scope: null },
    { type: 'language', subtag: 'gcf', prefix: [], scope: null },
    { type: 'language', subtag: 'gcl', prefix: [], scope: null },
    { type: 'language', subtag: 'gcn', prefix: [], scope: null },
    { type: 'language', subtag: 'gcr', prefix: [], scope: null },
    { type: 'language', subtag: 'gct', prefix: [], scope: null },
    { type: 'language', subtag: 'gda', prefix: [], scope: null },
    { type: 'language', subtag: 'gdb', prefix: [], scope: null },
    { type: 'language', subtag: 'gdc', prefix: [], scope: null },
    { type: 'language', subtag: 'gdd', prefix: [], scope: null },
    { type: 'language', subtag: 'gde', prefix: [], scope: null },
    { type: 'language', subtag: 'gdf', prefix: [], scope: null },
    { type: 'language', subtag: 'gdg', prefix: [], scope: null },
    { type: 'language', subtag: 'gdh', prefix: [], scope: null },
    { type: 'language', subtag: 'gdi', prefix: [], scope: null },
    { type: 'language', subtag: 'gdj', prefix: [], scope: null },
    { type: 'language', subtag: 'gdk', prefix: [], scope: null },
    { type: 'language', subtag: 'gdl', prefix: [], scope: null },
    { type: 'language', subtag: 'gdm', prefix: [], scope: null },
    { type: 'language', subtag: 'gdn', prefix: [], scope: null },
    { type: 'language', subtag: 'gdo', prefix: [], scope: null },
    { type: 'language', subtag: 'gdq', prefix: [], scope: null },
    { type: 'language', subtag: 'gdr', prefix: [], scope: null },
    { type: 'language', subtag: 'gds', prefix: [], scope: null },
    { type: 'language', subtag: 'gdt', prefix: [], scope: null },
    { type: 'language', subtag: 'gdu', prefix: [], scope: null },
    { type: 'language', subtag: 'gdx', prefix: [], scope: null },
    { type: 'language', subtag: 'gea', prefix: [], scope: null },
    { type: 'language', subtag: 'geb', prefix: [], scope: null },
    { type: 'language', subtag: 'gec', prefix: [], scope: null },
    { type: 'language', subtag: 'ged', prefix: [], scope: null },
    { type: 'language', subtag: 'gef', prefix: [], scope: null },
    { type: 'language', subtag: 'geg', prefix: [], scope: null },
    { type: 'language', subtag: 'geh', prefix: [], scope: null },
    { type: 'language', subtag: 'gei', prefix: [], scope: null },
    { type: 'language', subtag: 'gej', prefix: [], scope: null },
    { type: 'language', subtag: 'gek', prefix: [], scope: null },
    { type: 'language', subtag: 'gel', prefix: [], scope: null },
    { type: 'language', subtag: 'gem', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'geq', prefix: [], scope: null },
    { type: 'language', subtag: 'ges', prefix: [], scope: null },
    { type: 'language', subtag: 'gev', prefix: [], scope: null },
    { type: 'language', subtag: 'gew', prefix: [], scope: null },
    { type: 'language', subtag: 'gex', prefix: [], scope: null },
    { type: 'language', subtag: 'gey', prefix: [], scope: null },
    { type: 'language', subtag: 'gez', prefix: [], scope: null },
    { type: 'language', subtag: 'gfk', prefix: [], scope: null },
    { type: 'language', subtag: 'gft', prefix: [], scope: null },
    { type: 'language', subtag: 'gfx', prefix: [], scope: null },
    { type: 'language', subtag: 'gga', prefix: [], scope: null },
    { type: 'language', subtag: 'ggb', prefix: [], scope: null },
    { type: 'language', subtag: 'ggd', prefix: [], scope: null },
    { type: 'language', subtag: 'gge', prefix: [], scope: null },
    { type: 'language', subtag: 'ggg', prefix: [], scope: null },
    { type: 'language', subtag: 'ggk', prefix: [], scope: null },
    { type: 'language', subtag: 'ggl', prefix: [], scope: null },
    { type: 'language', subtag: 'ggn', prefix: [], scope: null },
    { type: 'language', subtag: 'ggo', prefix: [], scope: null },
    { type: 'language', subtag: 'ggr', prefix: [], scope: null },
    { type: 'language', subtag: 'ggt', prefix: [], scope: null },
    { type: 'language', subtag: 'ggu', prefix: [], scope: null },
    { type: 'language', subtag: 'ggw', prefix: [], scope: null },
    { type: 'language', subtag: 'gha', prefix: [], scope: null },
    { type: 'language', subtag: 'ghc', prefix: [], scope: null },
    { type: 'language', subtag: 'ghe', prefix: [], scope: null },
    { type: 'language', subtag: 'ghh', prefix: [], scope: null },
    { type: 'language', subtag: 'ghk', prefix: [], scope: null },
    { type: 'language', subtag: 'ghl', prefix: [], scope: null },
    { type: 'language', subtag: 'ghn', prefix: [], scope: null },
    { type: 'language', subtag: 'gho', prefix: [], scope: null },
    { type: 'language', subtag: 'ghr', prefix: [], scope: null },
    { type: 'language', subtag: 'ghs', prefix: [], scope: null },
    { type: 'language', subtag: 'ght', prefix: [], scope: null },
    { type: 'language', subtag: 'gia', prefix: [], scope: null },
    { type: 'language', subtag: 'gib', prefix: [], scope: null },
    { type: 'language', subtag: 'gic', prefix: [], scope: null },
    { type: 'language', subtag: 'gid', prefix: [], scope: null },
    { type: 'language', subtag: 'gie', prefix: [], scope: null },
    { type: 'language', subtag: 'gig', prefix: [], scope: null },
    { type: 'language', subtag: 'gih', prefix: [], scope: null },
    { type: 'language', subtag: 'gii', prefix: [], scope: null },
    { type: 'language', subtag: 'gil', prefix: [], scope: null },
    { type: 'language', subtag: 'gim', prefix: [], scope: null },
    { type: 'language', subtag: 'gin', prefix: [], scope: null },
    { type: 'language', subtag: 'gio', prefix: [], scope: null },
    { type: 'language', subtag: 'gip', prefix: [], scope: null },
    { type: 'language', subtag: 'giq', prefix: [], scope: null },
    { type: 'language', subtag: 'gir', prefix: [], scope: null },
    { type: 'language', subtag: 'gis', prefix: [], scope: null },
    { type: 'language', subtag: 'git', prefix: [], scope: null },
    { type: 'language', subtag: 'giu', prefix: [], scope: null },
    { type: 'language', subtag: 'giw', prefix: [], scope: null },
    { type: 'language', subtag: 'gix', prefix: [], scope: null },
    { type: 'language', subtag: 'giy', prefix: [], scope: null },
    { type: 'language', subtag: 'giz', prefix: [], scope: null },
    { type: 'language', subtag: 'gji', prefix: [], scope: null },
    { type: 'language', subtag: 'gjk', prefix: [], scope: null },
    { type: 'language', subtag: 'gjm', prefix: [], scope: null },
    { type: 'language', subtag: 'gjn', prefix: [], scope: null },
    { type: 'language', subtag: 'gjr', prefix: [], scope: null },
    { type: 'language', subtag: 'gju', prefix: [], scope: null },
    { type: 'language', subtag: 'gka', prefix: [], scope: null },
    { type: 'language', subtag: 'gkd', prefix: [], scope: null },
    { type: 'language', subtag: 'gke', prefix: [], scope: null },
    { type: 'language', subtag: 'gkn', prefix: [], scope: null },
    { type: 'language', subtag: 'gko', prefix: [], scope: null },
    { type: 'language', subtag: 'gkp', prefix: [], scope: null },
    { type: 'language', subtag: 'gku', prefix: [], scope: null },
    { type: 'language', subtag: 'glb', prefix: [], scope: null },
    { type: 'language', subtag: 'glc', prefix: [], scope: null },
    { type: 'language', subtag: 'gld', prefix: [], scope: null },
    { type: 'language', subtag: 'glh', prefix: [], scope: null },
    { type: 'language', subtag: 'gli', prefix: [], scope: null },
    { type: 'language', subtag: 'glj', prefix: [], scope: null },
    { type: 'language', subtag: 'glk', prefix: [], scope: null },
    { type: 'language', subtag: 'gll', prefix: [], scope: null },
    { type: 'language', subtag: 'glo', prefix: [], scope: null },
    { type: 'language', subtag: 'glr', prefix: [], scope: null },
    { type: 'language', subtag: 'glu', prefix: [], scope: null },
    { type: 'language', subtag: 'glw', prefix: [], scope: null },
    { type: 'language', subtag: 'gly', prefix: [], scope: null },
    { type: 'language', subtag: 'gma', prefix: [], scope: null },
    { type: 'language', subtag: 'gmb', prefix: [], scope: null },
    { type: 'language', subtag: 'gmd', prefix: [], scope: null },
    { type: 'language', subtag: 'gme', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'gmg', prefix: [], scope: null },
    { type: 'language', subtag: 'gmh', prefix: [], scope: null },
    { type: 'language', subtag: 'gml', prefix: [], scope: null },
    { type: 'language', subtag: 'gmm', prefix: [], scope: null },
    { type: 'language', subtag: 'gmn', prefix: [], scope: null },
    { type: 'language', subtag: 'gmq', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'gmr', prefix: [], scope: null },
    { type: 'language', subtag: 'gmu', prefix: [], scope: null },
    { type: 'language', subtag: 'gmv', prefix: [], scope: null },
    { type: 'language', subtag: 'gmw', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'gmx', prefix: [], scope: null },
    { type: 'language', subtag: 'gmy', prefix: [], scope: null },
    { type: 'language', subtag: 'gmz', prefix: [], scope: null },
    { type: 'language', subtag: 'gna', prefix: [], scope: null },
    { type: 'language', subtag: 'gnb', prefix: [], scope: null },
    { type: 'language', subtag: 'gnc', prefix: [], scope: null },
    { type: 'language', subtag: 'gnd', prefix: [], scope: null },
    { type: 'language', subtag: 'gne', prefix: [], scope: null },
    { type: 'language', subtag: 'gng', prefix: [], scope: null },
    { type: 'language', subtag: 'gnh', prefix: [], scope: null },
    { type: 'language', subtag: 'gni', prefix: [], scope: null },
    { type: 'language', subtag: 'gnj', prefix: [], scope: null },
    { type: 'language', subtag: 'gnk', prefix: [], scope: null },
    { type: 'language', subtag: 'gnl', prefix: [], scope: null },
    { type: 'language', subtag: 'gnm', prefix: [], scope: null },
    { type: 'language', subtag: 'gnn', prefix: [], scope: null },
    { type: 'language', subtag: 'gno', prefix: [], scope: null },
    { type: 'language', subtag: 'gnq', prefix: [], scope: null },
    { type: 'language', subtag: 'gnr', prefix: [], scope: null },
    { type: 'language', subtag: 'gnt', prefix: [], scope: null },
    { type: 'language', subtag: 'gnu', prefix: [], scope: null },
    { type: 'language', subtag: 'gnw', prefix: [], scope: null },
    { type: 'language', subtag: 'gnz', prefix: [], scope: null },
    { type: 'language', subtag: 'goa', prefix: [], scope: null },
    { type: 'language', subtag: 'gob', prefix: [], scope: null },
    { type: 'language', subtag: 'goc', prefix: [], scope: null },
    { type: 'language', subtag: 'god', prefix: [], scope: null },
    { type: 'language', subtag: 'goe', prefix: [], scope: null },
    { type: 'language', subtag: 'gof', prefix: [], scope: null },
    { type: 'language', subtag: 'gog', prefix: [], scope: null },
    { type: 'language', subtag: 'goh', prefix: [], scope: null },
    { type: 'language', subtag: 'goi', prefix: [], scope: null },
    { type: 'language', subtag: 'goj', prefix: [], scope: null },
    { type: 'language', subtag: 'gok', prefix: [], scope: null },
    { type: 'language', subtag: 'gol', prefix: [], scope: null },
    { type: 'language', subtag: 'gom', prefix: [], scope: null },
    { type: 'language', subtag: 'gon', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'goo', prefix: [], scope: null },
    { type: 'language', subtag: 'gop', prefix: [], scope: null },
    { type: 'language', subtag: 'goq', prefix: [], scope: null },
    { type: 'language', subtag: 'gor', prefix: [], scope: null },
    { type: 'language', subtag: 'gos', prefix: [], scope: null },
    { type: 'language', subtag: 'got', prefix: [], scope: null },
    { type: 'language', subtag: 'gou', prefix: [], scope: null },
    { type: 'language', subtag: 'gov', prefix: [], scope: null },
    { type: 'language', subtag: 'gow', prefix: [], scope: null },
    { type: 'language', subtag: 'gox', prefix: [], scope: null },
    { type: 'language', subtag: 'goy', prefix: [], scope: null },
    { type: 'language', subtag: 'goz', prefix: [], scope: null },
    { type: 'language', subtag: 'gpa', prefix: [], scope: null },
    { type: 'language', subtag: 'gpe', prefix: [], scope: null },
    { type: 'language', subtag: 'gpn', prefix: [], scope: null },
    { type: 'language', subtag: 'gqa', prefix: [], scope: null },
    { type: 'language', subtag: 'gqi', prefix: [], scope: null },
    { type: 'language', subtag: 'gqn', prefix: [], scope: null },
    { type: 'language', subtag: 'gqr', prefix: [], scope: null },
    { type: 'language', subtag: 'gqu', prefix: [], scope: null },
    { type: 'language', subtag: 'gra', prefix: [], scope: null },
    { type: 'language', subtag: 'grb', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'grc', prefix: [], scope: null },
    { type: 'language', subtag: 'grd', prefix: [], scope: null },
    { type: 'language', subtag: 'grg', prefix: [], scope: null },
    { type: 'language', subtag: 'grh', prefix: [], scope: null },
    { type: 'language', subtag: 'gri', prefix: [], scope: null },
    { type: 'language', subtag: 'grj', prefix: [], scope: null },
    { type: 'language', subtag: 'grk', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'grm', prefix: [], scope: null },
    { type: 'language', subtag: 'gro', prefix: [], scope: null },
    { type: 'language', subtag: 'grq', prefix: [], scope: null },
    { type: 'language', subtag: 'grr', prefix: [], scope: null },
    { type: 'language', subtag: 'grs', prefix: [], scope: null },
    { type: 'language', subtag: 'grt', prefix: [], scope: null },
    { type: 'language', subtag: 'gru', prefix: [], scope: null },
    { type: 'language', subtag: 'grv', prefix: [], scope: null },
    { type: 'language', subtag: 'grw', prefix: [], scope: null },
    { type: 'language', subtag: 'grx', prefix: [], scope: null },
    { type: 'language', subtag: 'gry', prefix: [], scope: null },
    { type: 'language', subtag: 'grz', prefix: [], scope: null },
    { type: 'language', subtag: 'gse', prefix: [], scope: null },
    { type: 'language', subtag: 'gsg', prefix: [], scope: null },
    { type: 'language', subtag: 'gsl', prefix: [], scope: null },
    { type: 'language', subtag: 'gsm', prefix: [], scope: null },
    { type: 'language', subtag: 'gsn', prefix: [], scope: null },
    { type: 'language', subtag: 'gso', prefix: [], scope: null },
    { type: 'language', subtag: 'gsp', prefix: [], scope: null },
    { type: 'language', subtag: 'gss', prefix: [], scope: null },
    { type: 'language', subtag: 'gsw', prefix: [], scope: null },
    { type: 'language', subtag: 'gta', prefix: [], scope: null },
    { type: 'language', subtag: 'gti', prefix: [], scope: null },
    { type: 'language', subtag: 'gtu', prefix: [], scope: null },
    { type: 'language', subtag: 'gua', prefix: [], scope: null },
    { type: 'language', subtag: 'gub', prefix: [], scope: null },
    { type: 'language', subtag: 'guc', prefix: [], scope: null },
    { type: 'language', subtag: 'gud', prefix: [], scope: null },
    { type: 'language', subtag: 'gue', prefix: [], scope: null },
    { type: 'language', subtag: 'guf', prefix: [], scope: null },
    { type: 'language', subtag: 'gug', prefix: [], scope: null },
    { type: 'language', subtag: 'guh', prefix: [], scope: null },
    { type: 'language', subtag: 'gui', prefix: [], scope: null },
    { type: 'language', subtag: 'guk', prefix: [], scope: null },
    { type: 'language', subtag: 'gul', prefix: [], scope: null },
    { type: 'language', subtag: 'gum', prefix: [], scope: null },
    { type: 'language', subtag: 'gun', prefix: [], scope: null },
    { type: 'language', subtag: 'guo', prefix: [], scope: null },
    { type: 'language', subtag: 'gup', prefix: [], scope: null },
    { type: 'language', subtag: 'guq', prefix: [], scope: null },
    { type: 'language', subtag: 'gur', prefix: [], scope: null },
    { type: 'language', subtag: 'gus', prefix: [], scope: null },
    { type: 'language', subtag: 'gut', prefix: [], scope: null },
    { type: 'language', subtag: 'guu', prefix: [], scope: null },
    { type: 'language', subtag: 'guv', prefix: [], scope: null },
    { type: 'language', subtag: 'guw', prefix: [], scope: null },
    { type: 'language', subtag: 'gux', prefix: [], scope: null },
    { type: 'language', subtag: 'guz', prefix: [], scope: null },
    { type: 'language', subtag: 'gva', prefix: [], scope: null },
    { type: 'language', subtag: 'gvc', prefix: [], scope: null },
    { type: 'language', subtag: 'gve', prefix: [], scope: null },
    { type: 'language', subtag: 'gvf', prefix: [], scope: null },
    { type: 'language', subtag: 'gvj', prefix: [], scope: null },
    { type: 'language', subtag: 'gvl', prefix: [], scope: null },
    { type: 'language', subtag: 'gvm', prefix: [], scope: null },
    { type: 'language', subtag: 'gvn', prefix: [], scope: null },
    { type: 'language', subtag: 'gvo', prefix: [], scope: null },
    { type: 'language', subtag: 'gvp', prefix: [], scope: null },
    { type: 'language', subtag: 'gvr', prefix: [], scope: null },
    { type: 'language', subtag: 'gvs', prefix: [], scope: null },
    { type: 'language', subtag: 'gvy', prefix: [], scope: null },
    { type: 'language', subtag: 'gwa', prefix: [], scope: null },
    { type: 'language', subtag: 'gwb', prefix: [], scope: null },
    { type: 'language', subtag: 'gwc', prefix: [], scope: null },
    { type: 'language', subtag: 'gwd', prefix: [], scope: null },
    { type: 'language', subtag: 'gwe', prefix: [], scope: null },
    { type: 'language', subtag: 'gwf', prefix: [], scope: null },
    { type: 'language', subtag: 'gwg', prefix: [], scope: null },
    { type: 'language', subtag: 'gwi', prefix: [], scope: null },
    { type: 'language', subtag: 'gwj', prefix: [], scope: null },
    { type: 'language', subtag: 'gwm', prefix: [], scope: null },
    { type: 'language', subtag: 'gwn', prefix: [], scope: null },
    { type: 'language', subtag: 'gwr', prefix: [], scope: null },
    { type: 'language', subtag: 'gwt', prefix: [], scope: null },
    { type: 'language', subtag: 'gwu', prefix: [], scope: null },
    { type: 'language', subtag: 'gww', prefix: [], scope: null },
    { type: 'language', subtag: 'gwx', prefix: [], scope: null },
    { type: 'language', subtag: 'gxx', prefix: [], scope: null },
    { type: 'language', subtag: 'gya', prefix: [], scope: null },
    { type: 'language', subtag: 'gyb', prefix: [], scope: null },
    { type: 'language', subtag: 'gyd', prefix: [], scope: null },
    { type: 'language', subtag: 'gye', prefix: [], scope: null },
    { type: 'language', subtag: 'gyf', prefix: [], scope: null },
    { type: 'language', subtag: 'gyg', prefix: [], scope: null },
    { type: 'language', subtag: 'gyi', prefix: [], scope: null },
    { type: 'language', subtag: 'gyl', prefix: [], scope: null },
    { type: 'language', subtag: 'gym', prefix: [], scope: null },
    { type: 'language', subtag: 'gyn', prefix: [], scope: null },
    { type: 'language', subtag: 'gyo', prefix: [], scope: null },
    { type: 'language', subtag: 'gyr', prefix: [], scope: null },
    { type: 'language', subtag: 'gyy', prefix: [], scope: null },
    { type: 'language', subtag: 'gyz', prefix: [], scope: null },
    { type: 'language', subtag: 'gza', prefix: [], scope: null },
    { type: 'language', subtag: 'gzi', prefix: [], scope: null },
    { type: 'language', subtag: 'gzn', prefix: [], scope: null },
    { type: 'language', subtag: 'haa', prefix: [], scope: null },
    { type: 'language', subtag: 'hab', prefix: [], scope: null },
    { type: 'language', subtag: 'hac', prefix: [], scope: null },
    { type: 'language', subtag: 'had', prefix: [], scope: null },
    { type: 'language', subtag: 'hae', prefix: [], scope: null },
    { type: 'language', subtag: 'haf', prefix: [], scope: null },
    { type: 'language', subtag: 'hag', prefix: [], scope: null },
    { type: 'language', subtag: 'hah', prefix: [], scope: null },
    { type: 'language', subtag: 'hai', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'haj', prefix: [], scope: null },
    { type: 'language', subtag: 'hak', prefix: [], scope: null },
    { type: 'language', subtag: 'hal', prefix: [], scope: null },
    { type: 'language', subtag: 'ham', prefix: [], scope: null },
    { type: 'language', subtag: 'han', prefix: [], scope: null },
    { type: 'language', subtag: 'hao', prefix: [], scope: null },
    { type: 'language', subtag: 'hap', prefix: [], scope: null },
    { type: 'language', subtag: 'haq', prefix: [], scope: null },
    { type: 'language', subtag: 'har', prefix: [], scope: null },
    { type: 'language', subtag: 'has', prefix: [], scope: null },
    { type: 'language', subtag: 'hav', prefix: [], scope: null },
    { type: 'language', subtag: 'haw', prefix: [], scope: null },
    { type: 'language', subtag: 'hax', prefix: [], scope: null },
    { type: 'language', subtag: 'hay', prefix: [], scope: null },
    { type: 'language', subtag: 'haz', prefix: [], scope: null },
    { type: 'language', subtag: 'hba', prefix: [], scope: null },
    { type: 'language', subtag: 'hbb', prefix: [], scope: null },
    { type: 'language', subtag: 'hbn', prefix: [], scope: null },
    { type: 'language', subtag: 'hbo', prefix: [], scope: null },
    { type: 'language', subtag: 'hbu', prefix: [], scope: null },
    { type: 'language', subtag: 'hca', prefix: [], scope: null },
    { type: 'language', subtag: 'hch', prefix: [], scope: null },
    { type: 'language', subtag: 'hdn', prefix: [], scope: null },
    { type: 'language', subtag: 'hds', prefix: [], scope: null },
    { type: 'language', subtag: 'hdy', prefix: [], scope: null },
    { type: 'language', subtag: 'hea', prefix: [], scope: null },
    { type: 'language', subtag: 'hed', prefix: [], scope: null },
    { type: 'language', subtag: 'heg', prefix: [], scope: null },
    { type: 'language', subtag: 'heh', prefix: [], scope: null },
    { type: 'language', subtag: 'hei', prefix: [], scope: null },
    { type: 'language', subtag: 'hem', prefix: [], scope: null },
    { type: 'language', subtag: 'hgm', prefix: [], scope: null },
    { type: 'language', subtag: 'hgw', prefix: [], scope: null },
    { type: 'language', subtag: 'hhi', prefix: [], scope: null },
    { type: 'language', subtag: 'hhr', prefix: [], scope: null },
    { type: 'language', subtag: 'hhy', prefix: [], scope: null },
    { type: 'language', subtag: 'hia', prefix: [], scope: null },
    { type: 'language', subtag: 'hib', prefix: [], scope: null },
    { type: 'language', subtag: 'hid', prefix: [], scope: null },
    { type: 'language', subtag: 'hif', prefix: [], scope: null },
    { type: 'language', subtag: 'hig', prefix: [], scope: null },
    { type: 'language', subtag: 'hih', prefix: [], scope: null },
    { type: 'language', subtag: 'hii', prefix: [], scope: null },
    { type: 'language', subtag: 'hij', prefix: [], scope: null },
    { type: 'language', subtag: 'hik', prefix: [], scope: null },
    { type: 'language', subtag: 'hil', prefix: [], scope: null },
    { type: 'language', subtag: 'him', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'hio', prefix: [], scope: null },
    { type: 'language', subtag: 'hir', prefix: [], scope: null },
    { type: 'language', subtag: 'hit', prefix: [], scope: null },
    { type: 'language', subtag: 'hiw', prefix: [], scope: null },
    { type: 'language', subtag: 'hix', prefix: [], scope: null },
    { type: 'language', subtag: 'hji', prefix: [], scope: null },
    { type: 'language', subtag: 'hka', prefix: [], scope: null },
    { type: 'language', subtag: 'hke', prefix: [], scope: null },
    { type: 'language', subtag: 'hkh', prefix: [], scope: null },
    { type: 'language', subtag: 'hkk', prefix: [], scope: null },
    { type: 'language', subtag: 'hkn', prefix: [], scope: null },
    { type: 'language', subtag: 'hks', prefix: [], scope: null },
    { type: 'language', subtag: 'hla', prefix: [], scope: null },
    { type: 'language', subtag: 'hlb', prefix: [], scope: null },
    { type: 'language', subtag: 'hld', prefix: [], scope: null },
    { type: 'language', subtag: 'hle', prefix: [], scope: null },
    { type: 'language', subtag: 'hlt', prefix: [], scope: null },
    { type: 'language', subtag: 'hlu', prefix: [], scope: null },
    { type: 'language', subtag: 'hma', prefix: [], scope: null },
    { type: 'language', subtag: 'hmb', prefix: [], scope: null },
    { type: 'language', subtag: 'hmc', prefix: [], scope: null },
    { type: 'language', subtag: 'hmd', prefix: [], scope: null },
    { type: 'language', subtag: 'hme', prefix: [], scope: null },
    { type: 'language', subtag: 'hmf', prefix: [], scope: null },
    { type: 'language', subtag: 'hmg', prefix: [], scope: null },
    { type: 'language', subtag: 'hmh', prefix: [], scope: null },
    { type: 'language', subtag: 'hmi', prefix: [], scope: null },
    { type: 'language', subtag: 'hmj', prefix: [], scope: null },
    { type: 'language', subtag: 'hmk', prefix: [], scope: null },
    { type: 'language', subtag: 'hml', prefix: [], scope: null },
    { type: 'language', subtag: 'hmm', prefix: [], scope: null },
    { type: 'language', subtag: 'hmn', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'hmp', prefix: [], scope: null },
    { type: 'language', subtag: 'hmq', prefix: [], scope: null },
    { type: 'language', subtag: 'hmr', prefix: [], scope: null },
    { type: 'language', subtag: 'hms', prefix: [], scope: null },
    { type: 'language', subtag: 'hmt', prefix: [], scope: null },
    { type: 'language', subtag: 'hmu', prefix: [], scope: null },
    { type: 'language', subtag: 'hmv', prefix: [], scope: null },
    { type: 'language', subtag: 'hmw', prefix: [], scope: null },
    { type: 'language', subtag: 'hmx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'hmy', prefix: [], scope: null },
    { type: 'language', subtag: 'hmz', prefix: [], scope: null },
    { type: 'language', subtag: 'hna', prefix: [], scope: null },
    { type: 'language', subtag: 'hnd', prefix: [], scope: null },
    { type: 'language', subtag: 'hne', prefix: [], scope: null },
    { type: 'language', subtag: 'hng', prefix: [], scope: null },
    { type: 'language', subtag: 'hnh', prefix: [], scope: null },
    { type: 'language', subtag: 'hni', prefix: [], scope: null },
    { type: 'language', subtag: 'hnj', prefix: [], scope: null },
    { type: 'language', subtag: 'hnn', prefix: [], scope: null },
    { type: 'language', subtag: 'hno', prefix: [], scope: null },
    { type: 'language', subtag: 'hns', prefix: [], scope: null },
    { type: 'language', subtag: 'hnu', prefix: [], scope: null },
    { type: 'language', subtag: 'hoa', prefix: [], scope: null },
    { type: 'language', subtag: 'hob', prefix: [], scope: null },
    { type: 'language', subtag: 'hoc', prefix: [], scope: null },
    { type: 'language', subtag: 'hod', prefix: [], scope: null },
    { type: 'language', subtag: 'hoe', prefix: [], scope: null },
    { type: 'language', subtag: 'hoh', prefix: [], scope: null },
    { type: 'language', subtag: 'hoi', prefix: [], scope: null },
    { type: 'language', subtag: 'hoj', prefix: [], scope: null },
    { type: 'language', subtag: 'hok', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'hol', prefix: [], scope: null },
    { type: 'language', subtag: 'hom', prefix: [], scope: null },
    { type: 'language', subtag: 'hoo', prefix: [], scope: null },
    { type: 'language', subtag: 'hop', prefix: [], scope: null },
    { type: 'language', subtag: 'hor', prefix: [], scope: null },
    { type: 'language', subtag: 'hos', prefix: [], scope: null },
    { type: 'language', subtag: 'hot', prefix: [], scope: null },
    { type: 'language', subtag: 'hov', prefix: [], scope: null },
    { type: 'language', subtag: 'how', prefix: [], scope: null },
    { type: 'language', subtag: 'hoy', prefix: [], scope: null },
    { type: 'language', subtag: 'hoz', prefix: [], scope: null },
    { type: 'language', subtag: 'hpo', prefix: [], scope: null },
    { type: 'language', subtag: 'hps', prefix: [], scope: null },
    { type: 'language', subtag: 'hra', prefix: [], scope: null },
    { type: 'language', subtag: 'hrc', prefix: [], scope: null },
    { type: 'language', subtag: 'hre', prefix: [], scope: null },
    { type: 'language', subtag: 'hrk', prefix: [], scope: null },
    { type: 'language', subtag: 'hrm', prefix: [], scope: null },
    { type: 'language', subtag: 'hro', prefix: [], scope: null },
    { type: 'language', subtag: 'hrp', prefix: [], scope: null },
    { type: 'language', subtag: 'hrr', prefix: [], scope: null },
    { type: 'language', subtag: 'hrt', prefix: [], scope: null },
    { type: 'language', subtag: 'hru', prefix: [], scope: null },
    { type: 'language', subtag: 'hrw', prefix: [], scope: null },
    { type: 'language', subtag: 'hrx', prefix: [], scope: null },
    { type: 'language', subtag: 'hrz', prefix: [], scope: null },
    { type: 'language', subtag: 'hsb', prefix: [], scope: null },
    { type: 'language', subtag: 'hsh', prefix: [], scope: null },
    { type: 'language', subtag: 'hsl', prefix: [], scope: null },
    { type: 'language', subtag: 'hsn', prefix: [], scope: null },
    { type: 'language', subtag: 'hss', prefix: [], scope: null },
    { type: 'language', subtag: 'hti', prefix: [], scope: null },
    { type: 'language', subtag: 'hto', prefix: [], scope: null },
    { type: 'language', subtag: 'hts', prefix: [], scope: null },
    { type: 'language', subtag: 'htu', prefix: [], scope: null },
    { type: 'language', subtag: 'htx', prefix: [], scope: null },
    { type: 'language', subtag: 'hub', prefix: [], scope: null },
    { type: 'language', subtag: 'huc', prefix: [], scope: null },
    { type: 'language', subtag: 'hud', prefix: [], scope: null },
    { type: 'language', subtag: 'hue', prefix: [], scope: null },
    { type: 'language', subtag: 'huf', prefix: [], scope: null },
    { type: 'language', subtag: 'hug', prefix: [], scope: null },
    { type: 'language', subtag: 'huh', prefix: [], scope: null },
    { type: 'language', subtag: 'hui', prefix: [], scope: null },
    { type: 'language', subtag: 'huj', prefix: [], scope: null },
    { type: 'language', subtag: 'huk', prefix: [], scope: null },
    { type: 'language', subtag: 'hul', prefix: [], scope: null },
    { type: 'language', subtag: 'hum', prefix: [], scope: null },
    { type: 'language', subtag: 'huo', prefix: [], scope: null },
    { type: 'language', subtag: 'hup', prefix: [], scope: null },
    { type: 'language', subtag: 'huq', prefix: [], scope: null },
    { type: 'language', subtag: 'hur', prefix: [], scope: null },
    { type: 'language', subtag: 'hus', prefix: [], scope: null },
    { type: 'language', subtag: 'hut', prefix: [], scope: null },
    { type: 'language', subtag: 'huu', prefix: [], scope: null },
    { type: 'language', subtag: 'huv', prefix: [], scope: null },
    { type: 'language', subtag: 'huw', prefix: [], scope: null },
    { type: 'language', subtag: 'hux', prefix: [], scope: null },
    { type: 'language', subtag: 'huy', prefix: [], scope: null },
    { type: 'language', subtag: 'huz', prefix: [], scope: null },
    { type: 'language', subtag: 'hvc', prefix: [], scope: null },
    { type: 'language', subtag: 'hve', prefix: [], scope: null },
    { type: 'language', subtag: 'hvk', prefix: [], scope: null },
    { type: 'language', subtag: 'hvn', prefix: [], scope: null },
    { type: 'language', subtag: 'hvv', prefix: [], scope: null },
    { type: 'language', subtag: 'hwa', prefix: [], scope: null },
    { type: 'language', subtag: 'hwc', prefix: [], scope: null },
    { type: 'language', subtag: 'hwo', prefix: [], scope: null },
    { type: 'language', subtag: 'hya', prefix: [], scope: null },
    { type: 'language', subtag: 'hyw', prefix: [], scope: null },
    { type: 'language', subtag: 'hyx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'iai', prefix: [], scope: null },
    { type: 'language', subtag: 'ian', prefix: [], scope: null },
    { type: 'language', subtag: 'iap', prefix: [], scope: null },
    { type: 'language', subtag: 'iar', prefix: [], scope: null },
    { type: 'language', subtag: 'iba', prefix: [], scope: null },
    { type: 'language', subtag: 'ibb', prefix: [], scope: null },
    { type: 'language', subtag: 'ibd', prefix: [], scope: null },
    { type: 'language', subtag: 'ibe', prefix: [], scope: null },
    { type: 'language', subtag: 'ibg', prefix: [], scope: null },
    { type: 'language', subtag: 'ibh', prefix: [], scope: null },
    { type: 'language', subtag: 'ibi', prefix: [], scope: null },
    { type: 'language', subtag: 'ibl', prefix: [], scope: null },
    { type: 'language', subtag: 'ibm', prefix: [], scope: null },
    { type: 'language', subtag: 'ibn', prefix: [], scope: null },
    { type: 'language', subtag: 'ibr', prefix: [], scope: null },
    { type: 'language', subtag: 'ibu', prefix: [], scope: null },
    { type: 'language', subtag: 'iby', prefix: [], scope: null },
    { type: 'language', subtag: 'ica', prefix: [], scope: null },
    { type: 'language', subtag: 'ich', prefix: [], scope: null },
    { type: 'language', subtag: 'icl', prefix: [], scope: null },
    { type: 'language', subtag: 'icr', prefix: [], scope: null },
    { type: 'language', subtag: 'ida', prefix: [], scope: null },
    { type: 'language', subtag: 'idb', prefix: [], scope: null },
    { type: 'language', subtag: 'idc', prefix: [], scope: null },
    { type: 'language', subtag: 'idd', prefix: [], scope: null },
    { type: 'language', subtag: 'ide', prefix: [], scope: null },
    { type: 'language', subtag: 'idi', prefix: [], scope: null },
    { type: 'language', subtag: 'idr', prefix: [], scope: null },
    { type: 'language', subtag: 'ids', prefix: [], scope: null },
    { type: 'language', subtag: 'idt', prefix: [], scope: null },
    { type: 'language', subtag: 'idu', prefix: [], scope: null },
    { type: 'language', subtag: 'ifa', prefix: [], scope: null },
    { type: 'language', subtag: 'ifb', prefix: [], scope: null },
    { type: 'language', subtag: 'ife', prefix: [], scope: null },
    { type: 'language', subtag: 'iff', prefix: [], scope: null },
    { type: 'language', subtag: 'ifk', prefix: [], scope: null },
    { type: 'language', subtag: 'ifm', prefix: [], scope: null },
    { type: 'language', subtag: 'ifu', prefix: [], scope: null },
    { type: 'language', subtag: 'ify', prefix: [], scope: null },
    { type: 'language', subtag: 'igb', prefix: [], scope: null },
    { type: 'language', subtag: 'ige', prefix: [], scope: null },
    { type: 'language', subtag: 'igg', prefix: [], scope: null },
    { type: 'language', subtag: 'igl', prefix: [], scope: null },
    { type: 'language', subtag: 'igm', prefix: [], scope: null },
    { type: 'language', subtag: 'ign', prefix: [], scope: null },
    { type: 'language', subtag: 'igo', prefix: [], scope: null },
    { type: 'language', subtag: 'igs', prefix: [], scope: null },
    { type: 'language', subtag: 'igw', prefix: [], scope: null },
    { type: 'language', subtag: 'ihb', prefix: [], scope: null },
    { type: 'language', subtag: 'ihi', prefix: [], scope: null },
    { type: 'language', subtag: 'ihp', prefix: [], scope: null },
    { type: 'language', subtag: 'ihw', prefix: [], scope: null },
    { type: 'language', subtag: 'iin', prefix: [], scope: null },
    { type: 'language', subtag: 'iir', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ijc', prefix: [], scope: null },
    { type: 'language', subtag: 'ije', prefix: [], scope: null },
    { type: 'language', subtag: 'ijj', prefix: [], scope: null },
    { type: 'language', subtag: 'ijn', prefix: [], scope: null },
    { type: 'language', subtag: 'ijo', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ijs', prefix: [], scope: null },
    { type: 'language', subtag: 'ike', prefix: [], scope: null },
    { type: 'language', subtag: 'iki', prefix: [], scope: null },
    { type: 'language', subtag: 'ikk', prefix: [], scope: null },
    { type: 'language', subtag: 'ikl', prefix: [], scope: null },
    { type: 'language', subtag: 'iko', prefix: [], scope: null },
    { type: 'language', subtag: 'ikp', prefix: [], scope: null },
    { type: 'language', subtag: 'ikr', prefix: [], scope: null },
    { type: 'language', subtag: 'iks', prefix: [], scope: null },
    { type: 'language', subtag: 'ikt', prefix: [], scope: null },
    { type: 'language', subtag: 'ikv', prefix: [], scope: null },
    { type: 'language', subtag: 'ikw', prefix: [], scope: null },
    { type: 'language', subtag: 'ikx', prefix: [], scope: null },
    { type: 'language', subtag: 'ikz', prefix: [], scope: null },
    { type: 'language', subtag: 'ila', prefix: [], scope: null },
    { type: 'language', subtag: 'ilb', prefix: [], scope: null },
    { type: 'language', subtag: 'ilg', prefix: [], scope: null },
    { type: 'language', subtag: 'ili', prefix: [], scope: null },
    { type: 'language', subtag: 'ilk', prefix: [], scope: null },
    { type: 'language', subtag: 'ill', prefix: [], scope: null },
    { type: 'language', subtag: 'ilm', prefix: [], scope: null },
    { type: 'language', subtag: 'ilo', prefix: [], scope: null },
    { type: 'language', subtag: 'ilp', prefix: [], scope: null },
    { type: 'language', subtag: 'ils', prefix: [], scope: null },
    { type: 'language', subtag: 'ilu', prefix: [], scope: null },
    { type: 'language', subtag: 'ilv', prefix: [], scope: null },
    { type: 'language', subtag: 'ilw', prefix: [], scope: null },
    { type: 'language', subtag: 'ima', prefix: [], scope: null },
    { type: 'language', subtag: 'ime', prefix: [], scope: null },
    { type: 'language', subtag: 'imi', prefix: [], scope: null },
    { type: 'language', subtag: 'iml', prefix: [], scope: null },
    { type: 'language', subtag: 'imn', prefix: [], scope: null },
    { type: 'language', subtag: 'imo', prefix: [], scope: null },
    { type: 'language', subtag: 'imr', prefix: [], scope: null },
    { type: 'language', subtag: 'ims', prefix: [], scope: null },
    { type: 'language', subtag: 'imt', prefix: [], scope: null },
    { type: 'language', subtag: 'imy', prefix: [], scope: null },
    { type: 'language', subtag: 'inb', prefix: [], scope: null },
    { type: 'language', subtag: 'inc', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ine', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ing', prefix: [], scope: null },
    { type: 'language', subtag: 'inh', prefix: [], scope: null },
    { type: 'language', subtag: 'inj', prefix: [], scope: null },
    { type: 'language', subtag: 'inl', prefix: [], scope: null },
    { type: 'language', subtag: 'inm', prefix: [], scope: null },
    { type: 'language', subtag: 'inn', prefix: [], scope: null },
    { type: 'language', subtag: 'ino', prefix: [], scope: null },
    { type: 'language', subtag: 'inp', prefix: [], scope: null },
    { type: 'language', subtag: 'ins', prefix: [], scope: null },
    { type: 'language', subtag: 'int', prefix: [], scope: null },
    { type: 'language', subtag: 'inz', prefix: [], scope: null },
    { type: 'language', subtag: 'ior', prefix: [], scope: null },
    { type: 'language', subtag: 'iou', prefix: [], scope: null },
    { type: 'language', subtag: 'iow', prefix: [], scope: null },
    { type: 'language', subtag: 'ipi', prefix: [], scope: null },
    { type: 'language', subtag: 'ipo', prefix: [], scope: null },
    { type: 'language', subtag: 'iqu', prefix: [], scope: null },
    { type: 'language', subtag: 'iqw', prefix: [], scope: null },
    { type: 'language', subtag: 'ira', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ire', prefix: [], scope: null },
    { type: 'language', subtag: 'irh', prefix: [], scope: null },
    { type: 'language', subtag: 'iri', prefix: [], scope: null },
    { type: 'language', subtag: 'irk', prefix: [], scope: null },
    { type: 'language', subtag: 'irn', prefix: [], scope: null },
    { type: 'language', subtag: 'iro', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'irr', prefix: [], scope: null },
    { type: 'language', subtag: 'iru', prefix: [], scope: null },
    { type: 'language', subtag: 'irx', prefix: [], scope: null },
    { type: 'language', subtag: 'iry', prefix: [], scope: null },
    { type: 'language', subtag: 'isa', prefix: [], scope: null },
    { type: 'language', subtag: 'isc', prefix: [], scope: null },
    { type: 'language', subtag: 'isd', prefix: [], scope: null },
    { type: 'language', subtag: 'ise', prefix: [], scope: null },
    { type: 'language', subtag: 'isg', prefix: [], scope: null },
    { type: 'language', subtag: 'ish', prefix: [], scope: null },
    { type: 'language', subtag: 'isi', prefix: [], scope: null },
    { type: 'language', subtag: 'isk', prefix: [], scope: null },
    { type: 'language', subtag: 'ism', prefix: [], scope: null },
    { type: 'language', subtag: 'isn', prefix: [], scope: null },
    { type: 'language', subtag: 'iso', prefix: [], scope: null },
    { type: 'language', subtag: 'isr', prefix: [], scope: null },
    { type: 'language', subtag: 'ist', prefix: [], scope: null },
    { type: 'language', subtag: 'isu', prefix: [], scope: null },
    { type: 'language', subtag: 'itb', prefix: [], scope: null },
    { type: 'language', subtag: 'itc', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'itd', prefix: [], scope: null },
    { type: 'language', subtag: 'ite', prefix: [], scope: null },
    { type: 'language', subtag: 'iti', prefix: [], scope: null },
    { type: 'language', subtag: 'itk', prefix: [], scope: null },
    { type: 'language', subtag: 'itl', prefix: [], scope: null },
    { type: 'language', subtag: 'itm', prefix: [], scope: null },
    { type: 'language', subtag: 'ito', prefix: [], scope: null },
    { type: 'language', subtag: 'itr', prefix: [], scope: null },
    { type: 'language', subtag: 'its', prefix: [], scope: null },
    { type: 'language', subtag: 'itt', prefix: [], scope: null },
    { type: 'language', subtag: 'itv', prefix: [], scope: null },
    { type: 'language', subtag: 'itw', prefix: [], scope: null },
    { type: 'language', subtag: 'itx', prefix: [], scope: null },
    { type: 'language', subtag: 'ity', prefix: [], scope: null },
    { type: 'language', subtag: 'itz', prefix: [], scope: null },
    { type: 'language', subtag: 'ium', prefix: [], scope: null },
    { type: 'language', subtag: 'ivb', prefix: [], scope: null },
    { type: 'language', subtag: 'ivv', prefix: [], scope: null },
    { type: 'language', subtag: 'iwk', prefix: [], scope: null },
    { type: 'language', subtag: 'iwm', prefix: [], scope: null },
    { type: 'language', subtag: 'iwo', prefix: [], scope: null },
    { type: 'language', subtag: 'iws', prefix: [], scope: null },
    { type: 'language', subtag: 'ixc', prefix: [], scope: null },
    { type: 'language', subtag: 'ixl', prefix: [], scope: null },
    { type: 'language', subtag: 'iya', prefix: [], scope: null },
    { type: 'language', subtag: 'iyo', prefix: [], scope: null },
    { type: 'language', subtag: 'iyx', prefix: [], scope: null },
    { type: 'language', subtag: 'izh', prefix: [], scope: null },
    { type: 'language', subtag: 'izi', prefix: [], scope: null },
    { type: 'language', subtag: 'izr', prefix: [], scope: null },
    { type: 'language', subtag: 'izz', prefix: [], scope: null },
    { type: 'language', subtag: 'jaa', prefix: [], scope: null },
    { type: 'language', subtag: 'jab', prefix: [], scope: null },
    { type: 'language', subtag: 'jac', prefix: [], scope: null },
    { type: 'language', subtag: 'jad', prefix: [], scope: null },
    { type: 'language', subtag: 'jae', prefix: [], scope: null },
    { type: 'language', subtag: 'jaf', prefix: [], scope: null },
    { type: 'language', subtag: 'jah', prefix: [], scope: null },
    { type: 'language', subtag: 'jaj', prefix: [], scope: null },
    { type: 'language', subtag: 'jak', prefix: [], scope: null },
    { type: 'language', subtag: 'jal', prefix: [], scope: null },
    { type: 'language', subtag: 'jam', prefix: [], scope: null },
    { type: 'language', subtag: 'jan', prefix: [], scope: null },
    { type: 'language', subtag: 'jao', prefix: [], scope: null },
    { type: 'language', subtag: 'jaq', prefix: [], scope: null },
    { type: 'language', subtag: 'jar', prefix: [], scope: null },
    { type: 'language', subtag: 'jas', prefix: [], scope: null },
    { type: 'language', subtag: 'jat', prefix: [], scope: null },
    { type: 'language', subtag: 'jau', prefix: [], scope: null },
    { type: 'language', subtag: 'jax', prefix: [], scope: null },
    { type: 'language', subtag: 'jay', prefix: [], scope: null },
    { type: 'language', subtag: 'jaz', prefix: [], scope: null },
    { type: 'language', subtag: 'jbe', prefix: [], scope: null },
    { type: 'language', subtag: 'jbi', prefix: [], scope: null },
    { type: 'language', subtag: 'jbj', prefix: [], scope: null },
    { type: 'language', subtag: 'jbk', prefix: [], scope: null },
    { type: 'language', subtag: 'jbm', prefix: [], scope: null },
    { type: 'language', subtag: 'jbn', prefix: [], scope: null },
    { type: 'language', subtag: 'jbo', prefix: [], scope: null },
    { type: 'language', subtag: 'jbr', prefix: [], scope: null },
    { type: 'language', subtag: 'jbt', prefix: [], scope: null },
    { type: 'language', subtag: 'jbu', prefix: [], scope: null },
    { type: 'language', subtag: 'jbw', prefix: [], scope: null },
    { type: 'language', subtag: 'jcs', prefix: [], scope: null },
    { type: 'language', subtag: 'jct', prefix: [], scope: null },
    { type: 'language', subtag: 'jda', prefix: [], scope: null },
    { type: 'language', subtag: 'jdg', prefix: [], scope: null },
    { type: 'language', subtag: 'jdt', prefix: [], scope: null },
    { type: 'language', subtag: 'jeb', prefix: [], scope: null },
    { type: 'language', subtag: 'jee', prefix: [], scope: null },
    { type: 'language', subtag: 'jeg', prefix: [], scope: null },
    { type: 'language', subtag: 'jeh', prefix: [], scope: null },
    { type: 'language', subtag: 'jei', prefix: [], scope: null },
    { type: 'language', subtag: 'jek', prefix: [], scope: null },
    { type: 'language', subtag: 'jel', prefix: [], scope: null },
    { type: 'language', subtag: 'jen', prefix: [], scope: null },
    { type: 'language', subtag: 'jer', prefix: [], scope: null },
    { type: 'language', subtag: 'jet', prefix: [], scope: null },
    { type: 'language', subtag: 'jeu', prefix: [], scope: null },
    { type: 'language', subtag: 'jgb', prefix: [], scope: null },
    { type: 'language', subtag: 'jge', prefix: [], scope: null },
    { type: 'language', subtag: 'jgk', prefix: [], scope: null },
    { type: 'language', subtag: 'jgo', prefix: [], scope: null },
    { type: 'language', subtag: 'jhi', prefix: [], scope: null },
    { type: 'language', subtag: 'jhs', prefix: [], scope: null },
    { type: 'language', subtag: 'jia', prefix: [], scope: null },
    { type: 'language', subtag: 'jib', prefix: [], scope: null },
    { type: 'language', subtag: 'jic', prefix: [], scope: null },
    { type: 'language', subtag: 'jid', prefix: [], scope: null },
    { type: 'language', subtag: 'jie', prefix: [], scope: null },
    { type: 'language', subtag: 'jig', prefix: [], scope: null },
    { type: 'language', subtag: 'jih', prefix: [], scope: null },
    { type: 'language', subtag: 'jii', prefix: [], scope: null },
    { type: 'language', subtag: 'jil', prefix: [], scope: null },
    { type: 'language', subtag: 'jim', prefix: [], scope: null },
    { type: 'language', subtag: 'jio', prefix: [], scope: null },
    { type: 'language', subtag: 'jiq', prefix: [], scope: null },
    { type: 'language', subtag: 'jit', prefix: [], scope: null },
    { type: 'language', subtag: 'jiu', prefix: [], scope: null },
    { type: 'language', subtag: 'jiv', prefix: [], scope: null },
    { type: 'language', subtag: 'jiy', prefix: [], scope: null },
    { type: 'language', subtag: 'jje', prefix: [], scope: null },
    { type: 'language', subtag: 'jjr', prefix: [], scope: null },
    { type: 'language', subtag: 'jka', prefix: [], scope: null },
    { type: 'language', subtag: 'jkm', prefix: [], scope: null },
    { type: 'language', subtag: 'jko', prefix: [], scope: null },
    { type: 'language', subtag: 'jkp', prefix: [], scope: null },
    { type: 'language', subtag: 'jkr', prefix: [], scope: null },
    { type: 'language', subtag: 'jks', prefix: [], scope: null },
    { type: 'language', subtag: 'jku', prefix: [], scope: null },
    { type: 'language', subtag: 'jle', prefix: [], scope: null },
    { type: 'language', subtag: 'jls', prefix: [], scope: null },
    { type: 'language', subtag: 'jma', prefix: [], scope: null },
    { type: 'language', subtag: 'jmb', prefix: [], scope: null },
    { type: 'language', subtag: 'jmc', prefix: [], scope: null },
    { type: 'language', subtag: 'jmd', prefix: [], scope: null },
    { type: 'language', subtag: 'jmi', prefix: [], scope: null },
    { type: 'language', subtag: 'jml', prefix: [], scope: null },
    { type: 'language', subtag: 'jmn', prefix: [], scope: null },
    { type: 'language', subtag: 'jmr', prefix: [], scope: null },
    { type: 'language', subtag: 'jms', prefix: [], scope: null },
    { type: 'language', subtag: 'jmw', prefix: [], scope: null },
    { type: 'language', subtag: 'jmx', prefix: [], scope: null },
    { type: 'language', subtag: 'jna', prefix: [], scope: null },
    { type: 'language', subtag: 'jnd', prefix: [], scope: null },
    { type: 'language', subtag: 'jng', prefix: [], scope: null },
    { type: 'language', subtag: 'jni', prefix: [], scope: null },
    { type: 'language', subtag: 'jnj', prefix: [], scope: null },
    { type: 'language', subtag: 'jnl', prefix: [], scope: null },
    { type: 'language', subtag: 'jns', prefix: [], scope: null },
    { type: 'language', subtag: 'job', prefix: [], scope: null },
    { type: 'language', subtag: 'jod', prefix: [], scope: null },
    { type: 'language', subtag: 'jog', prefix: [], scope: null },
    { type: 'language', subtag: 'jor', prefix: [], scope: null },
    { type: 'language', subtag: 'jos', prefix: [], scope: null },
    { type: 'language', subtag: 'jow', prefix: [], scope: null },
    { type: 'language', subtag: 'jpa', prefix: [], scope: null },
    { type: 'language', subtag: 'jpr', prefix: [], scope: null },
    { type: 'language', subtag: 'jpx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'jqr', prefix: [], scope: null },
    { type: 'language', subtag: 'jra', prefix: [], scope: null },
    { type: 'language', subtag: 'jrb', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'jrr', prefix: [], scope: null },
    { type: 'language', subtag: 'jrt', prefix: [], scope: null },
    { type: 'language', subtag: 'jru', prefix: [], scope: null },
    { type: 'language', subtag: 'jsl', prefix: [], scope: null },
    { type: 'language', subtag: 'jua', prefix: [], scope: null },
    { type: 'language', subtag: 'jub', prefix: [], scope: null },
    { type: 'language', subtag: 'juc', prefix: [], scope: null },
    { type: 'language', subtag: 'jud', prefix: [], scope: null },
    { type: 'language', subtag: 'juh', prefix: [], scope: null },
    { type: 'language', subtag: 'jui', prefix: [], scope: null },
    { type: 'language', subtag: 'juk', prefix: [], scope: null },
    { type: 'language', subtag: 'jul', prefix: [], scope: null },
    { type: 'language', subtag: 'jum', prefix: [], scope: null },
    { type: 'language', subtag: 'jun', prefix: [], scope: null },
    { type: 'language', subtag: 'juo', prefix: [], scope: null },
    { type: 'language', subtag: 'jup', prefix: [], scope: null },
    { type: 'language', subtag: 'jur', prefix: [], scope: null },
    { type: 'language', subtag: 'jus', prefix: [], scope: null },
    { type: 'language', subtag: 'jut', prefix: [], scope: null },
    { type: 'language', subtag: 'juu', prefix: [], scope: null },
    { type: 'language', subtag: 'juw', prefix: [], scope: null },
    { type: 'language', subtag: 'juy', prefix: [], scope: null },
    { type: 'language', subtag: 'jvd', prefix: [], scope: null },
    { type: 'language', subtag: 'jvn', prefix: [], scope: null },
    { type: 'language', subtag: 'jwi', prefix: [], scope: null },
    { type: 'language', subtag: 'jya', prefix: [], scope: null },
    { type: 'language', subtag: 'jye', prefix: [], scope: null },
    { type: 'language', subtag: 'jyy', prefix: [], scope: null },
    { type: 'language', subtag: 'kaa', prefix: [], scope: null },
    { type: 'language', subtag: 'kab', prefix: [], scope: null },
    { type: 'language', subtag: 'kac', prefix: [], scope: null },
    { type: 'language', subtag: 'kad', prefix: [], scope: null },
    { type: 'language', subtag: 'kae', prefix: [], scope: null },
    { type: 'language', subtag: 'kaf', prefix: [], scope: null },
    { type: 'language', subtag: 'kag', prefix: [], scope: null },
    { type: 'language', subtag: 'kah', prefix: [], scope: null },
    { type: 'language', subtag: 'kai', prefix: [], scope: null },
    { type: 'language', subtag: 'kaj', prefix: [], scope: null },
    { type: 'language', subtag: 'kak', prefix: [], scope: null },
    { type: 'language', subtag: 'kam', prefix: [], scope: null },
    { type: 'language', subtag: 'kao', prefix: [], scope: null },
    { type: 'language', subtag: 'kap', prefix: [], scope: null },
    { type: 'language', subtag: 'kaq', prefix: [], scope: null },
    { type: 'language', subtag: 'kar', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'kav', prefix: [], scope: null },
    { type: 'language', subtag: 'kaw', prefix: [], scope: null },
    { type: 'language', subtag: 'kax', prefix: [], scope: null },
    { type: 'language', subtag: 'kay', prefix: [], scope: null },
    { type: 'language', subtag: 'kba', prefix: [], scope: null },
    { type: 'language', subtag: 'kbb', prefix: [], scope: null },
    { type: 'language', subtag: 'kbc', prefix: [], scope: null },
    { type: 'language', subtag: 'kbd', prefix: [], scope: null },
    { type: 'language', subtag: 'kbe', prefix: [], scope: null },
    { type: 'language', subtag: 'kbf', prefix: [], scope: null },
    { type: 'language', subtag: 'kbg', prefix: [], scope: null },
    { type: 'language', subtag: 'kbh', prefix: [], scope: null },
    { type: 'language', subtag: 'kbi', prefix: [], scope: null },
    { type: 'language', subtag: 'kbj', prefix: [], scope: null },
    { type: 'language', subtag: 'kbk', prefix: [], scope: null },
    { type: 'language', subtag: 'kbl', prefix: [], scope: null },
    { type: 'language', subtag: 'kbm', prefix: [], scope: null },
    { type: 'language', subtag: 'kbn', prefix: [], scope: null },
    { type: 'language', subtag: 'kbo', prefix: [], scope: null },
    { type: 'language', subtag: 'kbp', prefix: [], scope: null },
    { type: 'language', subtag: 'kbq', prefix: [], scope: null },
    { type: 'language', subtag: 'kbr', prefix: [], scope: null },
    { type: 'language', subtag: 'kbs', prefix: [], scope: null },
    { type: 'language', subtag: 'kbt', prefix: [], scope: null },
    { type: 'language', subtag: 'kbu', prefix: [], scope: null },
    { type: 'language', subtag: 'kbv', prefix: [], scope: null },
    { type: 'language', subtag: 'kbw', prefix: [], scope: null },
    { type: 'language', subtag: 'kbx', prefix: [], scope: null },
    { type: 'language', subtag: 'kby', prefix: [], scope: null },
    { type: 'language', subtag: 'kbz', prefix: [], scope: null },
    { type: 'language', subtag: 'kca', prefix: [], scope: null },
    { type: 'language', subtag: 'kcb', prefix: [], scope: null },
    { type: 'language', subtag: 'kcc', prefix: [], scope: null },
    { type: 'language', subtag: 'kcd', prefix: [], scope: null },
    { type: 'language', subtag: 'kce', prefix: [], scope: null },
    { type: 'language', subtag: 'kcf', prefix: [], scope: null },
    { type: 'language', subtag: 'kcg', prefix: [], scope: null },
    { type: 'language', subtag: 'kch', prefix: [], scope: null },
    { type: 'language', subtag: 'kci', prefix: [], scope: null },
    { type: 'language', subtag: 'kcj', prefix: [], scope: null },
    { type: 'language', subtag: 'kck', prefix: [], scope: null },
    { type: 'language', subtag: 'kcl', prefix: [], scope: null },
    { type: 'language', subtag: 'kcm', prefix: [], scope: null },
    { type: 'language', subtag: 'kcn', prefix: [], scope: null },
    { type: 'language', subtag: 'kco', prefix: [], scope: null },
    { type: 'language', subtag: 'kcp', prefix: [], scope: null },
    { type: 'language', subtag: 'kcq', prefix: [], scope: null },
    { type: 'language', subtag: 'kcr', prefix: [], scope: null },
    { type: 'language', subtag: 'kcs', prefix: [], scope: null },
    { type: 'language', subtag: 'kct', prefix: [], scope: null },
    { type: 'language', subtag: 'kcu', prefix: [], scope: null },
    { type: 'language', subtag: 'kcv', prefix: [], scope: null },
    { type: 'language', subtag: 'kcw', prefix: [], scope: null },
    { type: 'language', subtag: 'kcx', prefix: [], scope: null },
    { type: 'language', subtag: 'kcy', prefix: [], scope: null },
    { type: 'language', subtag: 'kcz', prefix: [], scope: null },
    { type: 'language', subtag: 'kda', prefix: [], scope: null },
    { type: 'language', subtag: 'kdc', prefix: [], scope: null },
    { type: 'language', subtag: 'kdd', prefix: [], scope: null },
    { type: 'language', subtag: 'kde', prefix: [], scope: null },
    { type: 'language', subtag: 'kdf', prefix: [], scope: null },
    { type: 'language', subtag: 'kdg', prefix: [], scope: null },
    { type: 'language', subtag: 'kdh', prefix: [], scope: null },
    { type: 'language', subtag: 'kdi', prefix: [], scope: null },
    { type: 'language', subtag: 'kdj', prefix: [], scope: null },
    { type: 'language', subtag: 'kdk', prefix: [], scope: null },
    { type: 'language', subtag: 'kdl', prefix: [], scope: null },
    { type: 'language', subtag: 'kdm', prefix: [], scope: null },
    { type: 'language', subtag: 'kdn', prefix: [], scope: null },
    { type: 'language', subtag: 'kdo', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'kdp', prefix: [], scope: null },
    { type: 'language', subtag: 'kdq', prefix: [], scope: null },
    { type: 'language', subtag: 'kdr', prefix: [], scope: null },
    { type: 'language', subtag: 'kdt', prefix: [], scope: null },
    { type: 'language', subtag: 'kdu', prefix: [], scope: null },
    { type: 'language', subtag: 'kdv', prefix: [], scope: null },
    { type: 'language', subtag: 'kdw', prefix: [], scope: null },
    { type: 'language', subtag: 'kdx', prefix: [], scope: null },
    { type: 'language', subtag: 'kdy', prefix: [], scope: null },
    { type: 'language', subtag: 'kdz', prefix: [], scope: null },
    { type: 'language', subtag: 'kea', prefix: [], scope: null },
    { type: 'language', subtag: 'keb', prefix: [], scope: null },
    { type: 'language', subtag: 'kec', prefix: [], scope: null },
    { type: 'language', subtag: 'ked', prefix: [], scope: null },
    { type: 'language', subtag: 'kee', prefix: [], scope: null },
    { type: 'language', subtag: 'kef', prefix: [], scope: null },
    { type: 'language', subtag: 'keg', prefix: [], scope: null },
    { type: 'language', subtag: 'keh', prefix: [], scope: null },
    { type: 'language', subtag: 'kei', prefix: [], scope: null },
    { type: 'language', subtag: 'kej', prefix: [], scope: null },
    { type: 'language', subtag: 'kek', prefix: [], scope: null },
    { type: 'language', subtag: 'kel', prefix: [], scope: null },
    { type: 'language', subtag: 'kem', prefix: [], scope: null },
    { type: 'language', subtag: 'ken', prefix: [], scope: null },
    { type: 'language', subtag: 'keo', prefix: [], scope: null },
    { type: 'language', subtag: 'kep', prefix: [], scope: null },
    { type: 'language', subtag: 'keq', prefix: [], scope: null },
    { type: 'language', subtag: 'ker', prefix: [], scope: null },
    { type: 'language', subtag: 'kes', prefix: [], scope: null },
    { type: 'language', subtag: 'ket', prefix: [], scope: null },
    { type: 'language', subtag: 'keu', prefix: [], scope: null },
    { type: 'language', subtag: 'kev', prefix: [], scope: null },
    { type: 'language', subtag: 'kew', prefix: [], scope: null },
    { type: 'language', subtag: 'kex', prefix: [], scope: null },
    { type: 'language', subtag: 'key', prefix: [], scope: null },
    { type: 'language', subtag: 'kez', prefix: [], scope: null },
    { type: 'language', subtag: 'kfa', prefix: [], scope: null },
    { type: 'language', subtag: 'kfb', prefix: [], scope: null },
    { type: 'language', subtag: 'kfc', prefix: [], scope: null },
    { type: 'language', subtag: 'kfd', prefix: [], scope: null },
    { type: 'language', subtag: 'kfe', prefix: [], scope: null },
    { type: 'language', subtag: 'kff', prefix: [], scope: null },
    { type: 'language', subtag: 'kfg', prefix: [], scope: null },
    { type: 'language', subtag: 'kfh', prefix: [], scope: null },
    { type: 'language', subtag: 'kfi', prefix: [], scope: null },
    { type: 'language', subtag: 'kfj', prefix: [], scope: null },
    { type: 'language', subtag: 'kfk', prefix: [], scope: null },
    { type: 'language', subtag: 'kfl', prefix: [], scope: null },
    { type: 'language', subtag: 'kfm', prefix: [], scope: null },
    { type: 'language', subtag: 'kfn', prefix: [], scope: null },
    { type: 'language', subtag: 'kfo', prefix: [], scope: null },
    { type: 'language', subtag: 'kfp', prefix: [], scope: null },
    { type: 'language', subtag: 'kfq', prefix: [], scope: null },
    { type: 'language', subtag: 'kfr', prefix: [], scope: null },
    { type: 'language', subtag: 'kfs', prefix: [], scope: null },
    { type: 'language', subtag: 'kft', prefix: [], scope: null },
    { type: 'language', subtag: 'kfu', prefix: [], scope: null },
    { type: 'language', subtag: 'kfv', prefix: [], scope: null },
    { type: 'language', subtag: 'kfw', prefix: [], scope: null },
    { type: 'language', subtag: 'kfx', prefix: [], scope: null },
    { type: 'language', subtag: 'kfy', prefix: [], scope: null },
    { type: 'language', subtag: 'kfz', prefix: [], scope: null },
    { type: 'language', subtag: 'kga', prefix: [], scope: null },
    { type: 'language', subtag: 'kgb', prefix: [], scope: null },
    { type: 'language', subtag: 'kgc', prefix: [], scope: null },
    { type: 'language', subtag: 'kgd', prefix: [], scope: null },
    { type: 'language', subtag: 'kge', prefix: [], scope: null },
    { type: 'language', subtag: 'kgf', prefix: [], scope: null },
    { type: 'language', subtag: 'kgg', prefix: [], scope: null },
    { type: 'language', subtag: 'kgh', prefix: [], scope: null },
    { type: 'language', subtag: 'kgi', prefix: [], scope: null },
    { type: 'language', subtag: 'kgj', prefix: [], scope: null },
    { type: 'language', subtag: 'kgk', prefix: [], scope: null },
    { type: 'language', subtag: 'kgl', prefix: [], scope: null },
    { type: 'language', subtag: 'kgm', prefix: [], scope: null },
    { type: 'language', subtag: 'kgn', prefix: [], scope: null },
    { type: 'language', subtag: 'kgo', prefix: [], scope: null },
    { type: 'language', subtag: 'kgp', prefix: [], scope: null },
    { type: 'language', subtag: 'kgq', prefix: [], scope: null },
    { type: 'language', subtag: 'kgr', prefix: [], scope: null },
    { type: 'language', subtag: 'kgs', prefix: [], scope: null },
    { type: 'language', subtag: 'kgt', prefix: [], scope: null },
    { type: 'language', subtag: 'kgu', prefix: [], scope: null },
    { type: 'language', subtag: 'kgv', prefix: [], scope: null },
    { type: 'language', subtag: 'kgw', prefix: [], scope: null },
    { type: 'language', subtag: 'kgx', prefix: [], scope: null },
    { type: 'language', subtag: 'kgy', prefix: [], scope: null },
    { type: 'language', subtag: 'kha', prefix: [], scope: null },
    { type: 'language', subtag: 'khb', prefix: [], scope: null },
    { type: 'language', subtag: 'khc', prefix: [], scope: null },
    { type: 'language', subtag: 'khd', prefix: [], scope: null },
    { type: 'language', subtag: 'khe', prefix: [], scope: null },
    { type: 'language', subtag: 'khf', prefix: [], scope: null },
    { type: 'language', subtag: 'khg', prefix: [], scope: null },
    { type: 'language', subtag: 'khh', prefix: [], scope: null },
    { type: 'language', subtag: 'khi', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'khj', prefix: [], scope: null },
    { type: 'language', subtag: 'khk', prefix: [], scope: null },
    { type: 'language', subtag: 'khl', prefix: [], scope: null },
    { type: 'language', subtag: 'khn', prefix: [], scope: null },
    { type: 'language', subtag: 'kho', prefix: [], scope: null },
    { type: 'language', subtag: 'khp', prefix: [], scope: null },
    { type: 'language', subtag: 'khq', prefix: [], scope: null },
    { type: 'language', subtag: 'khr', prefix: [], scope: null },
    { type: 'language', subtag: 'khs', prefix: [], scope: null },
    { type: 'language', subtag: 'kht', prefix: [], scope: null },
    { type: 'language', subtag: 'khu', prefix: [], scope: null },
    { type: 'language', subtag: 'khv', prefix: [], scope: null },
    { type: 'language', subtag: 'khw', prefix: [], scope: null },
    { type: 'language', subtag: 'khx', prefix: [], scope: null },
    { type: 'language', subtag: 'khy', prefix: [], scope: null },
    { type: 'language', subtag: 'khz', prefix: [], scope: null },
    { type: 'language', subtag: 'kia', prefix: [], scope: null },
    { type: 'language', subtag: 'kib', prefix: [], scope: null },
    { type: 'language', subtag: 'kic', prefix: [], scope: null },
    { type: 'language', subtag: 'kid', prefix: [], scope: null },
    { type: 'language', subtag: 'kie', prefix: [], scope: null },
    { type: 'language', subtag: 'kif', prefix: [], scope: null },
    { type: 'language', subtag: 'kig', prefix: [], scope: null },
    { type: 'language', subtag: 'kih', prefix: [], scope: null },
    { type: 'language', subtag: 'kii', prefix: [], scope: null },
    { type: 'language', subtag: 'kij', prefix: [], scope: null },
    { type: 'language', subtag: 'kil', prefix: [], scope: null },
    { type: 'language', subtag: 'kim', prefix: [], scope: null },
    { type: 'language', subtag: 'kio', prefix: [], scope: null },
    { type: 'language', subtag: 'kip', prefix: [], scope: null },
    { type: 'language', subtag: 'kiq', prefix: [], scope: null },
    { type: 'language', subtag: 'kis', prefix: [], scope: null },
    { type: 'language', subtag: 'kit', prefix: [], scope: null },
    { type: 'language', subtag: 'kiu', prefix: [], scope: null },
    { type: 'language', subtag: 'kiv', prefix: [], scope: null },
    { type: 'language', subtag: 'kiw', prefix: [], scope: null },
    { type: 'language', subtag: 'kix', prefix: [], scope: null },
    { type: 'language', subtag: 'kiy', prefix: [], scope: null },
    { type: 'language', subtag: 'kiz', prefix: [], scope: null },
    { type: 'language', subtag: 'kja', prefix: [], scope: null },
    { type: 'language', subtag: 'kjb', prefix: [], scope: null },
    { type: 'language', subtag: 'kjc', prefix: [], scope: null },
    { type: 'language', subtag: 'kjd', prefix: [], scope: null },
    { type: 'language', subtag: 'kje', prefix: [], scope: null },
    { type: 'language', subtag: 'kjf', prefix: [], scope: null },
    { type: 'language', subtag: 'kjg', prefix: [], scope: null },
    { type: 'language', subtag: 'kjh', prefix: [], scope: null },
    { type: 'language', subtag: 'kji', prefix: [], scope: null },
    { type: 'language', subtag: 'kjj', prefix: [], scope: null },
    { type: 'language', subtag: 'kjk', prefix: [], scope: null },
    { type: 'language', subtag: 'kjl', prefix: [], scope: null },
    { type: 'language', subtag: 'kjm', prefix: [], scope: null },
    { type: 'language', subtag: 'kjn', prefix: [], scope: null },
    { type: 'language', subtag: 'kjo', prefix: [], scope: null },
    { type: 'language', subtag: 'kjp', prefix: [], scope: null },
    { type: 'language', subtag: 'kjq', prefix: [], scope: null },
    { type: 'language', subtag: 'kjr', prefix: [], scope: null },
    { type: 'language', subtag: 'kjs', prefix: [], scope: null },
    { type: 'language', subtag: 'kjt', prefix: [], scope: null },
    { type: 'language', subtag: 'kju', prefix: [], scope: null },
    { type: 'language', subtag: 'kjv', prefix: [], scope: null },
    { type: 'language', subtag: 'kjx', prefix: [], scope: null },
    { type: 'language', subtag: 'kjy', prefix: [], scope: null },
    { type: 'language', subtag: 'kjz', prefix: [], scope: null },
    { type: 'language', subtag: 'kka', prefix: [], scope: null },
    { type: 'language', subtag: 'kkb', prefix: [], scope: null },
    { type: 'language', subtag: 'kkc', prefix: [], scope: null },
    { type: 'language', subtag: 'kkd', prefix: [], scope: null },
    { type: 'language', subtag: 'kke', prefix: [], scope: null },
    { type: 'language', subtag: 'kkf', prefix: [], scope: null },
    { type: 'language', subtag: 'kkg', prefix: [], scope: null },
    { type: 'language', subtag: 'kkh', prefix: [], scope: null },
    { type: 'language', subtag: 'kki', prefix: [], scope: null },
    { type: 'language', subtag: 'kkj', prefix: [], scope: null },
    { type: 'language', subtag: 'kkk', prefix: [], scope: null },
    { type: 'language', subtag: 'kkl', prefix: [], scope: null },
    { type: 'language', subtag: 'kkm', prefix: [], scope: null },
    { type: 'language', subtag: 'kkn', prefix: [], scope: null },
    { type: 'language', subtag: 'kko', prefix: [], scope: null },
    { type: 'language', subtag: 'kkp', prefix: [], scope: null },
    { type: 'language', subtag: 'kkq', prefix: [], scope: null },
    { type: 'language', subtag: 'kkr', prefix: [], scope: null },
    { type: 'language', subtag: 'kks', prefix: [], scope: null },
    { type: 'language', subtag: 'kkt', prefix: [], scope: null },
    { type: 'language', subtag: 'kku', prefix: [], scope: null },
    { type: 'language', subtag: 'kkv', prefix: [], scope: null },
    { type: 'language', subtag: 'kkw', prefix: [], scope: null },
    { type: 'language', subtag: 'kkx', prefix: [], scope: null },
    { type: 'language', subtag: 'kky', prefix: [], scope: null },
    { type: 'language', subtag: 'kkz', prefix: [], scope: null },
    { type: 'language', subtag: 'kla', prefix: [], scope: null },
    { type: 'language', subtag: 'klb', prefix: [], scope: null },
    { type: 'language', subtag: 'klc', prefix: [], scope: null },
    { type: 'language', subtag: 'kld', prefix: [], scope: null },
    { type: 'language', subtag: 'kle', prefix: [], scope: null },
    { type: 'language', subtag: 'klf', prefix: [], scope: null },
    { type: 'language', subtag: 'klg', prefix: [], scope: null },
    { type: 'language', subtag: 'klh', prefix: [], scope: null },
    { type: 'language', subtag: 'kli', prefix: [], scope: null },
    { type: 'language', subtag: 'klj', prefix: [], scope: null },
    { type: 'language', subtag: 'klk', prefix: [], scope: null },
    { type: 'language', subtag: 'kll', prefix: [], scope: null },
    { type: 'language', subtag: 'klm', prefix: [], scope: null },
    { type: 'language', subtag: 'kln', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'klo', prefix: [], scope: null },
    { type: 'language', subtag: 'klp', prefix: [], scope: null },
    { type: 'language', subtag: 'klq', prefix: [], scope: null },
    { type: 'language', subtag: 'klr', prefix: [], scope: null },
    { type: 'language', subtag: 'kls', prefix: [], scope: null },
    { type: 'language', subtag: 'klt', prefix: [], scope: null },
    { type: 'language', subtag: 'klu', prefix: [], scope: null },
    { type: 'language', subtag: 'klv', prefix: [], scope: null },
    { type: 'language', subtag: 'klw', prefix: [], scope: null },
    { type: 'language', subtag: 'klx', prefix: [], scope: null },
    { type: 'language', subtag: 'kly', prefix: [], scope: null },
    { type: 'language', subtag: 'klz', prefix: [], scope: null },
    { type: 'language', subtag: 'kma', prefix: [], scope: null },
    { type: 'language', subtag: 'kmb', prefix: [], scope: null },
    { type: 'language', subtag: 'kmc', prefix: [], scope: null },
    { type: 'language', subtag: 'kmd', prefix: [], scope: null },
    { type: 'language', subtag: 'kme', prefix: [], scope: null },
    { type: 'language', subtag: 'kmf', prefix: [], scope: null },
    { type: 'language', subtag: 'kmg', prefix: [], scope: null },
    { type: 'language', subtag: 'kmh', prefix: [], scope: null },
    { type: 'language', subtag: 'kmi', prefix: [], scope: null },
    { type: 'language', subtag: 'kmj', prefix: [], scope: null },
    { type: 'language', subtag: 'kmk', prefix: [], scope: null },
    { type: 'language', subtag: 'kml', prefix: [], scope: null },
    { type: 'language', subtag: 'kmm', prefix: [], scope: null },
    { type: 'language', subtag: 'kmn', prefix: [], scope: null },
    { type: 'language', subtag: 'kmo', prefix: [], scope: null },
    { type: 'language', subtag: 'kmp', prefix: [], scope: null },
    { type: 'language', subtag: 'kmq', prefix: [], scope: null },
    { type: 'language', subtag: 'kmr', prefix: [], scope: null },
    { type: 'language', subtag: 'kms', prefix: [], scope: null },
    { type: 'language', subtag: 'kmt', prefix: [], scope: null },
    { type: 'language', subtag: 'kmu', prefix: [], scope: null },
    { type: 'language', subtag: 'kmv', prefix: [], scope: null },
    { type: 'language', subtag: 'kmw', prefix: [], scope: null },
    { type: 'language', subtag: 'kmx', prefix: [], scope: null },
    { type: 'language', subtag: 'kmy', prefix: [], scope: null },
    { type: 'language', subtag: 'kmz', prefix: [], scope: null },
    { type: 'language', subtag: 'kna', prefix: [], scope: null },
    { type: 'language', subtag: 'knb', prefix: [], scope: null },
    { type: 'language', subtag: 'knc', prefix: [], scope: null },
    { type: 'language', subtag: 'knd', prefix: [], scope: null },
    { type: 'language', subtag: 'kne', prefix: [], scope: null },
    { type: 'language', subtag: 'knf', prefix: [], scope: null },
    { type: 'language', subtag: 'kng', prefix: [], scope: null },
    { type: 'language', subtag: 'kni', prefix: [], scope: null },
    { type: 'language', subtag: 'knj', prefix: [], scope: null },
    { type: 'language', subtag: 'knk', prefix: [], scope: null },
    { type: 'language', subtag: 'knl', prefix: [], scope: null },
    { type: 'language', subtag: 'knm', prefix: [], scope: null },
    { type: 'language', subtag: 'knn', prefix: [], scope: null },
    { type: 'language', subtag: 'kno', prefix: [], scope: null },
    { type: 'language', subtag: 'knp', prefix: [], scope: null },
    { type: 'language', subtag: 'knq', prefix: [], scope: null },
    { type: 'language', subtag: 'knr', prefix: [], scope: null },
    { type: 'language', subtag: 'kns', prefix: [], scope: null },
    { type: 'language', subtag: 'knt', prefix: [], scope: null },
    { type: 'language', subtag: 'knu', prefix: [], scope: null },
    { type: 'language', subtag: 'knv', prefix: [], scope: null },
    { type: 'language', subtag: 'knw', prefix: [], scope: null },
    { type: 'language', subtag: 'knx', prefix: [], scope: null },
    { type: 'language', subtag: 'kny', prefix: [], scope: null },
    { type: 'language', subtag: 'knz', prefix: [], scope: null },
    { type: 'language', subtag: 'koa', prefix: [], scope: null },
    { type: 'language', subtag: 'koc', prefix: [], scope: null },
    { type: 'language', subtag: 'kod', prefix: [], scope: null },
    { type: 'language', subtag: 'koe', prefix: [], scope: null },
    { type: 'language', subtag: 'kof', prefix: [], scope: null },
    { type: 'language', subtag: 'kog', prefix: [], scope: null },
    { type: 'language', subtag: 'koh', prefix: [], scope: null },
    { type: 'language', subtag: 'koi', prefix: [], scope: null },
    { type: 'language', subtag: 'koj', prefix: [], scope: null },
    { type: 'language', subtag: 'kok', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'kol', prefix: [], scope: null },
    { type: 'language', subtag: 'koo', prefix: [], scope: null },
    { type: 'language', subtag: 'kop', prefix: [], scope: null },
    { type: 'language', subtag: 'koq', prefix: [], scope: null },
    { type: 'language', subtag: 'kos', prefix: [], scope: null },
    { type: 'language', subtag: 'kot', prefix: [], scope: null },
    { type: 'language', subtag: 'kou', prefix: [], scope: null },
    { type: 'language', subtag: 'kov', prefix: [], scope: null },
    { type: 'language', subtag: 'kow', prefix: [], scope: null },
    { type: 'language', subtag: 'kox', prefix: [], scope: null },
    { type: 'language', subtag: 'koy', prefix: [], scope: null },
    { type: 'language', subtag: 'koz', prefix: [], scope: null },
    { type: 'language', subtag: 'kpa', prefix: [], scope: null },
    { type: 'language', subtag: 'kpb', prefix: [], scope: null },
    { type: 'language', subtag: 'kpc', prefix: [], scope: null },
    { type: 'language', subtag: 'kpd', prefix: [], scope: null },
    { type: 'language', subtag: 'kpe', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'kpf', prefix: [], scope: null },
    { type: 'language', subtag: 'kpg', prefix: [], scope: null },
    { type: 'language', subtag: 'kph', prefix: [], scope: null },
    { type: 'language', subtag: 'kpi', prefix: [], scope: null },
    { type: 'language', subtag: 'kpj', prefix: [], scope: null },
    { type: 'language', subtag: 'kpk', prefix: [], scope: null },
    { type: 'language', subtag: 'kpl', prefix: [], scope: null },
    { type: 'language', subtag: 'kpm', prefix: [], scope: null },
    { type: 'language', subtag: 'kpn', prefix: [], scope: null },
    { type: 'language', subtag: 'kpo', prefix: [], scope: null },
    { type: 'language', subtag: 'kpp', prefix: [], scope: null },
    { type: 'language', subtag: 'kpq', prefix: [], scope: null },
    { type: 'language', subtag: 'kpr', prefix: [], scope: null },
    { type: 'language', subtag: 'kps', prefix: [], scope: null },
    { type: 'language', subtag: 'kpt', prefix: [], scope: null },
    { type: 'language', subtag: 'kpu', prefix: [], scope: null },
    { type: 'language', subtag: 'kpv', prefix: [], scope: null },
    { type: 'language', subtag: 'kpw', prefix: [], scope: null },
    { type: 'language', subtag: 'kpx', prefix: [], scope: null },
    { type: 'language', subtag: 'kpy', prefix: [], scope: null },
    { type: 'language', subtag: 'kpz', prefix: [], scope: null },
    { type: 'language', subtag: 'kqa', prefix: [], scope: null },
    { type: 'language', subtag: 'kqb', prefix: [], scope: null },
    { type: 'language', subtag: 'kqc', prefix: [], scope: null },
    { type: 'language', subtag: 'kqd', prefix: [], scope: null },
    { type: 'language', subtag: 'kqe', prefix: [], scope: null },
    { type: 'language', subtag: 'kqf', prefix: [], scope: null },
    { type: 'language', subtag: 'kqg', prefix: [], scope: null },
    { type: 'language', subtag: 'kqh', prefix: [], scope: null },
    { type: 'language', subtag: 'kqi', prefix: [], scope: null },
    { type: 'language', subtag: 'kqj', prefix: [], scope: null },
    { type: 'language', subtag: 'kqk', prefix: [], scope: null },
    { type: 'language', subtag: 'kql', prefix: [], scope: null },
    { type: 'language', subtag: 'kqm', prefix: [], scope: null },
    { type: 'language', subtag: 'kqn', prefix: [], scope: null },
    { type: 'language', subtag: 'kqo', prefix: [], scope: null },
    { type: 'language', subtag: 'kqp', prefix: [], scope: null },
    { type: 'language', subtag: 'kqq', prefix: [], scope: null },
    { type: 'language', subtag: 'kqr', prefix: [], scope: null },
    { type: 'language', subtag: 'kqs', prefix: [], scope: null },
    { type: 'language', subtag: 'kqt', prefix: [], scope: null },
    { type: 'language', subtag: 'kqu', prefix: [], scope: null },
    { type: 'language', subtag: 'kqv', prefix: [], scope: null },
    { type: 'language', subtag: 'kqw', prefix: [], scope: null },
    { type: 'language', subtag: 'kqx', prefix: [], scope: null },
    { type: 'language', subtag: 'kqy', prefix: [], scope: null },
    { type: 'language', subtag: 'kqz', prefix: [], scope: null },
    { type: 'language', subtag: 'kra', prefix: [], scope: null },
    { type: 'language', subtag: 'krb', prefix: [], scope: null },
    { type: 'language', subtag: 'krc', prefix: [], scope: null },
    { type: 'language', subtag: 'krd', prefix: [], scope: null },
    { type: 'language', subtag: 'kre', prefix: [], scope: null },
    { type: 'language', subtag: 'krf', prefix: [], scope: null },
    { type: 'language', subtag: 'krh', prefix: [], scope: null },
    { type: 'language', subtag: 'kri', prefix: [], scope: null },
    { type: 'language', subtag: 'krj', prefix: [], scope: null },
    { type: 'language', subtag: 'krk', prefix: [], scope: null },
    { type: 'language', subtag: 'krl', prefix: [], scope: null },
    { type: 'language', subtag: 'krm', prefix: [], scope: null },
    { type: 'language', subtag: 'krn', prefix: [], scope: null },
    { type: 'language', subtag: 'kro', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'krp', prefix: [], scope: null },
    { type: 'language', subtag: 'krr', prefix: [], scope: null },
    { type: 'language', subtag: 'krs', prefix: [], scope: null },
    { type: 'language', subtag: 'krt', prefix: [], scope: null },
    { type: 'language', subtag: 'kru', prefix: [], scope: null },
    { type: 'language', subtag: 'krv', prefix: [], scope: null },
    { type: 'language', subtag: 'krw', prefix: [], scope: null },
    { type: 'language', subtag: 'krx', prefix: [], scope: null },
    { type: 'language', subtag: 'kry', prefix: [], scope: null },
    { type: 'language', subtag: 'krz', prefix: [], scope: null },
    { type: 'language', subtag: 'ksa', prefix: [], scope: null },
    { type: 'language', subtag: 'ksb', prefix: [], scope: null },
    { type: 'language', subtag: 'ksc', prefix: [], scope: null },
    { type: 'language', subtag: 'ksd', prefix: [], scope: null },
    { type: 'language', subtag: 'kse', prefix: [], scope: null },
    { type: 'language', subtag: 'ksf', prefix: [], scope: null },
    { type: 'language', subtag: 'ksg', prefix: [], scope: null },
    { type: 'language', subtag: 'ksh', prefix: [], scope: null },
    { type: 'language', subtag: 'ksi', prefix: [], scope: null },
    { type: 'language', subtag: 'ksj', prefix: [], scope: null },
    { type: 'language', subtag: 'ksk', prefix: [], scope: null },
    { type: 'language', subtag: 'ksl', prefix: [], scope: null },
    { type: 'language', subtag: 'ksm', prefix: [], scope: null },
    { type: 'language', subtag: 'ksn', prefix: [], scope: null },
    { type: 'language', subtag: 'kso', prefix: [], scope: null },
    { type: 'language', subtag: 'ksp', prefix: [], scope: null },
    { type: 'language', subtag: 'ksq', prefix: [], scope: null },
    { type: 'language', subtag: 'ksr', prefix: [], scope: null },
    { type: 'language', subtag: 'kss', prefix: [], scope: null },
    { type: 'language', subtag: 'kst', prefix: [], scope: null },
    { type: 'language', subtag: 'ksu', prefix: [], scope: null },
    { type: 'language', subtag: 'ksv', prefix: [], scope: null },
    { type: 'language', subtag: 'ksw', prefix: [], scope: null },
    { type: 'language', subtag: 'ksx', prefix: [], scope: null },
    { type: 'language', subtag: 'ksy', prefix: [], scope: null },
    { type: 'language', subtag: 'ksz', prefix: [], scope: null },
    { type: 'language', subtag: 'kta', prefix: [], scope: null },
    { type: 'language', subtag: 'ktb', prefix: [], scope: null },
    { type: 'language', subtag: 'ktc', prefix: [], scope: null },
    { type: 'language', subtag: 'ktd', prefix: [], scope: null },
    { type: 'language', subtag: 'kte', prefix: [], scope: null },
    { type: 'language', subtag: 'ktf', prefix: [], scope: null },
    { type: 'language', subtag: 'ktg', prefix: [], scope: null },
    { type: 'language', subtag: 'kth', prefix: [], scope: null },
    { type: 'language', subtag: 'kti', prefix: [], scope: null },
    { type: 'language', subtag: 'ktj', prefix: [], scope: null },
    { type: 'language', subtag: 'ktk', prefix: [], scope: null },
    { type: 'language', subtag: 'ktl', prefix: [], scope: null },
    { type: 'language', subtag: 'ktm', prefix: [], scope: null },
    { type: 'language', subtag: 'ktn', prefix: [], scope: null },
    { type: 'language', subtag: 'kto', prefix: [], scope: null },
    { type: 'language', subtag: 'ktp', prefix: [], scope: null },
    { type: 'language', subtag: 'ktq', prefix: [], scope: null },
    { type: 'language', subtag: 'ktr', prefix: [], scope: null },
    { type: 'language', subtag: 'kts', prefix: [], scope: null },
    { type: 'language', subtag: 'ktt', prefix: [], scope: null },
    { type: 'language', subtag: 'ktu', prefix: [], scope: null },
    { type: 'language', subtag: 'ktv', prefix: [], scope: null },
    { type: 'language', subtag: 'ktw', prefix: [], scope: null },
    { type: 'language', subtag: 'ktx', prefix: [], scope: null },
    { type: 'language', subtag: 'kty', prefix: [], scope: null },
    { type: 'language', subtag: 'ktz', prefix: [], scope: null },
    { type: 'language', subtag: 'kub', prefix: [], scope: null },
    { type: 'language', subtag: 'kuc', prefix: [], scope: null },
    { type: 'language', subtag: 'kud', prefix: [], scope: null },
    { type: 'language', subtag: 'kue', prefix: [], scope: null },
    { type: 'language', subtag: 'kuf', prefix: [], scope: null },
    { type: 'language', subtag: 'kug', prefix: [], scope: null },
    { type: 'language', subtag: 'kuh', prefix: [], scope: null },
    { type: 'language', subtag: 'kui', prefix: [], scope: null },
    { type: 'language', subtag: 'kuj', prefix: [], scope: null },
    { type: 'language', subtag: 'kuk', prefix: [], scope: null },
    { type: 'language', subtag: 'kul', prefix: [], scope: null },
    { type: 'language', subtag: 'kum', prefix: [], scope: null },
    { type: 'language', subtag: 'kun', prefix: [], scope: null },
    { type: 'language', subtag: 'kuo', prefix: [], scope: null },
    { type: 'language', subtag: 'kup', prefix: [], scope: null },
    { type: 'language', subtag: 'kuq', prefix: [], scope: null },
    { type: 'language', subtag: 'kus', prefix: [], scope: null },
    { type: 'language', subtag: 'kut', prefix: [], scope: null },
    { type: 'language', subtag: 'kuu', prefix: [], scope: null },
    { type: 'language', subtag: 'kuv', prefix: [], scope: null },
    { type: 'language', subtag: 'kuw', prefix: [], scope: null },
    { type: 'language', subtag: 'kux', prefix: [], scope: null },
    { type: 'language', subtag: 'kuy', prefix: [], scope: null },
    { type: 'language', subtag: 'kuz', prefix: [], scope: null },
    { type: 'language', subtag: 'kva', prefix: [], scope: null },
    { type: 'language', subtag: 'kvb', prefix: [], scope: null },
    { type: 'language', subtag: 'kvc', prefix: [], scope: null },
    { type: 'language', subtag: 'kvd', prefix: [], scope: null },
    { type: 'language', subtag: 'kve', prefix: [], scope: null },
    { type: 'language', subtag: 'kvf', prefix: [], scope: null },
    { type: 'language', subtag: 'kvg', prefix: [], scope: null },
    { type: 'language', subtag: 'kvh', prefix: [], scope: null },
    { type: 'language', subtag: 'kvi', prefix: [], scope: null },
    { type: 'language', subtag: 'kvj', prefix: [], scope: null },
    { type: 'language', subtag: 'kvk', prefix: [], scope: null },
    { type: 'language', subtag: 'kvl', prefix: [], scope: null },
    { type: 'language', subtag: 'kvm', prefix: [], scope: null },
    { type: 'language', subtag: 'kvn', prefix: [], scope: null },
    { type: 'language', subtag: 'kvo', prefix: [], scope: null },
    { type: 'language', subtag: 'kvp', prefix: [], scope: null },
    { type: 'language', subtag: 'kvq', prefix: [], scope: null },
    { type: 'language', subtag: 'kvr', prefix: [], scope: null },
    { type: 'language', subtag: 'kvs', prefix: [], scope: null },
    { type: 'language', subtag: 'kvt', prefix: [], scope: null },
    { type: 'language', subtag: 'kvu', prefix: [], scope: null },
    { type: 'language', subtag: 'kvv', prefix: [], scope: null },
    { type: 'language', subtag: 'kvw', prefix: [], scope: null },
    { type: 'language', subtag: 'kvx', prefix: [], scope: null },
    { type: 'language', subtag: 'kvy', prefix: [], scope: null },
    { type: 'language', subtag: 'kvz', prefix: [], scope: null },
    { type: 'language', subtag: 'kwa', prefix: [], scope: null },
    { type: 'language', subtag: 'kwb', prefix: [], scope: null },
    { type: 'language', subtag: 'kwc', prefix: [], scope: null },
    { type: 'language', subtag: 'kwd', prefix: [], scope: null },
    { type: 'language', subtag: 'kwe', prefix: [], scope: null },
    { type: 'language', subtag: 'kwf', prefix: [], scope: null },
    { type: 'language', subtag: 'kwg', prefix: [], scope: null },
    { type: 'language', subtag: 'kwh', prefix: [], scope: null },
    { type: 'language', subtag: 'kwi', prefix: [], scope: null },
    { type: 'language', subtag: 'kwj', prefix: [], scope: null },
    { type: 'language', subtag: 'kwk', prefix: [], scope: null },
    { type: 'language', subtag: 'kwl', prefix: [], scope: null },
    { type: 'language', subtag: 'kwm', prefix: [], scope: null },
    { type: 'language', subtag: 'kwn', prefix: [], scope: null },
    { type: 'language', subtag: 'kwo', prefix: [], scope: null },
    { type: 'language', subtag: 'kwp', prefix: [], scope: null },
    { type: 'language', subtag: 'kwq', prefix: [], scope: null },
    { type: 'language', subtag: 'kwr', prefix: [], scope: null },
    { type: 'language', subtag: 'kws', prefix: [], scope: null },
    { type: 'language', subtag: 'kwt', prefix: [], scope: null },
    { type: 'language', subtag: 'kwu', prefix: [], scope: null },
    { type: 'language', subtag: 'kwv', prefix: [], scope: null },
    { type: 'language', subtag: 'kww', prefix: [], scope: null },
    { type: 'language', subtag: 'kwx', prefix: [], scope: null },
    { type: 'language', subtag: 'kwy', prefix: [], scope: null },
    { type: 'language', subtag: 'kwz', prefix: [], scope: null },
    { type: 'language', subtag: 'kxa', prefix: [], scope: null },
    { type: 'language', subtag: 'kxb', prefix: [], scope: null },
    { type: 'language', subtag: 'kxc', prefix: [], scope: null },
    { type: 'language', subtag: 'kxd', prefix: [], scope: null },
    { type: 'language', subtag: 'kxe', prefix: [], scope: null },
    { type: 'language', subtag: 'kxf', prefix: [], scope: null },
    { type: 'language', subtag: 'kxh', prefix: [], scope: null },
    { type: 'language', subtag: 'kxi', prefix: [], scope: null },
    { type: 'language', subtag: 'kxj', prefix: [], scope: null },
    { type: 'language', subtag: 'kxk', prefix: [], scope: null },
    { type: 'language', subtag: 'kxl', prefix: [], scope: null },
    { type: 'language', subtag: 'kxm', prefix: [], scope: null },
    { type: 'language', subtag: 'kxn', prefix: [], scope: null },
    { type: 'language', subtag: 'kxo', prefix: [], scope: null },
    { type: 'language', subtag: 'kxp', prefix: [], scope: null },
    { type: 'language', subtag: 'kxq', prefix: [], scope: null },
    { type: 'language', subtag: 'kxr', prefix: [], scope: null },
    { type: 'language', subtag: 'kxs', prefix: [], scope: null },
    { type: 'language', subtag: 'kxt', prefix: [], scope: null },
    { type: 'language', subtag: 'kxu', prefix: [], scope: null },
    { type: 'language', subtag: 'kxv', prefix: [], scope: null },
    { type: 'language', subtag: 'kxw', prefix: [], scope: null },
    { type: 'language', subtag: 'kxx', prefix: [], scope: null },
    { type: 'language', subtag: 'kxy', prefix: [], scope: null },
    { type: 'language', subtag: 'kxz', prefix: [], scope: null },
    { type: 'language', subtag: 'kya', prefix: [], scope: null },
    { type: 'language', subtag: 'kyb', prefix: [], scope: null },
    { type: 'language', subtag: 'kyc', prefix: [], scope: null },
    { type: 'language', subtag: 'kyd', prefix: [], scope: null },
    { type: 'language', subtag: 'kye', prefix: [], scope: null },
    { type: 'language', subtag: 'kyf', prefix: [], scope: null },
    { type: 'language', subtag: 'kyg', prefix: [], scope: null },
    { type: 'language', subtag: 'kyh', prefix: [], scope: null },
    { type: 'language', subtag: 'kyi', prefix: [], scope: null },
    { type: 'language', subtag: 'kyj', prefix: [], scope: null },
    { type: 'language', subtag: 'kyk', prefix: [], scope: null },
    { type: 'language', subtag: 'kyl', prefix: [], scope: null },
    { type: 'language', subtag: 'kym', prefix: [], scope: null },
    { type: 'language', subtag: 'kyn', prefix: [], scope: null },
    { type: 'language', subtag: 'kyo', prefix: [], scope: null },
    { type: 'language', subtag: 'kyp', prefix: [], scope: null },
    { type: 'language', subtag: 'kyq', prefix: [], scope: null },
    { type: 'language', subtag: 'kyr', prefix: [], scope: null },
    { type: 'language', subtag: 'kys', prefix: [], scope: null },
    { type: 'language', subtag: 'kyt', prefix: [], scope: null },
    { type: 'language', subtag: 'kyu', prefix: [], scope: null },
    { type: 'language', subtag: 'kyv', prefix: [], scope: null },
    { type: 'language', subtag: 'kyw', prefix: [], scope: null },
    { type: 'language', subtag: 'kyx', prefix: [], scope: null },
    { type: 'language', subtag: 'kyy', prefix: [], scope: null },
    { type: 'language', subtag: 'kyz', prefix: [], scope: null },
    { type: 'language', subtag: 'kza', prefix: [], scope: null },
    { type: 'language', subtag: 'kzb', prefix: [], scope: null },
    { type: 'language', subtag: 'kzc', prefix: [], scope: null },
    { type: 'language', subtag: 'kzd', prefix: [], scope: null },
    { type: 'language', subtag: 'kze', prefix: [], scope: null },
    { type: 'language', subtag: 'kzf', prefix: [], scope: null },
    { type: 'language', subtag: 'kzg', prefix: [], scope: null },
    { type: 'language', subtag: 'kzh', prefix: [], scope: null },
    { type: 'language', subtag: 'kzi', prefix: [], scope: null },
    { type: 'language', subtag: 'kzj', prefix: [], scope: null },
    { type: 'language', subtag: 'kzk', prefix: [], scope: null },
    { type: 'language', subtag: 'kzl', prefix: [], scope: null },
    { type: 'language', subtag: 'kzm', prefix: [], scope: null },
    { type: 'language', subtag: 'kzn', prefix: [], scope: null },
    { type: 'language', subtag: 'kzo', prefix: [], scope: null },
    { type: 'language', subtag: 'kzp', prefix: [], scope: null },
    { type: 'language', subtag: 'kzq', prefix: [], scope: null },
    { type: 'language', subtag: 'kzr', prefix: [], scope: null },
    { type: 'language', subtag: 'kzs', prefix: [], scope: null },
    { type: 'language', subtag: 'kzt', prefix: [], scope: null },
    { type: 'language', subtag: 'kzu', prefix: [], scope: null },
    { type: 'language', subtag: 'kzv', prefix: [], scope: null },
    { type: 'language', subtag: 'kzw', prefix: [], scope: null },
    { type: 'language', subtag: 'kzx', prefix: [], scope: null },
    { type: 'language', subtag: 'kzy', prefix: [], scope: null },
    { type: 'language', subtag: 'kzz', prefix: [], scope: null },
    { type: 'language', subtag: 'laa', prefix: [], scope: null },
    { type: 'language', subtag: 'lab', prefix: [], scope: null },
    { type: 'language', subtag: 'lac', prefix: [], scope: null },
    { type: 'language', subtag: 'lad', prefix: [], scope: null },
    { type: 'language', subtag: 'lae', prefix: [], scope: null },
    { type: 'language', subtag: 'laf', prefix: [], scope: null },
    { type: 'language', subtag: 'lag', prefix: [], scope: null },
    { type: 'language', subtag: 'lah', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'lai', prefix: [], scope: null },
    { type: 'language', subtag: 'laj', prefix: [], scope: null },
    { type: 'language', subtag: 'lak', prefix: [], scope: null },
    { type: 'language', subtag: 'lal', prefix: [], scope: null },
    { type: 'language', subtag: 'lam', prefix: [], scope: null },
    { type: 'language', subtag: 'lan', prefix: [], scope: null },
    { type: 'language', subtag: 'lap', prefix: [], scope: null },
    { type: 'language', subtag: 'laq', prefix: [], scope: null },
    { type: 'language', subtag: 'lar', prefix: [], scope: null },
    { type: 'language', subtag: 'las', prefix: [], scope: null },
    { type: 'language', subtag: 'lau', prefix: [], scope: null },
    { type: 'language', subtag: 'law', prefix: [], scope: null },
    { type: 'language', subtag: 'lax', prefix: [], scope: null },
    { type: 'language', subtag: 'lay', prefix: [], scope: null },
    { type: 'language', subtag: 'laz', prefix: [], scope: null },
    { type: 'language', subtag: 'lba', prefix: [], scope: null },
    { type: 'language', subtag: 'lbb', prefix: [], scope: null },
    { type: 'language', subtag: 'lbc', prefix: [], scope: null },
    { type: 'language', subtag: 'lbe', prefix: [], scope: null },
    { type: 'language', subtag: 'lbf', prefix: [], scope: null },
    { type: 'language', subtag: 'lbg', prefix: [], scope: null },
    { type: 'language', subtag: 'lbi', prefix: [], scope: null },
    { type: 'language', subtag: 'lbj', prefix: [], scope: null },
    { type: 'language', subtag: 'lbk', prefix: [], scope: null },
    { type: 'language', subtag: 'lbl', prefix: [], scope: null },
    { type: 'language', subtag: 'lbm', prefix: [], scope: null },
    { type: 'language', subtag: 'lbn', prefix: [], scope: null },
    { type: 'language', subtag: 'lbo', prefix: [], scope: null },
    { type: 'language', subtag: 'lbq', prefix: [], scope: null },
    { type: 'language', subtag: 'lbr', prefix: [], scope: null },
    { type: 'language', subtag: 'lbs', prefix: [], scope: null },
    { type: 'language', subtag: 'lbt', prefix: [], scope: null },
    { type: 'language', subtag: 'lbu', prefix: [], scope: null },
    { type: 'language', subtag: 'lbv', prefix: [], scope: null },
    { type: 'language', subtag: 'lbw', prefix: [], scope: null },
    { type: 'language', subtag: 'lbx', prefix: [], scope: null },
    { type: 'language', subtag: 'lby', prefix: [], scope: null },
    { type: 'language', subtag: 'lbz', prefix: [], scope: null },
    { type: 'language', subtag: 'lcc', prefix: [], scope: null },
    { type: 'language', subtag: 'lcd', prefix: [], scope: null },
    { type: 'language', subtag: 'lce', prefix: [], scope: null },
    { type: 'language', subtag: 'lcf', prefix: [], scope: null },
    { type: 'language', subtag: 'lch', prefix: [], scope: null },
    { type: 'language', subtag: 'lcl', prefix: [], scope: null },
    { type: 'language', subtag: 'lcm', prefix: [], scope: null },
    { type: 'language', subtag: 'lcp', prefix: [], scope: null },
    { type: 'language', subtag: 'lcq', prefix: [], scope: null },
    { type: 'language', subtag: 'lcs', prefix: [], scope: null },
    { type: 'language', subtag: 'lda', prefix: [], scope: null },
    { type: 'language', subtag: 'ldb', prefix: [], scope: null },
    { type: 'language', subtag: 'ldd', prefix: [], scope: null },
    { type: 'language', subtag: 'ldg', prefix: [], scope: null },
    { type: 'language', subtag: 'ldh', prefix: [], scope: null },
    { type: 'language', subtag: 'ldi', prefix: [], scope: null },
    { type: 'language', subtag: 'ldj', prefix: [], scope: null },
    { type: 'language', subtag: 'ldk', prefix: [], scope: null },
    { type: 'language', subtag: 'ldl', prefix: [], scope: null },
    { type: 'language', subtag: 'ldm', prefix: [], scope: null },
    { type: 'language', subtag: 'ldn', prefix: [], scope: null },
    { type: 'language', subtag: 'ldo', prefix: [], scope: null },
    { type: 'language', subtag: 'ldp', prefix: [], scope: null },
    { type: 'language', subtag: 'ldq', prefix: [], scope: null },
    { type: 'language', subtag: 'lea', prefix: [], scope: null },
    { type: 'language', subtag: 'leb', prefix: [], scope: null },
    { type: 'language', subtag: 'lec', prefix: [], scope: null },
    { type: 'language', subtag: 'led', prefix: [], scope: null },
    { type: 'language', subtag: 'lee', prefix: [], scope: null },
    { type: 'language', subtag: 'lef', prefix: [], scope: null },
    { type: 'language', subtag: 'leg', prefix: [], scope: null },
    { type: 'language', subtag: 'leh', prefix: [], scope: null },
    { type: 'language', subtag: 'lei', prefix: [], scope: null },
    { type: 'language', subtag: 'lej', prefix: [], scope: null },
    { type: 'language', subtag: 'lek', prefix: [], scope: null },
    { type: 'language', subtag: 'lel', prefix: [], scope: null },
    { type: 'language', subtag: 'lem', prefix: [], scope: null },
    { type: 'language', subtag: 'len', prefix: [], scope: null },
    { type: 'language', subtag: 'leo', prefix: [], scope: null },
    { type: 'language', subtag: 'lep', prefix: [], scope: null },
    { type: 'language', subtag: 'leq', prefix: [], scope: null },
    { type: 'language', subtag: 'ler', prefix: [], scope: null },
    { type: 'language', subtag: 'les', prefix: [], scope: null },
    { type: 'language', subtag: 'let', prefix: [], scope: null },
    { type: 'language', subtag: 'leu', prefix: [], scope: null },
    { type: 'language', subtag: 'lev', prefix: [], scope: null },
    { type: 'language', subtag: 'lew', prefix: [], scope: null },
    { type: 'language', subtag: 'lex', prefix: [], scope: null },
    { type: 'language', subtag: 'ley', prefix: [], scope: null },
    { type: 'language', subtag: 'lez', prefix: [], scope: null },
    { type: 'language', subtag: 'lfa', prefix: [], scope: null },
    { type: 'language', subtag: 'lfn', prefix: [], scope: null },
    { type: 'language', subtag: 'lga', prefix: [], scope: null },
    { type: 'language', subtag: 'lgb', prefix: [], scope: null },
    { type: 'language', subtag: 'lgg', prefix: [], scope: null },
    { type: 'language', subtag: 'lgh', prefix: [], scope: null },
    { type: 'language', subtag: 'lgi', prefix: [], scope: null },
    { type: 'language', subtag: 'lgk', prefix: [], scope: null },
    { type: 'language', subtag: 'lgl', prefix: [], scope: null },
    { type: 'language', subtag: 'lgm', prefix: [], scope: null },
    { type: 'language', subtag: 'lgn', prefix: [], scope: null },
    { type: 'language', subtag: 'lgo', prefix: [], scope: null },
    { type: 'language', subtag: 'lgq', prefix: [], scope: null },
    { type: 'language', subtag: 'lgr', prefix: [], scope: null },
    { type: 'language', subtag: 'lgt', prefix: [], scope: null },
    { type: 'language', subtag: 'lgu', prefix: [], scope: null },
    { type: 'language', subtag: 'lgz', prefix: [], scope: null },
    { type: 'language', subtag: 'lha', prefix: [], scope: null },
    { type: 'language', subtag: 'lhh', prefix: [], scope: null },
    { type: 'language', subtag: 'lhi', prefix: [], scope: null },
    { type: 'language', subtag: 'lhl', prefix: [], scope: null },
    { type: 'language', subtag: 'lhm', prefix: [], scope: null },
    { type: 'language', subtag: 'lhn', prefix: [], scope: null },
    { type: 'language', subtag: 'lhp', prefix: [], scope: null },
    { type: 'language', subtag: 'lhs', prefix: [], scope: null },
    { type: 'language', subtag: 'lht', prefix: [], scope: null },
    { type: 'language', subtag: 'lhu', prefix: [], scope: null },
    { type: 'language', subtag: 'lia', prefix: [], scope: null },
    { type: 'language', subtag: 'lib', prefix: [], scope: null },
    { type: 'language', subtag: 'lic', prefix: [], scope: null },
    { type: 'language', subtag: 'lid', prefix: [], scope: null },
    { type: 'language', subtag: 'lie', prefix: [], scope: null },
    { type: 'language', subtag: 'lif', prefix: [], scope: null },
    { type: 'language', subtag: 'lig', prefix: [], scope: null },
    { type: 'language', subtag: 'lih', prefix: [], scope: null },
    { type: 'language', subtag: 'lii', prefix: [], scope: null },
    { type: 'language', subtag: 'lij', prefix: [], scope: null },
    { type: 'language', subtag: 'lik', prefix: [], scope: null },
    { type: 'language', subtag: 'lil', prefix: [], scope: null },
    { type: 'language', subtag: 'lio', prefix: [], scope: null },
    { type: 'language', subtag: 'lip', prefix: [], scope: null },
    { type: 'language', subtag: 'liq', prefix: [], scope: null },
    { type: 'language', subtag: 'lir', prefix: [], scope: null },
    { type: 'language', subtag: 'lis', prefix: [], scope: null },
    { type: 'language', subtag: 'liu', prefix: [], scope: null },
    { type: 'language', subtag: 'liv', prefix: [], scope: null },
    { type: 'language', subtag: 'liw', prefix: [], scope: null },
    { type: 'language', subtag: 'lix', prefix: [], scope: null },
    { type: 'language', subtag: 'liy', prefix: [], scope: null },
    { type: 'language', subtag: 'liz', prefix: [], scope: null },
    { type: 'language', subtag: 'lja', prefix: [], scope: null },
    { type: 'language', subtag: 'lje', prefix: [], scope: null },
    { type: 'language', subtag: 'lji', prefix: [], scope: null },
    { type: 'language', subtag: 'ljl', prefix: [], scope: null },
    { type: 'language', subtag: 'ljp', prefix: [], scope: null },
    { type: 'language', subtag: 'ljw', prefix: [], scope: null },
    { type: 'language', subtag: 'ljx', prefix: [], scope: null },
    { type: 'language', subtag: 'lka', prefix: [], scope: null },
    { type: 'language', subtag: 'lkb', prefix: [], scope: null },
    { type: 'language', subtag: 'lkc', prefix: [], scope: null },
    { type: 'language', subtag: 'lkd', prefix: [], scope: null },
    { type: 'language', subtag: 'lke', prefix: [], scope: null },
    { type: 'language', subtag: 'lkh', prefix: [], scope: null },
    { type: 'language', subtag: 'lki', prefix: [], scope: null },
    { type: 'language', subtag: 'lkj', prefix: [], scope: null },
    { type: 'language', subtag: 'lkl', prefix: [], scope: null },
    { type: 'language', subtag: 'lkm', prefix: [], scope: null },
    { type: 'language', subtag: 'lkn', prefix: [], scope: null },
    { type: 'language', subtag: 'lko', prefix: [], scope: null },
    { type: 'language', subtag: 'lkr', prefix: [], scope: null },
    { type: 'language', subtag: 'lks', prefix: [], scope: null },
    { type: 'language', subtag: 'lkt', prefix: [], scope: null },
    { type: 'language', subtag: 'lku', prefix: [], scope: null },
    { type: 'language', subtag: 'lky', prefix: [], scope: null },
    { type: 'language', subtag: 'lla', prefix: [], scope: null },
    { type: 'language', subtag: 'llb', prefix: [], scope: null },
    { type: 'language', subtag: 'llc', prefix: [], scope: null },
    { type: 'language', subtag: 'lld', prefix: [], scope: null },
    { type: 'language', subtag: 'lle', prefix: [], scope: null },
    { type: 'language', subtag: 'llf', prefix: [], scope: null },
    { type: 'language', subtag: 'llg', prefix: [], scope: null },
    { type: 'language', subtag: 'llh', prefix: [], scope: null },
    { type: 'language', subtag: 'lli', prefix: [], scope: null },
    { type: 'language', subtag: 'llj', prefix: [], scope: null },
    { type: 'language', subtag: 'llk', prefix: [], scope: null },
    { type: 'language', subtag: 'lll', prefix: [], scope: null },
    { type: 'language', subtag: 'llm', prefix: [], scope: null },
    { type: 'language', subtag: 'lln', prefix: [], scope: null },
    { type: 'language', subtag: 'llo', prefix: [], scope: null },
    { type: 'language', subtag: 'llp', prefix: [], scope: null },
    { type: 'language', subtag: 'llq', prefix: [], scope: null },
    { type: 'language', subtag: 'lls', prefix: [], scope: null },
    { type: 'language', subtag: 'llu', prefix: [], scope: null },
    { type: 'language', subtag: 'llx', prefix: [], scope: null },
    { type: 'language', subtag: 'lma', prefix: [], scope: null },
    { type: 'language', subtag: 'lmb', prefix: [], scope: null },
    { type: 'language', subtag: 'lmc', prefix: [], scope: null },
    { type: 'language', subtag: 'lmd', prefix: [], scope: null },
    { type: 'language', subtag: 'lme', prefix: [], scope: null },
    { type: 'language', subtag: 'lmf', prefix: [], scope: null },
    { type: 'language', subtag: 'lmg', prefix: [], scope: null },
    { type: 'language', subtag: 'lmh', prefix: [], scope: null },
    { type: 'language', subtag: 'lmi', prefix: [], scope: null },
    { type: 'language', subtag: 'lmj', prefix: [], scope: null },
    { type: 'language', subtag: 'lmk', prefix: [], scope: null },
    { type: 'language', subtag: 'lml', prefix: [], scope: null },
    { type: 'language', subtag: 'lmm', prefix: [], scope: null },
    { type: 'language', subtag: 'lmn', prefix: [], scope: null },
    { type: 'language', subtag: 'lmo', prefix: [], scope: null },
    { type: 'language', subtag: 'lmp', prefix: [], scope: null },
    { type: 'language', subtag: 'lmq', prefix: [], scope: null },
    { type: 'language', subtag: 'lmr', prefix: [], scope: null },
    { type: 'language', subtag: 'lmu', prefix: [], scope: null },
    { type: 'language', subtag: 'lmv', prefix: [], scope: null },
    { type: 'language', subtag: 'lmw', prefix: [], scope: null },
    { type: 'language', subtag: 'lmx', prefix: [], scope: null },
    { type: 'language', subtag: 'lmy', prefix: [], scope: null },
    { type: 'language', subtag: 'lmz', prefix: [], scope: null },
    { type: 'language', subtag: 'lna', prefix: [], scope: null },
    { type: 'language', subtag: 'lnb', prefix: [], scope: null },
    { type: 'language', subtag: 'lnd', prefix: [], scope: null },
    { type: 'language', subtag: 'lng', prefix: [], scope: null },
    { type: 'language', subtag: 'lnh', prefix: [], scope: null },
    { type: 'language', subtag: 'lni', prefix: [], scope: null },
    { type: 'language', subtag: 'lnj', prefix: [], scope: null },
    { type: 'language', subtag: 'lnl', prefix: [], scope: null },
    { type: 'language', subtag: 'lnm', prefix: [], scope: null },
    { type: 'language', subtag: 'lnn', prefix: [], scope: null },
    { type: 'language', subtag: 'lno', prefix: [], scope: null },
    { type: 'language', subtag: 'lns', prefix: [], scope: null },
    { type: 'language', subtag: 'lnu', prefix: [], scope: null },
    { type: 'language', subtag: 'lnw', prefix: [], scope: null },
    { type: 'language', subtag: 'lnz', prefix: [], scope: null },
    { type: 'language', subtag: 'loa', prefix: [], scope: null },
    { type: 'language', subtag: 'lob', prefix: [], scope: null },
    { type: 'language', subtag: 'loc', prefix: [], scope: null },
    { type: 'language', subtag: 'loe', prefix: [], scope: null },
    { type: 'language', subtag: 'lof', prefix: [], scope: null },
    { type: 'language', subtag: 'log', prefix: [], scope: null },
    { type: 'language', subtag: 'loh', prefix: [], scope: null },
    { type: 'language', subtag: 'loi', prefix: [], scope: null },
    { type: 'language', subtag: 'loj', prefix: [], scope: null },
    { type: 'language', subtag: 'lok', prefix: [], scope: null },
    { type: 'language', subtag: 'lol', prefix: [], scope: null },
    { type: 'language', subtag: 'lom', prefix: [], scope: null },
    { type: 'language', subtag: 'lon', prefix: [], scope: null },
    { type: 'language', subtag: 'loo', prefix: [], scope: null },
    { type: 'language', subtag: 'lop', prefix: [], scope: null },
    { type: 'language', subtag: 'loq', prefix: [], scope: null },
    { type: 'language', subtag: 'lor', prefix: [], scope: null },
    { type: 'language', subtag: 'los', prefix: [], scope: null },
    { type: 'language', subtag: 'lot', prefix: [], scope: null },
    { type: 'language', subtag: 'lou', prefix: [], scope: null },
    { type: 'language', subtag: 'lov', prefix: [], scope: null },
    { type: 'language', subtag: 'low', prefix: [], scope: null },
    { type: 'language', subtag: 'lox', prefix: [], scope: null },
    { type: 'language', subtag: 'loy', prefix: [], scope: null },
    { type: 'language', subtag: 'loz', prefix: [], scope: null },
    { type: 'language', subtag: 'lpa', prefix: [], scope: null },
    { type: 'language', subtag: 'lpe', prefix: [], scope: null },
    { type: 'language', subtag: 'lpn', prefix: [], scope: null },
    { type: 'language', subtag: 'lpo', prefix: [], scope: null },
    { type: 'language', subtag: 'lpx', prefix: [], scope: null },
    { type: 'language', subtag: 'lqr', prefix: [], scope: null },
    { type: 'language', subtag: 'lra', prefix: [], scope: null },
    { type: 'language', subtag: 'lrc', prefix: [], scope: null },
    { type: 'language', subtag: 'lre', prefix: [], scope: null },
    { type: 'language', subtag: 'lrg', prefix: [], scope: null },
    { type: 'language', subtag: 'lri', prefix: [], scope: null },
    { type: 'language', subtag: 'lrk', prefix: [], scope: null },
    { type: 'language', subtag: 'lrl', prefix: [], scope: null },
    { type: 'language', subtag: 'lrm', prefix: [], scope: null },
    { type: 'language', subtag: 'lrn', prefix: [], scope: null },
    { type: 'language', subtag: 'lro', prefix: [], scope: null },
    { type: 'language', subtag: 'lrr', prefix: [], scope: null },
    { type: 'language', subtag: 'lrt', prefix: [], scope: null },
    { type: 'language', subtag: 'lrv', prefix: [], scope: null },
    { type: 'language', subtag: 'lrz', prefix: [], scope: null },
    { type: 'language', subtag: 'lsa', prefix: [], scope: null },
    { type: 'language', subtag: 'lsb', prefix: [], scope: null },
    { type: 'language', subtag: 'lsc', prefix: [], scope: null },
    { type: 'language', subtag: 'lsd', prefix: [], scope: null },
    { type: 'language', subtag: 'lse', prefix: [], scope: null },
    { type: 'language', subtag: 'lsg', prefix: [], scope: null },
    { type: 'language', subtag: 'lsh', prefix: [], scope: null },
    { type: 'language', subtag: 'lsi', prefix: [], scope: null },
    { type: 'language', subtag: 'lsl', prefix: [], scope: null },
    { type: 'language', subtag: 'lsm', prefix: [], scope: null },
    { type: 'language', subtag: 'lsn', prefix: [], scope: null },
    { type: 'language', subtag: 'lso', prefix: [], scope: null },
    { type: 'language', subtag: 'lsp', prefix: [], scope: null },
    { type: 'language', subtag: 'lsr', prefix: [], scope: null },
    { type: 'language', subtag: 'lss', prefix: [], scope: null },
    { type: 'language', subtag: 'lst', prefix: [], scope: null },
    { type: 'language', subtag: 'lsv', prefix: [], scope: null },
    { type: 'language', subtag: 'lsw', prefix: [], scope: null },
    { type: 'language', subtag: 'lsy', prefix: [], scope: null },
    { type: 'language', subtag: 'ltc', prefix: [], scope: null },
    { type: 'language', subtag: 'ltg', prefix: [], scope: null },
    { type: 'language', subtag: 'lth', prefix: [], scope: null },
    { type: 'language', subtag: 'lti', prefix: [], scope: null },
    { type: 'language', subtag: 'ltn', prefix: [], scope: null },
    { type: 'language', subtag: 'lto', prefix: [], scope: null },
    { type: 'language', subtag: 'lts', prefix: [], scope: null },
    { type: 'language', subtag: 'ltu', prefix: [], scope: null },
    { type: 'language', subtag: 'lua', prefix: [], scope: null },
    { type: 'language', subtag: 'luc', prefix: [], scope: null },
    { type: 'language', subtag: 'lud', prefix: [], scope: null },
    { type: 'language', subtag: 'lue', prefix: [], scope: null },
    { type: 'language', subtag: 'luf', prefix: [], scope: null },
    { type: 'language', subtag: 'lui', prefix: [], scope: null },
    { type: 'language', subtag: 'luj', prefix: [], scope: null },
    { type: 'language', subtag: 'luk', prefix: [], scope: null },
    { type: 'language', subtag: 'lul', prefix: [], scope: null },
    { type: 'language', subtag: 'lum', prefix: [], scope: null },
    { type: 'language', subtag: 'lun', prefix: [], scope: null },
    { type: 'language', subtag: 'luo', prefix: [], scope: null },
    { type: 'language', subtag: 'lup', prefix: [], scope: null },
    { type: 'language', subtag: 'luq', prefix: [], scope: null },
    { type: 'language', subtag: 'lur', prefix: [], scope: null },
    { type: 'language', subtag: 'lus', prefix: [], scope: null },
    { type: 'language', subtag: 'lut', prefix: [], scope: null },
    { type: 'language', subtag: 'luu', prefix: [], scope: null },
    { type: 'language', subtag: 'luv', prefix: [], scope: null },
    { type: 'language', subtag: 'luw', prefix: [], scope: null },
    { type: 'language', subtag: 'luy', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'luz', prefix: [], scope: null },
    { type: 'language', subtag: 'lva', prefix: [], scope: null },
    { type: 'language', subtag: 'lvi', prefix: [], scope: null },
    { type: 'language', subtag: 'lvk', prefix: [], scope: null },
    { type: 'language', subtag: 'lvs', prefix: [], scope: null },
    { type: 'language', subtag: 'lvu', prefix: [], scope: null },
    { type: 'language', subtag: 'lwa', prefix: [], scope: null },
    { type: 'language', subtag: 'lwe', prefix: [], scope: null },
    { type: 'language', subtag: 'lwg', prefix: [], scope: null },
    { type: 'language', subtag: 'lwh', prefix: [], scope: null },
    { type: 'language', subtag: 'lwl', prefix: [], scope: null },
    { type: 'language', subtag: 'lwm', prefix: [], scope: null },
    { type: 'language', subtag: 'lwo', prefix: [], scope: null },
    { type: 'language', subtag: 'lws', prefix: [], scope: null },
    { type: 'language', subtag: 'lwt', prefix: [], scope: null },
    { type: 'language', subtag: 'lwu', prefix: [], scope: null },
    { type: 'language', subtag: 'lww', prefix: [], scope: null },
    { type: 'language', subtag: 'lxm', prefix: [], scope: null },
    { type: 'language', subtag: 'lya', prefix: [], scope: null },
    { type: 'language', subtag: 'lyg', prefix: [], scope: null },
    { type: 'language', subtag: 'lyn', prefix: [], scope: null },
    { type: 'language', subtag: 'lzh', prefix: [], scope: null },
    { type: 'language', subtag: 'lzl', prefix: [], scope: null },
    { type: 'language', subtag: 'lzn', prefix: [], scope: null },
    { type: 'language', subtag: 'lzz', prefix: [], scope: null },
    { type: 'language', subtag: 'maa', prefix: [], scope: null },
    { type: 'language', subtag: 'mab', prefix: [], scope: null },
    { type: 'language', subtag: 'mad', prefix: [], scope: null },
    { type: 'language', subtag: 'mae', prefix: [], scope: null },
    { type: 'language', subtag: 'maf', prefix: [], scope: null },
    { type: 'language', subtag: 'mag', prefix: [], scope: null },
    { type: 'language', subtag: 'mai', prefix: [], scope: null },
    { type: 'language', subtag: 'maj', prefix: [], scope: null },
    { type: 'language', subtag: 'mak', prefix: [], scope: null },
    { type: 'language', subtag: 'mam', prefix: [], scope: null },
    { type: 'language', subtag: 'man', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'map', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'maq', prefix: [], scope: null },
    { type: 'language', subtag: 'mas', prefix: [], scope: null },
    { type: 'language', subtag: 'mat', prefix: [], scope: null },
    { type: 'language', subtag: 'mau', prefix: [], scope: null },
    { type: 'language', subtag: 'mav', prefix: [], scope: null },
    { type: 'language', subtag: 'maw', prefix: [], scope: null },
    { type: 'language', subtag: 'max', prefix: [], scope: null },
    { type: 'language', subtag: 'maz', prefix: [], scope: null },
    { type: 'language', subtag: 'mba', prefix: [], scope: null },
    { type: 'language', subtag: 'mbb', prefix: [], scope: null },
    { type: 'language', subtag: 'mbc', prefix: [], scope: null },
    { type: 'language', subtag: 'mbd', prefix: [], scope: null },
    { type: 'language', subtag: 'mbe', prefix: [], scope: null },
    { type: 'language', subtag: 'mbf', prefix: [], scope: null },
    { type: 'language', subtag: 'mbh', prefix: [], scope: null },
    { type: 'language', subtag: 'mbi', prefix: [], scope: null },
    { type: 'language', subtag: 'mbj', prefix: [], scope: null },
    { type: 'language', subtag: 'mbk', prefix: [], scope: null },
    { type: 'language', subtag: 'mbl', prefix: [], scope: null },
    { type: 'language', subtag: 'mbm', prefix: [], scope: null },
    { type: 'language', subtag: 'mbn', prefix: [], scope: null },
    { type: 'language', subtag: 'mbo', prefix: [], scope: null },
    { type: 'language', subtag: 'mbp', prefix: [], scope: null },
    { type: 'language', subtag: 'mbq', prefix: [], scope: null },
    { type: 'language', subtag: 'mbr', prefix: [], scope: null },
    { type: 'language', subtag: 'mbs', prefix: [], scope: null },
    { type: 'language', subtag: 'mbt', prefix: [], scope: null },
    { type: 'language', subtag: 'mbu', prefix: [], scope: null },
    { type: 'language', subtag: 'mbv', prefix: [], scope: null },
    { type: 'language', subtag: 'mbw', prefix: [], scope: null },
    { type: 'language', subtag: 'mbx', prefix: [], scope: null },
    { type: 'language', subtag: 'mby', prefix: [], scope: null },
    { type: 'language', subtag: 'mbz', prefix: [], scope: null },
    { type: 'language', subtag: 'mca', prefix: [], scope: null },
    { type: 'language', subtag: 'mcb', prefix: [], scope: null },
    { type: 'language', subtag: 'mcc', prefix: [], scope: null },
    { type: 'language', subtag: 'mcd', prefix: [], scope: null },
    { type: 'language', subtag: 'mce', prefix: [], scope: null },
    { type: 'language', subtag: 'mcf', prefix: [], scope: null },
    { type: 'language', subtag: 'mcg', prefix: [], scope: null },
    { type: 'language', subtag: 'mch', prefix: [], scope: null },
    { type: 'language', subtag: 'mci', prefix: [], scope: null },
    { type: 'language', subtag: 'mcj', prefix: [], scope: null },
    { type: 'language', subtag: 'mck', prefix: [], scope: null },
    { type: 'language', subtag: 'mcl', prefix: [], scope: null },
    { type: 'language', subtag: 'mcm', prefix: [], scope: null },
    { type: 'language', subtag: 'mcn', prefix: [], scope: null },
    { type: 'language', subtag: 'mco', prefix: [], scope: null },
    { type: 'language', subtag: 'mcp', prefix: [], scope: null },
    { type: 'language', subtag: 'mcq', prefix: [], scope: null },
    { type: 'language', subtag: 'mcr', prefix: [], scope: null },
    { type: 'language', subtag: 'mcs', prefix: [], scope: null },
    { type: 'language', subtag: 'mct', prefix: [], scope: null },
    { type: 'language', subtag: 'mcu', prefix: [], scope: null },
    { type: 'language', subtag: 'mcv', prefix: [], scope: null },
    { type: 'language', subtag: 'mcw', prefix: [], scope: null },
    { type: 'language', subtag: 'mcx', prefix: [], scope: null },
    { type: 'language', subtag: 'mcy', prefix: [], scope: null },
    { type: 'language', subtag: 'mcz', prefix: [], scope: null },
    { type: 'language', subtag: 'mda', prefix: [], scope: null },
    { type: 'language', subtag: 'mdb', prefix: [], scope: null },
    { type: 'language', subtag: 'mdc', prefix: [], scope: null },
    { type: 'language', subtag: 'mdd', prefix: [], scope: null },
    { type: 'language', subtag: 'mde', prefix: [], scope: null },
    { type: 'language', subtag: 'mdf', prefix: [], scope: null },
    { type: 'language', subtag: 'mdg', prefix: [], scope: null },
    { type: 'language', subtag: 'mdh', prefix: [], scope: null },
    { type: 'language', subtag: 'mdi', prefix: [], scope: null },
    { type: 'language', subtag: 'mdj', prefix: [], scope: null },
    { type: 'language', subtag: 'mdk', prefix: [], scope: null },
    { type: 'language', subtag: 'mdl', prefix: [], scope: null },
    { type: 'language', subtag: 'mdm', prefix: [], scope: null },
    { type: 'language', subtag: 'mdn', prefix: [], scope: null },
    { type: 'language', subtag: 'mdp', prefix: [], scope: null },
    { type: 'language', subtag: 'mdq', prefix: [], scope: null },
    { type: 'language', subtag: 'mdr', prefix: [], scope: null },
    { type: 'language', subtag: 'mds', prefix: [], scope: null },
    { type: 'language', subtag: 'mdt', prefix: [], scope: null },
    { type: 'language', subtag: 'mdu', prefix: [], scope: null },
    { type: 'language', subtag: 'mdv', prefix: [], scope: null },
    { type: 'language', subtag: 'mdw', prefix: [], scope: null },
    { type: 'language', subtag: 'mdx', prefix: [], scope: null },
    { type: 'language', subtag: 'mdy', prefix: [], scope: null },
    { type: 'language', subtag: 'mdz', prefix: [], scope: null },
    { type: 'language', subtag: 'mea', prefix: [], scope: null },
    { type: 'language', subtag: 'meb', prefix: [], scope: null },
    { type: 'language', subtag: 'mec', prefix: [], scope: null },
    { type: 'language', subtag: 'med', prefix: [], scope: null },
    { type: 'language', subtag: 'mee', prefix: [], scope: null },
    { type: 'language', subtag: 'mef', prefix: [], scope: null },
    { type: 'language', subtag: 'meg', prefix: [], scope: null },
    { type: 'language', subtag: 'meh', prefix: [], scope: null },
    { type: 'language', subtag: 'mei', prefix: [], scope: null },
    { type: 'language', subtag: 'mej', prefix: [], scope: null },
    { type: 'language', subtag: 'mek', prefix: [], scope: null },
    { type: 'language', subtag: 'mel', prefix: [], scope: null },
    { type: 'language', subtag: 'mem', prefix: [], scope: null },
    { type: 'language', subtag: 'men', prefix: [], scope: null },
    { type: 'language', subtag: 'meo', prefix: [], scope: null },
    { type: 'language', subtag: 'mep', prefix: [], scope: null },
    { type: 'language', subtag: 'meq', prefix: [], scope: null },
    { type: 'language', subtag: 'mer', prefix: [], scope: null },
    { type: 'language', subtag: 'mes', prefix: [], scope: null },
    { type: 'language', subtag: 'met', prefix: [], scope: null },
    { type: 'language', subtag: 'meu', prefix: [], scope: null },
    { type: 'language', subtag: 'mev', prefix: [], scope: null },
    { type: 'language', subtag: 'mew', prefix: [], scope: null },
    { type: 'language', subtag: 'mey', prefix: [], scope: null },
    { type: 'language', subtag: 'mez', prefix: [], scope: null },
    { type: 'language', subtag: 'mfa', prefix: [], scope: null },
    { type: 'language', subtag: 'mfb', prefix: [], scope: null },
    { type: 'language', subtag: 'mfc', prefix: [], scope: null },
    { type: 'language', subtag: 'mfd', prefix: [], scope: null },
    { type: 'language', subtag: 'mfe', prefix: [], scope: null },
    { type: 'language', subtag: 'mff', prefix: [], scope: null },
    { type: 'language', subtag: 'mfg', prefix: [], scope: null },
    { type: 'language', subtag: 'mfh', prefix: [], scope: null },
    { type: 'language', subtag: 'mfi', prefix: [], scope: null },
    { type: 'language', subtag: 'mfj', prefix: [], scope: null },
    { type: 'language', subtag: 'mfk', prefix: [], scope: null },
    { type: 'language', subtag: 'mfl', prefix: [], scope: null },
    { type: 'language', subtag: 'mfm', prefix: [], scope: null },
    { type: 'language', subtag: 'mfn', prefix: [], scope: null },
    { type: 'language', subtag: 'mfo', prefix: [], scope: null },
    { type: 'language', subtag: 'mfp', prefix: [], scope: null },
    { type: 'language', subtag: 'mfq', prefix: [], scope: null },
    { type: 'language', subtag: 'mfr', prefix: [], scope: null },
    { type: 'language', subtag: 'mfs', prefix: [], scope: null },
    { type: 'language', subtag: 'mft', prefix: [], scope: null },
    { type: 'language', subtag: 'mfu', prefix: [], scope: null },
    { type: 'language', subtag: 'mfv', prefix: [], scope: null },
    { type: 'language', subtag: 'mfw', prefix: [], scope: null },
    { type: 'language', subtag: 'mfx', prefix: [], scope: null },
    { type: 'language', subtag: 'mfy', prefix: [], scope: null },
    { type: 'language', subtag: 'mfz', prefix: [], scope: null },
    { type: 'language', subtag: 'mga', prefix: [], scope: null },
    { type: 'language', subtag: 'mgb', prefix: [], scope: null },
    { type: 'language', subtag: 'mgc', prefix: [], scope: null },
    { type: 'language', subtag: 'mgd', prefix: [], scope: null },
    { type: 'language', subtag: 'mge', prefix: [], scope: null },
    { type: 'language', subtag: 'mgf', prefix: [], scope: null },
    { type: 'language', subtag: 'mgg', prefix: [], scope: null },
    { type: 'language', subtag: 'mgh', prefix: [], scope: null },
    { type: 'language', subtag: 'mgi', prefix: [], scope: null },
    { type: 'language', subtag: 'mgj', prefix: [], scope: null },
    { type: 'language', subtag: 'mgk', prefix: [], scope: null },
    { type: 'language', subtag: 'mgl', prefix: [], scope: null },
    { type: 'language', subtag: 'mgm', prefix: [], scope: null },
    { type: 'language', subtag: 'mgn', prefix: [], scope: null },
    { type: 'language', subtag: 'mgo', prefix: [], scope: null },
    { type: 'language', subtag: 'mgp', prefix: [], scope: null },
    { type: 'language', subtag: 'mgq', prefix: [], scope: null },
    { type: 'language', subtag: 'mgr', prefix: [], scope: null },
    { type: 'language', subtag: 'mgs', prefix: [], scope: null },
    { type: 'language', subtag: 'mgt', prefix: [], scope: null },
    { type: 'language', subtag: 'mgu', prefix: [], scope: null },
    { type: 'language', subtag: 'mgv', prefix: [], scope: null },
    { type: 'language', subtag: 'mgw', prefix: [], scope: null },
    { type: 'language', subtag: 'mgx', prefix: [], scope: null },
    { type: 'language', subtag: 'mgy', prefix: [], scope: null },
    { type: 'language', subtag: 'mgz', prefix: [], scope: null },
    { type: 'language', subtag: 'mha', prefix: [], scope: null },
    { type: 'language', subtag: 'mhb', prefix: [], scope: null },
    { type: 'language', subtag: 'mhc', prefix: [], scope: null },
    { type: 'language', subtag: 'mhd', prefix: [], scope: null },
    { type: 'language', subtag: 'mhe', prefix: [], scope: null },
    { type: 'language', subtag: 'mhf', prefix: [], scope: null },
    { type: 'language', subtag: 'mhg', prefix: [], scope: null },
    { type: 'language', subtag: 'mhh', prefix: [], scope: null },
    { type: 'language', subtag: 'mhi', prefix: [], scope: null },
    { type: 'language', subtag: 'mhj', prefix: [], scope: null },
    { type: 'language', subtag: 'mhk', prefix: [], scope: null },
    { type: 'language', subtag: 'mhl', prefix: [], scope: null },
    { type: 'language', subtag: 'mhm', prefix: [], scope: null },
    { type: 'language', subtag: 'mhn', prefix: [], scope: null },
    { type: 'language', subtag: 'mho', prefix: [], scope: null },
    { type: 'language', subtag: 'mhp', prefix: [], scope: null },
    { type: 'language', subtag: 'mhq', prefix: [], scope: null },
    { type: 'language', subtag: 'mhr', prefix: [], scope: null },
    { type: 'language', subtag: 'mhs', prefix: [], scope: null },
    { type: 'language', subtag: 'mht', prefix: [], scope: null },
    { type: 'language', subtag: 'mhu', prefix: [], scope: null },
    { type: 'language', subtag: 'mhw', prefix: [], scope: null },
    { type: 'language', subtag: 'mhx', prefix: [], scope: null },
    { type: 'language', subtag: 'mhy', prefix: [], scope: null },
    { type: 'language', subtag: 'mhz', prefix: [], scope: null },
    { type: 'language', subtag: 'mia', prefix: [], scope: null },
    { type: 'language', subtag: 'mib', prefix: [], scope: null },
    { type: 'language', subtag: 'mic', prefix: [], scope: null },
    { type: 'language', subtag: 'mid', prefix: [], scope: null },
    { type: 'language', subtag: 'mie', prefix: [], scope: null },
    { type: 'language', subtag: 'mif', prefix: [], scope: null },
    { type: 'language', subtag: 'mig', prefix: [], scope: null },
    { type: 'language', subtag: 'mih', prefix: [], scope: null },
    { type: 'language', subtag: 'mii', prefix: [], scope: null },
    { type: 'language', subtag: 'mij', prefix: [], scope: null },
    { type: 'language', subtag: 'mik', prefix: [], scope: null },
    { type: 'language', subtag: 'mil', prefix: [], scope: null },
    { type: 'language', subtag: 'mim', prefix: [], scope: null },
    { type: 'language', subtag: 'min', prefix: [], scope: null },
    { type: 'language', subtag: 'mio', prefix: [], scope: null },
    { type: 'language', subtag: 'mip', prefix: [], scope: null },
    { type: 'language', subtag: 'miq', prefix: [], scope: null },
    { type: 'language', subtag: 'mir', prefix: [], scope: null },
    { type: 'language', subtag: 'mis', prefix: [], scope: 'special' },
    { type: 'language', subtag: 'mit', prefix: [], scope: null },
    { type: 'language', subtag: 'miu', prefix: [], scope: null },
    { type: 'language', subtag: 'miw', prefix: [], scope: null },
    { type: 'language', subtag: 'mix', prefix: [], scope: null },
    { type: 'language', subtag: 'miy', prefix: [], scope: null },
    { type: 'language', subtag: 'miz', prefix: [], scope: null },
    { type: 'language', subtag: 'mja', prefix: [], scope: null },
    { type: 'language', subtag: 'mjb', prefix: [], scope: null },
    { type: 'language', subtag: 'mjc', prefix: [], scope: null },
    { type: 'language', subtag: 'mjd', prefix: [], scope: null },
    { type: 'language', subtag: 'mje', prefix: [], scope: null },
    { type: 'language', subtag: 'mjg', prefix: [], scope: null },
    { type: 'language', subtag: 'mjh', prefix: [], scope: null },
    { type: 'language', subtag: 'mji', prefix: [], scope: null },
    { type: 'language', subtag: 'mjj', prefix: [], scope: null },
    { type: 'language', subtag: 'mjk', prefix: [], scope: null },
    { type: 'language', subtag: 'mjl', prefix: [], scope: null },
    { type: 'language', subtag: 'mjm', prefix: [], scope: null },
    { type: 'language', subtag: 'mjn', prefix: [], scope: null },
    { type: 'language', subtag: 'mjo', prefix: [], scope: null },
    { type: 'language', subtag: 'mjp', prefix: [], scope: null },
    { type: 'language', subtag: 'mjq', prefix: [], scope: null },
    { type: 'language', subtag: 'mjr', prefix: [], scope: null },
    { type: 'language', subtag: 'mjs', prefix: [], scope: null },
    { type: 'language', subtag: 'mjt', prefix: [], scope: null },
    { type: 'language', subtag: 'mju', prefix: [], scope: null },
    { type: 'language', subtag: 'mjv', prefix: [], scope: null },
    { type: 'language', subtag: 'mjw', prefix: [], scope: null },
    { type: 'language', subtag: 'mjx', prefix: [], scope: null },
    { type: 'language', subtag: 'mjy', prefix: [], scope: null },
    { type: 'language', subtag: 'mjz', prefix: [], scope: null },
    { type: 'language', subtag: 'mka', prefix: [], scope: null },
    { type: 'language', subtag: 'mkb', prefix: [], scope: null },
    { type: 'language', subtag: 'mkc', prefix: [], scope: null },
    { type: 'language', subtag: 'mke', prefix: [], scope: null },
    { type: 'language', subtag: 'mkf', prefix: [], scope: null },
    { type: 'language', subtag: 'mkg', prefix: [], scope: null },
    { type: 'language', subtag: 'mkh', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'mki', prefix: [], scope: null },
    { type: 'language', subtag: 'mkj', prefix: [], scope: null },
    { type: 'language', subtag: 'mkk', prefix: [], scope: null },
    { type: 'language', subtag: 'mkl', prefix: [], scope: null },
    { type: 'language', subtag: 'mkm', prefix: [], scope: null },
    { type: 'language', subtag: 'mkn', prefix: [], scope: null },
    { type: 'language', subtag: 'mko', prefix: [], scope: null },
    { type: 'language', subtag: 'mkp', prefix: [], scope: null },
    { type: 'language', subtag: 'mkq', prefix: [], scope: null },
    { type: 'language', subtag: 'mkr', prefix: [], scope: null },
    { type: 'language', subtag: 'mks', prefix: [], scope: null },
    { type: 'language', subtag: 'mkt', prefix: [], scope: null },
    { type: 'language', subtag: 'mku', prefix: [], scope: null },
    { type: 'language', subtag: 'mkv', prefix: [], scope: null },
    { type: 'language', subtag: 'mkw', prefix: [], scope: null },
    { type: 'language', subtag: 'mkx', prefix: [], scope: null },
    { type: 'language', subtag: 'mky', prefix: [], scope: null },
    { type: 'language', subtag: 'mkz', prefix: [], scope: null },
    { type: 'language', subtag: 'mla', prefix: [], scope: null },
    { type: 'language', subtag: 'mlb', prefix: [], scope: null },
    { type: 'language', subtag: 'mlc', prefix: [], scope: null },
    { type: 'language', subtag: 'mld', prefix: [], scope: null },
    { type: 'language', subtag: 'mle', prefix: [], scope: null },
    { type: 'language', subtag: 'mlf', prefix: [], scope: null },
    { type: 'language', subtag: 'mlh', prefix: [], scope: null },
    { type: 'language', subtag: 'mli', prefix: [], scope: null },
    { type: 'language', subtag: 'mlj', prefix: [], scope: null },
    { type: 'language', subtag: 'mlk', prefix: [], scope: null },
    { type: 'language', subtag: 'mll', prefix: [], scope: null },
    { type: 'language', subtag: 'mlm', prefix: [], scope: null },
    { type: 'language', subtag: 'mln', prefix: [], scope: null },
    { type: 'language', subtag: 'mlo', prefix: [], scope: null },
    { type: 'language', subtag: 'mlp', prefix: [], scope: null },
    { type: 'language', subtag: 'mlq', prefix: [], scope: null },
    { type: 'language', subtag: 'mlr', prefix: [], scope: null },
    { type: 'language', subtag: 'mls', prefix: [], scope: null },
    { type: 'language', subtag: 'mlu', prefix: [], scope: null },
    { type: 'language', subtag: 'mlv', prefix: [], scope: null },
    { type: 'language', subtag: 'mlw', prefix: [], scope: null },
    { type: 'language', subtag: 'mlx', prefix: [], scope: null },
    { type: 'language', subtag: 'mlz', prefix: [], scope: null },
    { type: 'language', subtag: 'mma', prefix: [], scope: null },
    { type: 'language', subtag: 'mmb', prefix: [], scope: null },
    { type: 'language', subtag: 'mmc', prefix: [], scope: null },
    { type: 'language', subtag: 'mmd', prefix: [], scope: null },
    { type: 'language', subtag: 'mme', prefix: [], scope: null },
    { type: 'language', subtag: 'mmf', prefix: [], scope: null },
    { type: 'language', subtag: 'mmg', prefix: [], scope: null },
    { type: 'language', subtag: 'mmh', prefix: [], scope: null },
    { type: 'language', subtag: 'mmi', prefix: [], scope: null },
    { type: 'language', subtag: 'mmj', prefix: [], scope: null },
    { type: 'language', subtag: 'mmk', prefix: [], scope: null },
    { type: 'language', subtag: 'mml', prefix: [], scope: null },
    { type: 'language', subtag: 'mmm', prefix: [], scope: null },
    { type: 'language', subtag: 'mmn', prefix: [], scope: null },
    { type: 'language', subtag: 'mmo', prefix: [], scope: null },
    { type: 'language', subtag: 'mmp', prefix: [], scope: null },
    { type: 'language', subtag: 'mmq', prefix: [], scope: null },
    { type: 'language', subtag: 'mmr', prefix: [], scope: null },
    { type: 'language', subtag: 'mmt', prefix: [], scope: null },
    { type: 'language', subtag: 'mmu', prefix: [], scope: null },
    { type: 'language', subtag: 'mmv', prefix: [], scope: null },
    { type: 'language', subtag: 'mmw', prefix: [], scope: null },
    { type: 'language', subtag: 'mmx', prefix: [], scope: null },
    { type: 'language', subtag: 'mmy', prefix: [], scope: null },
    { type: 'language', subtag: 'mmz', prefix: [], scope: null },
    { type: 'language', subtag: 'mna', prefix: [], scope: null },
    { type: 'language', subtag: 'mnb', prefix: [], scope: null },
    { type: 'language', subtag: 'mnc', prefix: [], scope: null },
    { type: 'language', subtag: 'mnd', prefix: [], scope: null },
    { type: 'language', subtag: 'mne', prefix: [], scope: null },
    { type: 'language', subtag: 'mnf', prefix: [], scope: null },
    { type: 'language', subtag: 'mng', prefix: [], scope: null },
    { type: 'language', subtag: 'mnh', prefix: [], scope: null },
    { type: 'language', subtag: 'mni', prefix: [], scope: null },
    { type: 'language', subtag: 'mnj', prefix: [], scope: null },
    { type: 'language', subtag: 'mnk', prefix: [], scope: null },
    { type: 'language', subtag: 'mnl', prefix: [], scope: null },
    { type: 'language', subtag: 'mnm', prefix: [], scope: null },
    { type: 'language', subtag: 'mnn', prefix: [], scope: null },
    { type: 'language', subtag: 'mno', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'mnp', prefix: [], scope: null },
    { type: 'language', subtag: 'mnq', prefix: [], scope: null },
    { type: 'language', subtag: 'mnr', prefix: [], scope: null },
    { type: 'language', subtag: 'mns', prefix: [], scope: null },
    { type: 'language', subtag: 'mnt', prefix: [], scope: null },
    { type: 'language', subtag: 'mnu', prefix: [], scope: null },
    { type: 'language', subtag: 'mnv', prefix: [], scope: null },
    { type: 'language', subtag: 'mnw', prefix: [], scope: null },
    { type: 'language', subtag: 'mnx', prefix: [], scope: null },
    { type: 'language', subtag: 'mny', prefix: [], scope: null },
    { type: 'language', subtag: 'mnz', prefix: [], scope: null },
    { type: 'language', subtag: 'moa', prefix: [], scope: null },
    { type: 'language', subtag: 'moc', prefix: [], scope: null },
    { type: 'language', subtag: 'mod', prefix: [], scope: null },
    { type: 'language', subtag: 'moe', prefix: [], scope: null },
    { type: 'language', subtag: 'mof', prefix: [], scope: null },
    { type: 'language', subtag: 'mog', prefix: [], scope: null },
    { type: 'language', subtag: 'moh', prefix: [], scope: null },
    { type: 'language', subtag: 'moi', prefix: [], scope: null },
    { type: 'language', subtag: 'moj', prefix: [], scope: null },
    { type: 'language', subtag: 'mok', prefix: [], scope: null },
    { type: 'language', subtag: 'mom', prefix: [], scope: null },
    { type: 'language', subtag: 'moo', prefix: [], scope: null },
    { type: 'language', subtag: 'mop', prefix: [], scope: null },
    { type: 'language', subtag: 'moq', prefix: [], scope: null },
    { type: 'language', subtag: 'mor', prefix: [], scope: null },
    { type: 'language', subtag: 'mos', prefix: [], scope: null },
    { type: 'language', subtag: 'mot', prefix: [], scope: null },
    { type: 'language', subtag: 'mou', prefix: [], scope: null },
    { type: 'language', subtag: 'mov', prefix: [], scope: null },
    { type: 'language', subtag: 'mow', prefix: [], scope: null },
    { type: 'language', subtag: 'mox', prefix: [], scope: null },
    { type: 'language', subtag: 'moy', prefix: [], scope: null },
    { type: 'language', subtag: 'moz', prefix: [], scope: null },
    { type: 'language', subtag: 'mpa', prefix: [], scope: null },
    { type: 'language', subtag: 'mpb', prefix: [], scope: null },
    { type: 'language', subtag: 'mpc', prefix: [], scope: null },
    { type: 'language', subtag: 'mpd', prefix: [], scope: null },
    { type: 'language', subtag: 'mpe', prefix: [], scope: null },
    { type: 'language', subtag: 'mpg', prefix: [], scope: null },
    { type: 'language', subtag: 'mph', prefix: [], scope: null },
    { type: 'language', subtag: 'mpi', prefix: [], scope: null },
    { type: 'language', subtag: 'mpj', prefix: [], scope: null },
    { type: 'language', subtag: 'mpk', prefix: [], scope: null },
    { type: 'language', subtag: 'mpl', prefix: [], scope: null },
    { type: 'language', subtag: 'mpm', prefix: [], scope: null },
    { type: 'language', subtag: 'mpn', prefix: [], scope: null },
    { type: 'language', subtag: 'mpo', prefix: [], scope: null },
    { type: 'language', subtag: 'mpp', prefix: [], scope: null },
    { type: 'language', subtag: 'mpq', prefix: [], scope: null },
    { type: 'language', subtag: 'mpr', prefix: [], scope: null },
    { type: 'language', subtag: 'mps', prefix: [], scope: null },
    { type: 'language', subtag: 'mpt', prefix: [], scope: null },
    { type: 'language', subtag: 'mpu', prefix: [], scope: null },
    { type: 'language', subtag: 'mpv', prefix: [], scope: null },
    { type: 'language', subtag: 'mpw', prefix: [], scope: null },
    { type: 'language', subtag: 'mpx', prefix: [], scope: null },
    { type: 'language', subtag: 'mpy', prefix: [], scope: null },
    { type: 'language', subtag: 'mpz', prefix: [], scope: null },
    { type: 'language', subtag: 'mqa', prefix: [], scope: null },
    { type: 'language', subtag: 'mqb', prefix: [], scope: null },
    { type: 'language', subtag: 'mqc', prefix: [], scope: null },
    { type: 'language', subtag: 'mqe', prefix: [], scope: null },
    { type: 'language', subtag: 'mqf', prefix: [], scope: null },
    { type: 'language', subtag: 'mqg', prefix: [], scope: null },
    { type: 'language', subtag: 'mqh', prefix: [], scope: null },
    { type: 'language', subtag: 'mqi', prefix: [], scope: null },
    { type: 'language', subtag: 'mqj', prefix: [], scope: null },
    { type: 'language', subtag: 'mqk', prefix: [], scope: null },
    { type: 'language', subtag: 'mql', prefix: [], scope: null },
    { type: 'language', subtag: 'mqm', prefix: [], scope: null },
    { type: 'language', subtag: 'mqn', prefix: [], scope: null },
    { type: 'language', subtag: 'mqo', prefix: [], scope: null },
    { type: 'language', subtag: 'mqp', prefix: [], scope: null },
    { type: 'language', subtag: 'mqq', prefix: [], scope: null },
    { type: 'language', subtag: 'mqr', prefix: [], scope: null },
    { type: 'language', subtag: 'mqs', prefix: [], scope: null },
    { type: 'language', subtag: 'mqt', prefix: [], scope: null },
    { type: 'language', subtag: 'mqu', prefix: [], scope: null },
    { type: 'language', subtag: 'mqv', prefix: [], scope: null },
    { type: 'language', subtag: 'mqw', prefix: [], scope: null },
    { type: 'language', subtag: 'mqx', prefix: [], scope: null },
    { type: 'language', subtag: 'mqy', prefix: [], scope: null },
    { type: 'language', subtag: 'mqz', prefix: [], scope: null },
    { type: 'language', subtag: 'mra', prefix: [], scope: null },
    { type: 'language', subtag: 'mrb', prefix: [], scope: null },
    { type: 'language', subtag: 'mrc', prefix: [], scope: null },
    { type: 'language', subtag: 'mrd', prefix: [], scope: null },
    { type: 'language', subtag: 'mre', prefix: [], scope: null },
    { type: 'language', subtag: 'mrf', prefix: [], scope: null },
    { type: 'language', subtag: 'mrg', prefix: [], scope: null },
    { type: 'language', subtag: 'mrh', prefix: [], scope: null },
    { type: 'language', subtag: 'mrj', prefix: [], scope: null },
    { type: 'language', subtag: 'mrk', prefix: [], scope: null },
    { type: 'language', subtag: 'mrl', prefix: [], scope: null },
    { type: 'language', subtag: 'mrm', prefix: [], scope: null },
    { type: 'language', subtag: 'mrn', prefix: [], scope: null },
    { type: 'language', subtag: 'mro', prefix: [], scope: null },
    { type: 'language', subtag: 'mrp', prefix: [], scope: null },
    { type: 'language', subtag: 'mrq', prefix: [], scope: null },
    { type: 'language', subtag: 'mrr', prefix: [], scope: null },
    { type: 'language', subtag: 'mrs', prefix: [], scope: null },
    { type: 'language', subtag: 'mrt', prefix: [], scope: null },
    { type: 'language', subtag: 'mru', prefix: [], scope: null },
    { type: 'language', subtag: 'mrv', prefix: [], scope: null },
    { type: 'language', subtag: 'mrw', prefix: [], scope: null },
    { type: 'language', subtag: 'mrx', prefix: [], scope: null },
    { type: 'language', subtag: 'mry', prefix: [], scope: null },
    { type: 'language', subtag: 'mrz', prefix: [], scope: null },
    { type: 'language', subtag: 'msb', prefix: [], scope: null },
    { type: 'language', subtag: 'msc', prefix: [], scope: null },
    { type: 'language', subtag: 'msd', prefix: [], scope: null },
    { type: 'language', subtag: 'mse', prefix: [], scope: null },
    { type: 'language', subtag: 'msf', prefix: [], scope: null },
    { type: 'language', subtag: 'msg', prefix: [], scope: null },
    { type: 'language', subtag: 'msh', prefix: [], scope: null },
    { type: 'language', subtag: 'msi', prefix: [], scope: null },
    { type: 'language', subtag: 'msj', prefix: [], scope: null },
    { type: 'language', subtag: 'msk', prefix: [], scope: null },
    { type: 'language', subtag: 'msl', prefix: [], scope: null },
    { type: 'language', subtag: 'msm', prefix: [], scope: null },
    { type: 'language', subtag: 'msn', prefix: [], scope: null },
    { type: 'language', subtag: 'mso', prefix: [], scope: null },
    { type: 'language', subtag: 'msp', prefix: [], scope: null },
    { type: 'language', subtag: 'msq', prefix: [], scope: null },
    { type: 'language', subtag: 'msr', prefix: [], scope: null },
    { type: 'language', subtag: 'mss', prefix: [], scope: null },
    { type: 'language', subtag: 'mst', prefix: [], scope: null },
    { type: 'language', subtag: 'msu', prefix: [], scope: null },
    { type: 'language', subtag: 'msv', prefix: [], scope: null },
    { type: 'language', subtag: 'msw', prefix: [], scope: null },
    { type: 'language', subtag: 'msx', prefix: [], scope: null },
    { type: 'language', subtag: 'msy', prefix: [], scope: null },
    { type: 'language', subtag: 'msz', prefix: [], scope: null },
    { type: 'language', subtag: 'mta', prefix: [], scope: null },
    { type: 'language', subtag: 'mtb', prefix: [], scope: null },
    { type: 'language', subtag: 'mtc', prefix: [], scope: null },
    { type: 'language', subtag: 'mtd', prefix: [], scope: null },
    { type: 'language', subtag: 'mte', prefix: [], scope: null },
    { type: 'language', subtag: 'mtf', prefix: [], scope: null },
    { type: 'language', subtag: 'mtg', prefix: [], scope: null },
    { type: 'language', subtag: 'mth', prefix: [], scope: null },
    { type: 'language', subtag: 'mti', prefix: [], scope: null },
    { type: 'language', subtag: 'mtj', prefix: [], scope: null },
    { type: 'language', subtag: 'mtk', prefix: [], scope: null },
    { type: 'language', subtag: 'mtl', prefix: [], scope: null },
    { type: 'language', subtag: 'mtm', prefix: [], scope: null },
    { type: 'language', subtag: 'mtn', prefix: [], scope: null },
    { type: 'language', subtag: 'mto', prefix: [], scope: null },
    { type: 'language', subtag: 'mtp', prefix: [], scope: null },
    { type: 'language', subtag: 'mtq', prefix: [], scope: null },
    { type: 'language', subtag: 'mtr', prefix: [], scope: null },
    { type: 'language', subtag: 'mts', prefix: [], scope: null },
    { type: 'language', subtag: 'mtt', prefix: [], scope: null },
    { type: 'language', subtag: 'mtu', prefix: [], scope: null },
    { type: 'language', subtag: 'mtv', prefix: [], scope: null },
    { type: 'language', subtag: 'mtw', prefix: [], scope: null },
    { type: 'language', subtag: 'mtx', prefix: [], scope: null },
    { type: 'language', subtag: 'mty', prefix: [], scope: null },
    { type: 'language', subtag: 'mua', prefix: [], scope: null },
    { type: 'language', subtag: 'mub', prefix: [], scope: null },
    { type: 'language', subtag: 'muc', prefix: [], scope: null },
    { type: 'language', subtag: 'mud', prefix: [], scope: null },
    { type: 'language', subtag: 'mue', prefix: [], scope: null },
    { type: 'language', subtag: 'mug', prefix: [], scope: null },
    { type: 'language', subtag: 'muh', prefix: [], scope: null },
    { type: 'language', subtag: 'mui', prefix: [], scope: null },
    { type: 'language', subtag: 'muj', prefix: [], scope: null },
    { type: 'language', subtag: 'muk', prefix: [], scope: null },
    { type: 'language', subtag: 'mul', prefix: [], scope: 'special' },
    { type: 'language', subtag: 'mum', prefix: [], scope: null },
    { type: 'language', subtag: 'mun', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'muo', prefix: [], scope: null },
    { type: 'language', subtag: 'mup', prefix: [], scope: null },
    { type: 'language', subtag: 'muq', prefix: [], scope: null },
    { type: 'language', subtag: 'mur', prefix: [], scope: null },
    { type: 'language', subtag: 'mus', prefix: [], scope: null },
    { type: 'language', subtag: 'mut', prefix: [], scope: null },
    { type: 'language', subtag: 'muu', prefix: [], scope: null },
    { type: 'language', subtag: 'muv', prefix: [], scope: null },
    { type: 'language', subtag: 'mux', prefix: [], scope: null },
    { type: 'language', subtag: 'muy', prefix: [], scope: null },
    { type: 'language', subtag: 'muz', prefix: [], scope: null },
    { type: 'language', subtag: 'mva', prefix: [], scope: null },
    { type: 'language', subtag: 'mvb', prefix: [], scope: null },
    { type: 'language', subtag: 'mvd', prefix: [], scope: null },
    { type: 'language', subtag: 'mve', prefix: [], scope: null },
    { type: 'language', subtag: 'mvf', prefix: [], scope: null },
    { type: 'language', subtag: 'mvg', prefix: [], scope: null },
    { type: 'language', subtag: 'mvh', prefix: [], scope: null },
    { type: 'language', subtag: 'mvi', prefix: [], scope: null },
    { type: 'language', subtag: 'mvk', prefix: [], scope: null },
    { type: 'language', subtag: 'mvl', prefix: [], scope: null },
    { type: 'language', subtag: 'mvm', prefix: [], scope: null },
    { type: 'language', subtag: 'mvn', prefix: [], scope: null },
    { type: 'language', subtag: 'mvo', prefix: [], scope: null },
    { type: 'language', subtag: 'mvp', prefix: [], scope: null },
    { type: 'language', subtag: 'mvq', prefix: [], scope: null },
    { type: 'language', subtag: 'mvr', prefix: [], scope: null },
    { type: 'language', subtag: 'mvs', prefix: [], scope: null },
    { type: 'language', subtag: 'mvt', prefix: [], scope: null },
    { type: 'language', subtag: 'mvu', prefix: [], scope: null },
    { type: 'language', subtag: 'mvv', prefix: [], scope: null },
    { type: 'language', subtag: 'mvw', prefix: [], scope: null },
    { type: 'language', subtag: 'mvx', prefix: [], scope: null },
    { type: 'language', subtag: 'mvy', prefix: [], scope: null },
    { type: 'language', subtag: 'mvz', prefix: [], scope: null },
    { type: 'language', subtag: 'mwa', prefix: [], scope: null },
    { type: 'language', subtag: 'mwb', prefix: [], scope: null },
    { type: 'language', subtag: 'mwc', prefix: [], scope: null },
    { type: 'language', subtag: 'mwd', prefix: [], scope: null },
    { type: 'language', subtag: 'mwe', prefix: [], scope: null },
    { type: 'language', subtag: 'mwf', prefix: [], scope: null },
    { type: 'language', subtag: 'mwg', prefix: [], scope: null },
    { type: 'language', subtag: 'mwh', prefix: [], scope: null },
    { type: 'language', subtag: 'mwi', prefix: [], scope: null },
    { type: 'language', subtag: 'mwj', prefix: [], scope: null },
    { type: 'language', subtag: 'mwk', prefix: [], scope: null },
    { type: 'language', subtag: 'mwl', prefix: [], scope: null },
    { type: 'language', subtag: 'mwm', prefix: [], scope: null },
    { type: 'language', subtag: 'mwn', prefix: [], scope: null },
    { type: 'language', subtag: 'mwo', prefix: [], scope: null },
    { type: 'language', subtag: 'mwp', prefix: [], scope: null },
    { type: 'language', subtag: 'mwq', prefix: [], scope: null },
    { type: 'language', subtag: 'mwr', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'mws', prefix: [], scope: null },
    { type: 'language', subtag: 'mwt', prefix: [], scope: null },
    { type: 'language', subtag: 'mwu', prefix: [], scope: null },
    { type: 'language', subtag: 'mwv', prefix: [], scope: null },
    { type: 'language', subtag: 'mww', prefix: [], scope: null },
    { type: 'language', subtag: 'mwx', prefix: [], scope: null },
    { type: 'language', subtag: 'mwy', prefix: [], scope: null },
    { type: 'language', subtag: 'mwz', prefix: [], scope: null },
    { type: 'language', subtag: 'mxa', prefix: [], scope: null },
    { type: 'language', subtag: 'mxb', prefix: [], scope: null },
    { type: 'language', subtag: 'mxc', prefix: [], scope: null },
    { type: 'language', subtag: 'mxd', prefix: [], scope: null },
    { type: 'language', subtag: 'mxe', prefix: [], scope: null },
    { type: 'language', subtag: 'mxf', prefix: [], scope: null },
    { type: 'language', subtag: 'mxg', prefix: [], scope: null },
    { type: 'language', subtag: 'mxh', prefix: [], scope: null },
    { type: 'language', subtag: 'mxi', prefix: [], scope: null },
    { type: 'language', subtag: 'mxj', prefix: [], scope: null },
    { type: 'language', subtag: 'mxk', prefix: [], scope: null },
    { type: 'language', subtag: 'mxl', prefix: [], scope: null },
    { type: 'language', subtag: 'mxm', prefix: [], scope: null },
    { type: 'language', subtag: 'mxn', prefix: [], scope: null },
    { type: 'language', subtag: 'mxo', prefix: [], scope: null },
    { type: 'language', subtag: 'mxp', prefix: [], scope: null },
    { type: 'language', subtag: 'mxq', prefix: [], scope: null },
    { type: 'language', subtag: 'mxr', prefix: [], scope: null },
    { type: 'language', subtag: 'mxs', prefix: [], scope: null },
    { type: 'language', subtag: 'mxt', prefix: [], scope: null },
    { type: 'language', subtag: 'mxu', prefix: [], scope: null },
    { type: 'language', subtag: 'mxv', prefix: [], scope: null },
    { type: 'language', subtag: 'mxw', prefix: [], scope: null },
    { type: 'language', subtag: 'mxx', prefix: [], scope: null },
    { type: 'language', subtag: 'mxy', prefix: [], scope: null },
    { type: 'language', subtag: 'mxz', prefix: [], scope: null },
    { type: 'language', subtag: 'myb', prefix: [], scope: null },
    { type: 'language', subtag: 'myc', prefix: [], scope: null },
    { type: 'language', subtag: 'myd', prefix: [], scope: null },
    { type: 'language', subtag: 'mye', prefix: [], scope: null },
    { type: 'language', subtag: 'myf', prefix: [], scope: null },
    { type: 'language', subtag: 'myg', prefix: [], scope: null },
    { type: 'language', subtag: 'myh', prefix: [], scope: null },
    { type: 'language', subtag: 'myi', prefix: [], scope: null },
    { type: 'language', subtag: 'myj', prefix: [], scope: null },
    { type: 'language', subtag: 'myk', prefix: [], scope: null },
    { type: 'language', subtag: 'myl', prefix: [], scope: null },
    { type: 'language', subtag: 'mym', prefix: [], scope: null },
    { type: 'language', subtag: 'myn', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'myo', prefix: [], scope: null },
    { type: 'language', subtag: 'myp', prefix: [], scope: null },
    { type: 'language', subtag: 'myq', prefix: [], scope: null },
    { type: 'language', subtag: 'myr', prefix: [], scope: null },
    { type: 'language', subtag: 'mys', prefix: [], scope: null },
    { type: 'language', subtag: 'myt', prefix: [], scope: null },
    { type: 'language', subtag: 'myu', prefix: [], scope: null },
    { type: 'language', subtag: 'myv', prefix: [], scope: null },
    { type: 'language', subtag: 'myw', prefix: [], scope: null },
    { type: 'language', subtag: 'myx', prefix: [], scope: null },
    { type: 'language', subtag: 'myy', prefix: [], scope: null },
    { type: 'language', subtag: 'myz', prefix: [], scope: null },
    { type: 'language', subtag: 'mza', prefix: [], scope: null },
    { type: 'language', subtag: 'mzb', prefix: [], scope: null },
    { type: 'language', subtag: 'mzc', prefix: [], scope: null },
    { type: 'language', subtag: 'mzd', prefix: [], scope: null },
    { type: 'language', subtag: 'mze', prefix: [], scope: null },
    { type: 'language', subtag: 'mzg', prefix: [], scope: null },
    { type: 'language', subtag: 'mzh', prefix: [], scope: null },
    { type: 'language', subtag: 'mzi', prefix: [], scope: null },
    { type: 'language', subtag: 'mzj', prefix: [], scope: null },
    { type: 'language', subtag: 'mzk', prefix: [], scope: null },
    { type: 'language', subtag: 'mzl', prefix: [], scope: null },
    { type: 'language', subtag: 'mzm', prefix: [], scope: null },
    { type: 'language', subtag: 'mzn', prefix: [], scope: null },
    { type: 'language', subtag: 'mzo', prefix: [], scope: null },
    { type: 'language', subtag: 'mzp', prefix: [], scope: null },
    { type: 'language', subtag: 'mzq', prefix: [], scope: null },
    { type: 'language', subtag: 'mzr', prefix: [], scope: null },
    { type: 'language', subtag: 'mzs', prefix: [], scope: null },
    { type: 'language', subtag: 'mzt', prefix: [], scope: null },
    { type: 'language', subtag: 'mzu', prefix: [], scope: null },
    { type: 'language', subtag: 'mzv', prefix: [], scope: null },
    { type: 'language', subtag: 'mzw', prefix: [], scope: null },
    { type: 'language', subtag: 'mzx', prefix: [], scope: null },
    { type: 'language', subtag: 'mzy', prefix: [], scope: null },
    { type: 'language', subtag: 'mzz', prefix: [], scope: null },
    { type: 'language', subtag: 'naa', prefix: [], scope: null },
    { type: 'language', subtag: 'nab', prefix: [], scope: null },
    { type: 'language', subtag: 'nac', prefix: [], scope: null },
    { type: 'language', subtag: 'nad', prefix: [], scope: null },
    { type: 'language', subtag: 'nae', prefix: [], scope: null },
    { type: 'language', subtag: 'naf', prefix: [], scope: null },
    { type: 'language', subtag: 'nag', prefix: [], scope: null },
    { type: 'language', subtag: 'nah', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'nai', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'naj', prefix: [], scope: null },
    { type: 'language', subtag: 'nak', prefix: [], scope: null },
    { type: 'language', subtag: 'nal', prefix: [], scope: null },
    { type: 'language', subtag: 'nam', prefix: [], scope: null },
    { type: 'language', subtag: 'nan', prefix: [], scope: null },
    { type: 'language', subtag: 'nao', prefix: [], scope: null },
    { type: 'language', subtag: 'nap', prefix: [], scope: null },
    { type: 'language', subtag: 'naq', prefix: [], scope: null },
    { type: 'language', subtag: 'nar', prefix: [], scope: null },
    { type: 'language', subtag: 'nas', prefix: [], scope: null },
    { type: 'language', subtag: 'nat', prefix: [], scope: null },
    { type: 'language', subtag: 'naw', prefix: [], scope: null },
    { type: 'language', subtag: 'nax', prefix: [], scope: null },
    { type: 'language', subtag: 'nay', prefix: [], scope: null },
    { type: 'language', subtag: 'naz', prefix: [], scope: null },
    { type: 'language', subtag: 'nba', prefix: [], scope: null },
    { type: 'language', subtag: 'nbb', prefix: [], scope: null },
    { type: 'language', subtag: 'nbc', prefix: [], scope: null },
    { type: 'language', subtag: 'nbd', prefix: [], scope: null },
    { type: 'language', subtag: 'nbe', prefix: [], scope: null },
    { type: 'language', subtag: 'nbf', prefix: [], scope: null },
    { type: 'language', subtag: 'nbg', prefix: [], scope: null },
    { type: 'language', subtag: 'nbh', prefix: [], scope: null },
    { type: 'language', subtag: 'nbi', prefix: [], scope: null },
    { type: 'language', subtag: 'nbj', prefix: [], scope: null },
    { type: 'language', subtag: 'nbk', prefix: [], scope: null },
    { type: 'language', subtag: 'nbm', prefix: [], scope: null },
    { type: 'language', subtag: 'nbn', prefix: [], scope: null },
    { type: 'language', subtag: 'nbo', prefix: [], scope: null },
    { type: 'language', subtag: 'nbp', prefix: [], scope: null },
    { type: 'language', subtag: 'nbq', prefix: [], scope: null },
    { type: 'language', subtag: 'nbr', prefix: [], scope: null },
    { type: 'language', subtag: 'nbs', prefix: [], scope: null },
    { type: 'language', subtag: 'nbt', prefix: [], scope: null },
    { type: 'language', subtag: 'nbu', prefix: [], scope: null },
    { type: 'language', subtag: 'nbv', prefix: [], scope: null },
    { type: 'language', subtag: 'nbw', prefix: [], scope: null },
    { type: 'language', subtag: 'nbx', prefix: [], scope: null },
    { type: 'language', subtag: 'nby', prefix: [], scope: null },
    { type: 'language', subtag: 'nca', prefix: [], scope: null },
    { type: 'language', subtag: 'ncb', prefix: [], scope: null },
    { type: 'language', subtag: 'ncc', prefix: [], scope: null },
    { type: 'language', subtag: 'ncd', prefix: [], scope: null },
    { type: 'language', subtag: 'nce', prefix: [], scope: null },
    { type: 'language', subtag: 'ncf', prefix: [], scope: null },
    { type: 'language', subtag: 'ncg', prefix: [], scope: null },
    { type: 'language', subtag: 'nch', prefix: [], scope: null },
    { type: 'language', subtag: 'nci', prefix: [], scope: null },
    { type: 'language', subtag: 'ncj', prefix: [], scope: null },
    { type: 'language', subtag: 'nck', prefix: [], scope: null },
    { type: 'language', subtag: 'ncl', prefix: [], scope: null },
    { type: 'language', subtag: 'ncm', prefix: [], scope: null },
    { type: 'language', subtag: 'ncn', prefix: [], scope: null },
    { type: 'language', subtag: 'nco', prefix: [], scope: null },
    { type: 'language', subtag: 'ncp', prefix: [], scope: null },
    { type: 'language', subtag: 'ncq', prefix: [], scope: null },
    { type: 'language', subtag: 'ncr', prefix: [], scope: null },
    { type: 'language', subtag: 'ncs', prefix: [], scope: null },
    { type: 'language', subtag: 'nct', prefix: [], scope: null },
    { type: 'language', subtag: 'ncu', prefix: [], scope: null },
    { type: 'language', subtag: 'ncx', prefix: [], scope: null },
    { type: 'language', subtag: 'ncz', prefix: [], scope: null },
    { type: 'language', subtag: 'nda', prefix: [], scope: null },
    { type: 'language', subtag: 'ndb', prefix: [], scope: null },
    { type: 'language', subtag: 'ndc', prefix: [], scope: null },
    { type: 'language', subtag: 'ndd', prefix: [], scope: null },
    { type: 'language', subtag: 'ndf', prefix: [], scope: null },
    { type: 'language', subtag: 'ndg', prefix: [], scope: null },
    { type: 'language', subtag: 'ndh', prefix: [], scope: null },
    { type: 'language', subtag: 'ndi', prefix: [], scope: null },
    { type: 'language', subtag: 'ndj', prefix: [], scope: null },
    { type: 'language', subtag: 'ndk', prefix: [], scope: null },
    { type: 'language', subtag: 'ndl', prefix: [], scope: null },
    { type: 'language', subtag: 'ndm', prefix: [], scope: null },
    { type: 'language', subtag: 'ndn', prefix: [], scope: null },
    { type: 'language', subtag: 'ndp', prefix: [], scope: null },
    { type: 'language', subtag: 'ndq', prefix: [], scope: null },
    { type: 'language', subtag: 'ndr', prefix: [], scope: null },
    { type: 'language', subtag: 'nds', prefix: [], scope: null },
    { type: 'language', subtag: 'ndt', prefix: [], scope: null },
    { type: 'language', subtag: 'ndu', prefix: [], scope: null },
    { type: 'language', subtag: 'ndv', prefix: [], scope: null },
    { type: 'language', subtag: 'ndw', prefix: [], scope: null },
    { type: 'language', subtag: 'ndx', prefix: [], scope: null },
    { type: 'language', subtag: 'ndy', prefix: [], scope: null },
    { type: 'language', subtag: 'ndz', prefix: [], scope: null },
    { type: 'language', subtag: 'nea', prefix: [], scope: null },
    { type: 'language', subtag: 'neb', prefix: [], scope: null },
    { type: 'language', subtag: 'nec', prefix: [], scope: null },
    { type: 'language', subtag: 'ned', prefix: [], scope: null },
    { type: 'language', subtag: 'nee', prefix: [], scope: null },
    { type: 'language', subtag: 'nef', prefix: [], scope: null },
    { type: 'language', subtag: 'neg', prefix: [], scope: null },
    { type: 'language', subtag: 'neh', prefix: [], scope: null },
    { type: 'language', subtag: 'nei', prefix: [], scope: null },
    { type: 'language', subtag: 'nej', prefix: [], scope: null },
    { type: 'language', subtag: 'nek', prefix: [], scope: null },
    { type: 'language', subtag: 'nem', prefix: [], scope: null },
    { type: 'language', subtag: 'nen', prefix: [], scope: null },
    { type: 'language', subtag: 'neo', prefix: [], scope: null },
    { type: 'language', subtag: 'neq', prefix: [], scope: null },
    { type: 'language', subtag: 'ner', prefix: [], scope: null },
    { type: 'language', subtag: 'nes', prefix: [], scope: null },
    { type: 'language', subtag: 'net', prefix: [], scope: null },
    { type: 'language', subtag: 'neu', prefix: [], scope: null },
    { type: 'language', subtag: 'nev', prefix: [], scope: null },
    { type: 'language', subtag: 'new', prefix: [], scope: null },
    { type: 'language', subtag: 'nex', prefix: [], scope: null },
    { type: 'language', subtag: 'ney', prefix: [], scope: null },
    { type: 'language', subtag: 'nez', prefix: [], scope: null },
    { type: 'language', subtag: 'nfa', prefix: [], scope: null },
    { type: 'language', subtag: 'nfd', prefix: [], scope: null },
    { type: 'language', subtag: 'nfl', prefix: [], scope: null },
    { type: 'language', subtag: 'nfr', prefix: [], scope: null },
    { type: 'language', subtag: 'nfu', prefix: [], scope: null },
    { type: 'language', subtag: 'nga', prefix: [], scope: null },
    { type: 'language', subtag: 'ngb', prefix: [], scope: null },
    { type: 'language', subtag: 'ngc', prefix: [], scope: null },
    { type: 'language', subtag: 'ngd', prefix: [], scope: null },
    { type: 'language', subtag: 'nge', prefix: [], scope: null },
    { type: 'language', subtag: 'ngf', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ngg', prefix: [], scope: null },
    { type: 'language', subtag: 'ngh', prefix: [], scope: null },
    { type: 'language', subtag: 'ngi', prefix: [], scope: null },
    { type: 'language', subtag: 'ngj', prefix: [], scope: null },
    { type: 'language', subtag: 'ngk', prefix: [], scope: null },
    { type: 'language', subtag: 'ngl', prefix: [], scope: null },
    { type: 'language', subtag: 'ngm', prefix: [], scope: null },
    { type: 'language', subtag: 'ngn', prefix: [], scope: null },
    { type: 'language', subtag: 'ngo', prefix: [], scope: null },
    { type: 'language', subtag: 'ngp', prefix: [], scope: null },
    { type: 'language', subtag: 'ngq', prefix: [], scope: null },
    { type: 'language', subtag: 'ngr', prefix: [], scope: null },
    { type: 'language', subtag: 'ngs', prefix: [], scope: null },
    { type: 'language', subtag: 'ngt', prefix: [], scope: null },
    { type: 'language', subtag: 'ngu', prefix: [], scope: null },
    { type: 'language', subtag: 'ngv', prefix: [], scope: null },
    { type: 'language', subtag: 'ngw', prefix: [], scope: null },
    { type: 'language', subtag: 'ngx', prefix: [], scope: null },
    { type: 'language', subtag: 'ngy', prefix: [], scope: null },
    { type: 'language', subtag: 'ngz', prefix: [], scope: null },
    { type: 'language', subtag: 'nha', prefix: [], scope: null },
    { type: 'language', subtag: 'nhb', prefix: [], scope: null },
    { type: 'language', subtag: 'nhc', prefix: [], scope: null },
    { type: 'language', subtag: 'nhd', prefix: [], scope: null },
    { type: 'language', subtag: 'nhe', prefix: [], scope: null },
    { type: 'language', subtag: 'nhf', prefix: [], scope: null },
    { type: 'language', subtag: 'nhg', prefix: [], scope: null },
    { type: 'language', subtag: 'nhh', prefix: [], scope: null },
    { type: 'language', subtag: 'nhi', prefix: [], scope: null },
    { type: 'language', subtag: 'nhk', prefix: [], scope: null },
    { type: 'language', subtag: 'nhm', prefix: [], scope: null },
    { type: 'language', subtag: 'nhn', prefix: [], scope: null },
    { type: 'language', subtag: 'nho', prefix: [], scope: null },
    { type: 'language', subtag: 'nhp', prefix: [], scope: null },
    { type: 'language', subtag: 'nhq', prefix: [], scope: null },
    { type: 'language', subtag: 'nhr', prefix: [], scope: null },
    { type: 'language', subtag: 'nht', prefix: [], scope: null },
    { type: 'language', subtag: 'nhu', prefix: [], scope: null },
    { type: 'language', subtag: 'nhv', prefix: [], scope: null },
    { type: 'language', subtag: 'nhw', prefix: [], scope: null },
    { type: 'language', subtag: 'nhx', prefix: [], scope: null },
    { type: 'language', subtag: 'nhy', prefix: [], scope: null },
    { type: 'language', subtag: 'nhz', prefix: [], scope: null },
    { type: 'language', subtag: 'nia', prefix: [], scope: null },
    { type: 'language', subtag: 'nib', prefix: [], scope: null },
    { type: 'language', subtag: 'nic', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'nid', prefix: [], scope: null },
    { type: 'language', subtag: 'nie', prefix: [], scope: null },
    { type: 'language', subtag: 'nif', prefix: [], scope: null },
    { type: 'language', subtag: 'nig', prefix: [], scope: null },
    { type: 'language', subtag: 'nih', prefix: [], scope: null },
    { type: 'language', subtag: 'nii', prefix: [], scope: null },
    { type: 'language', subtag: 'nij', prefix: [], scope: null },
    { type: 'language', subtag: 'nik', prefix: [], scope: null },
    { type: 'language', subtag: 'nil', prefix: [], scope: null },
    { type: 'language', subtag: 'nim', prefix: [], scope: null },
    { type: 'language', subtag: 'nin', prefix: [], scope: null },
    { type: 'language', subtag: 'nio', prefix: [], scope: null },
    { type: 'language', subtag: 'niq', prefix: [], scope: null },
    { type: 'language', subtag: 'nir', prefix: [], scope: null },
    { type: 'language', subtag: 'nis', prefix: [], scope: null },
    { type: 'language', subtag: 'nit', prefix: [], scope: null },
    { type: 'language', subtag: 'niu', prefix: [], scope: null },
    { type: 'language', subtag: 'niv', prefix: [], scope: null },
    { type: 'language', subtag: 'niw', prefix: [], scope: null },
    { type: 'language', subtag: 'nix', prefix: [], scope: null },
    { type: 'language', subtag: 'niy', prefix: [], scope: null },
    { type: 'language', subtag: 'niz', prefix: [], scope: null },
    { type: 'language', subtag: 'nja', prefix: [], scope: null },
    { type: 'language', subtag: 'njb', prefix: [], scope: null },
    { type: 'language', subtag: 'njd', prefix: [], scope: null },
    { type: 'language', subtag: 'njh', prefix: [], scope: null },
    { type: 'language', subtag: 'nji', prefix: [], scope: null },
    { type: 'language', subtag: 'njj', prefix: [], scope: null },
    { type: 'language', subtag: 'njl', prefix: [], scope: null },
    { type: 'language', subtag: 'njm', prefix: [], scope: null },
    { type: 'language', subtag: 'njn', prefix: [], scope: null },
    { type: 'language', subtag: 'njo', prefix: [], scope: null },
    { type: 'language', subtag: 'njr', prefix: [], scope: null },
    { type: 'language', subtag: 'njs', prefix: [], scope: null },
    { type: 'language', subtag: 'njt', prefix: [], scope: null },
    { type: 'language', subtag: 'nju', prefix: [], scope: null },
    { type: 'language', subtag: 'njx', prefix: [], scope: null },
    { type: 'language', subtag: 'njy', prefix: [], scope: null },
    { type: 'language', subtag: 'njz', prefix: [], scope: null },
    { type: 'language', subtag: 'nka', prefix: [], scope: null },
    { type: 'language', subtag: 'nkb', prefix: [], scope: null },
    { type: 'language', subtag: 'nkc', prefix: [], scope: null },
    { type: 'language', subtag: 'nkd', prefix: [], scope: null },
    { type: 'language', subtag: 'nke', prefix: [], scope: null },
    { type: 'language', subtag: 'nkf', prefix: [], scope: null },
    { type: 'language', subtag: 'nkg', prefix: [], scope: null },
    { type: 'language', subtag: 'nkh', prefix: [], scope: null },
    { type: 'language', subtag: 'nki', prefix: [], scope: null },
    { type: 'language', subtag: 'nkj', prefix: [], scope: null },
    { type: 'language', subtag: 'nkk', prefix: [], scope: null },
    { type: 'language', subtag: 'nkm', prefix: [], scope: null },
    { type: 'language', subtag: 'nkn', prefix: [], scope: null },
    { type: 'language', subtag: 'nko', prefix: [], scope: null },
    { type: 'language', subtag: 'nkp', prefix: [], scope: null },
    { type: 'language', subtag: 'nkq', prefix: [], scope: null },
    { type: 'language', subtag: 'nkr', prefix: [], scope: null },
    { type: 'language', subtag: 'nks', prefix: [], scope: null },
    { type: 'language', subtag: 'nkt', prefix: [], scope: null },
    { type: 'language', subtag: 'nku', prefix: [], scope: null },
    { type: 'language', subtag: 'nkv', prefix: [], scope: null },
    { type: 'language', subtag: 'nkw', prefix: [], scope: null },
    { type: 'language', subtag: 'nkx', prefix: [], scope: null },
    { type: 'language', subtag: 'nkz', prefix: [], scope: null },
    { type: 'language', subtag: 'nla', prefix: [], scope: null },
    { type: 'language', subtag: 'nlc', prefix: [], scope: null },
    { type: 'language', subtag: 'nle', prefix: [], scope: null },
    { type: 'language', subtag: 'nlg', prefix: [], scope: null },
    { type: 'language', subtag: 'nli', prefix: [], scope: null },
    { type: 'language', subtag: 'nlj', prefix: [], scope: null },
    { type: 'language', subtag: 'nlk', prefix: [], scope: null },
    { type: 'language', subtag: 'nll', prefix: [], scope: null },
    { type: 'language', subtag: 'nlm', prefix: [], scope: null },
    { type: 'language', subtag: 'nln', prefix: [], scope: null },
    { type: 'language', subtag: 'nlo', prefix: [], scope: null },
    { type: 'language', subtag: 'nlq', prefix: [], scope: null },
    { type: 'language', subtag: 'nlr', prefix: [], scope: null },
    { type: 'language', subtag: 'nlu', prefix: [], scope: null },
    { type: 'language', subtag: 'nlv', prefix: [], scope: null },
    { type: 'language', subtag: 'nlw', prefix: [], scope: null },
    { type: 'language', subtag: 'nlx', prefix: [], scope: null },
    { type: 'language', subtag: 'nly', prefix: [], scope: null },
    { type: 'language', subtag: 'nlz', prefix: [], scope: null },
    { type: 'language', subtag: 'nma', prefix: [], scope: null },
    { type: 'language', subtag: 'nmb', prefix: [], scope: null },
    { type: 'language', subtag: 'nmc', prefix: [], scope: null },
    { type: 'language', subtag: 'nmd', prefix: [], scope: null },
    { type: 'language', subtag: 'nme', prefix: [], scope: null },
    { type: 'language', subtag: 'nmf', prefix: [], scope: null },
    { type: 'language', subtag: 'nmg', prefix: [], scope: null },
    { type: 'language', subtag: 'nmh', prefix: [], scope: null },
    { type: 'language', subtag: 'nmi', prefix: [], scope: null },
    { type: 'language', subtag: 'nmj', prefix: [], scope: null },
    { type: 'language', subtag: 'nmk', prefix: [], scope: null },
    { type: 'language', subtag: 'nml', prefix: [], scope: null },
    { type: 'language', subtag: 'nmm', prefix: [], scope: null },
    { type: 'language', subtag: 'nmn', prefix: [], scope: null },
    { type: 'language', subtag: 'nmo', prefix: [], scope: null },
    { type: 'language', subtag: 'nmp', prefix: [], scope: null },
    { type: 'language', subtag: 'nmq', prefix: [], scope: null },
    { type: 'language', subtag: 'nmr', prefix: [], scope: null },
    { type: 'language', subtag: 'nms', prefix: [], scope: null },
    { type: 'language', subtag: 'nmt', prefix: [], scope: null },
    { type: 'language', subtag: 'nmu', prefix: [], scope: null },
    { type: 'language', subtag: 'nmv', prefix: [], scope: null },
    { type: 'language', subtag: 'nmw', prefix: [], scope: null },
    { type: 'language', subtag: 'nmx', prefix: [], scope: null },
    { type: 'language', subtag: 'nmy', prefix: [], scope: null },
    { type: 'language', subtag: 'nmz', prefix: [], scope: null },
    { type: 'language', subtag: 'nna', prefix: [], scope: null },
    { type: 'language', subtag: 'nnb', prefix: [], scope: null },
    { type: 'language', subtag: 'nnc', prefix: [], scope: null },
    { type: 'language', subtag: 'nnd', prefix: [], scope: null },
    { type: 'language', subtag: 'nne', prefix: [], scope: null },
    { type: 'language', subtag: 'nnf', prefix: [], scope: null },
    { type: 'language', subtag: 'nng', prefix: [], scope: null },
    { type: 'language', subtag: 'nnh', prefix: [], scope: null },
    { type: 'language', subtag: 'nni', prefix: [], scope: null },
    { type: 'language', subtag: 'nnj', prefix: [], scope: null },
    { type: 'language', subtag: 'nnk', prefix: [], scope: null },
    { type: 'language', subtag: 'nnl', prefix: [], scope: null },
    { type: 'language', subtag: 'nnm', prefix: [], scope: null },
    { type: 'language', subtag: 'nnn', prefix: [], scope: null },
    { type: 'language', subtag: 'nnp', prefix: [], scope: null },
    { type: 'language', subtag: 'nnq', prefix: [], scope: null },
    { type: 'language', subtag: 'nnr', prefix: [], scope: null },
    { type: 'language', subtag: 'nns', prefix: [], scope: null },
    { type: 'language', subtag: 'nnt', prefix: [], scope: null },
    { type: 'language', subtag: 'nnu', prefix: [], scope: null },
    { type: 'language', subtag: 'nnv', prefix: [], scope: null },
    { type: 'language', subtag: 'nnw', prefix: [], scope: null },
    { type: 'language', subtag: 'nnx', prefix: [], scope: null },
    { type: 'language', subtag: 'nny', prefix: [], scope: null },
    { type: 'language', subtag: 'nnz', prefix: [], scope: null },
    { type: 'language', subtag: 'noa', prefix: [], scope: null },
    { type: 'language', subtag: 'noc', prefix: [], scope: null },
    { type: 'language', subtag: 'nod', prefix: [], scope: null },
    { type: 'language', subtag: 'noe', prefix: [], scope: null },
    { type: 'language', subtag: 'nof', prefix: [], scope: null },
    { type: 'language', subtag: 'nog', prefix: [], scope: null },
    { type: 'language', subtag: 'noh', prefix: [], scope: null },
    { type: 'language', subtag: 'noi', prefix: [], scope: null },
    { type: 'language', subtag: 'noj', prefix: [], scope: null },
    { type: 'language', subtag: 'nok', prefix: [], scope: null },
    { type: 'language', subtag: 'nol', prefix: [], scope: null },
    { type: 'language', subtag: 'nom', prefix: [], scope: null },
    { type: 'language', subtag: 'non', prefix: [], scope: null },
    { type: 'language', subtag: 'noo', prefix: [], scope: null },
    { type: 'language', subtag: 'nop', prefix: [], scope: null },
    { type: 'language', subtag: 'noq', prefix: [], scope: null },
    { type: 'language', subtag: 'nos', prefix: [], scope: null },
    { type: 'language', subtag: 'not', prefix: [], scope: null },
    { type: 'language', subtag: 'nou', prefix: [], scope: null },
    { type: 'language', subtag: 'nov', prefix: [], scope: null },
    { type: 'language', subtag: 'now', prefix: [], scope: null },
    { type: 'language', subtag: 'noy', prefix: [], scope: null },
    { type: 'language', subtag: 'noz', prefix: [], scope: null },
    { type: 'language', subtag: 'npa', prefix: [], scope: null },
    { type: 'language', subtag: 'npb', prefix: [], scope: null },
    { type: 'language', subtag: 'npg', prefix: [], scope: null },
    { type: 'language', subtag: 'nph', prefix: [], scope: null },
    { type: 'language', subtag: 'npi', prefix: [], scope: null },
    { type: 'language', subtag: 'npl', prefix: [], scope: null },
    { type: 'language', subtag: 'npn', prefix: [], scope: null },
    { type: 'language', subtag: 'npo', prefix: [], scope: null },
    { type: 'language', subtag: 'nps', prefix: [], scope: null },
    { type: 'language', subtag: 'npu', prefix: [], scope: null },
    { type: 'language', subtag: 'npx', prefix: [], scope: null },
    { type: 'language', subtag: 'npy', prefix: [], scope: null },
    { type: 'language', subtag: 'nqg', prefix: [], scope: null },
    { type: 'language', subtag: 'nqk', prefix: [], scope: null },
    { type: 'language', subtag: 'nql', prefix: [], scope: null },
    { type: 'language', subtag: 'nqm', prefix: [], scope: null },
    { type: 'language', subtag: 'nqn', prefix: [], scope: null },
    { type: 'language', subtag: 'nqo', prefix: [], scope: null },
    { type: 'language', subtag: 'nqq', prefix: [], scope: null },
    { type: 'language', subtag: 'nqt', prefix: [], scope: null },
    { type: 'language', subtag: 'nqy', prefix: [], scope: null },
    { type: 'language', subtag: 'nra', prefix: [], scope: null },
    { type: 'language', subtag: 'nrb', prefix: [], scope: null },
    { type: 'language', subtag: 'nrc', prefix: [], scope: null },
    { type: 'language', subtag: 'nre', prefix: [], scope: null },
    { type: 'language', subtag: 'nrf', prefix: [], scope: null },
    { type: 'language', subtag: 'nrg', prefix: [], scope: null },
    { type: 'language', subtag: 'nri', prefix: [], scope: null },
    { type: 'language', subtag: 'nrk', prefix: [], scope: null },
    { type: 'language', subtag: 'nrl', prefix: [], scope: null },
    { type: 'language', subtag: 'nrm', prefix: [], scope: null },
    { type: 'language', subtag: 'nrn', prefix: [], scope: null },
    { type: 'language', subtag: 'nrp', prefix: [], scope: null },
    { type: 'language', subtag: 'nrr', prefix: [], scope: null },
    { type: 'language', subtag: 'nrt', prefix: [], scope: null },
    { type: 'language', subtag: 'nru', prefix: [], scope: null },
    { type: 'language', subtag: 'nrx', prefix: [], scope: null },
    { type: 'language', subtag: 'nrz', prefix: [], scope: null },
    { type: 'language', subtag: 'nsa', prefix: [], scope: null },
    { type: 'language', subtag: 'nsb', prefix: [], scope: null },
    { type: 'language', subtag: 'nsc', prefix: [], scope: null },
    { type: 'language', subtag: 'nsd', prefix: [], scope: null },
    { type: 'language', subtag: 'nse', prefix: [], scope: null },
    { type: 'language', subtag: 'nsf', prefix: [], scope: null },
    { type: 'language', subtag: 'nsg', prefix: [], scope: null },
    { type: 'language', subtag: 'nsh', prefix: [], scope: null },
    { type: 'language', subtag: 'nsi', prefix: [], scope: null },
    { type: 'language', subtag: 'nsk', prefix: [], scope: null },
    { type: 'language', subtag: 'nsl', prefix: [], scope: null },
    { type: 'language', subtag: 'nsm', prefix: [], scope: null },
    { type: 'language', subtag: 'nsn', prefix: [], scope: null },
    { type: 'language', subtag: 'nso', prefix: [], scope: null },
    { type: 'language', subtag: 'nsp', prefix: [], scope: null },
    { type: 'language', subtag: 'nsq', prefix: [], scope: null },
    { type: 'language', subtag: 'nsr', prefix: [], scope: null },
    { type: 'language', subtag: 'nss', prefix: [], scope: null },
    { type: 'language', subtag: 'nst', prefix: [], scope: null },
    { type: 'language', subtag: 'nsu', prefix: [], scope: null },
    { type: 'language', subtag: 'nsv', prefix: [], scope: null },
    { type: 'language', subtag: 'nsw', prefix: [], scope: null },
    { type: 'language', subtag: 'nsx', prefix: [], scope: null },
    { type: 'language', subtag: 'nsy', prefix: [], scope: null },
    { type: 'language', subtag: 'nsz', prefix: [], scope: null },
    { type: 'language', subtag: 'ntd', prefix: [], scope: null },
    { type: 'language', subtag: 'nte', prefix: [], scope: null },
    { type: 'language', subtag: 'ntg', prefix: [], scope: null },
    { type: 'language', subtag: 'nti', prefix: [], scope: null },
    { type: 'language', subtag: 'ntj', prefix: [], scope: null },
    { type: 'language', subtag: 'ntk', prefix: [], scope: null },
    { type: 'language', subtag: 'ntm', prefix: [], scope: null },
    { type: 'language', subtag: 'nto', prefix: [], scope: null },
    { type: 'language', subtag: 'ntp', prefix: [], scope: null },
    { type: 'language', subtag: 'ntr', prefix: [], scope: null },
    { type: 'language', subtag: 'nts', prefix: [], scope: null },
    { type: 'language', subtag: 'ntu', prefix: [], scope: null },
    { type: 'language', subtag: 'ntw', prefix: [], scope: null },
    { type: 'language', subtag: 'ntx', prefix: [], scope: null },
    { type: 'language', subtag: 'nty', prefix: [], scope: null },
    { type: 'language', subtag: 'ntz', prefix: [], scope: null },
    { type: 'language', subtag: 'nua', prefix: [], scope: null },
    { type: 'language', subtag: 'nub', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'nuc', prefix: [], scope: null },
    { type: 'language', subtag: 'nud', prefix: [], scope: null },
    { type: 'language', subtag: 'nue', prefix: [], scope: null },
    { type: 'language', subtag: 'nuf', prefix: [], scope: null },
    { type: 'language', subtag: 'nug', prefix: [], scope: null },
    { type: 'language', subtag: 'nuh', prefix: [], scope: null },
    { type: 'language', subtag: 'nui', prefix: [], scope: null },
    { type: 'language', subtag: 'nuj', prefix: [], scope: null },
    { type: 'language', subtag: 'nuk', prefix: [], scope: null },
    { type: 'language', subtag: 'nul', prefix: [], scope: null },
    { type: 'language', subtag: 'num', prefix: [], scope: null },
    { type: 'language', subtag: 'nun', prefix: [], scope: null },
    { type: 'language', subtag: 'nuo', prefix: [], scope: null },
    { type: 'language', subtag: 'nup', prefix: [], scope: null },
    { type: 'language', subtag: 'nuq', prefix: [], scope: null },
    { type: 'language', subtag: 'nur', prefix: [], scope: null },
    { type: 'language', subtag: 'nus', prefix: [], scope: null },
    { type: 'language', subtag: 'nut', prefix: [], scope: null },
    { type: 'language', subtag: 'nuu', prefix: [], scope: null },
    { type: 'language', subtag: 'nuv', prefix: [], scope: null },
    { type: 'language', subtag: 'nuw', prefix: [], scope: null },
    { type: 'language', subtag: 'nux', prefix: [], scope: null },
    { type: 'language', subtag: 'nuy', prefix: [], scope: null },
    { type: 'language', subtag: 'nuz', prefix: [], scope: null },
    { type: 'language', subtag: 'nvh', prefix: [], scope: null },
    { type: 'language', subtag: 'nvm', prefix: [], scope: null },
    { type: 'language', subtag: 'nvo', prefix: [], scope: null },
    { type: 'language', subtag: 'nwa', prefix: [], scope: null },
    { type: 'language', subtag: 'nwb', prefix: [], scope: null },
    { type: 'language', subtag: 'nwc', prefix: [], scope: null },
    { type: 'language', subtag: 'nwe', prefix: [], scope: null },
    { type: 'language', subtag: 'nwg', prefix: [], scope: null },
    { type: 'language', subtag: 'nwi', prefix: [], scope: null },
    { type: 'language', subtag: 'nwm', prefix: [], scope: null },
    { type: 'language', subtag: 'nwo', prefix: [], scope: null },
    { type: 'language', subtag: 'nwr', prefix: [], scope: null },
    { type: 'language', subtag: 'nww', prefix: [], scope: null },
    { type: 'language', subtag: 'nwx', prefix: [], scope: null },
    { type: 'language', subtag: 'nwy', prefix: [], scope: null },
    { type: 'language', subtag: 'nxa', prefix: [], scope: null },
    { type: 'language', subtag: 'nxd', prefix: [], scope: null },
    { type: 'language', subtag: 'nxe', prefix: [], scope: null },
    { type: 'language', subtag: 'nxg', prefix: [], scope: null },
    { type: 'language', subtag: 'nxi', prefix: [], scope: null },
    { type: 'language', subtag: 'nxk', prefix: [], scope: null },
    { type: 'language', subtag: 'nxl', prefix: [], scope: null },
    { type: 'language', subtag: 'nxm', prefix: [], scope: null },
    { type: 'language', subtag: 'nxn', prefix: [], scope: null },
    { type: 'language', subtag: 'nxo', prefix: [], scope: null },
    { type: 'language', subtag: 'nxq', prefix: [], scope: null },
    { type: 'language', subtag: 'nxr', prefix: [], scope: null },
    { type: 'language', subtag: 'nxu', prefix: [], scope: null },
    { type: 'language', subtag: 'nxx', prefix: [], scope: null },
    { type: 'language', subtag: 'nyb', prefix: [], scope: null },
    { type: 'language', subtag: 'nyc', prefix: [], scope: null },
    { type: 'language', subtag: 'nyd', prefix: [], scope: null },
    { type: 'language', subtag: 'nye', prefix: [], scope: null },
    { type: 'language', subtag: 'nyf', prefix: [], scope: null },
    { type: 'language', subtag: 'nyg', prefix: [], scope: null },
    { type: 'language', subtag: 'nyh', prefix: [], scope: null },
    { type: 'language', subtag: 'nyi', prefix: [], scope: null },
    { type: 'language', subtag: 'nyj', prefix: [], scope: null },
    { type: 'language', subtag: 'nyk', prefix: [], scope: null },
    { type: 'language', subtag: 'nyl', prefix: [], scope: null },
    { type: 'language', subtag: 'nym', prefix: [], scope: null },
    { type: 'language', subtag: 'nyn', prefix: [], scope: null },
    { type: 'language', subtag: 'nyo', prefix: [], scope: null },
    { type: 'language', subtag: 'nyp', prefix: [], scope: null },
    { type: 'language', subtag: 'nyq', prefix: [], scope: null },
    { type: 'language', subtag: 'nyr', prefix: [], scope: null },
    { type: 'language', subtag: 'nys', prefix: [], scope: null },
    { type: 'language', subtag: 'nyt', prefix: [], scope: null },
    { type: 'language', subtag: 'nyu', prefix: [], scope: null },
    { type: 'language', subtag: 'nyv', prefix: [], scope: null },
    { type: 'language', subtag: 'nyw', prefix: [], scope: null },
    { type: 'language', subtag: 'nyx', prefix: [], scope: null },
    { type: 'language', subtag: 'nyy', prefix: [], scope: null },
    { type: 'language', subtag: 'nza', prefix: [], scope: null },
    { type: 'language', subtag: 'nzb', prefix: [], scope: null },
    { type: 'language', subtag: 'nzd', prefix: [], scope: null },
    { type: 'language', subtag: 'nzi', prefix: [], scope: null },
    { type: 'language', subtag: 'nzk', prefix: [], scope: null },
    { type: 'language', subtag: 'nzm', prefix: [], scope: null },
    { type: 'language', subtag: 'nzs', prefix: [], scope: null },
    { type: 'language', subtag: 'nzu', prefix: [], scope: null },
    { type: 'language', subtag: 'nzy', prefix: [], scope: null },
    { type: 'language', subtag: 'nzz', prefix: [], scope: null },
    { type: 'language', subtag: 'oaa', prefix: [], scope: null },
    { type: 'language', subtag: 'oac', prefix: [], scope: null },
    { type: 'language', subtag: 'oar', prefix: [], scope: null },
    { type: 'language', subtag: 'oav', prefix: [], scope: null },
    { type: 'language', subtag: 'obi', prefix: [], scope: null },
    { type: 'language', subtag: 'obk', prefix: [], scope: null },
    { type: 'language', subtag: 'obl', prefix: [], scope: null },
    { type: 'language', subtag: 'obm', prefix: [], scope: null },
    { type: 'language', subtag: 'obo', prefix: [], scope: null },
    { type: 'language', subtag: 'obr', prefix: [], scope: null },
    { type: 'language', subtag: 'obt', prefix: [], scope: null },
    { type: 'language', subtag: 'obu', prefix: [], scope: null },
    { type: 'language', subtag: 'oca', prefix: [], scope: null },
    { type: 'language', subtag: 'och', prefix: [], scope: null },
    { type: 'language', subtag: 'ocm', prefix: [], scope: null },
    { type: 'language', subtag: 'oco', prefix: [], scope: null },
    { type: 'language', subtag: 'ocu', prefix: [], scope: null },
    { type: 'language', subtag: 'oda', prefix: [], scope: null },
    { type: 'language', subtag: 'odk', prefix: [], scope: null },
    { type: 'language', subtag: 'odt', prefix: [], scope: null },
    { type: 'language', subtag: 'odu', prefix: [], scope: null },
    { type: 'language', subtag: 'ofo', prefix: [], scope: null },
    { type: 'language', subtag: 'ofs', prefix: [], scope: null },
    { type: 'language', subtag: 'ofu', prefix: [], scope: null },
    { type: 'language', subtag: 'ogb', prefix: [], scope: null },
    { type: 'language', subtag: 'ogc', prefix: [], scope: null },
    { type: 'language', subtag: 'oge', prefix: [], scope: null },
    { type: 'language', subtag: 'ogg', prefix: [], scope: null },
    { type: 'language', subtag: 'ogo', prefix: [], scope: null },
    { type: 'language', subtag: 'ogu', prefix: [], scope: null },
    { type: 'language', subtag: 'oht', prefix: [], scope: null },
    { type: 'language', subtag: 'ohu', prefix: [], scope: null },
    { type: 'language', subtag: 'oia', prefix: [], scope: null },
    { type: 'language', subtag: 'oie', prefix: [], scope: null },
    { type: 'language', subtag: 'oin', prefix: [], scope: null },
    { type: 'language', subtag: 'ojb', prefix: [], scope: null },
    { type: 'language', subtag: 'ojc', prefix: [], scope: null },
    { type: 'language', subtag: 'ojg', prefix: [], scope: null },
    { type: 'language', subtag: 'ojp', prefix: [], scope: null },
    { type: 'language', subtag: 'ojs', prefix: [], scope: null },
    { type: 'language', subtag: 'ojv', prefix: [], scope: null },
    { type: 'language', subtag: 'ojw', prefix: [], scope: null },
    { type: 'language', subtag: 'oka', prefix: [], scope: null },
    { type: 'language', subtag: 'okb', prefix: [], scope: null },
    { type: 'language', subtag: 'okc', prefix: [], scope: null },
    { type: 'language', subtag: 'okd', prefix: [], scope: null },
    { type: 'language', subtag: 'oke', prefix: [], scope: null },
    { type: 'language', subtag: 'okg', prefix: [], scope: null },
    { type: 'language', subtag: 'okh', prefix: [], scope: null },
    { type: 'language', subtag: 'oki', prefix: [], scope: null },
    { type: 'language', subtag: 'okj', prefix: [], scope: null },
    { type: 'language', subtag: 'okk', prefix: [], scope: null },
    { type: 'language', subtag: 'okl', prefix: [], scope: null },
    { type: 'language', subtag: 'okm', prefix: [], scope: null },
    { type: 'language', subtag: 'okn', prefix: [], scope: null },
    { type: 'language', subtag: 'oko', prefix: [], scope: null },
    { type: 'language', subtag: 'okr', prefix: [], scope: null },
    { type: 'language', subtag: 'oks', prefix: [], scope: null },
    { type: 'language', subtag: 'oku', prefix: [], scope: null },
    { type: 'language', subtag: 'okv', prefix: [], scope: null },
    { type: 'language', subtag: 'okx', prefix: [], scope: null },
    { type: 'language', subtag: 'okz', prefix: [], scope: null },
    { type: 'language', subtag: 'ola', prefix: [], scope: null },
    { type: 'language', subtag: 'old', prefix: [], scope: null },
    { type: 'language', subtag: 'ole', prefix: [], scope: null },
    { type: 'language', subtag: 'olk', prefix: [], scope: null },
    { type: 'language', subtag: 'olm', prefix: [], scope: null },
    { type: 'language', subtag: 'olo', prefix: [], scope: null },
    { type: 'language', subtag: 'olr', prefix: [], scope: null },
    { type: 'language', subtag: 'olt', prefix: [], scope: null },
    { type: 'language', subtag: 'olu', prefix: [], scope: null },
    { type: 'language', subtag: 'oma', prefix: [], scope: null },
    { type: 'language', subtag: 'omb', prefix: [], scope: null },
    { type: 'language', subtag: 'omc', prefix: [], scope: null },
    { type: 'language', subtag: 'ome', prefix: [], scope: null },
    { type: 'language', subtag: 'omg', prefix: [], scope: null },
    { type: 'language', subtag: 'omi', prefix: [], scope: null },
    { type: 'language', subtag: 'omk', prefix: [], scope: null },
    { type: 'language', subtag: 'oml', prefix: [], scope: null },
    { type: 'language', subtag: 'omn', prefix: [], scope: null },
    { type: 'language', subtag: 'omo', prefix: [], scope: null },
    { type: 'language', subtag: 'omp', prefix: [], scope: null },
    { type: 'language', subtag: 'omq', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'omr', prefix: [], scope: null },
    { type: 'language', subtag: 'omt', prefix: [], scope: null },
    { type: 'language', subtag: 'omu', prefix: [], scope: null },
    { type: 'language', subtag: 'omv', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'omw', prefix: [], scope: null },
    { type: 'language', subtag: 'omx', prefix: [], scope: null },
    { type: 'language', subtag: 'omy', prefix: [], scope: null },
    { type: 'language', subtag: 'ona', prefix: [], scope: null },
    { type: 'language', subtag: 'onb', prefix: [], scope: null },
    { type: 'language', subtag: 'one', prefix: [], scope: null },
    { type: 'language', subtag: 'ong', prefix: [], scope: null },
    { type: 'language', subtag: 'oni', prefix: [], scope: null },
    { type: 'language', subtag: 'onj', prefix: [], scope: null },
    { type: 'language', subtag: 'onk', prefix: [], scope: null },
    { type: 'language', subtag: 'onn', prefix: [], scope: null },
    { type: 'language', subtag: 'ono', prefix: [], scope: null },
    { type: 'language', subtag: 'onp', prefix: [], scope: null },
    { type: 'language', subtag: 'onr', prefix: [], scope: null },
    { type: 'language', subtag: 'ons', prefix: [], scope: null },
    { type: 'language', subtag: 'ont', prefix: [], scope: null },
    { type: 'language', subtag: 'onu', prefix: [], scope: null },
    { type: 'language', subtag: 'onw', prefix: [], scope: null },
    { type: 'language', subtag: 'onx', prefix: [], scope: null },
    { type: 'language', subtag: 'ood', prefix: [], scope: null },
    { type: 'language', subtag: 'oog', prefix: [], scope: null },
    { type: 'language', subtag: 'oon', prefix: [], scope: null },
    { type: 'language', subtag: 'oor', prefix: [], scope: null },
    { type: 'language', subtag: 'oos', prefix: [], scope: null },
    { type: 'language', subtag: 'opa', prefix: [], scope: null },
    { type: 'language', subtag: 'opk', prefix: [], scope: null },
    { type: 'language', subtag: 'opm', prefix: [], scope: null },
    { type: 'language', subtag: 'opo', prefix: [], scope: null },
    { type: 'language', subtag: 'opt', prefix: [], scope: null },
    { type: 'language', subtag: 'opy', prefix: [], scope: null },
    { type: 'language', subtag: 'ora', prefix: [], scope: null },
    { type: 'language', subtag: 'orc', prefix: [], scope: null },
    { type: 'language', subtag: 'ore', prefix: [], scope: null },
    { type: 'language', subtag: 'org', prefix: [], scope: null },
    { type: 'language', subtag: 'orh', prefix: [], scope: null },
    { type: 'language', subtag: 'orn', prefix: [], scope: null },
    { type: 'language', subtag: 'oro', prefix: [], scope: null },
    { type: 'language', subtag: 'orr', prefix: [], scope: null },
    { type: 'language', subtag: 'ors', prefix: [], scope: null },
    { type: 'language', subtag: 'ort', prefix: [], scope: null },
    { type: 'language', subtag: 'oru', prefix: [], scope: null },
    { type: 'language', subtag: 'orv', prefix: [], scope: null },
    { type: 'language', subtag: 'orw', prefix: [], scope: null },
    { type: 'language', subtag: 'orx', prefix: [], scope: null },
    { type: 'language', subtag: 'ory', prefix: [], scope: null },
    { type: 'language', subtag: 'orz', prefix: [], scope: null },
    { type: 'language', subtag: 'osa', prefix: [], scope: null },
    { type: 'language', subtag: 'osc', prefix: [], scope: null },
    { type: 'language', subtag: 'osi', prefix: [], scope: null },
    { type: 'language', subtag: 'osn', prefix: [], scope: null },
    { type: 'language', subtag: 'oso', prefix: [], scope: null },
    { type: 'language', subtag: 'osp', prefix: [], scope: null },
    { type: 'language', subtag: 'ost', prefix: [], scope: null },
    { type: 'language', subtag: 'osu', prefix: [], scope: null },
    { type: 'language', subtag: 'osx', prefix: [], scope: null },
    { type: 'language', subtag: 'ota', prefix: [], scope: null },
    { type: 'language', subtag: 'otb', prefix: [], scope: null },
    { type: 'language', subtag: 'otd', prefix: [], scope: null },
    { type: 'language', subtag: 'ote', prefix: [], scope: null },
    { type: 'language', subtag: 'oti', prefix: [], scope: null },
    { type: 'language', subtag: 'otk', prefix: [], scope: null },
    { type: 'language', subtag: 'otl', prefix: [], scope: null },
    { type: 'language', subtag: 'otm', prefix: [], scope: null },
    { type: 'language', subtag: 'otn', prefix: [], scope: null },
    { type: 'language', subtag: 'oto', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'otq', prefix: [], scope: null },
    { type: 'language', subtag: 'otr', prefix: [], scope: null },
    { type: 'language', subtag: 'ots', prefix: [], scope: null },
    { type: 'language', subtag: 'ott', prefix: [], scope: null },
    { type: 'language', subtag: 'otu', prefix: [], scope: null },
    { type: 'language', subtag: 'otw', prefix: [], scope: null },
    { type: 'language', subtag: 'otx', prefix: [], scope: null },
    { type: 'language', subtag: 'oty', prefix: [], scope: null },
    { type: 'language', subtag: 'otz', prefix: [], scope: null },
    { type: 'language', subtag: 'oua', prefix: [], scope: null },
    { type: 'language', subtag: 'oub', prefix: [], scope: null },
    { type: 'language', subtag: 'oue', prefix: [], scope: null },
    { type: 'language', subtag: 'oui', prefix: [], scope: null },
    { type: 'language', subtag: 'oum', prefix: [], scope: null },
    { type: 'language', subtag: 'oun', prefix: [], scope: null },
    { type: 'language', subtag: 'ovd', prefix: [], scope: null },
    { type: 'language', subtag: 'owi', prefix: [], scope: null },
    { type: 'language', subtag: 'owl', prefix: [], scope: null },
    { type: 'language', subtag: 'oyb', prefix: [], scope: null },
    { type: 'language', subtag: 'oyd', prefix: [], scope: null },
    { type: 'language', subtag: 'oym', prefix: [], scope: null },
    { type: 'language', subtag: 'oyy', prefix: [], scope: null },
    { type: 'language', subtag: 'ozm', prefix: [], scope: null },
    { type: 'language', subtag: 'paa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'pab', prefix: [], scope: null },
    { type: 'language', subtag: 'pac', prefix: [], scope: null },
    { type: 'language', subtag: 'pad', prefix: [], scope: null },
    { type: 'language', subtag: 'pae', prefix: [], scope: null },
    { type: 'language', subtag: 'paf', prefix: [], scope: null },
    { type: 'language', subtag: 'pag', prefix: [], scope: null },
    { type: 'language', subtag: 'pah', prefix: [], scope: null },
    { type: 'language', subtag: 'pai', prefix: [], scope: null },
    { type: 'language', subtag: 'pak', prefix: [], scope: null },
    { type: 'language', subtag: 'pal', prefix: [], scope: null },
    { type: 'language', subtag: 'pam', prefix: [], scope: null },
    { type: 'language', subtag: 'pao', prefix: [], scope: null },
    { type: 'language', subtag: 'pap', prefix: [], scope: null },
    { type: 'language', subtag: 'paq', prefix: [], scope: null },
    { type: 'language', subtag: 'par', prefix: [], scope: null },
    { type: 'language', subtag: 'pas', prefix: [], scope: null },
    { type: 'language', subtag: 'pat', prefix: [], scope: null },
    { type: 'language', subtag: 'pau', prefix: [], scope: null },
    { type: 'language', subtag: 'pav', prefix: [], scope: null },
    { type: 'language', subtag: 'paw', prefix: [], scope: null },
    { type: 'language', subtag: 'pax', prefix: [], scope: null },
    { type: 'language', subtag: 'pay', prefix: [], scope: null },
    { type: 'language', subtag: 'paz', prefix: [], scope: null },
    { type: 'language', subtag: 'pbb', prefix: [], scope: null },
    { type: 'language', subtag: 'pbc', prefix: [], scope: null },
    { type: 'language', subtag: 'pbe', prefix: [], scope: null },
    { type: 'language', subtag: 'pbf', prefix: [], scope: null },
    { type: 'language', subtag: 'pbg', prefix: [], scope: null },
    { type: 'language', subtag: 'pbh', prefix: [], scope: null },
    { type: 'language', subtag: 'pbi', prefix: [], scope: null },
    { type: 'language', subtag: 'pbl', prefix: [], scope: null },
    { type: 'language', subtag: 'pbm', prefix: [], scope: null },
    { type: 'language', subtag: 'pbn', prefix: [], scope: null },
    { type: 'language', subtag: 'pbo', prefix: [], scope: null },
    { type: 'language', subtag: 'pbp', prefix: [], scope: null },
    { type: 'language', subtag: 'pbr', prefix: [], scope: null },
    { type: 'language', subtag: 'pbs', prefix: [], scope: null },
    { type: 'language', subtag: 'pbt', prefix: [], scope: null },
    { type: 'language', subtag: 'pbu', prefix: [], scope: null },
    { type: 'language', subtag: 'pbv', prefix: [], scope: null },
    { type: 'language', subtag: 'pby', prefix: [], scope: null },
    { type: 'language', subtag: 'pbz', prefix: [], scope: null },
    { type: 'language', subtag: 'pca', prefix: [], scope: null },
    { type: 'language', subtag: 'pcb', prefix: [], scope: null },
    { type: 'language', subtag: 'pcc', prefix: [], scope: null },
    { type: 'language', subtag: 'pcd', prefix: [], scope: null },
    { type: 'language', subtag: 'pce', prefix: [], scope: null },
    { type: 'language', subtag: 'pcf', prefix: [], scope: null },
    { type: 'language', subtag: 'pcg', prefix: [], scope: null },
    { type: 'language', subtag: 'pch', prefix: [], scope: null },
    { type: 'language', subtag: 'pci', prefix: [], scope: null },
    { type: 'language', subtag: 'pcj', prefix: [], scope: null },
    { type: 'language', subtag: 'pck', prefix: [], scope: null },
    { type: 'language', subtag: 'pcl', prefix: [], scope: null },
    { type: 'language', subtag: 'pcm', prefix: [], scope: null },
    { type: 'language', subtag: 'pcn', prefix: [], scope: null },
    { type: 'language', subtag: 'pcp', prefix: [], scope: null },
    { type: 'language', subtag: 'pcr', prefix: [], scope: null },
    { type: 'language', subtag: 'pcw', prefix: [], scope: null },
    { type: 'language', subtag: 'pda', prefix: [], scope: null },
    { type: 'language', subtag: 'pdc', prefix: [], scope: null },
    { type: 'language', subtag: 'pdi', prefix: [], scope: null },
    { type: 'language', subtag: 'pdn', prefix: [], scope: null },
    { type: 'language', subtag: 'pdo', prefix: [], scope: null },
    { type: 'language', subtag: 'pdt', prefix: [], scope: null },
    { type: 'language', subtag: 'pdu', prefix: [], scope: null },
    { type: 'language', subtag: 'pea', prefix: [], scope: null },
    { type: 'language', subtag: 'peb', prefix: [], scope: null },
    { type: 'language', subtag: 'ped', prefix: [], scope: null },
    { type: 'language', subtag: 'pee', prefix: [], scope: null },
    { type: 'language', subtag: 'pef', prefix: [], scope: null },
    { type: 'language', subtag: 'peg', prefix: [], scope: null },
    { type: 'language', subtag: 'peh', prefix: [], scope: null },
    { type: 'language', subtag: 'pei', prefix: [], scope: null },
    { type: 'language', subtag: 'pej', prefix: [], scope: null },
    { type: 'language', subtag: 'pek', prefix: [], scope: null },
    { type: 'language', subtag: 'pel', prefix: [], scope: null },
    { type: 'language', subtag: 'pem', prefix: [], scope: null },
    { type: 'language', subtag: 'peo', prefix: [], scope: null },
    { type: 'language', subtag: 'pep', prefix: [], scope: null },
    { type: 'language', subtag: 'peq', prefix: [], scope: null },
    { type: 'language', subtag: 'pes', prefix: [], scope: null },
    { type: 'language', subtag: 'pev', prefix: [], scope: null },
    { type: 'language', subtag: 'pex', prefix: [], scope: null },
    { type: 'language', subtag: 'pey', prefix: [], scope: null },
    { type: 'language', subtag: 'pez', prefix: [], scope: null },
    { type: 'language', subtag: 'pfa', prefix: [], scope: null },
    { type: 'language', subtag: 'pfe', prefix: [], scope: null },
    { type: 'language', subtag: 'pfl', prefix: [], scope: null },
    { type: 'language', subtag: 'pga', prefix: [], scope: null },
    { type: 'language', subtag: 'pgd', prefix: [], scope: null },
    { type: 'language', subtag: 'pgg', prefix: [], scope: null },
    { type: 'language', subtag: 'pgi', prefix: [], scope: null },
    { type: 'language', subtag: 'pgk', prefix: [], scope: null },
    { type: 'language', subtag: 'pgl', prefix: [], scope: null },
    { type: 'language', subtag: 'pgn', prefix: [], scope: null },
    { type: 'language', subtag: 'pgs', prefix: [], scope: null },
    { type: 'language', subtag: 'pgu', prefix: [], scope: null },
    { type: 'language', subtag: 'pgy', prefix: [], scope: null },
    { type: 'language', subtag: 'pgz', prefix: [], scope: null },
    { type: 'language', subtag: 'pha', prefix: [], scope: null },
    { type: 'language', subtag: 'phd', prefix: [], scope: null },
    { type: 'language', subtag: 'phg', prefix: [], scope: null },
    { type: 'language', subtag: 'phh', prefix: [], scope: null },
    { type: 'language', subtag: 'phi', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'phj', prefix: [], scope: null },
    { type: 'language', subtag: 'phk', prefix: [], scope: null },
    { type: 'language', subtag: 'phl', prefix: [], scope: null },
    { type: 'language', subtag: 'phm', prefix: [], scope: null },
    { type: 'language', subtag: 'phn', prefix: [], scope: null },
    { type: 'language', subtag: 'pho', prefix: [], scope: null },
    { type: 'language', subtag: 'phq', prefix: [], scope: null },
    { type: 'language', subtag: 'phr', prefix: [], scope: null },
    { type: 'language', subtag: 'pht', prefix: [], scope: null },
    { type: 'language', subtag: 'phu', prefix: [], scope: null },
    { type: 'language', subtag: 'phv', prefix: [], scope: null },
    { type: 'language', subtag: 'phw', prefix: [], scope: null },
    { type: 'language', subtag: 'pia', prefix: [], scope: null },
    { type: 'language', subtag: 'pib', prefix: [], scope: null },
    { type: 'language', subtag: 'pic', prefix: [], scope: null },
    { type: 'language', subtag: 'pid', prefix: [], scope: null },
    { type: 'language', subtag: 'pie', prefix: [], scope: null },
    { type: 'language', subtag: 'pif', prefix: [], scope: null },
    { type: 'language', subtag: 'pig', prefix: [], scope: null },
    { type: 'language', subtag: 'pih', prefix: [], scope: null },
    { type: 'language', subtag: 'pii', prefix: [], scope: null },
    { type: 'language', subtag: 'pij', prefix: [], scope: null },
    { type: 'language', subtag: 'pil', prefix: [], scope: null },
    { type: 'language', subtag: 'pim', prefix: [], scope: null },
    { type: 'language', subtag: 'pin', prefix: [], scope: null },
    { type: 'language', subtag: 'pio', prefix: [], scope: null },
    { type: 'language', subtag: 'pip', prefix: [], scope: null },
    { type: 'language', subtag: 'pir', prefix: [], scope: null },
    { type: 'language', subtag: 'pis', prefix: [], scope: null },
    { type: 'language', subtag: 'pit', prefix: [], scope: null },
    { type: 'language', subtag: 'piu', prefix: [], scope: null },
    { type: 'language', subtag: 'piv', prefix: [], scope: null },
    { type: 'language', subtag: 'piw', prefix: [], scope: null },
    { type: 'language', subtag: 'pix', prefix: [], scope: null },
    { type: 'language', subtag: 'piy', prefix: [], scope: null },
    { type: 'language', subtag: 'piz', prefix: [], scope: null },
    { type: 'language', subtag: 'pjt', prefix: [], scope: null },
    { type: 'language', subtag: 'pka', prefix: [], scope: null },
    { type: 'language', subtag: 'pkb', prefix: [], scope: null },
    { type: 'language', subtag: 'pkc', prefix: [], scope: null },
    { type: 'language', subtag: 'pkg', prefix: [], scope: null },
    { type: 'language', subtag: 'pkh', prefix: [], scope: null },
    { type: 'language', subtag: 'pkn', prefix: [], scope: null },
    { type: 'language', subtag: 'pko', prefix: [], scope: null },
    { type: 'language', subtag: 'pkp', prefix: [], scope: null },
    { type: 'language', subtag: 'pkr', prefix: [], scope: null },
    { type: 'language', subtag: 'pks', prefix: [], scope: null },
    { type: 'language', subtag: 'pkt', prefix: [], scope: null },
    { type: 'language', subtag: 'pku', prefix: [], scope: null },
    { type: 'language', subtag: 'pla', prefix: [], scope: null },
    { type: 'language', subtag: 'plb', prefix: [], scope: null },
    { type: 'language', subtag: 'plc', prefix: [], scope: null },
    { type: 'language', subtag: 'pld', prefix: [], scope: null },
    { type: 'language', subtag: 'ple', prefix: [], scope: null },
    { type: 'language', subtag: 'plf', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'plg', prefix: [], scope: null },
    { type: 'language', subtag: 'plh', prefix: [], scope: null },
    { type: 'language', subtag: 'plj', prefix: [], scope: null },
    { type: 'language', subtag: 'plk', prefix: [], scope: null },
    { type: 'language', subtag: 'pll', prefix: [], scope: null },
    { type: 'language', subtag: 'pln', prefix: [], scope: null },
    { type: 'language', subtag: 'plo', prefix: [], scope: null },
    { type: 'language', subtag: 'plp', prefix: [], scope: null },
    { type: 'language', subtag: 'plq', prefix: [], scope: null },
    { type: 'language', subtag: 'plr', prefix: [], scope: null },
    { type: 'language', subtag: 'pls', prefix: [], scope: null },
    { type: 'language', subtag: 'plt', prefix: [], scope: null },
    { type: 'language', subtag: 'plu', prefix: [], scope: null },
    { type: 'language', subtag: 'plv', prefix: [], scope: null },
    { type: 'language', subtag: 'plw', prefix: [], scope: null },
    { type: 'language', subtag: 'ply', prefix: [], scope: null },
    { type: 'language', subtag: 'plz', prefix: [], scope: null },
    { type: 'language', subtag: 'pma', prefix: [], scope: null },
    { type: 'language', subtag: 'pmb', prefix: [], scope: null },
    { type: 'language', subtag: 'pmc', prefix: [], scope: null },
    { type: 'language', subtag: 'pmd', prefix: [], scope: null },
    { type: 'language', subtag: 'pme', prefix: [], scope: null },
    { type: 'language', subtag: 'pmf', prefix: [], scope: null },
    { type: 'language', subtag: 'pmh', prefix: [], scope: null },
    { type: 'language', subtag: 'pmi', prefix: [], scope: null },
    { type: 'language', subtag: 'pmj', prefix: [], scope: null },
    { type: 'language', subtag: 'pmk', prefix: [], scope: null },
    { type: 'language', subtag: 'pml', prefix: [], scope: null },
    { type: 'language', subtag: 'pmm', prefix: [], scope: null },
    { type: 'language', subtag: 'pmn', prefix: [], scope: null },
    { type: 'language', subtag: 'pmo', prefix: [], scope: null },
    { type: 'language', subtag: 'pmq', prefix: [], scope: null },
    { type: 'language', subtag: 'pmr', prefix: [], scope: null },
    { type: 'language', subtag: 'pms', prefix: [], scope: null },
    { type: 'language', subtag: 'pmt', prefix: [], scope: null },
    { type: 'language', subtag: 'pmu', prefix: [], scope: null },
    { type: 'language', subtag: 'pmw', prefix: [], scope: null },
    { type: 'language', subtag: 'pmx', prefix: [], scope: null },
    { type: 'language', subtag: 'pmy', prefix: [], scope: null },
    { type: 'language', subtag: 'pmz', prefix: [], scope: null },
    { type: 'language', subtag: 'pna', prefix: [], scope: null },
    { type: 'language', subtag: 'pnb', prefix: [], scope: null },
    { type: 'language', subtag: 'pnc', prefix: [], scope: null },
    { type: 'language', subtag: 'pnd', prefix: [], scope: null },
    { type: 'language', subtag: 'pne', prefix: [], scope: null },
    { type: 'language', subtag: 'png', prefix: [], scope: null },
    { type: 'language', subtag: 'pnh', prefix: [], scope: null },
    { type: 'language', subtag: 'pni', prefix: [], scope: null },
    { type: 'language', subtag: 'pnj', prefix: [], scope: null },
    { type: 'language', subtag: 'pnk', prefix: [], scope: null },
    { type: 'language', subtag: 'pnl', prefix: [], scope: null },
    { type: 'language', subtag: 'pnm', prefix: [], scope: null },
    { type: 'language', subtag: 'pnn', prefix: [], scope: null },
    { type: 'language', subtag: 'pno', prefix: [], scope: null },
    { type: 'language', subtag: 'pnp', prefix: [], scope: null },
    { type: 'language', subtag: 'pnq', prefix: [], scope: null },
    { type: 'language', subtag: 'pnr', prefix: [], scope: null },
    { type: 'language', subtag: 'pns', prefix: [], scope: null },
    { type: 'language', subtag: 'pnt', prefix: [], scope: null },
    { type: 'language', subtag: 'pnu', prefix: [], scope: null },
    { type: 'language', subtag: 'pnv', prefix: [], scope: null },
    { type: 'language', subtag: 'pnw', prefix: [], scope: null },
    { type: 'language', subtag: 'pnx', prefix: [], scope: null },
    { type: 'language', subtag: 'pny', prefix: [], scope: null },
    { type: 'language', subtag: 'pnz', prefix: [], scope: null },
    { type: 'language', subtag: 'poc', prefix: [], scope: null },
    { type: 'language', subtag: 'pod', prefix: [], scope: null },
    { type: 'language', subtag: 'poe', prefix: [], scope: null },
    { type: 'language', subtag: 'pof', prefix: [], scope: null },
    { type: 'language', subtag: 'pog', prefix: [], scope: null },
    { type: 'language', subtag: 'poh', prefix: [], scope: null },
    { type: 'language', subtag: 'poi', prefix: [], scope: null },
    { type: 'language', subtag: 'pok', prefix: [], scope: null },
    { type: 'language', subtag: 'pom', prefix: [], scope: null },
    { type: 'language', subtag: 'pon', prefix: [], scope: null },
    { type: 'language', subtag: 'poo', prefix: [], scope: null },
    { type: 'language', subtag: 'pop', prefix: [], scope: null },
    { type: 'language', subtag: 'poq', prefix: [], scope: null },
    { type: 'language', subtag: 'pos', prefix: [], scope: null },
    { type: 'language', subtag: 'pot', prefix: [], scope: null },
    { type: 'language', subtag: 'pov', prefix: [], scope: null },
    { type: 'language', subtag: 'pow', prefix: [], scope: null },
    { type: 'language', subtag: 'pox', prefix: [], scope: null },
    { type: 'language', subtag: 'poy', prefix: [], scope: null },
    { type: 'language', subtag: 'poz', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ppa', prefix: [], scope: null },
    { type: 'language', subtag: 'ppe', prefix: [], scope: null },
    { type: 'language', subtag: 'ppi', prefix: [], scope: null },
    { type: 'language', subtag: 'ppk', prefix: [], scope: null },
    { type: 'language', subtag: 'ppl', prefix: [], scope: null },
    { type: 'language', subtag: 'ppm', prefix: [], scope: null },
    { type: 'language', subtag: 'ppn', prefix: [], scope: null },
    { type: 'language', subtag: 'ppo', prefix: [], scope: null },
    { type: 'language', subtag: 'ppp', prefix: [], scope: null },
    { type: 'language', subtag: 'ppq', prefix: [], scope: null },
    { type: 'language', subtag: 'ppr', prefix: [], scope: null },
    { type: 'language', subtag: 'pps', prefix: [], scope: null },
    { type: 'language', subtag: 'ppt', prefix: [], scope: null },
    { type: 'language', subtag: 'ppu', prefix: [], scope: null },
    { type: 'language', subtag: 'pqa', prefix: [], scope: null },
    { type: 'language', subtag: 'pqe', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'pqm', prefix: [], scope: null },
    { type: 'language', subtag: 'pqw', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'pra', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'prb', prefix: [], scope: null },
    { type: 'language', subtag: 'prc', prefix: [], scope: null },
    { type: 'language', subtag: 'prd', prefix: [], scope: null },
    { type: 'language', subtag: 'pre', prefix: [], scope: null },
    { type: 'language', subtag: 'prf', prefix: [], scope: null },
    { type: 'language', subtag: 'prg', prefix: [], scope: null },
    { type: 'language', subtag: 'prh', prefix: [], scope: null },
    { type: 'language', subtag: 'pri', prefix: [], scope: null },
    { type: 'language', subtag: 'prk', prefix: [], scope: null },
    { type: 'language', subtag: 'prl', prefix: [], scope: null },
    { type: 'language', subtag: 'prm', prefix: [], scope: null },
    { type: 'language', subtag: 'prn', prefix: [], scope: null },
    { type: 'language', subtag: 'pro', prefix: [], scope: null },
    { type: 'language', subtag: 'prp', prefix: [], scope: null },
    { type: 'language', subtag: 'prq', prefix: [], scope: null },
    { type: 'language', subtag: 'prr', prefix: [], scope: null },
    { type: 'language', subtag: 'prs', prefix: [], scope: null },
    { type: 'language', subtag: 'prt', prefix: [], scope: null },
    { type: 'language', subtag: 'pru', prefix: [], scope: null },
    { type: 'language', subtag: 'prw', prefix: [], scope: null },
    { type: 'language', subtag: 'prx', prefix: [], scope: null },
    { type: 'language', subtag: 'pry', prefix: [], scope: null },
    { type: 'language', subtag: 'prz', prefix: [], scope: null },
    { type: 'language', subtag: 'psa', prefix: [], scope: null },
    { type: 'language', subtag: 'psc', prefix: [], scope: null },
    { type: 'language', subtag: 'psd', prefix: [], scope: null },
    { type: 'language', subtag: 'pse', prefix: [], scope: null },
    { type: 'language', subtag: 'psg', prefix: [], scope: null },
    { type: 'language', subtag: 'psh', prefix: [], scope: null },
    { type: 'language', subtag: 'psi', prefix: [], scope: null },
    { type: 'language', subtag: 'psl', prefix: [], scope: null },
    { type: 'language', subtag: 'psm', prefix: [], scope: null },
    { type: 'language', subtag: 'psn', prefix: [], scope: null },
    { type: 'language', subtag: 'pso', prefix: [], scope: null },
    { type: 'language', subtag: 'psp', prefix: [], scope: null },
    { type: 'language', subtag: 'psq', prefix: [], scope: null },
    { type: 'language', subtag: 'psr', prefix: [], scope: null },
    { type: 'language', subtag: 'pss', prefix: [], scope: null },
    { type: 'language', subtag: 'pst', prefix: [], scope: null },
    { type: 'language', subtag: 'psu', prefix: [], scope: null },
    { type: 'language', subtag: 'psw', prefix: [], scope: null },
    { type: 'language', subtag: 'psy', prefix: [], scope: null },
    { type: 'language', subtag: 'pta', prefix: [], scope: null },
    { type: 'language', subtag: 'pth', prefix: [], scope: null },
    { type: 'language', subtag: 'pti', prefix: [], scope: null },
    { type: 'language', subtag: 'ptn', prefix: [], scope: null },
    { type: 'language', subtag: 'pto', prefix: [], scope: null },
    { type: 'language', subtag: 'ptp', prefix: [], scope: null },
    { type: 'language', subtag: 'ptq', prefix: [], scope: null },
    { type: 'language', subtag: 'ptr', prefix: [], scope: null },
    { type: 'language', subtag: 'ptt', prefix: [], scope: null },
    { type: 'language', subtag: 'ptu', prefix: [], scope: null },
    { type: 'language', subtag: 'ptv', prefix: [], scope: null },
    { type: 'language', subtag: 'ptw', prefix: [], scope: null },
    { type: 'language', subtag: 'pty', prefix: [], scope: null },
    { type: 'language', subtag: 'pua', prefix: [], scope: null },
    { type: 'language', subtag: 'pub', prefix: [], scope: null },
    { type: 'language', subtag: 'puc', prefix: [], scope: null },
    { type: 'language', subtag: 'pud', prefix: [], scope: null },
    { type: 'language', subtag: 'pue', prefix: [], scope: null },
    { type: 'language', subtag: 'puf', prefix: [], scope: null },
    { type: 'language', subtag: 'pug', prefix: [], scope: null },
    { type: 'language', subtag: 'pui', prefix: [], scope: null },
    { type: 'language', subtag: 'puj', prefix: [], scope: null },
    { type: 'language', subtag: 'puk', prefix: [], scope: null },
    { type: 'language', subtag: 'pum', prefix: [], scope: null },
    { type: 'language', subtag: 'puo', prefix: [], scope: null },
    { type: 'language', subtag: 'pup', prefix: [], scope: null },
    { type: 'language', subtag: 'puq', prefix: [], scope: null },
    { type: 'language', subtag: 'pur', prefix: [], scope: null },
    { type: 'language', subtag: 'put', prefix: [], scope: null },
    { type: 'language', subtag: 'puu', prefix: [], scope: null },
    { type: 'language', subtag: 'puw', prefix: [], scope: null },
    { type: 'language', subtag: 'pux', prefix: [], scope: null },
    { type: 'language', subtag: 'puy', prefix: [], scope: null },
    { type: 'language', subtag: 'puz', prefix: [], scope: null },
    { type: 'language', subtag: 'pwa', prefix: [], scope: null },
    { type: 'language', subtag: 'pwb', prefix: [], scope: null },
    { type: 'language', subtag: 'pwg', prefix: [], scope: null },
    { type: 'language', subtag: 'pwi', prefix: [], scope: null },
    { type: 'language', subtag: 'pwm', prefix: [], scope: null },
    { type: 'language', subtag: 'pwn', prefix: [], scope: null },
    { type: 'language', subtag: 'pwo', prefix: [], scope: null },
    { type: 'language', subtag: 'pwr', prefix: [], scope: null },
    { type: 'language', subtag: 'pww', prefix: [], scope: null },
    { type: 'language', subtag: 'pxm', prefix: [], scope: null },
    { type: 'language', subtag: 'pye', prefix: [], scope: null },
    { type: 'language', subtag: 'pym', prefix: [], scope: null },
    { type: 'language', subtag: 'pyn', prefix: [], scope: null },
    { type: 'language', subtag: 'pys', prefix: [], scope: null },
    { type: 'language', subtag: 'pyu', prefix: [], scope: null },
    { type: 'language', subtag: 'pyx', prefix: [], scope: null },
    { type: 'language', subtag: 'pyy', prefix: [], scope: null },
    { type: 'language', subtag: 'pzh', prefix: [], scope: null },
    { type: 'language', subtag: 'pzn', prefix: [], scope: null },
    { type: 'language', subtag: 'qaa..qtz', prefix: [], scope: 'private-use' },
    { type: 'language', subtag: 'qua', prefix: [], scope: null },
    { type: 'language', subtag: 'qub', prefix: [], scope: null },
    { type: 'language', subtag: 'quc', prefix: [], scope: null },
    { type: 'language', subtag: 'qud', prefix: [], scope: null },
    { type: 'language', subtag: 'quf', prefix: [], scope: null },
    { type: 'language', subtag: 'qug', prefix: [], scope: null },
    { type: 'language', subtag: 'quh', prefix: [], scope: null },
    { type: 'language', subtag: 'qui', prefix: [], scope: null },
    { type: 'language', subtag: 'quk', prefix: [], scope: null },
    { type: 'language', subtag: 'qul', prefix: [], scope: null },
    { type: 'language', subtag: 'qum', prefix: [], scope: null },
    { type: 'language', subtag: 'qun', prefix: [], scope: null },
    { type: 'language', subtag: 'qup', prefix: [], scope: null },
    { type: 'language', subtag: 'quq', prefix: [], scope: null },
    { type: 'language', subtag: 'qur', prefix: [], scope: null },
    { type: 'language', subtag: 'qus', prefix: [], scope: null },
    { type: 'language', subtag: 'quv', prefix: [], scope: null },
    { type: 'language', subtag: 'quw', prefix: [], scope: null },
    { type: 'language', subtag: 'qux', prefix: [], scope: null },
    { type: 'language', subtag: 'quy', prefix: [], scope: null },
    { type: 'language', subtag: 'quz', prefix: [], scope: null },
    { type: 'language', subtag: 'qva', prefix: [], scope: null },
    { type: 'language', subtag: 'qvc', prefix: [], scope: null },
    { type: 'language', subtag: 'qve', prefix: [], scope: null },
    { type: 'language', subtag: 'qvh', prefix: [], scope: null },
    { type: 'language', subtag: 'qvi', prefix: [], scope: null },
    { type: 'language', subtag: 'qvj', prefix: [], scope: null },
    { type: 'language', subtag: 'qvl', prefix: [], scope: null },
    { type: 'language', subtag: 'qvm', prefix: [], scope: null },
    { type: 'language', subtag: 'qvn', prefix: [], scope: null },
    { type: 'language', subtag: 'qvo', prefix: [], scope: null },
    { type: 'language', subtag: 'qvp', prefix: [], scope: null },
    { type: 'language', subtag: 'qvs', prefix: [], scope: null },
    { type: 'language', subtag: 'qvw', prefix: [], scope: null },
    { type: 'language', subtag: 'qvy', prefix: [], scope: null },
    { type: 'language', subtag: 'qvz', prefix: [], scope: null },
    { type: 'language', subtag: 'qwa', prefix: [], scope: null },
    { type: 'language', subtag: 'qwc', prefix: [], scope: null },
    { type: 'language', subtag: 'qwe', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'qwh', prefix: [], scope: null },
    { type: 'language', subtag: 'qwm', prefix: [], scope: null },
    { type: 'language', subtag: 'qws', prefix: [], scope: null },
    { type: 'language', subtag: 'qwt', prefix: [], scope: null },
    { type: 'language', subtag: 'qxa', prefix: [], scope: null },
    { type: 'language', subtag: 'qxc', prefix: [], scope: null },
    { type: 'language', subtag: 'qxh', prefix: [], scope: null },
    { type: 'language', subtag: 'qxl', prefix: [], scope: null },
    { type: 'language', subtag: 'qxn', prefix: [], scope: null },
    { type: 'language', subtag: 'qxo', prefix: [], scope: null },
    { type: 'language', subtag: 'qxp', prefix: [], scope: null },
    { type: 'language', subtag: 'qxq', prefix: [], scope: null },
    { type: 'language', subtag: 'qxr', prefix: [], scope: null },
    { type: 'language', subtag: 'qxs', prefix: [], scope: null },
    { type: 'language', subtag: 'qxt', prefix: [], scope: null },
    { type: 'language', subtag: 'qxu', prefix: [], scope: null },
    { type: 'language', subtag: 'qxw', prefix: [], scope: null },
    { type: 'language', subtag: 'qya', prefix: [], scope: null },
    { type: 'language', subtag: 'qyp', prefix: [], scope: null },
    { type: 'language', subtag: 'raa', prefix: [], scope: null },
    { type: 'language', subtag: 'rab', prefix: [], scope: null },
    { type: 'language', subtag: 'rac', prefix: [], scope: null },
    { type: 'language', subtag: 'rad', prefix: [], scope: null },
    { type: 'language', subtag: 'raf', prefix: [], scope: null },
    { type: 'language', subtag: 'rag', prefix: [], scope: null },
    { type: 'language', subtag: 'rah', prefix: [], scope: null },
    { type: 'language', subtag: 'rai', prefix: [], scope: null },
    { type: 'language', subtag: 'raj', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'rak', prefix: [], scope: null },
    { type: 'language', subtag: 'ral', prefix: [], scope: null },
    { type: 'language', subtag: 'ram', prefix: [], scope: null },
    { type: 'language', subtag: 'ran', prefix: [], scope: null },
    { type: 'language', subtag: 'rao', prefix: [], scope: null },
    { type: 'language', subtag: 'rap', prefix: [], scope: null },
    { type: 'language', subtag: 'raq', prefix: [], scope: null },
    { type: 'language', subtag: 'rar', prefix: [], scope: null },
    { type: 'language', subtag: 'ras', prefix: [], scope: null },
    { type: 'language', subtag: 'rat', prefix: [], scope: null },
    { type: 'language', subtag: 'rau', prefix: [], scope: null },
    { type: 'language', subtag: 'rav', prefix: [], scope: null },
    { type: 'language', subtag: 'raw', prefix: [], scope: null },
    { type: 'language', subtag: 'rax', prefix: [], scope: null },
    { type: 'language', subtag: 'ray', prefix: [], scope: null },
    { type: 'language', subtag: 'raz', prefix: [], scope: null },
    { type: 'language', subtag: 'rbb', prefix: [], scope: null },
    { type: 'language', subtag: 'rbk', prefix: [], scope: null },
    { type: 'language', subtag: 'rbl', prefix: [], scope: null },
    { type: 'language', subtag: 'rbp', prefix: [], scope: null },
    { type: 'language', subtag: 'rcf', prefix: [], scope: null },
    { type: 'language', subtag: 'rdb', prefix: [], scope: null },
    { type: 'language', subtag: 'rea', prefix: [], scope: null },
    { type: 'language', subtag: 'reb', prefix: [], scope: null },
    { type: 'language', subtag: 'ree', prefix: [], scope: null },
    { type: 'language', subtag: 'reg', prefix: [], scope: null },
    { type: 'language', subtag: 'rei', prefix: [], scope: null },
    { type: 'language', subtag: 'rej', prefix: [], scope: null },
    { type: 'language', subtag: 'rel', prefix: [], scope: null },
    { type: 'language', subtag: 'rem', prefix: [], scope: null },
    { type: 'language', subtag: 'ren', prefix: [], scope: null },
    { type: 'language', subtag: 'rer', prefix: [], scope: null },
    { type: 'language', subtag: 'res', prefix: [], scope: null },
    { type: 'language', subtag: 'ret', prefix: [], scope: null },
    { type: 'language', subtag: 'rey', prefix: [], scope: null },
    { type: 'language', subtag: 'rga', prefix: [], scope: null },
    { type: 'language', subtag: 'rge', prefix: [], scope: null },
    { type: 'language', subtag: 'rgk', prefix: [], scope: null },
    { type: 'language', subtag: 'rgn', prefix: [], scope: null },
    { type: 'language', subtag: 'rgr', prefix: [], scope: null },
    { type: 'language', subtag: 'rgs', prefix: [], scope: null },
    { type: 'language', subtag: 'rgu', prefix: [], scope: null },
    { type: 'language', subtag: 'rhg', prefix: [], scope: null },
    { type: 'language', subtag: 'rhp', prefix: [], scope: null },
    { type: 'language', subtag: 'ria', prefix: [], scope: null },
    { type: 'language', subtag: 'rib', prefix: [], scope: null },
    { type: 'language', subtag: 'rie', prefix: [], scope: null },
    { type: 'language', subtag: 'rif', prefix: [], scope: null },
    { type: 'language', subtag: 'ril', prefix: [], scope: null },
    { type: 'language', subtag: 'rim', prefix: [], scope: null },
    { type: 'language', subtag: 'rin', prefix: [], scope: null },
    { type: 'language', subtag: 'rir', prefix: [], scope: null },
    { type: 'language', subtag: 'rit', prefix: [], scope: null },
    { type: 'language', subtag: 'riu', prefix: [], scope: null },
    { type: 'language', subtag: 'rjg', prefix: [], scope: null },
    { type: 'language', subtag: 'rji', prefix: [], scope: null },
    { type: 'language', subtag: 'rjs', prefix: [], scope: null },
    { type: 'language', subtag: 'rka', prefix: [], scope: null },
    { type: 'language', subtag: 'rkb', prefix: [], scope: null },
    { type: 'language', subtag: 'rkh', prefix: [], scope: null },
    { type: 'language', subtag: 'rki', prefix: [], scope: null },
    { type: 'language', subtag: 'rkm', prefix: [], scope: null },
    { type: 'language', subtag: 'rkt', prefix: [], scope: null },
    { type: 'language', subtag: 'rkw', prefix: [], scope: null },
    { type: 'language', subtag: 'rma', prefix: [], scope: null },
    { type: 'language', subtag: 'rmb', prefix: [], scope: null },
    { type: 'language', subtag: 'rmc', prefix: [], scope: null },
    { type: 'language', subtag: 'rmd', prefix: [], scope: null },
    { type: 'language', subtag: 'rme', prefix: [], scope: null },
    { type: 'language', subtag: 'rmf', prefix: [], scope: null },
    { type: 'language', subtag: 'rmg', prefix: [], scope: null },
    { type: 'language', subtag: 'rmh', prefix: [], scope: null },
    { type: 'language', subtag: 'rmi', prefix: [], scope: null },
    { type: 'language', subtag: 'rmk', prefix: [], scope: null },
    { type: 'language', subtag: 'rml', prefix: [], scope: null },
    { type: 'language', subtag: 'rmm', prefix: [], scope: null },
    { type: 'language', subtag: 'rmn', prefix: [], scope: null },
    { type: 'language', subtag: 'rmo', prefix: [], scope: null },
    { type: 'language', subtag: 'rmp', prefix: [], scope: null },
    { type: 'language', subtag: 'rmq', prefix: [], scope: null },
    { type: 'language', subtag: 'rmr', prefix: [], scope: null },
    { type: 'language', subtag: 'rms', prefix: [], scope: null },
    { type: 'language', subtag: 'rmt', prefix: [], scope: null },
    { type: 'language', subtag: 'rmu', prefix: [], scope: null },
    { type: 'language', subtag: 'rmv', prefix: [], scope: null },
    { type: 'language', subtag: 'rmw', prefix: [], scope: null },
    { type: 'language', subtag: 'rmx', prefix: [], scope: null },
    { type: 'language', subtag: 'rmy', prefix: [], scope: null },
    { type: 'language', subtag: 'rmz', prefix: [], scope: null },
    { type: 'language', subtag: 'rna', prefix: [], scope: null },
    { type: 'language', subtag: 'rnb', prefix: [], scope: null },
    { type: 'language', subtag: 'rnd', prefix: [], scope: null },
    { type: 'language', subtag: 'rng', prefix: [], scope: null },
    { type: 'language', subtag: 'rnl', prefix: [], scope: null },
    { type: 'language', subtag: 'rnn', prefix: [], scope: null },
    { type: 'language', subtag: 'rnp', prefix: [], scope: null },
    { type: 'language', subtag: 'rnr', prefix: [], scope: null },
    { type: 'language', subtag: 'rnw', prefix: [], scope: null },
    { type: 'language', subtag: 'roa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'rob', prefix: [], scope: null },
    { type: 'language', subtag: 'roc', prefix: [], scope: null },
    { type: 'language', subtag: 'rod', prefix: [], scope: null },
    { type: 'language', subtag: 'roe', prefix: [], scope: null },
    { type: 'language', subtag: 'rof', prefix: [], scope: null },
    { type: 'language', subtag: 'rog', prefix: [], scope: null },
    { type: 'language', subtag: 'rol', prefix: [], scope: null },
    { type: 'language', subtag: 'rom', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'roo', prefix: [], scope: null },
    { type: 'language', subtag: 'rop', prefix: [], scope: null },
    { type: 'language', subtag: 'ror', prefix: [], scope: null },
    { type: 'language', subtag: 'rou', prefix: [], scope: null },
    { type: 'language', subtag: 'row', prefix: [], scope: null },
    { type: 'language', subtag: 'rpn', prefix: [], scope: null },
    { type: 'language', subtag: 'rpt', prefix: [], scope: null },
    { type: 'language', subtag: 'rri', prefix: [], scope: null },
    { type: 'language', subtag: 'rro', prefix: [], scope: null },
    { type: 'language', subtag: 'rrt', prefix: [], scope: null },
    { type: 'language', subtag: 'rsb', prefix: [], scope: null },
    { type: 'language', subtag: 'rsi', prefix: [], scope: null },
    { type: 'language', subtag: 'rsk', prefix: [], scope: null },
    { type: 'language', subtag: 'rsl', prefix: [], scope: null },
    { type: 'language', subtag: 'rsm', prefix: [], scope: null },
    { type: 'language', subtag: 'rsn', prefix: [], scope: null },
    { type: 'language', subtag: 'rtc', prefix: [], scope: null },
    { type: 'language', subtag: 'rth', prefix: [], scope: null },
    { type: 'language', subtag: 'rtm', prefix: [], scope: null },
    { type: 'language', subtag: 'rts', prefix: [], scope: null },
    { type: 'language', subtag: 'rtw', prefix: [], scope: null },
    { type: 'language', subtag: 'rub', prefix: [], scope: null },
    { type: 'language', subtag: 'ruc', prefix: [], scope: null },
    { type: 'language', subtag: 'rue', prefix: [], scope: null },
    { type: 'language', subtag: 'ruf', prefix: [], scope: null },
    { type: 'language', subtag: 'rug', prefix: [], scope: null },
    { type: 'language', subtag: 'ruh', prefix: [], scope: null },
    { type: 'language', subtag: 'rui', prefix: [], scope: null },
    { type: 'language', subtag: 'ruk', prefix: [], scope: null },
    { type: 'language', subtag: 'ruo', prefix: [], scope: null },
    { type: 'language', subtag: 'rup', prefix: [], scope: null },
    { type: 'language', subtag: 'ruq', prefix: [], scope: null },
    { type: 'language', subtag: 'rut', prefix: [], scope: null },
    { type: 'language', subtag: 'ruu', prefix: [], scope: null },
    { type: 'language', subtag: 'ruy', prefix: [], scope: null },
    { type: 'language', subtag: 'ruz', prefix: [], scope: null },
    { type: 'language', subtag: 'rwa', prefix: [], scope: null },
    { type: 'language', subtag: 'rwk', prefix: [], scope: null },
    { type: 'language', subtag: 'rwl', prefix: [], scope: null },
    { type: 'language', subtag: 'rwm', prefix: [], scope: null },
    { type: 'language', subtag: 'rwo', prefix: [], scope: null },
    { type: 'language', subtag: 'rwr', prefix: [], scope: null },
    { type: 'language', subtag: 'rxd', prefix: [], scope: null },
    { type: 'language', subtag: 'rxw', prefix: [], scope: null },
    { type: 'language', subtag: 'ryn', prefix: [], scope: null },
    { type: 'language', subtag: 'rys', prefix: [], scope: null },
    { type: 'language', subtag: 'ryu', prefix: [], scope: null },
    { type: 'language', subtag: 'rzh', prefix: [], scope: null },
    { type: 'language', subtag: 'saa', prefix: [], scope: null },
    { type: 'language', subtag: 'sab', prefix: [], scope: null },
    { type: 'language', subtag: 'sac', prefix: [], scope: null },
    { type: 'language', subtag: 'sad', prefix: [], scope: null },
    { type: 'language', subtag: 'sae', prefix: [], scope: null },
    { type: 'language', subtag: 'saf', prefix: [], scope: null },
    { type: 'language', subtag: 'sah', prefix: [], scope: null },
    { type: 'language', subtag: 'sai', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'saj', prefix: [], scope: null },
    { type: 'language', subtag: 'sak', prefix: [], scope: null },
    { type: 'language', subtag: 'sal', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sam', prefix: [], scope: null },
    { type: 'language', subtag: 'sao', prefix: [], scope: null },
    { type: 'language', subtag: 'sap', prefix: [], scope: null },
    { type: 'language', subtag: 'saq', prefix: [], scope: null },
    { type: 'language', subtag: 'sar', prefix: [], scope: null },
    { type: 'language', subtag: 'sas', prefix: [], scope: null },
    { type: 'language', subtag: 'sat', prefix: [], scope: null },
    { type: 'language', subtag: 'sau', prefix: [], scope: null },
    { type: 'language', subtag: 'sav', prefix: [], scope: null },
    { type: 'language', subtag: 'saw', prefix: [], scope: null },
    { type: 'language', subtag: 'sax', prefix: [], scope: null },
    { type: 'language', subtag: 'say', prefix: [], scope: null },
    { type: 'language', subtag: 'saz', prefix: [], scope: null },
    { type: 'language', subtag: 'sba', prefix: [], scope: null },
    { type: 'language', subtag: 'sbb', prefix: [], scope: null },
    { type: 'language', subtag: 'sbc', prefix: [], scope: null },
    { type: 'language', subtag: 'sbd', prefix: [], scope: null },
    { type: 'language', subtag: 'sbe', prefix: [], scope: null },
    { type: 'language', subtag: 'sbf', prefix: [], scope: null },
    { type: 'language', subtag: 'sbg', prefix: [], scope: null },
    { type: 'language', subtag: 'sbh', prefix: [], scope: null },
    { type: 'language', subtag: 'sbi', prefix: [], scope: null },
    { type: 'language', subtag: 'sbj', prefix: [], scope: null },
    { type: 'language', subtag: 'sbk', prefix: [], scope: null },
    { type: 'language', subtag: 'sbl', prefix: [], scope: null },
    { type: 'language', subtag: 'sbm', prefix: [], scope: null },
    { type: 'language', subtag: 'sbn', prefix: [], scope: null },
    { type: 'language', subtag: 'sbo', prefix: [], scope: null },
    { type: 'language', subtag: 'sbp', prefix: [], scope: null },
    { type: 'language', subtag: 'sbq', prefix: [], scope: null },
    { type: 'language', subtag: 'sbr', prefix: [], scope: null },
    { type: 'language', subtag: 'sbs', prefix: [], scope: null },
    { type: 'language', subtag: 'sbt', prefix: [], scope: null },
    { type: 'language', subtag: 'sbu', prefix: [], scope: null },
    { type: 'language', subtag: 'sbv', prefix: [], scope: null },
    { type: 'language', subtag: 'sbw', prefix: [], scope: null },
    { type: 'language', subtag: 'sbx', prefix: [], scope: null },
    { type: 'language', subtag: 'sby', prefix: [], scope: null },
    { type: 'language', subtag: 'sbz', prefix: [], scope: null },
    { type: 'language', subtag: 'sca', prefix: [], scope: null },
    { type: 'language', subtag: 'scb', prefix: [], scope: null },
    { type: 'language', subtag: 'sce', prefix: [], scope: null },
    { type: 'language', subtag: 'scf', prefix: [], scope: null },
    { type: 'language', subtag: 'scg', prefix: [], scope: null },
    { type: 'language', subtag: 'sch', prefix: [], scope: null },
    { type: 'language', subtag: 'sci', prefix: [], scope: null },
    { type: 'language', subtag: 'sck', prefix: [], scope: null },
    { type: 'language', subtag: 'scl', prefix: [], scope: null },
    { type: 'language', subtag: 'scn', prefix: [], scope: null },
    { type: 'language', subtag: 'sco', prefix: [], scope: null },
    { type: 'language', subtag: 'scp', prefix: [], scope: null },
    { type: 'language', subtag: 'scq', prefix: [], scope: null },
    { type: 'language', subtag: 'scs', prefix: [], scope: null },
    { type: 'language', subtag: 'sct', prefix: [], scope: null },
    { type: 'language', subtag: 'scu', prefix: [], scope: null },
    { type: 'language', subtag: 'scv', prefix: [], scope: null },
    { type: 'language', subtag: 'scw', prefix: [], scope: null },
    { type: 'language', subtag: 'scx', prefix: [], scope: null },
    { type: 'language', subtag: 'sda', prefix: [], scope: null },
    { type: 'language', subtag: 'sdb', prefix: [], scope: null },
    { type: 'language', subtag: 'sdc', prefix: [], scope: null },
    { type: 'language', subtag: 'sde', prefix: [], scope: null },
    { type: 'language', subtag: 'sdf', prefix: [], scope: null },
    { type: 'language', subtag: 'sdg', prefix: [], scope: null },
    { type: 'language', subtag: 'sdh', prefix: [], scope: null },
    { type: 'language', subtag: 'sdj', prefix: [], scope: null },
    { type: 'language', subtag: 'sdk', prefix: [], scope: null },
    { type: 'language', subtag: 'sdl', prefix: [], scope: null },
    { type: 'language', subtag: 'sdm', prefix: [], scope: null },
    { type: 'language', subtag: 'sdn', prefix: [], scope: null },
    { type: 'language', subtag: 'sdo', prefix: [], scope: null },
    { type: 'language', subtag: 'sdp', prefix: [], scope: null },
    { type: 'language', subtag: 'sdq', prefix: [], scope: null },
    { type: 'language', subtag: 'sdr', prefix: [], scope: null },
    { type: 'language', subtag: 'sds', prefix: [], scope: null },
    { type: 'language', subtag: 'sdt', prefix: [], scope: null },
    { type: 'language', subtag: 'sdu', prefix: [], scope: null },
    { type: 'language', subtag: 'sdv', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sdx', prefix: [], scope: null },
    { type: 'language', subtag: 'sdz', prefix: [], scope: null },
    { type: 'language', subtag: 'sea', prefix: [], scope: null },
    { type: 'language', subtag: 'seb', prefix: [], scope: null },
    { type: 'language', subtag: 'sec', prefix: [], scope: null },
    { type: 'language', subtag: 'sed', prefix: [], scope: null },
    { type: 'language', subtag: 'see', prefix: [], scope: null },
    { type: 'language', subtag: 'sef', prefix: [], scope: null },
    { type: 'language', subtag: 'seg', prefix: [], scope: null },
    { type: 'language', subtag: 'seh', prefix: [], scope: null },
    { type: 'language', subtag: 'sei', prefix: [], scope: null },
    { type: 'language', subtag: 'sej', prefix: [], scope: null },
    { type: 'language', subtag: 'sek', prefix: [], scope: null },
    { type: 'language', subtag: 'sel', prefix: [], scope: null },
    { type: 'language', subtag: 'sem', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sen', prefix: [], scope: null },
    { type: 'language', subtag: 'seo', prefix: [], scope: null },
    { type: 'language', subtag: 'sep', prefix: [], scope: null },
    { type: 'language', subtag: 'seq', prefix: [], scope: null },
    { type: 'language', subtag: 'ser', prefix: [], scope: null },
    { type: 'language', subtag: 'ses', prefix: [], scope: null },
    { type: 'language', subtag: 'set', prefix: [], scope: null },
    { type: 'language', subtag: 'seu', prefix: [], scope: null },
    { type: 'language', subtag: 'sev', prefix: [], scope: null },
    { type: 'language', subtag: 'sew', prefix: [], scope: null },
    { type: 'language', subtag: 'sey', prefix: [], scope: null },
    { type: 'language', subtag: 'sez', prefix: [], scope: null },
    { type: 'language', subtag: 'sfb', prefix: [], scope: null },
    { type: 'language', subtag: 'sfe', prefix: [], scope: null },
    { type: 'language', subtag: 'sfm', prefix: [], scope: null },
    { type: 'language', subtag: 'sfs', prefix: [], scope: null },
    { type: 'language', subtag: 'sfw', prefix: [], scope: null },
    { type: 'language', subtag: 'sga', prefix: [], scope: null },
    { type: 'language', subtag: 'sgb', prefix: [], scope: null },
    { type: 'language', subtag: 'sgc', prefix: [], scope: null },
    { type: 'language', subtag: 'sgd', prefix: [], scope: null },
    { type: 'language', subtag: 'sge', prefix: [], scope: null },
    { type: 'language', subtag: 'sgg', prefix: [], scope: null },
    { type: 'language', subtag: 'sgh', prefix: [], scope: null },
    { type: 'language', subtag: 'sgi', prefix: [], scope: null },
    { type: 'language', subtag: 'sgj', prefix: [], scope: null },
    { type: 'language', subtag: 'sgk', prefix: [], scope: null },
    { type: 'language', subtag: 'sgl', prefix: [], scope: null },
    { type: 'language', subtag: 'sgm', prefix: [], scope: null },
    { type: 'language', subtag: 'sgn', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sgo', prefix: [], scope: null },
    { type: 'language', subtag: 'sgp', prefix: [], scope: null },
    { type: 'language', subtag: 'sgr', prefix: [], scope: null },
    { type: 'language', subtag: 'sgs', prefix: [], scope: null },
    { type: 'language', subtag: 'sgt', prefix: [], scope: null },
    { type: 'language', subtag: 'sgu', prefix: [], scope: null },
    { type: 'language', subtag: 'sgw', prefix: [], scope: null },
    { type: 'language', subtag: 'sgx', prefix: [], scope: null },
    { type: 'language', subtag: 'sgy', prefix: [], scope: null },
    { type: 'language', subtag: 'sgz', prefix: [], scope: null },
    { type: 'language', subtag: 'sha', prefix: [], scope: null },
    { type: 'language', subtag: 'shb', prefix: [], scope: null },
    { type: 'language', subtag: 'shc', prefix: [], scope: null },
    { type: 'language', subtag: 'shd', prefix: [], scope: null },
    { type: 'language', subtag: 'she', prefix: [], scope: null },
    { type: 'language', subtag: 'shg', prefix: [], scope: null },
    { type: 'language', subtag: 'shh', prefix: [], scope: null },
    { type: 'language', subtag: 'shi', prefix: [], scope: null },
    { type: 'language', subtag: 'shj', prefix: [], scope: null },
    { type: 'language', subtag: 'shk', prefix: [], scope: null },
    { type: 'language', subtag: 'shl', prefix: [], scope: null },
    { type: 'language', subtag: 'shm', prefix: [], scope: null },
    { type: 'language', subtag: 'shn', prefix: [], scope: null },
    { type: 'language', subtag: 'sho', prefix: [], scope: null },
    { type: 'language', subtag: 'shp', prefix: [], scope: null },
    { type: 'language', subtag: 'shq', prefix: [], scope: null },
    { type: 'language', subtag: 'shr', prefix: [], scope: null },
    { type: 'language', subtag: 'shs', prefix: [], scope: null },
    { type: 'language', subtag: 'sht', prefix: [], scope: null },
    { type: 'language', subtag: 'shu', prefix: [], scope: null },
    { type: 'language', subtag: 'shv', prefix: [], scope: null },
    { type: 'language', subtag: 'shw', prefix: [], scope: null },
    { type: 'language', subtag: 'shx', prefix: [], scope: null },
    { type: 'language', subtag: 'shy', prefix: [], scope: null },
    { type: 'language', subtag: 'shz', prefix: [], scope: null },
    { type: 'language', subtag: 'sia', prefix: [], scope: null },
    { type: 'language', subtag: 'sib', prefix: [], scope: null },
    { type: 'language', subtag: 'sid', prefix: [], scope: null },
    { type: 'language', subtag: 'sie', prefix: [], scope: null },
    { type: 'language', subtag: 'sif', prefix: [], scope: null },
    { type: 'language', subtag: 'sig', prefix: [], scope: null },
    { type: 'language', subtag: 'sih', prefix: [], scope: null },
    { type: 'language', subtag: 'sii', prefix: [], scope: null },
    { type: 'language', subtag: 'sij', prefix: [], scope: null },
    { type: 'language', subtag: 'sik', prefix: [], scope: null },
    { type: 'language', subtag: 'sil', prefix: [], scope: null },
    { type: 'language', subtag: 'sim', prefix: [], scope: null },
    { type: 'language', subtag: 'sio', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sip', prefix: [], scope: null },
    { type: 'language', subtag: 'siq', prefix: [], scope: null },
    { type: 'language', subtag: 'sir', prefix: [], scope: null },
    { type: 'language', subtag: 'sis', prefix: [], scope: null },
    { type: 'language', subtag: 'sit', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'siu', prefix: [], scope: null },
    { type: 'language', subtag: 'siv', prefix: [], scope: null },
    { type: 'language', subtag: 'siw', prefix: [], scope: null },
    { type: 'language', subtag: 'six', prefix: [], scope: null },
    { type: 'language', subtag: 'siy', prefix: [], scope: null },
    { type: 'language', subtag: 'siz', prefix: [], scope: null },
    { type: 'language', subtag: 'sja', prefix: [], scope: null },
    { type: 'language', subtag: 'sjb', prefix: [], scope: null },
    { type: 'language', subtag: 'sjd', prefix: [], scope: null },
    { type: 'language', subtag: 'sje', prefix: [], scope: null },
    { type: 'language', subtag: 'sjg', prefix: [], scope: null },
    { type: 'language', subtag: 'sjk', prefix: [], scope: null },
    { type: 'language', subtag: 'sjl', prefix: [], scope: null },
    { type: 'language', subtag: 'sjm', prefix: [], scope: null },
    { type: 'language', subtag: 'sjn', prefix: [], scope: null },
    { type: 'language', subtag: 'sjo', prefix: [], scope: null },
    { type: 'language', subtag: 'sjp', prefix: [], scope: null },
    { type: 'language', subtag: 'sjr', prefix: [], scope: null },
    { type: 'language', subtag: 'sjs', prefix: [], scope: null },
    { type: 'language', subtag: 'sjt', prefix: [], scope: null },
    { type: 'language', subtag: 'sju', prefix: [], scope: null },
    { type: 'language', subtag: 'sjw', prefix: [], scope: null },
    { type: 'language', subtag: 'ska', prefix: [], scope: null },
    { type: 'language', subtag: 'skb', prefix: [], scope: null },
    { type: 'language', subtag: 'skc', prefix: [], scope: null },
    { type: 'language', subtag: 'skd', prefix: [], scope: null },
    { type: 'language', subtag: 'ske', prefix: [], scope: null },
    { type: 'language', subtag: 'skf', prefix: [], scope: null },
    { type: 'language', subtag: 'skg', prefix: [], scope: null },
    { type: 'language', subtag: 'skh', prefix: [], scope: null },
    { type: 'language', subtag: 'ski', prefix: [], scope: null },
    { type: 'language', subtag: 'skj', prefix: [], scope: null },
    { type: 'language', subtag: 'skk', prefix: [], scope: null },
    { type: 'language', subtag: 'skm', prefix: [], scope: null },
    { type: 'language', subtag: 'skn', prefix: [], scope: null },
    { type: 'language', subtag: 'sko', prefix: [], scope: null },
    { type: 'language', subtag: 'skp', prefix: [], scope: null },
    { type: 'language', subtag: 'skq', prefix: [], scope: null },
    { type: 'language', subtag: 'skr', prefix: [], scope: null },
    { type: 'language', subtag: 'sks', prefix: [], scope: null },
    { type: 'language', subtag: 'skt', prefix: [], scope: null },
    { type: 'language', subtag: 'sku', prefix: [], scope: null },
    { type: 'language', subtag: 'skv', prefix: [], scope: null },
    { type: 'language', subtag: 'skw', prefix: [], scope: null },
    { type: 'language', subtag: 'skx', prefix: [], scope: null },
    { type: 'language', subtag: 'sky', prefix: [], scope: null },
    { type: 'language', subtag: 'skz', prefix: [], scope: null },
    { type: 'language', subtag: 'sla', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'slc', prefix: [], scope: null },
    { type: 'language', subtag: 'sld', prefix: [], scope: null },
    { type: 'language', subtag: 'sle', prefix: [], scope: null },
    { type: 'language', subtag: 'slf', prefix: [], scope: null },
    { type: 'language', subtag: 'slg', prefix: [], scope: null },
    { type: 'language', subtag: 'slh', prefix: [], scope: null },
    { type: 'language', subtag: 'sli', prefix: [], scope: null },
    { type: 'language', subtag: 'slj', prefix: [], scope: null },
    { type: 'language', subtag: 'sll', prefix: [], scope: null },
    { type: 'language', subtag: 'slm', prefix: [], scope: null },
    { type: 'language', subtag: 'sln', prefix: [], scope: null },
    { type: 'language', subtag: 'slp', prefix: [], scope: null },
    { type: 'language', subtag: 'slq', prefix: [], scope: null },
    { type: 'language', subtag: 'slr', prefix: [], scope: null },
    { type: 'language', subtag: 'sls', prefix: [], scope: null },
    { type: 'language', subtag: 'slt', prefix: [], scope: null },
    { type: 'language', subtag: 'slu', prefix: [], scope: null },
    { type: 'language', subtag: 'slw', prefix: [], scope: null },
    { type: 'language', subtag: 'slx', prefix: [], scope: null },
    { type: 'language', subtag: 'sly', prefix: [], scope: null },
    { type: 'language', subtag: 'slz', prefix: [], scope: null },
    { type: 'language', subtag: 'sma', prefix: [], scope: null },
    { type: 'language', subtag: 'smb', prefix: [], scope: null },
    { type: 'language', subtag: 'smc', prefix: [], scope: null },
    { type: 'language', subtag: 'smd', prefix: [], scope: null },
    { type: 'language', subtag: 'smf', prefix: [], scope: null },
    { type: 'language', subtag: 'smg', prefix: [], scope: null },
    { type: 'language', subtag: 'smh', prefix: [], scope: null },
    { type: 'language', subtag: 'smi', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'smj', prefix: [], scope: null },
    { type: 'language', subtag: 'smk', prefix: [], scope: null },
    { type: 'language', subtag: 'sml', prefix: [], scope: null },
    { type: 'language', subtag: 'smm', prefix: [], scope: null },
    { type: 'language', subtag: 'smn', prefix: [], scope: null },
    { type: 'language', subtag: 'smp', prefix: [], scope: null },
    { type: 'language', subtag: 'smq', prefix: [], scope: null },
    { type: 'language', subtag: 'smr', prefix: [], scope: null },
    { type: 'language', subtag: 'sms', prefix: [], scope: null },
    { type: 'language', subtag: 'smt', prefix: [], scope: null },
    { type: 'language', subtag: 'smu', prefix: [], scope: null },
    { type: 'language', subtag: 'smv', prefix: [], scope: null },
    { type: 'language', subtag: 'smw', prefix: [], scope: null },
    { type: 'language', subtag: 'smx', prefix: [], scope: null },
    { type: 'language', subtag: 'smy', prefix: [], scope: null },
    { type: 'language', subtag: 'smz', prefix: [], scope: null },
    { type: 'language', subtag: 'snb', prefix: [], scope: null },
    { type: 'language', subtag: 'snc', prefix: [], scope: null },
    { type: 'language', subtag: 'sne', prefix: [], scope: null },
    { type: 'language', subtag: 'snf', prefix: [], scope: null },
    { type: 'language', subtag: 'sng', prefix: [], scope: null },
    { type: 'language', subtag: 'snh', prefix: [], scope: null },
    { type: 'language', subtag: 'sni', prefix: [], scope: null },
    { type: 'language', subtag: 'snj', prefix: [], scope: null },
    { type: 'language', subtag: 'snk', prefix: [], scope: null },
    { type: 'language', subtag: 'snl', prefix: [], scope: null },
    { type: 'language', subtag: 'snm', prefix: [], scope: null },
    { type: 'language', subtag: 'snn', prefix: [], scope: null },
    { type: 'language', subtag: 'sno', prefix: [], scope: null },
    { type: 'language', subtag: 'snp', prefix: [], scope: null },
    { type: 'language', subtag: 'snq', prefix: [], scope: null },
    { type: 'language', subtag: 'snr', prefix: [], scope: null },
    { type: 'language', subtag: 'sns', prefix: [], scope: null },
    { type: 'language', subtag: 'snu', prefix: [], scope: null },
    { type: 'language', subtag: 'snv', prefix: [], scope: null },
    { type: 'language', subtag: 'snw', prefix: [], scope: null },
    { type: 'language', subtag: 'snx', prefix: [], scope: null },
    { type: 'language', subtag: 'sny', prefix: [], scope: null },
    { type: 'language', subtag: 'snz', prefix: [], scope: null },
    { type: 'language', subtag: 'soa', prefix: [], scope: null },
    { type: 'language', subtag: 'sob', prefix: [], scope: null },
    { type: 'language', subtag: 'soc', prefix: [], scope: null },
    { type: 'language', subtag: 'sod', prefix: [], scope: null },
    { type: 'language', subtag: 'soe', prefix: [], scope: null },
    { type: 'language', subtag: 'sog', prefix: [], scope: null },
    { type: 'language', subtag: 'soh', prefix: [], scope: null },
    { type: 'language', subtag: 'soi', prefix: [], scope: null },
    { type: 'language', subtag: 'soj', prefix: [], scope: null },
    { type: 'language', subtag: 'sok', prefix: [], scope: null },
    { type: 'language', subtag: 'sol', prefix: [], scope: null },
    { type: 'language', subtag: 'son', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'soo', prefix: [], scope: null },
    { type: 'language', subtag: 'sop', prefix: [], scope: null },
    { type: 'language', subtag: 'soq', prefix: [], scope: null },
    { type: 'language', subtag: 'sor', prefix: [], scope: null },
    { type: 'language', subtag: 'sos', prefix: [], scope: null },
    { type: 'language', subtag: 'sou', prefix: [], scope: null },
    { type: 'language', subtag: 'sov', prefix: [], scope: null },
    { type: 'language', subtag: 'sow', prefix: [], scope: null },
    { type: 'language', subtag: 'sox', prefix: [], scope: null },
    { type: 'language', subtag: 'soy', prefix: [], scope: null },
    { type: 'language', subtag: 'soz', prefix: [], scope: null },
    { type: 'language', subtag: 'spb', prefix: [], scope: null },
    { type: 'language', subtag: 'spc', prefix: [], scope: null },
    { type: 'language', subtag: 'spd', prefix: [], scope: null },
    { type: 'language', subtag: 'spe', prefix: [], scope: null },
    { type: 'language', subtag: 'spg', prefix: [], scope: null },
    { type: 'language', subtag: 'spi', prefix: [], scope: null },
    { type: 'language', subtag: 'spk', prefix: [], scope: null },
    { type: 'language', subtag: 'spl', prefix: [], scope: null },
    { type: 'language', subtag: 'spm', prefix: [], scope: null },
    { type: 'language', subtag: 'spn', prefix: [], scope: null },
    { type: 'language', subtag: 'spo', prefix: [], scope: null },
    { type: 'language', subtag: 'spp', prefix: [], scope: null },
    { type: 'language', subtag: 'spq', prefix: [], scope: null },
    { type: 'language', subtag: 'spr', prefix: [], scope: null },
    { type: 'language', subtag: 'sps', prefix: [], scope: null },
    { type: 'language', subtag: 'spt', prefix: [], scope: null },
    { type: 'language', subtag: 'spu', prefix: [], scope: null },
    { type: 'language', subtag: 'spv', prefix: [], scope: null },
    { type: 'language', subtag: 'spx', prefix: [], scope: null },
    { type: 'language', subtag: 'spy', prefix: [], scope: null },
    { type: 'language', subtag: 'sqa', prefix: [], scope: null },
    { type: 'language', subtag: 'sqh', prefix: [], scope: null },
    { type: 'language', subtag: 'sqj', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'sqk', prefix: [], scope: null },
    { type: 'language', subtag: 'sqm', prefix: [], scope: null },
    { type: 'language', subtag: 'sqn', prefix: [], scope: null },
    { type: 'language', subtag: 'sqo', prefix: [], scope: null },
    { type: 'language', subtag: 'sqq', prefix: [], scope: null },
    { type: 'language', subtag: 'sqr', prefix: [], scope: null },
    { type: 'language', subtag: 'sqs', prefix: [], scope: null },
    { type: 'language', subtag: 'sqt', prefix: [], scope: null },
    { type: 'language', subtag: 'squ', prefix: [], scope: null },
    { type: 'language', subtag: 'sqx', prefix: [], scope: null },
    { type: 'language', subtag: 'sra', prefix: [], scope: null },
    { type: 'language', subtag: 'srb', prefix: [], scope: null },
    { type: 'language', subtag: 'src', prefix: [], scope: null },
    { type: 'language', subtag: 'sre', prefix: [], scope: null },
    { type: 'language', subtag: 'srf', prefix: [], scope: null },
    { type: 'language', subtag: 'srg', prefix: [], scope: null },
    { type: 'language', subtag: 'srh', prefix: [], scope: null },
    { type: 'language', subtag: 'sri', prefix: [], scope: null },
    { type: 'language', subtag: 'srk', prefix: [], scope: null },
    { type: 'language', subtag: 'srl', prefix: [], scope: null },
    { type: 'language', subtag: 'srm', prefix: [], scope: null },
    { type: 'language', subtag: 'srn', prefix: [], scope: null },
    { type: 'language', subtag: 'sro', prefix: [], scope: null },
    { type: 'language', subtag: 'srq', prefix: [], scope: null },
    { type: 'language', subtag: 'srr', prefix: [], scope: null },
    { type: 'language', subtag: 'srs', prefix: [], scope: null },
    { type: 'language', subtag: 'srt', prefix: [], scope: null },
    { type: 'language', subtag: 'sru', prefix: [], scope: null },
    { type: 'language', subtag: 'srv', prefix: [], scope: null },
    { type: 'language', subtag: 'srw', prefix: [], scope: null },
    { type: 'language', subtag: 'srx', prefix: [], scope: null },
    { type: 'language', subtag: 'sry', prefix: [], scope: null },
    { type: 'language', subtag: 'srz', prefix: [], scope: null },
    { type: 'language', subtag: 'ssa', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ssb', prefix: [], scope: null },
    { type: 'language', subtag: 'ssc', prefix: [], scope: null },
    { type: 'language', subtag: 'ssd', prefix: [], scope: null },
    { type: 'language', subtag: 'sse', prefix: [], scope: null },
    { type: 'language', subtag: 'ssf', prefix: [], scope: null },
    { type: 'language', subtag: 'ssg', prefix: [], scope: null },
    { type: 'language', subtag: 'ssh', prefix: [], scope: null },
    { type: 'language', subtag: 'ssi', prefix: [], scope: null },
    { type: 'language', subtag: 'ssj', prefix: [], scope: null },
    { type: 'language', subtag: 'ssk', prefix: [], scope: null },
    { type: 'language', subtag: 'ssl', prefix: [], scope: null },
    { type: 'language', subtag: 'ssm', prefix: [], scope: null },
    { type: 'language', subtag: 'ssn', prefix: [], scope: null },
    { type: 'language', subtag: 'sso', prefix: [], scope: null },
    { type: 'language', subtag: 'ssp', prefix: [], scope: null },
    { type: 'language', subtag: 'ssq', prefix: [], scope: null },
    { type: 'language', subtag: 'ssr', prefix: [], scope: null },
    { type: 'language', subtag: 'sss', prefix: [], scope: null },
    { type: 'language', subtag: 'sst', prefix: [], scope: null },
    { type: 'language', subtag: 'ssu', prefix: [], scope: null },
    { type: 'language', subtag: 'ssv', prefix: [], scope: null },
    { type: 'language', subtag: 'ssx', prefix: [], scope: null },
    { type: 'language', subtag: 'ssy', prefix: [], scope: null },
    { type: 'language', subtag: 'ssz', prefix: [], scope: null },
    { type: 'language', subtag: 'sta', prefix: [], scope: null },
    { type: 'language', subtag: 'stb', prefix: [], scope: null },
    { type: 'language', subtag: 'std', prefix: [], scope: null },
    { type: 'language', subtag: 'ste', prefix: [], scope: null },
    { type: 'language', subtag: 'stf', prefix: [], scope: null },
    { type: 'language', subtag: 'stg', prefix: [], scope: null },
    { type: 'language', subtag: 'sth', prefix: [], scope: null },
    { type: 'language', subtag: 'sti', prefix: [], scope: null },
    { type: 'language', subtag: 'stj', prefix: [], scope: null },
    { type: 'language', subtag: 'stk', prefix: [], scope: null },
    { type: 'language', subtag: 'stl', prefix: [], scope: null },
    { type: 'language', subtag: 'stm', prefix: [], scope: null },
    { type: 'language', subtag: 'stn', prefix: [], scope: null },
    { type: 'language', subtag: 'sto', prefix: [], scope: null },
    { type: 'language', subtag: 'stp', prefix: [], scope: null },
    { type: 'language', subtag: 'stq', prefix: [], scope: null },
    { type: 'language', subtag: 'str', prefix: [], scope: null },
    { type: 'language', subtag: 'sts', prefix: [], scope: null },
    { type: 'language', subtag: 'stt', prefix: [], scope: null },
    { type: 'language', subtag: 'stu', prefix: [], scope: null },
    { type: 'language', subtag: 'stv', prefix: [], scope: null },
    { type: 'language', subtag: 'stw', prefix: [], scope: null },
    { type: 'language', subtag: 'sty', prefix: [], scope: null },
    { type: 'language', subtag: 'sua', prefix: [], scope: null },
    { type: 'language', subtag: 'sub', prefix: [], scope: null },
    { type: 'language', subtag: 'suc', prefix: [], scope: null },
    { type: 'language', subtag: 'sue', prefix: [], scope: null },
    { type: 'language', subtag: 'sug', prefix: [], scope: null },
    { type: 'language', subtag: 'sui', prefix: [], scope: null },
    { type: 'language', subtag: 'suj', prefix: [], scope: null },
    { type: 'language', subtag: 'suk', prefix: [], scope: null },
    { type: 'language', subtag: 'sul', prefix: [], scope: null },
    { type: 'language', subtag: 'sum', prefix: [], scope: null },
    { type: 'language', subtag: 'suo', prefix: [], scope: null },
    { type: 'language', subtag: 'suq', prefix: [], scope: null },
    { type: 'language', subtag: 'sur', prefix: [], scope: null },
    { type: 'language', subtag: 'sus', prefix: [], scope: null },
    { type: 'language', subtag: 'sut', prefix: [], scope: null },
    { type: 'language', subtag: 'suv', prefix: [], scope: null },
    { type: 'language', subtag: 'suw', prefix: [], scope: null },
    { type: 'language', subtag: 'sux', prefix: [], scope: null },
    { type: 'language', subtag: 'suy', prefix: [], scope: null },
    { type: 'language', subtag: 'suz', prefix: [], scope: null },
    { type: 'language', subtag: 'sva', prefix: [], scope: null },
    { type: 'language', subtag: 'svb', prefix: [], scope: null },
    { type: 'language', subtag: 'svc', prefix: [], scope: null },
    { type: 'language', subtag: 'sve', prefix: [], scope: null },
    { type: 'language', subtag: 'svk', prefix: [], scope: null },
    { type: 'language', subtag: 'svm', prefix: [], scope: null },
    { type: 'language', subtag: 'svr', prefix: [], scope: null },
    { type: 'language', subtag: 'svs', prefix: [], scope: null },
    { type: 'language', subtag: 'svx', prefix: [], scope: null },
    { type: 'language', subtag: 'swb', prefix: [], scope: null },
    { type: 'language', subtag: 'swc', prefix: [], scope: null },
    { type: 'language', subtag: 'swf', prefix: [], scope: null },
    { type: 'language', subtag: 'swg', prefix: [], scope: null },
    { type: 'language', subtag: 'swh', prefix: [], scope: null },
    { type: 'language', subtag: 'swi', prefix: [], scope: null },
    { type: 'language', subtag: 'swj', prefix: [], scope: null },
    { type: 'language', subtag: 'swk', prefix: [], scope: null },
    { type: 'language', subtag: 'swl', prefix: [], scope: null },
    { type: 'language', subtag: 'swm', prefix: [], scope: null },
    { type: 'language', subtag: 'swn', prefix: [], scope: null },
    { type: 'language', subtag: 'swo', prefix: [], scope: null },
    { type: 'language', subtag: 'swp', prefix: [], scope: null },
    { type: 'language', subtag: 'swq', prefix: [], scope: null },
    { type: 'language', subtag: 'swr', prefix: [], scope: null },
    { type: 'language', subtag: 'sws', prefix: [], scope: null },
    { type: 'language', subtag: 'swt', prefix: [], scope: null },
    { type: 'language', subtag: 'swu', prefix: [], scope: null },
    { type: 'language', subtag: 'swv', prefix: [], scope: null },
    { type: 'language', subtag: 'sww', prefix: [], scope: null },
    { type: 'language', subtag: 'swx', prefix: [], scope: null },
    { type: 'language', subtag: 'swy', prefix: [], scope: null },
    { type: 'language', subtag: 'sxb', prefix: [], scope: null },
    { type: 'language', subtag: 'sxc', prefix: [], scope: null },
    { type: 'language', subtag: 'sxe', prefix: [], scope: null },
    { type: 'language', subtag: 'sxg', prefix: [], scope: null },
    { type: 'language', subtag: 'sxk', prefix: [], scope: null },
    { type: 'language', subtag: 'sxl', prefix: [], scope: null },
    { type: 'language', subtag: 'sxm', prefix: [], scope: null },
    { type: 'language', subtag: 'sxn', prefix: [], scope: null },
    { type: 'language', subtag: 'sxo', prefix: [], scope: null },
    { type: 'language', subtag: 'sxr', prefix: [], scope: null },
    { type: 'language', subtag: 'sxs', prefix: [], scope: null },
    { type: 'language', subtag: 'sxu', prefix: [], scope: null },
    { type: 'language', subtag: 'sxw', prefix: [], scope: null },
    { type: 'language', subtag: 'sya', prefix: [], scope: null },
    { type: 'language', subtag: 'syb', prefix: [], scope: null },
    { type: 'language', subtag: 'syc', prefix: [], scope: null },
    { type: 'language', subtag: 'syd', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'syi', prefix: [], scope: null },
    { type: 'language', subtag: 'syk', prefix: [], scope: null },
    { type: 'language', subtag: 'syl', prefix: [], scope: null },
    { type: 'language', subtag: 'sym', prefix: [], scope: null },
    { type: 'language', subtag: 'syn', prefix: [], scope: null },
    { type: 'language', subtag: 'syo', prefix: [], scope: null },
    { type: 'language', subtag: 'syr', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'sys', prefix: [], scope: null },
    { type: 'language', subtag: 'syw', prefix: [], scope: null },
    { type: 'language', subtag: 'syx', prefix: [], scope: null },
    { type: 'language', subtag: 'syy', prefix: [], scope: null },
    { type: 'language', subtag: 'sza', prefix: [], scope: null },
    { type: 'language', subtag: 'szb', prefix: [], scope: null },
    { type: 'language', subtag: 'szc', prefix: [], scope: null },
    { type: 'language', subtag: 'szd', prefix: [], scope: null },
    { type: 'language', subtag: 'sze', prefix: [], scope: null },
    { type: 'language', subtag: 'szg', prefix: [], scope: null },
    { type: 'language', subtag: 'szl', prefix: [], scope: null },
    { type: 'language', subtag: 'szn', prefix: [], scope: null },
    { type: 'language', subtag: 'szp', prefix: [], scope: null },
    { type: 'language', subtag: 'szs', prefix: [], scope: null },
    { type: 'language', subtag: 'szv', prefix: [], scope: null },
    { type: 'language', subtag: 'szw', prefix: [], scope: null },
    { type: 'language', subtag: 'szy', prefix: [], scope: null },
    { type: 'language', subtag: 'taa', prefix: [], scope: null },
    { type: 'language', subtag: 'tab', prefix: [], scope: null },
    { type: 'language', subtag: 'tac', prefix: [], scope: null },
    { type: 'language', subtag: 'tad', prefix: [], scope: null },
    { type: 'language', subtag: 'tae', prefix: [], scope: null },
    { type: 'language', subtag: 'taf', prefix: [], scope: null },
    { type: 'language', subtag: 'tag', prefix: [], scope: null },
    { type: 'language', subtag: 'tai', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'taj', prefix: [], scope: null },
    { type: 'language', subtag: 'tak', prefix: [], scope: null },
    { type: 'language', subtag: 'tal', prefix: [], scope: null },
    { type: 'language', subtag: 'tan', prefix: [], scope: null },
    { type: 'language', subtag: 'tao', prefix: [], scope: null },
    { type: 'language', subtag: 'tap', prefix: [], scope: null },
    { type: 'language', subtag: 'taq', prefix: [], scope: null },
    { type: 'language', subtag: 'tar', prefix: [], scope: null },
    { type: 'language', subtag: 'tas', prefix: [], scope: null },
    { type: 'language', subtag: 'tau', prefix: [], scope: null },
    { type: 'language', subtag: 'tav', prefix: [], scope: null },
    { type: 'language', subtag: 'taw', prefix: [], scope: null },
    { type: 'language', subtag: 'tax', prefix: [], scope: null },
    { type: 'language', subtag: 'tay', prefix: [], scope: null },
    { type: 'language', subtag: 'taz', prefix: [], scope: null },
    { type: 'language', subtag: 'tba', prefix: [], scope: null },
    { type: 'language', subtag: 'tbb', prefix: [], scope: null },
    { type: 'language', subtag: 'tbc', prefix: [], scope: null },
    { type: 'language', subtag: 'tbd', prefix: [], scope: null },
    { type: 'language', subtag: 'tbe', prefix: [], scope: null },
    { type: 'language', subtag: 'tbf', prefix: [], scope: null },
    { type: 'language', subtag: 'tbg', prefix: [], scope: null },
    { type: 'language', subtag: 'tbh', prefix: [], scope: null },
    { type: 'language', subtag: 'tbi', prefix: [], scope: null },
    { type: 'language', subtag: 'tbj', prefix: [], scope: null },
    { type: 'language', subtag: 'tbk', prefix: [], scope: null },
    { type: 'language', subtag: 'tbl', prefix: [], scope: null },
    { type: 'language', subtag: 'tbm', prefix: [], scope: null },
    { type: 'language', subtag: 'tbn', prefix: [], scope: null },
    { type: 'language', subtag: 'tbo', prefix: [], scope: null },
    { type: 'language', subtag: 'tbp', prefix: [], scope: null },
    { type: 'language', subtag: 'tbq', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'tbr', prefix: [], scope: null },
    { type: 'language', subtag: 'tbs', prefix: [], scope: null },
    { type: 'language', subtag: 'tbt', prefix: [], scope: null },
    { type: 'language', subtag: 'tbu', prefix: [], scope: null },
    { type: 'language', subtag: 'tbv', prefix: [], scope: null },
    { type: 'language', subtag: 'tbw', prefix: [], scope: null },
    { type: 'language', subtag: 'tbx', prefix: [], scope: null },
    { type: 'language', subtag: 'tby', prefix: [], scope: null },
    { type: 'language', subtag: 'tbz', prefix: [], scope: null },
    { type: 'language', subtag: 'tca', prefix: [], scope: null },
    { type: 'language', subtag: 'tcb', prefix: [], scope: null },
    { type: 'language', subtag: 'tcc', prefix: [], scope: null },
    { type: 'language', subtag: 'tcd', prefix: [], scope: null },
    { type: 'language', subtag: 'tce', prefix: [], scope: null },
    { type: 'language', subtag: 'tcf', prefix: [], scope: null },
    { type: 'language', subtag: 'tcg', prefix: [], scope: null },
    { type: 'language', subtag: 'tch', prefix: [], scope: null },
    { type: 'language', subtag: 'tci', prefix: [], scope: null },
    { type: 'language', subtag: 'tck', prefix: [], scope: null },
    { type: 'language', subtag: 'tcl', prefix: [], scope: null },
    { type: 'language', subtag: 'tcm', prefix: [], scope: null },
    { type: 'language', subtag: 'tcn', prefix: [], scope: null },
    { type: 'language', subtag: 'tco', prefix: [], scope: null },
    { type: 'language', subtag: 'tcp', prefix: [], scope: null },
    { type: 'language', subtag: 'tcq', prefix: [], scope: null },
    { type: 'language', subtag: 'tcs', prefix: [], scope: null },
    { type: 'language', subtag: 'tct', prefix: [], scope: null },
    { type: 'language', subtag: 'tcu', prefix: [], scope: null },
    { type: 'language', subtag: 'tcw', prefix: [], scope: null },
    { type: 'language', subtag: 'tcx', prefix: [], scope: null },
    { type: 'language', subtag: 'tcy', prefix: [], scope: null },
    { type: 'language', subtag: 'tcz', prefix: [], scope: null },
    { type: 'language', subtag: 'tda', prefix: [], scope: null },
    { type: 'language', subtag: 'tdb', prefix: [], scope: null },
    { type: 'language', subtag: 'tdc', prefix: [], scope: null },
    { type: 'language', subtag: 'tdd', prefix: [], scope: null },
    { type: 'language', subtag: 'tde', prefix: [], scope: null },
    { type: 'language', subtag: 'tdf', prefix: [], scope: null },
    { type: 'language', subtag: 'tdg', prefix: [], scope: null },
    { type: 'language', subtag: 'tdh', prefix: [], scope: null },
    { type: 'language', subtag: 'tdi', prefix: [], scope: null },
    { type: 'language', subtag: 'tdj', prefix: [], scope: null },
    { type: 'language', subtag: 'tdk', prefix: [], scope: null },
    { type: 'language', subtag: 'tdl', prefix: [], scope: null },
    { type: 'language', subtag: 'tdm', prefix: [], scope: null },
    { type: 'language', subtag: 'tdn', prefix: [], scope: null },
    { type: 'language', subtag: 'tdo', prefix: [], scope: null },
    { type: 'language', subtag: 'tdq', prefix: [], scope: null },
    { type: 'language', subtag: 'tdr', prefix: [], scope: null },
    { type: 'language', subtag: 'tds', prefix: [], scope: null },
    { type: 'language', subtag: 'tdt', prefix: [], scope: null },
    { type: 'language', subtag: 'tdu', prefix: [], scope: null },
    { type: 'language', subtag: 'tdv', prefix: [], scope: null },
    { type: 'language', subtag: 'tdx', prefix: [], scope: null },
    { type: 'language', subtag: 'tdy', prefix: [], scope: null },
    { type: 'language', subtag: 'tea', prefix: [], scope: null },
    { type: 'language', subtag: 'teb', prefix: [], scope: null },
    { type: 'language', subtag: 'tec', prefix: [], scope: null },
    { type: 'language', subtag: 'ted', prefix: [], scope: null },
    { type: 'language', subtag: 'tee', prefix: [], scope: null },
    { type: 'language', subtag: 'tef', prefix: [], scope: null },
    { type: 'language', subtag: 'teg', prefix: [], scope: null },
    { type: 'language', subtag: 'teh', prefix: [], scope: null },
    { type: 'language', subtag: 'tei', prefix: [], scope: null },
    { type: 'language', subtag: 'tek', prefix: [], scope: null },
    { type: 'language', subtag: 'tem', prefix: [], scope: null },
    { type: 'language', subtag: 'ten', prefix: [], scope: null },
    { type: 'language', subtag: 'teo', prefix: [], scope: null },
    { type: 'language', subtag: 'tep', prefix: [], scope: null },
    { type: 'language', subtag: 'teq', prefix: [], scope: null },
    { type: 'language', subtag: 'ter', prefix: [], scope: null },
    { type: 'language', subtag: 'tes', prefix: [], scope: null },
    { type: 'language', subtag: 'tet', prefix: [], scope: null },
    { type: 'language', subtag: 'teu', prefix: [], scope: null },
    { type: 'language', subtag: 'tev', prefix: [], scope: null },
    { type: 'language', subtag: 'tew', prefix: [], scope: null },
    { type: 'language', subtag: 'tex', prefix: [], scope: null },
    { type: 'language', subtag: 'tey', prefix: [], scope: null },
    { type: 'language', subtag: 'tez', prefix: [], scope: null },
    { type: 'language', subtag: 'tfi', prefix: [], scope: null },
    { type: 'language', subtag: 'tfn', prefix: [], scope: null },
    { type: 'language', subtag: 'tfo', prefix: [], scope: null },
    { type: 'language', subtag: 'tfr', prefix: [], scope: null },
    { type: 'language', subtag: 'tft', prefix: [], scope: null },
    { type: 'language', subtag: 'tga', prefix: [], scope: null },
    { type: 'language', subtag: 'tgb', prefix: [], scope: null },
    { type: 'language', subtag: 'tgc', prefix: [], scope: null },
    { type: 'language', subtag: 'tgd', prefix: [], scope: null },
    { type: 'language', subtag: 'tge', prefix: [], scope: null },
    { type: 'language', subtag: 'tgf', prefix: [], scope: null },
    { type: 'language', subtag: 'tgg', prefix: [], scope: null },
    { type: 'language', subtag: 'tgh', prefix: [], scope: null },
    { type: 'language', subtag: 'tgi', prefix: [], scope: null },
    { type: 'language', subtag: 'tgj', prefix: [], scope: null },
    { type: 'language', subtag: 'tgn', prefix: [], scope: null },
    { type: 'language', subtag: 'tgo', prefix: [], scope: null },
    { type: 'language', subtag: 'tgp', prefix: [], scope: null },
    { type: 'language', subtag: 'tgq', prefix: [], scope: null },
    { type: 'language', subtag: 'tgr', prefix: [], scope: null },
    { type: 'language', subtag: 'tgs', prefix: [], scope: null },
    { type: 'language', subtag: 'tgt', prefix: [], scope: null },
    { type: 'language', subtag: 'tgu', prefix: [], scope: null },
    { type: 'language', subtag: 'tgv', prefix: [], scope: null },
    { type: 'language', subtag: 'tgw', prefix: [], scope: null },
    { type: 'language', subtag: 'tgx', prefix: [], scope: null },
    { type: 'language', subtag: 'tgy', prefix: [], scope: null },
    { type: 'language', subtag: 'tgz', prefix: [], scope: null },
    { type: 'language', subtag: 'thc', prefix: [], scope: null },
    { type: 'language', subtag: 'thd', prefix: [], scope: null },
    { type: 'language', subtag: 'the', prefix: [], scope: null },
    { type: 'language', subtag: 'thf', prefix: [], scope: null },
    { type: 'language', subtag: 'thh', prefix: [], scope: null },
    { type: 'language', subtag: 'thi', prefix: [], scope: null },
    { type: 'language', subtag: 'thk', prefix: [], scope: null },
    { type: 'language', subtag: 'thl', prefix: [], scope: null },
    { type: 'language', subtag: 'thm', prefix: [], scope: null },
    { type: 'language', subtag: 'thn', prefix: [], scope: null },
    { type: 'language', subtag: 'thp', prefix: [], scope: null },
    { type: 'language', subtag: 'thq', prefix: [], scope: null },
    { type: 'language', subtag: 'thr', prefix: [], scope: null },
    { type: 'language', subtag: 'ths', prefix: [], scope: null },
    { type: 'language', subtag: 'tht', prefix: [], scope: null },
    { type: 'language', subtag: 'thu', prefix: [], scope: null },
    { type: 'language', subtag: 'thv', prefix: [], scope: null },
    { type: 'language', subtag: 'thw', prefix: [], scope: null },
    { type: 'language', subtag: 'thx', prefix: [], scope: null },
    { type: 'language', subtag: 'thy', prefix: [], scope: null },
    { type: 'language', subtag: 'thz', prefix: [], scope: null },
    { type: 'language', subtag: 'tia', prefix: [], scope: null },
    { type: 'language', subtag: 'tic', prefix: [], scope: null },
    { type: 'language', subtag: 'tid', prefix: [], scope: null },
    { type: 'language', subtag: 'tie', prefix: [], scope: null },
    { type: 'language', subtag: 'tif', prefix: [], scope: null },
    { type: 'language', subtag: 'tig', prefix: [], scope: null },
    { type: 'language', subtag: 'tih', prefix: [], scope: null },
    { type: 'language', subtag: 'tii', prefix: [], scope: null },
    { type: 'language', subtag: 'tij', prefix: [], scope: null },
    { type: 'language', subtag: 'tik', prefix: [], scope: null },
    { type: 'language', subtag: 'til', prefix: [], scope: null },
    { type: 'language', subtag: 'tim', prefix: [], scope: null },
    { type: 'language', subtag: 'tin', prefix: [], scope: null },
    { type: 'language', subtag: 'tio', prefix: [], scope: null },
    { type: 'language', subtag: 'tip', prefix: [], scope: null },
    { type: 'language', subtag: 'tiq', prefix: [], scope: null },
    { type: 'language', subtag: 'tis', prefix: [], scope: null },
    { type: 'language', subtag: 'tit', prefix: [], scope: null },
    { type: 'language', subtag: 'tiu', prefix: [], scope: null },
    { type: 'language', subtag: 'tiv', prefix: [], scope: null },
    { type: 'language', subtag: 'tiw', prefix: [], scope: null },
    { type: 'language', subtag: 'tix', prefix: [], scope: null },
    { type: 'language', subtag: 'tiy', prefix: [], scope: null },
    { type: 'language', subtag: 'tiz', prefix: [], scope: null },
    { type: 'language', subtag: 'tja', prefix: [], scope: null },
    { type: 'language', subtag: 'tjg', prefix: [], scope: null },
    { type: 'language', subtag: 'tji', prefix: [], scope: null },
    { type: 'language', subtag: 'tjj', prefix: [], scope: null },
    { type: 'language', subtag: 'tjl', prefix: [], scope: null },
    { type: 'language', subtag: 'tjm', prefix: [], scope: null },
    { type: 'language', subtag: 'tjn', prefix: [], scope: null },
    { type: 'language', subtag: 'tjo', prefix: [], scope: null },
    { type: 'language', subtag: 'tjp', prefix: [], scope: null },
    { type: 'language', subtag: 'tjs', prefix: [], scope: null },
    { type: 'language', subtag: 'tju', prefix: [], scope: null },
    { type: 'language', subtag: 'tjw', prefix: [], scope: null },
    { type: 'language', subtag: 'tka', prefix: [], scope: null },
    { type: 'language', subtag: 'tkb', prefix: [], scope: null },
    { type: 'language', subtag: 'tkd', prefix: [], scope: null },
    { type: 'language', subtag: 'tke', prefix: [], scope: null },
    { type: 'language', subtag: 'tkf', prefix: [], scope: null },
    { type: 'language', subtag: 'tkg', prefix: [], scope: null },
    { type: 'language', subtag: 'tkk', prefix: [], scope: null },
    { type: 'language', subtag: 'tkl', prefix: [], scope: null },
    { type: 'language', subtag: 'tkm', prefix: [], scope: null },
    { type: 'language', subtag: 'tkn', prefix: [], scope: null },
    { type: 'language', subtag: 'tkp', prefix: [], scope: null },
    { type: 'language', subtag: 'tkq', prefix: [], scope: null },
    { type: 'language', subtag: 'tkr', prefix: [], scope: null },
    { type: 'language', subtag: 'tks', prefix: [], scope: null },
    { type: 'language', subtag: 'tkt', prefix: [], scope: null },
    { type: 'language', subtag: 'tku', prefix: [], scope: null },
    { type: 'language', subtag: 'tkv', prefix: [], scope: null },
    { type: 'language', subtag: 'tkw', prefix: [], scope: null },
    { type: 'language', subtag: 'tkx', prefix: [], scope: null },
    { type: 'language', subtag: 'tkz', prefix: [], scope: null },
    { type: 'language', subtag: 'tla', prefix: [], scope: null },
    { type: 'language', subtag: 'tlb', prefix: [], scope: null },
    { type: 'language', subtag: 'tlc', prefix: [], scope: null },
    { type: 'language', subtag: 'tld', prefix: [], scope: null },
    { type: 'language', subtag: 'tlf', prefix: [], scope: null },
    { type: 'language', subtag: 'tlg', prefix: [], scope: null },
    { type: 'language', subtag: 'tlh', prefix: [], scope: null },
    { type: 'language', subtag: 'tli', prefix: [], scope: null },
    { type: 'language', subtag: 'tlj', prefix: [], scope: null },
    { type: 'language', subtag: 'tlk', prefix: [], scope: null },
    { type: 'language', subtag: 'tll', prefix: [], scope: null },
    { type: 'language', subtag: 'tlm', prefix: [], scope: null },
    { type: 'language', subtag: 'tln', prefix: [], scope: null },
    { type: 'language', subtag: 'tlo', prefix: [], scope: null },
    { type: 'language', subtag: 'tlp', prefix: [], scope: null },
    { type: 'language', subtag: 'tlq', prefix: [], scope: null },
    { type: 'language', subtag: 'tlr', prefix: [], scope: null },
    { type: 'language', subtag: 'tls', prefix: [], scope: null },
    { type: 'language', subtag: 'tlt', prefix: [], scope: null },
    { type: 'language', subtag: 'tlu', prefix: [], scope: null },
    { type: 'language', subtag: 'tlv', prefix: [], scope: null },
    { type: 'language', subtag: 'tlw', prefix: [], scope: null },
    { type: 'language', subtag: 'tlx', prefix: [], scope: null },
    { type: 'language', subtag: 'tly', prefix: [], scope: null },
    { type: 'language', subtag: 'tma', prefix: [], scope: null },
    { type: 'language', subtag: 'tmb', prefix: [], scope: null },
    { type: 'language', subtag: 'tmc', prefix: [], scope: null },
    { type: 'language', subtag: 'tmd', prefix: [], scope: null },
    { type: 'language', subtag: 'tme', prefix: [], scope: null },
    { type: 'language', subtag: 'tmf', prefix: [], scope: null },
    { type: 'language', subtag: 'tmg', prefix: [], scope: null },
    { type: 'language', subtag: 'tmh', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'tmi', prefix: [], scope: null },
    { type: 'language', subtag: 'tmj', prefix: [], scope: null },
    { type: 'language', subtag: 'tmk', prefix: [], scope: null },
    { type: 'language', subtag: 'tml', prefix: [], scope: null },
    { type: 'language', subtag: 'tmm', prefix: [], scope: null },
    { type: 'language', subtag: 'tmn', prefix: [], scope: null },
    { type: 'language', subtag: 'tmo', prefix: [], scope: null },
    { type: 'language', subtag: 'tmp', prefix: [], scope: null },
    { type: 'language', subtag: 'tmq', prefix: [], scope: null },
    { type: 'language', subtag: 'tmr', prefix: [], scope: null },
    { type: 'language', subtag: 'tms', prefix: [], scope: null },
    { type: 'language', subtag: 'tmt', prefix: [], scope: null },
    { type: 'language', subtag: 'tmu', prefix: [], scope: null },
    { type: 'language', subtag: 'tmv', prefix: [], scope: null },
    { type: 'language', subtag: 'tmw', prefix: [], scope: null },
    { type: 'language', subtag: 'tmy', prefix: [], scope: null },
    { type: 'language', subtag: 'tmz', prefix: [], scope: null },
    { type: 'language', subtag: 'tna', prefix: [], scope: null },
    { type: 'language', subtag: 'tnb', prefix: [], scope: null },
    { type: 'language', subtag: 'tnc', prefix: [], scope: null },
    { type: 'language', subtag: 'tnd', prefix: [], scope: null },
    { type: 'language', subtag: 'tne', prefix: [], scope: null },
    { type: 'language', subtag: 'tnf', prefix: [], scope: null },
    { type: 'language', subtag: 'tng', prefix: [], scope: null },
    { type: 'language', subtag: 'tnh', prefix: [], scope: null },
    { type: 'language', subtag: 'tni', prefix: [], scope: null },
    { type: 'language', subtag: 'tnk', prefix: [], scope: null },
    { type: 'language', subtag: 'tnl', prefix: [], scope: null },
    { type: 'language', subtag: 'tnm', prefix: [], scope: null },
    { type: 'language', subtag: 'tnn', prefix: [], scope: null },
    { type: 'language', subtag: 'tno', prefix: [], scope: null },
    { type: 'language', subtag: 'tnp', prefix: [], scope: null },
    { type: 'language', subtag: 'tnq', prefix: [], scope: null },
    { type: 'language', subtag: 'tnr', prefix: [], scope: null },
    { type: 'language', subtag: 'tns', prefix: [], scope: null },
    { type: 'language', subtag: 'tnt', prefix: [], scope: null },
    { type: 'language', subtag: 'tnu', prefix: [], scope: null },
    { type: 'language', subtag: 'tnv', prefix: [], scope: null },
    { type: 'language', subtag: 'tnw', prefix: [], scope: null },
    { type: 'language', subtag: 'tnx', prefix: [], scope: null },
    { type: 'language', subtag: 'tny', prefix: [], scope: null },
    { type: 'language', subtag: 'tnz', prefix: [], scope: null },
    { type: 'language', subtag: 'tob', prefix: [], scope: null },
    { type: 'language', subtag: 'toc', prefix: [], scope: null },
    { type: 'language', subtag: 'tod', prefix: [], scope: null },
    { type: 'language', subtag: 'toe', prefix: [], scope: null },
    { type: 'language', subtag: 'tof', prefix: [], scope: null },
    { type: 'language', subtag: 'tog', prefix: [], scope: null },
    { type: 'language', subtag: 'toh', prefix: [], scope: null },
    { type: 'language', subtag: 'toi', prefix: [], scope: null },
    { type: 'language', subtag: 'toj', prefix: [], scope: null },
    { type: 'language', subtag: 'tok', prefix: [], scope: null },
    { type: 'language', subtag: 'tol', prefix: [], scope: null },
    { type: 'language', subtag: 'tom', prefix: [], scope: null },
    { type: 'language', subtag: 'too', prefix: [], scope: null },
    { type: 'language', subtag: 'top', prefix: [], scope: null },
    { type: 'language', subtag: 'toq', prefix: [], scope: null },
    { type: 'language', subtag: 'tor', prefix: [], scope: null },
    { type: 'language', subtag: 'tos', prefix: [], scope: null },
    { type: 'language', subtag: 'tou', prefix: [], scope: null },
    { type: 'language', subtag: 'tov', prefix: [], scope: null },
    { type: 'language', subtag: 'tow', prefix: [], scope: null },
    { type: 'language', subtag: 'tox', prefix: [], scope: null },
    { type: 'language', subtag: 'toy', prefix: [], scope: null },
    { type: 'language', subtag: 'toz', prefix: [], scope: null },
    { type: 'language', subtag: 'tpa', prefix: [], scope: null },
    { type: 'language', subtag: 'tpc', prefix: [], scope: null },
    { type: 'language', subtag: 'tpe', prefix: [], scope: null },
    { type: 'language', subtag: 'tpf', prefix: [], scope: null },
    { type: 'language', subtag: 'tpg', prefix: [], scope: null },
    { type: 'language', subtag: 'tpi', prefix: [], scope: null },
    { type: 'language', subtag: 'tpj', prefix: [], scope: null },
    { type: 'language', subtag: 'tpk', prefix: [], scope: null },
    { type: 'language', subtag: 'tpl', prefix: [], scope: null },
    { type: 'language', subtag: 'tpm', prefix: [], scope: null },
    { type: 'language', subtag: 'tpn', prefix: [], scope: null },
    { type: 'language', subtag: 'tpo', prefix: [], scope: null },
    { type: 'language', subtag: 'tpp', prefix: [], scope: null },
    { type: 'language', subtag: 'tpq', prefix: [], scope: null },
    { type: 'language', subtag: 'tpr', prefix: [], scope: null },
    { type: 'language', subtag: 'tpt', prefix: [], scope: null },
    { type: 'language', subtag: 'tpu', prefix: [], scope: null },
    { type: 'language', subtag: 'tpv', prefix: [], scope: null },
    { type: 'language', subtag: 'tpw', prefix: [], scope: null },
    { type: 'language', subtag: 'tpx', prefix: [], scope: null },
    { type: 'language', subtag: 'tpy', prefix: [], scope: null },
    { type: 'language', subtag: 'tpz', prefix: [], scope: null },
    { type: 'language', subtag: 'tqb', prefix: [], scope: null },
    { type: 'language', subtag: 'tql', prefix: [], scope: null },
    { type: 'language', subtag: 'tqm', prefix: [], scope: null },
    { type: 'language', subtag: 'tqn', prefix: [], scope: null },
    { type: 'language', subtag: 'tqo', prefix: [], scope: null },
    { type: 'language', subtag: 'tqp', prefix: [], scope: null },
    { type: 'language', subtag: 'tqq', prefix: [], scope: null },
    { type: 'language', subtag: 'tqr', prefix: [], scope: null },
    { type: 'language', subtag: 'tqt', prefix: [], scope: null },
    { type: 'language', subtag: 'tqu', prefix: [], scope: null },
    { type: 'language', subtag: 'tqw', prefix: [], scope: null },
    { type: 'language', subtag: 'tra', prefix: [], scope: null },
    { type: 'language', subtag: 'trb', prefix: [], scope: null },
    { type: 'language', subtag: 'trc', prefix: [], scope: null },
    { type: 'language', subtag: 'trd', prefix: [], scope: null },
    { type: 'language', subtag: 'tre', prefix: [], scope: null },
    { type: 'language', subtag: 'trf', prefix: [], scope: null },
    { type: 'language', subtag: 'trg', prefix: [], scope: null },
    { type: 'language', subtag: 'trh', prefix: [], scope: null },
    { type: 'language', subtag: 'tri', prefix: [], scope: null },
    { type: 'language', subtag: 'trj', prefix: [], scope: null },
    { type: 'language', subtag: 'trk', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'trl', prefix: [], scope: null },
    { type: 'language', subtag: 'trm', prefix: [], scope: null },
    { type: 'language', subtag: 'trn', prefix: [], scope: null },
    { type: 'language', subtag: 'tro', prefix: [], scope: null },
    { type: 'language', subtag: 'trp', prefix: [], scope: null },
    { type: 'language', subtag: 'trq', prefix: [], scope: null },
    { type: 'language', subtag: 'trr', prefix: [], scope: null },
    { type: 'language', subtag: 'trs', prefix: [], scope: null },
    { type: 'language', subtag: 'trt', prefix: [], scope: null },
    { type: 'language', subtag: 'tru', prefix: [], scope: null },
    { type: 'language', subtag: 'trv', prefix: [], scope: null },
    { type: 'language', subtag: 'trw', prefix: [], scope: null },
    { type: 'language', subtag: 'trx', prefix: [], scope: null },
    { type: 'language', subtag: 'try', prefix: [], scope: null },
    { type: 'language', subtag: 'trz', prefix: [], scope: null },
    { type: 'language', subtag: 'tsa', prefix: [], scope: null },
    { type: 'language', subtag: 'tsb', prefix: [], scope: null },
    { type: 'language', subtag: 'tsc', prefix: [], scope: null },
    { type: 'language', subtag: 'tsd', prefix: [], scope: null },
    { type: 'language', subtag: 'tse', prefix: [], scope: null },
    { type: 'language', subtag: 'tsf', prefix: [], scope: null },
    { type: 'language', subtag: 'tsg', prefix: [], scope: null },
    { type: 'language', subtag: 'tsh', prefix: [], scope: null },
    { type: 'language', subtag: 'tsi', prefix: [], scope: null },
    { type: 'language', subtag: 'tsj', prefix: [], scope: null },
    { type: 'language', subtag: 'tsk', prefix: [], scope: null },
    { type: 'language', subtag: 'tsl', prefix: [], scope: null },
    { type: 'language', subtag: 'tsm', prefix: [], scope: null },
    { type: 'language', subtag: 'tsp', prefix: [], scope: null },
    { type: 'language', subtag: 'tsq', prefix: [], scope: null },
    { type: 'language', subtag: 'tsr', prefix: [], scope: null },
    { type: 'language', subtag: 'tss', prefix: [], scope: null },
    { type: 'language', subtag: 'tst', prefix: [], scope: null },
    { type: 'language', subtag: 'tsu', prefix: [], scope: null },
    { type: 'language', subtag: 'tsv', prefix: [], scope: null },
    { type: 'language', subtag: 'tsw', prefix: [], scope: null },
    { type: 'language', subtag: 'tsx', prefix: [], scope: null },
    { type: 'language', subtag: 'tsy', prefix: [], scope: null },
    { type: 'language', subtag: 'tsz', prefix: [], scope: null },
    { type: 'language', subtag: 'tta', prefix: [], scope: null },
    { type: 'language', subtag: 'ttb', prefix: [], scope: null },
    { type: 'language', subtag: 'ttc', prefix: [], scope: null },
    { type: 'language', subtag: 'ttd', prefix: [], scope: null },
    { type: 'language', subtag: 'tte', prefix: [], scope: null },
    { type: 'language', subtag: 'ttf', prefix: [], scope: null },
    { type: 'language', subtag: 'ttg', prefix: [], scope: null },
    { type: 'language', subtag: 'tth', prefix: [], scope: null },
    { type: 'language', subtag: 'tti', prefix: [], scope: null },
    { type: 'language', subtag: 'ttj', prefix: [], scope: null },
    { type: 'language', subtag: 'ttk', prefix: [], scope: null },
    { type: 'language', subtag: 'ttl', prefix: [], scope: null },
    { type: 'language', subtag: 'ttm', prefix: [], scope: null },
    { type: 'language', subtag: 'ttn', prefix: [], scope: null },
    { type: 'language', subtag: 'tto', prefix: [], scope: null },
    { type: 'language', subtag: 'ttp', prefix: [], scope: null },
    { type: 'language', subtag: 'ttq', prefix: [], scope: null },
    { type: 'language', subtag: 'ttr', prefix: [], scope: null },
    { type: 'language', subtag: 'tts', prefix: [], scope: null },
    { type: 'language', subtag: 'ttt', prefix: [], scope: null },
    { type: 'language', subtag: 'ttu', prefix: [], scope: null },
    { type: 'language', subtag: 'ttv', prefix: [], scope: null },
    { type: 'language', subtag: 'ttw', prefix: [], scope: null },
    { type: 'language', subtag: 'tty', prefix: [], scope: null },
    { type: 'language', subtag: 'ttz', prefix: [], scope: null },
    { type: 'language', subtag: 'tua', prefix: [], scope: null },
    { type: 'language', subtag: 'tub', prefix: [], scope: null },
    { type: 'language', subtag: 'tuc', prefix: [], scope: null },
    { type: 'language', subtag: 'tud', prefix: [], scope: null },
    { type: 'language', subtag: 'tue', prefix: [], scope: null },
    { type: 'language', subtag: 'tuf', prefix: [], scope: null },
    { type: 'language', subtag: 'tug', prefix: [], scope: null },
    { type: 'language', subtag: 'tuh', prefix: [], scope: null },
    { type: 'language', subtag: 'tui', prefix: [], scope: null },
    { type: 'language', subtag: 'tuj', prefix: [], scope: null },
    { type: 'language', subtag: 'tul', prefix: [], scope: null },
    { type: 'language', subtag: 'tum', prefix: [], scope: null },
    { type: 'language', subtag: 'tun', prefix: [], scope: null },
    { type: 'language', subtag: 'tuo', prefix: [], scope: null },
    { type: 'language', subtag: 'tup', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'tuq', prefix: [], scope: null },
    { type: 'language', subtag: 'tus', prefix: [], scope: null },
    { type: 'language', subtag: 'tut', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'tuu', prefix: [], scope: null },
    { type: 'language', subtag: 'tuv', prefix: [], scope: null },
    { type: 'language', subtag: 'tuw', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'tux', prefix: [], scope: null },
    { type: 'language', subtag: 'tuy', prefix: [], scope: null },
    { type: 'language', subtag: 'tuz', prefix: [], scope: null },
    { type: 'language', subtag: 'tva', prefix: [], scope: null },
    { type: 'language', subtag: 'tvd', prefix: [], scope: null },
    { type: 'language', subtag: 'tve', prefix: [], scope: null },
    { type: 'language', subtag: 'tvk', prefix: [], scope: null },
    { type: 'language', subtag: 'tvl', prefix: [], scope: null },
    { type: 'language', subtag: 'tvm', prefix: [], scope: null },
    { type: 'language', subtag: 'tvn', prefix: [], scope: null },
    { type: 'language', subtag: 'tvo', prefix: [], scope: null },
    { type: 'language', subtag: 'tvs', prefix: [], scope: null },
    { type: 'language', subtag: 'tvt', prefix: [], scope: null },
    { type: 'language', subtag: 'tvu', prefix: [], scope: null },
    { type: 'language', subtag: 'tvw', prefix: [], scope: null },
    { type: 'language', subtag: 'tvx', prefix: [], scope: null },
    { type: 'language', subtag: 'tvy', prefix: [], scope: null },
    { type: 'language', subtag: 'twa', prefix: [], scope: null },
    { type: 'language', subtag: 'twb', prefix: [], scope: null },
    { type: 'language', subtag: 'twc', prefix: [], scope: null },
    { type: 'language', subtag: 'twd', prefix: [], scope: null },
    { type: 'language', subtag: 'twe', prefix: [], scope: null },
    { type: 'language', subtag: 'twf', prefix: [], scope: null },
    { type: 'language', subtag: 'twg', prefix: [], scope: null },
    { type: 'language', subtag: 'twh', prefix: [], scope: null },
    { type: 'language', subtag: 'twl', prefix: [], scope: null },
    { type: 'language', subtag: 'twm', prefix: [], scope: null },
    { type: 'language', subtag: 'twn', prefix: [], scope: null },
    { type: 'language', subtag: 'two', prefix: [], scope: null },
    { type: 'language', subtag: 'twp', prefix: [], scope: null },
    { type: 'language', subtag: 'twq', prefix: [], scope: null },
    { type: 'language', subtag: 'twr', prefix: [], scope: null },
    { type: 'language', subtag: 'twt', prefix: [], scope: null },
    { type: 'language', subtag: 'twu', prefix: [], scope: null },
    { type: 'language', subtag: 'tww', prefix: [], scope: null },
    { type: 'language', subtag: 'twx', prefix: [], scope: null },
    { type: 'language', subtag: 'twy', prefix: [], scope: null },
    { type: 'language', subtag: 'txa', prefix: [], scope: null },
    { type: 'language', subtag: 'txb', prefix: [], scope: null },
    { type: 'language', subtag: 'txc', prefix: [], scope: null },
    { type: 'language', subtag: 'txe', prefix: [], scope: null },
    { type: 'language', subtag: 'txg', prefix: [], scope: null },
    { type: 'language', subtag: 'txh', prefix: [], scope: null },
    { type: 'language', subtag: 'txi', prefix: [], scope: null },
    { type: 'language', subtag: 'txj', prefix: [], scope: null },
    { type: 'language', subtag: 'txm', prefix: [], scope: null },
    { type: 'language', subtag: 'txn', prefix: [], scope: null },
    { type: 'language', subtag: 'txo', prefix: [], scope: null },
    { type: 'language', subtag: 'txq', prefix: [], scope: null },
    { type: 'language', subtag: 'txr', prefix: [], scope: null },
    { type: 'language', subtag: 'txs', prefix: [], scope: null },
    { type: 'language', subtag: 'txt', prefix: [], scope: null },
    { type: 'language', subtag: 'txu', prefix: [], scope: null },
    { type: 'language', subtag: 'txx', prefix: [], scope: null },
    { type: 'language', subtag: 'txy', prefix: [], scope: null },
    { type: 'language', subtag: 'tya', prefix: [], scope: null },
    { type: 'language', subtag: 'tye', prefix: [], scope: null },
    { type: 'language', subtag: 'tyh', prefix: [], scope: null },
    { type: 'language', subtag: 'tyi', prefix: [], scope: null },
    { type: 'language', subtag: 'tyj', prefix: [], scope: null },
    { type: 'language', subtag: 'tyl', prefix: [], scope: null },
    { type: 'language', subtag: 'tyn', prefix: [], scope: null },
    { type: 'language', subtag: 'typ', prefix: [], scope: null },
    { type: 'language', subtag: 'tyr', prefix: [], scope: null },
    { type: 'language', subtag: 'tys', prefix: [], scope: null },
    { type: 'language', subtag: 'tyt', prefix: [], scope: null },
    { type: 'language', subtag: 'tyu', prefix: [], scope: null },
    { type: 'language', subtag: 'tyv', prefix: [], scope: null },
    { type: 'language', subtag: 'tyx', prefix: [], scope: null },
    { type: 'language', subtag: 'tyy', prefix: [], scope: null },
    { type: 'language', subtag: 'tyz', prefix: [], scope: null },
    { type: 'language', subtag: 'tza', prefix: [], scope: null },
    { type: 'language', subtag: 'tzh', prefix: [], scope: null },
    { type: 'language', subtag: 'tzj', prefix: [], scope: null },
    { type: 'language', subtag: 'tzl', prefix: [], scope: null },
    { type: 'language', subtag: 'tzm', prefix: [], scope: null },
    { type: 'language', subtag: 'tzn', prefix: [], scope: null },
    { type: 'language', subtag: 'tzo', prefix: [], scope: null },
    { type: 'language', subtag: 'tzx', prefix: [], scope: null },
    { type: 'language', subtag: 'uam', prefix: [], scope: null },
    { type: 'language', subtag: 'uan', prefix: [], scope: null },
    { type: 'language', subtag: 'uar', prefix: [], scope: null },
    { type: 'language', subtag: 'uba', prefix: [], scope: null },
    { type: 'language', subtag: 'ubi', prefix: [], scope: null },
    { type: 'language', subtag: 'ubl', prefix: [], scope: null },
    { type: 'language', subtag: 'ubr', prefix: [], scope: null },
    { type: 'language', subtag: 'ubu', prefix: [], scope: null },
    { type: 'language', subtag: 'uby', prefix: [], scope: null },
    { type: 'language', subtag: 'uda', prefix: [], scope: null },
    { type: 'language', subtag: 'ude', prefix: [], scope: null },
    { type: 'language', subtag: 'udg', prefix: [], scope: null },
    { type: 'language', subtag: 'udi', prefix: [], scope: null },
    { type: 'language', subtag: 'udj', prefix: [], scope: null },
    { type: 'language', subtag: 'udl', prefix: [], scope: null },
    { type: 'language', subtag: 'udm', prefix: [], scope: null },
    { type: 'language', subtag: 'udu', prefix: [], scope: null },
    { type: 'language', subtag: 'ues', prefix: [], scope: null },
    { type: 'language', subtag: 'ufi', prefix: [], scope: null },
    { type: 'language', subtag: 'uga', prefix: [], scope: null },
    { type: 'language', subtag: 'ugb', prefix: [], scope: null },
    { type: 'language', subtag: 'uge', prefix: [], scope: null },
    { type: 'language', subtag: 'ugh', prefix: [], scope: null },
    { type: 'language', subtag: 'ugn', prefix: [], scope: null },
    { type: 'language', subtag: 'ugo', prefix: [], scope: null },
    { type: 'language', subtag: 'ugy', prefix: [], scope: null },
    { type: 'language', subtag: 'uha', prefix: [], scope: null },
    { type: 'language', subtag: 'uhn', prefix: [], scope: null },
    { type: 'language', subtag: 'uis', prefix: [], scope: null },
    { type: 'language', subtag: 'uiv', prefix: [], scope: null },
    { type: 'language', subtag: 'uji', prefix: [], scope: null },
    { type: 'language', subtag: 'uka', prefix: [], scope: null },
    { type: 'language', subtag: 'ukg', prefix: [], scope: null },
    { type: 'language', subtag: 'ukh', prefix: [], scope: null },
    { type: 'language', subtag: 'uki', prefix: [], scope: null },
    { type: 'language', subtag: 'ukk', prefix: [], scope: null },
    { type: 'language', subtag: 'ukl', prefix: [], scope: null },
    { type: 'language', subtag: 'ukp', prefix: [], scope: null },
    { type: 'language', subtag: 'ukq', prefix: [], scope: null },
    { type: 'language', subtag: 'uks', prefix: [], scope: null },
    { type: 'language', subtag: 'uku', prefix: [], scope: null },
    { type: 'language', subtag: 'ukv', prefix: [], scope: null },
    { type: 'language', subtag: 'ukw', prefix: [], scope: null },
    { type: 'language', subtag: 'uky', prefix: [], scope: null },
    { type: 'language', subtag: 'ula', prefix: [], scope: null },
    { type: 'language', subtag: 'ulb', prefix: [], scope: null },
    { type: 'language', subtag: 'ulc', prefix: [], scope: null },
    { type: 'language', subtag: 'ule', prefix: [], scope: null },
    { type: 'language', subtag: 'ulf', prefix: [], scope: null },
    { type: 'language', subtag: 'uli', prefix: [], scope: null },
    { type: 'language', subtag: 'ulk', prefix: [], scope: null },
    { type: 'language', subtag: 'ull', prefix: [], scope: null },
    { type: 'language', subtag: 'ulm', prefix: [], scope: null },
    { type: 'language', subtag: 'uln', prefix: [], scope: null },
    { type: 'language', subtag: 'ulu', prefix: [], scope: null },
    { type: 'language', subtag: 'ulw', prefix: [], scope: null },
    { type: 'language', subtag: 'uma', prefix: [], scope: null },
    { type: 'language', subtag: 'umb', prefix: [], scope: null },
    { type: 'language', subtag: 'umc', prefix: [], scope: null },
    { type: 'language', subtag: 'umd', prefix: [], scope: null },
    { type: 'language', subtag: 'umg', prefix: [], scope: null },
    { type: 'language', subtag: 'umi', prefix: [], scope: null },
    { type: 'language', subtag: 'umm', prefix: [], scope: null },
    { type: 'language', subtag: 'umn', prefix: [], scope: null },
    { type: 'language', subtag: 'umo', prefix: [], scope: null },
    { type: 'language', subtag: 'ump', prefix: [], scope: null },
    { type: 'language', subtag: 'umr', prefix: [], scope: null },
    { type: 'language', subtag: 'ums', prefix: [], scope: null },
    { type: 'language', subtag: 'umu', prefix: [], scope: null },
    { type: 'language', subtag: 'una', prefix: [], scope: null },
    { type: 'language', subtag: 'und', prefix: [], scope: 'special' },
    { type: 'language', subtag: 'une', prefix: [], scope: null },
    { type: 'language', subtag: 'ung', prefix: [], scope: null },
    { type: 'language', subtag: 'uni', prefix: [], scope: null },
    { type: 'language', subtag: 'unk', prefix: [], scope: null },
    { type: 'language', subtag: 'unm', prefix: [], scope: null },
    { type: 'language', subtag: 'unn', prefix: [], scope: null },
    { type: 'language', subtag: 'unp', prefix: [], scope: null },
    { type: 'language', subtag: 'unr', prefix: [], scope: null },
    { type: 'language', subtag: 'unu', prefix: [], scope: null },
    { type: 'language', subtag: 'unx', prefix: [], scope: null },
    { type: 'language', subtag: 'unz', prefix: [], scope: null },
    { type: 'language', subtag: 'uok', prefix: [], scope: null },
    { type: 'language', subtag: 'uon', prefix: [], scope: null },
    { type: 'language', subtag: 'upi', prefix: [], scope: null },
    { type: 'language', subtag: 'upv', prefix: [], scope: null },
    { type: 'language', subtag: 'ura', prefix: [], scope: null },
    { type: 'language', subtag: 'urb', prefix: [], scope: null },
    { type: 'language', subtag: 'urc', prefix: [], scope: null },
    { type: 'language', subtag: 'ure', prefix: [], scope: null },
    { type: 'language', subtag: 'urf', prefix: [], scope: null },
    { type: 'language', subtag: 'urg', prefix: [], scope: null },
    { type: 'language', subtag: 'urh', prefix: [], scope: null },
    { type: 'language', subtag: 'uri', prefix: [], scope: null },
    { type: 'language', subtag: 'urj', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'urk', prefix: [], scope: null },
    { type: 'language', subtag: 'url', prefix: [], scope: null },
    { type: 'language', subtag: 'urm', prefix: [], scope: null },
    { type: 'language', subtag: 'urn', prefix: [], scope: null },
    { type: 'language', subtag: 'uro', prefix: [], scope: null },
    { type: 'language', subtag: 'urp', prefix: [], scope: null },
    { type: 'language', subtag: 'urr', prefix: [], scope: null },
    { type: 'language', subtag: 'urt', prefix: [], scope: null },
    { type: 'language', subtag: 'uru', prefix: [], scope: null },
    { type: 'language', subtag: 'urv', prefix: [], scope: null },
    { type: 'language', subtag: 'urw', prefix: [], scope: null },
    { type: 'language', subtag: 'urx', prefix: [], scope: null },
    { type: 'language', subtag: 'ury', prefix: [], scope: null },
    { type: 'language', subtag: 'urz', prefix: [], scope: null },
    { type: 'language', subtag: 'usa', prefix: [], scope: null },
    { type: 'language', subtag: 'ush', prefix: [], scope: null },
    { type: 'language', subtag: 'usi', prefix: [], scope: null },
    { type: 'language', subtag: 'usk', prefix: [], scope: null },
    { type: 'language', subtag: 'usp', prefix: [], scope: null },
    { type: 'language', subtag: 'uss', prefix: [], scope: null },
    { type: 'language', subtag: 'usu', prefix: [], scope: null },
    { type: 'language', subtag: 'uta', prefix: [], scope: null },
    { type: 'language', subtag: 'ute', prefix: [], scope: null },
    { type: 'language', subtag: 'uth', prefix: [], scope: null },
    { type: 'language', subtag: 'utp', prefix: [], scope: null },
    { type: 'language', subtag: 'utr', prefix: [], scope: null },
    { type: 'language', subtag: 'utu', prefix: [], scope: null },
    { type: 'language', subtag: 'uum', prefix: [], scope: null },
    { type: 'language', subtag: 'uun', prefix: [], scope: null },
    { type: 'language', subtag: 'uur', prefix: [], scope: null },
    { type: 'language', subtag: 'uuu', prefix: [], scope: null },
    { type: 'language', subtag: 'uve', prefix: [], scope: null },
    { type: 'language', subtag: 'uvh', prefix: [], scope: null },
    { type: 'language', subtag: 'uvl', prefix: [], scope: null },
    { type: 'language', subtag: 'uwa', prefix: [], scope: null },
    { type: 'language', subtag: 'uya', prefix: [], scope: null },
    { type: 'language', subtag: 'uzn', prefix: [], scope: null },
    { type: 'language', subtag: 'uzs', prefix: [], scope: null },
    { type: 'language', subtag: 'vaa', prefix: [], scope: null },
    { type: 'language', subtag: 'vae', prefix: [], scope: null },
    { type: 'language', subtag: 'vaf', prefix: [], scope: null },
    { type: 'language', subtag: 'vag', prefix: [], scope: null },
    { type: 'language', subtag: 'vah', prefix: [], scope: null },
    { type: 'language', subtag: 'vai', prefix: [], scope: null },
    { type: 'language', subtag: 'vaj', prefix: [], scope: null },
    { type: 'language', subtag: 'val', prefix: [], scope: null },
    { type: 'language', subtag: 'vam', prefix: [], scope: null },
    { type: 'language', subtag: 'van', prefix: [], scope: null },
    { type: 'language', subtag: 'vao', prefix: [], scope: null },
    { type: 'language', subtag: 'vap', prefix: [], scope: null },
    { type: 'language', subtag: 'var', prefix: [], scope: null },
    { type: 'language', subtag: 'vas', prefix: [], scope: null },
    { type: 'language', subtag: 'vau', prefix: [], scope: null },
    { type: 'language', subtag: 'vav', prefix: [], scope: null },
    { type: 'language', subtag: 'vay', prefix: [], scope: null },
    { type: 'language', subtag: 'vbb', prefix: [], scope: null },
    { type: 'language', subtag: 'vbk', prefix: [], scope: null },
    { type: 'language', subtag: 'vec', prefix: [], scope: null },
    { type: 'language', subtag: 'ved', prefix: [], scope: null },
    { type: 'language', subtag: 'vel', prefix: [], scope: null },
    { type: 'language', subtag: 'vem', prefix: [], scope: null },
    { type: 'language', subtag: 'veo', prefix: [], scope: null },
    { type: 'language', subtag: 'vep', prefix: [], scope: null },
    { type: 'language', subtag: 'ver', prefix: [], scope: null },
    { type: 'language', subtag: 'vgr', prefix: [], scope: null },
    { type: 'language', subtag: 'vgt', prefix: [], scope: null },
    { type: 'language', subtag: 'vic', prefix: [], scope: null },
    { type: 'language', subtag: 'vid', prefix: [], scope: null },
    { type: 'language', subtag: 'vif', prefix: [], scope: null },
    { type: 'language', subtag: 'vig', prefix: [], scope: null },
    { type: 'language', subtag: 'vil', prefix: [], scope: null },
    { type: 'language', subtag: 'vin', prefix: [], scope: null },
    { type: 'language', subtag: 'vis', prefix: [], scope: null },
    { type: 'language', subtag: 'vit', prefix: [], scope: null },
    { type: 'language', subtag: 'viv', prefix: [], scope: null },
    { type: 'language', subtag: 'vka', prefix: [], scope: null },
    { type: 'language', subtag: 'vki', prefix: [], scope: null },
    { type: 'language', subtag: 'vkj', prefix: [], scope: null },
    { type: 'language', subtag: 'vkk', prefix: [], scope: null },
    { type: 'language', subtag: 'vkl', prefix: [], scope: null },
    { type: 'language', subtag: 'vkm', prefix: [], scope: null },
    { type: 'language', subtag: 'vkn', prefix: [], scope: null },
    { type: 'language', subtag: 'vko', prefix: [], scope: null },
    { type: 'language', subtag: 'vkp', prefix: [], scope: null },
    { type: 'language', subtag: 'vkt', prefix: [], scope: null },
    { type: 'language', subtag: 'vku', prefix: [], scope: null },
    { type: 'language', subtag: 'vkz', prefix: [], scope: null },
    { type: 'language', subtag: 'vlp', prefix: [], scope: null },
    { type: 'language', subtag: 'vls', prefix: [], scope: null },
    { type: 'language', subtag: 'vma', prefix: [], scope: null },
    { type: 'language', subtag: 'vmb', prefix: [], scope: null },
    { type: 'language', subtag: 'vmc', prefix: [], scope: null },
    { type: 'language', subtag: 'vmd', prefix: [], scope: null },
    { type: 'language', subtag: 'vme', prefix: [], scope: null },
    { type: 'language', subtag: 'vmf', prefix: [], scope: null },
    { type: 'language', subtag: 'vmg', prefix: [], scope: null },
    { type: 'language', subtag: 'vmh', prefix: [], scope: null },
    { type: 'language', subtag: 'vmi', prefix: [], scope: null },
    { type: 'language', subtag: 'vmj', prefix: [], scope: null },
    { type: 'language', subtag: 'vmk', prefix: [], scope: null },
    { type: 'language', subtag: 'vml', prefix: [], scope: null },
    { type: 'language', subtag: 'vmm', prefix: [], scope: null },
    { type: 'language', subtag: 'vmp', prefix: [], scope: null },
    { type: 'language', subtag: 'vmq', prefix: [], scope: null },
    { type: 'language', subtag: 'vmr', prefix: [], scope: null },
    { type: 'language', subtag: 'vms', prefix: [], scope: null },
    { type: 'language', subtag: 'vmu', prefix: [], scope: null },
    { type: 'language', subtag: 'vmv', prefix: [], scope: null },
    { type: 'language', subtag: 'vmw', prefix: [], scope: null },
    { type: 'language', subtag: 'vmx', prefix: [], scope: null },
    { type: 'language', subtag: 'vmy', prefix: [], scope: null },
    { type: 'language', subtag: 'vmz', prefix: [], scope: null },
    { type: 'language', subtag: 'vnk', prefix: [], scope: null },
    { type: 'language', subtag: 'vnm', prefix: [], scope: null },
    { type: 'language', subtag: 'vnp', prefix: [], scope: null },
    { type: 'language', subtag: 'vor', prefix: [], scope: null },
    { type: 'language', subtag: 'vot', prefix: [], scope: null },
    { type: 'language', subtag: 'vra', prefix: [], scope: null },
    { type: 'language', subtag: 'vro', prefix: [], scope: null },
    { type: 'language', subtag: 'vrs', prefix: [], scope: null },
    { type: 'language', subtag: 'vrt', prefix: [], scope: null },
    { type: 'language', subtag: 'vsi', prefix: [], scope: null },
    { type: 'language', subtag: 'vsl', prefix: [], scope: null },
    { type: 'language', subtag: 'vsv', prefix: [], scope: null },
    { type: 'language', subtag: 'vto', prefix: [], scope: null },
    { type: 'language', subtag: 'vum', prefix: [], scope: null },
    { type: 'language', subtag: 'vun', prefix: [], scope: null },
    { type: 'language', subtag: 'vut', prefix: [], scope: null },
    { type: 'language', subtag: 'vwa', prefix: [], scope: null },
    { type: 'language', subtag: 'waa', prefix: [], scope: null },
    { type: 'language', subtag: 'wab', prefix: [], scope: null },
    { type: 'language', subtag: 'wac', prefix: [], scope: null },
    { type: 'language', subtag: 'wad', prefix: [], scope: null },
    { type: 'language', subtag: 'wae', prefix: [], scope: null },
    { type: 'language', subtag: 'waf', prefix: [], scope: null },
    { type: 'language', subtag: 'wag', prefix: [], scope: null },
    { type: 'language', subtag: 'wah', prefix: [], scope: null },
    { type: 'language', subtag: 'wai', prefix: [], scope: null },
    { type: 'language', subtag: 'waj', prefix: [], scope: null },
    { type: 'language', subtag: 'wak', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'wal', prefix: [], scope: null },
    { type: 'language', subtag: 'wam', prefix: [], scope: null },
    { type: 'language', subtag: 'wan', prefix: [], scope: null },
    { type: 'language', subtag: 'wao', prefix: [], scope: null },
    { type: 'language', subtag: 'wap', prefix: [], scope: null },
    { type: 'language', subtag: 'waq', prefix: [], scope: null },
    { type: 'language', subtag: 'war', prefix: [], scope: null },
    { type: 'language', subtag: 'was', prefix: [], scope: null },
    { type: 'language', subtag: 'wat', prefix: [], scope: null },
    { type: 'language', subtag: 'wau', prefix: [], scope: null },
    { type: 'language', subtag: 'wav', prefix: [], scope: null },
    { type: 'language', subtag: 'waw', prefix: [], scope: null },
    { type: 'language', subtag: 'wax', prefix: [], scope: null },
    { type: 'language', subtag: 'way', prefix: [], scope: null },
    { type: 'language', subtag: 'waz', prefix: [], scope: null },
    { type: 'language', subtag: 'wba', prefix: [], scope: null },
    { type: 'language', subtag: 'wbb', prefix: [], scope: null },
    { type: 'language', subtag: 'wbe', prefix: [], scope: null },
    { type: 'language', subtag: 'wbf', prefix: [], scope: null },
    { type: 'language', subtag: 'wbh', prefix: [], scope: null },
    { type: 'language', subtag: 'wbi', prefix: [], scope: null },
    { type: 'language', subtag: 'wbj', prefix: [], scope: null },
    { type: 'language', subtag: 'wbk', prefix: [], scope: null },
    { type: 'language', subtag: 'wbl', prefix: [], scope: null },
    { type: 'language', subtag: 'wbm', prefix: [], scope: null },
    { type: 'language', subtag: 'wbp', prefix: [], scope: null },
    { type: 'language', subtag: 'wbq', prefix: [], scope: null },
    { type: 'language', subtag: 'wbr', prefix: [], scope: null },
    { type: 'language', subtag: 'wbs', prefix: [], scope: null },
    { type: 'language', subtag: 'wbt', prefix: [], scope: null },
    { type: 'language', subtag: 'wbv', prefix: [], scope: null },
    { type: 'language', subtag: 'wbw', prefix: [], scope: null },
    { type: 'language', subtag: 'wca', prefix: [], scope: null },
    { type: 'language', subtag: 'wci', prefix: [], scope: null },
    { type: 'language', subtag: 'wdd', prefix: [], scope: null },
    { type: 'language', subtag: 'wdg', prefix: [], scope: null },
    { type: 'language', subtag: 'wdj', prefix: [], scope: null },
    { type: 'language', subtag: 'wdk', prefix: [], scope: null },
    { type: 'language', subtag: 'wdt', prefix: [], scope: null },
    { type: 'language', subtag: 'wdu', prefix: [], scope: null },
    { type: 'language', subtag: 'wdy', prefix: [], scope: null },
    { type: 'language', subtag: 'wea', prefix: [], scope: null },
    { type: 'language', subtag: 'wec', prefix: [], scope: null },
    { type: 'language', subtag: 'wed', prefix: [], scope: null },
    { type: 'language', subtag: 'weg', prefix: [], scope: null },
    { type: 'language', subtag: 'weh', prefix: [], scope: null },
    { type: 'language', subtag: 'wei', prefix: [], scope: null },
    { type: 'language', subtag: 'wem', prefix: [], scope: null },
    { type: 'language', subtag: 'wen', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'weo', prefix: [], scope: null },
    { type: 'language', subtag: 'wep', prefix: [], scope: null },
    { type: 'language', subtag: 'wer', prefix: [], scope: null },
    { type: 'language', subtag: 'wes', prefix: [], scope: null },
    { type: 'language', subtag: 'wet', prefix: [], scope: null },
    { type: 'language', subtag: 'weu', prefix: [], scope: null },
    { type: 'language', subtag: 'wew', prefix: [], scope: null },
    { type: 'language', subtag: 'wfg', prefix: [], scope: null },
    { type: 'language', subtag: 'wga', prefix: [], scope: null },
    { type: 'language', subtag: 'wgb', prefix: [], scope: null },
    { type: 'language', subtag: 'wgg', prefix: [], scope: null },
    { type: 'language', subtag: 'wgi', prefix: [], scope: null },
    { type: 'language', subtag: 'wgo', prefix: [], scope: null },
    { type: 'language', subtag: 'wgu', prefix: [], scope: null },
    { type: 'language', subtag: 'wgw', prefix: [], scope: null },
    { type: 'language', subtag: 'wgy', prefix: [], scope: null },
    { type: 'language', subtag: 'wha', prefix: [], scope: null },
    { type: 'language', subtag: 'whg', prefix: [], scope: null },
    { type: 'language', subtag: 'whk', prefix: [], scope: null },
    { type: 'language', subtag: 'whu', prefix: [], scope: null },
    { type: 'language', subtag: 'wib', prefix: [], scope: null },
    { type: 'language', subtag: 'wic', prefix: [], scope: null },
    { type: 'language', subtag: 'wie', prefix: [], scope: null },
    { type: 'language', subtag: 'wif', prefix: [], scope: null },
    { type: 'language', subtag: 'wig', prefix: [], scope: null },
    { type: 'language', subtag: 'wih', prefix: [], scope: null },
    { type: 'language', subtag: 'wii', prefix: [], scope: null },
    { type: 'language', subtag: 'wij', prefix: [], scope: null },
    { type: 'language', subtag: 'wik', prefix: [], scope: null },
    { type: 'language', subtag: 'wil', prefix: [], scope: null },
    { type: 'language', subtag: 'wim', prefix: [], scope: null },
    { type: 'language', subtag: 'win', prefix: [], scope: null },
    { type: 'language', subtag: 'wir', prefix: [], scope: null },
    { type: 'language', subtag: 'wit', prefix: [], scope: null },
    { type: 'language', subtag: 'wiu', prefix: [], scope: null },
    { type: 'language', subtag: 'wiv', prefix: [], scope: null },
    { type: 'language', subtag: 'wiw', prefix: [], scope: null },
    { type: 'language', subtag: 'wiy', prefix: [], scope: null },
    { type: 'language', subtag: 'wja', prefix: [], scope: null },
    { type: 'language', subtag: 'wji', prefix: [], scope: null },
    { type: 'language', subtag: 'wka', prefix: [], scope: null },
    { type: 'language', subtag: 'wkb', prefix: [], scope: null },
    { type: 'language', subtag: 'wkd', prefix: [], scope: null },
    { type: 'language', subtag: 'wkl', prefix: [], scope: null },
    { type: 'language', subtag: 'wkr', prefix: [], scope: null },
    { type: 'language', subtag: 'wku', prefix: [], scope: null },
    { type: 'language', subtag: 'wkw', prefix: [], scope: null },
    { type: 'language', subtag: 'wky', prefix: [], scope: null },
    { type: 'language', subtag: 'wla', prefix: [], scope: null },
    { type: 'language', subtag: 'wlc', prefix: [], scope: null },
    { type: 'language', subtag: 'wle', prefix: [], scope: null },
    { type: 'language', subtag: 'wlg', prefix: [], scope: null },
    { type: 'language', subtag: 'wlh', prefix: [], scope: null },
    { type: 'language', subtag: 'wli', prefix: [], scope: null },
    { type: 'language', subtag: 'wlk', prefix: [], scope: null },
    { type: 'language', subtag: 'wll', prefix: [], scope: null },
    { type: 'language', subtag: 'wlm', prefix: [], scope: null },
    { type: 'language', subtag: 'wlo', prefix: [], scope: null },
    { type: 'language', subtag: 'wlr', prefix: [], scope: null },
    { type: 'language', subtag: 'wls', prefix: [], scope: null },
    { type: 'language', subtag: 'wlu', prefix: [], scope: null },
    { type: 'language', subtag: 'wlv', prefix: [], scope: null },
    { type: 'language', subtag: 'wlw', prefix: [], scope: null },
    { type: 'language', subtag: 'wlx', prefix: [], scope: null },
    { type: 'language', subtag: 'wly', prefix: [], scope: null },
    { type: 'language', subtag: 'wma', prefix: [], scope: null },
    { type: 'language', subtag: 'wmb', prefix: [], scope: null },
    { type: 'language', subtag: 'wmc', prefix: [], scope: null },
    { type: 'language', subtag: 'wmd', prefix: [], scope: null },
    { type: 'language', subtag: 'wme', prefix: [], scope: null },
    { type: 'language', subtag: 'wmg', prefix: [], scope: null },
    { type: 'language', subtag: 'wmh', prefix: [], scope: null },
    { type: 'language', subtag: 'wmi', prefix: [], scope: null },
    { type: 'language', subtag: 'wmm', prefix: [], scope: null },
    { type: 'language', subtag: 'wmn', prefix: [], scope: null },
    { type: 'language', subtag: 'wmo', prefix: [], scope: null },
    { type: 'language', subtag: 'wms', prefix: [], scope: null },
    { type: 'language', subtag: 'wmt', prefix: [], scope: null },
    { type: 'language', subtag: 'wmw', prefix: [], scope: null },
    { type: 'language', subtag: 'wmx', prefix: [], scope: null },
    { type: 'language', subtag: 'wnb', prefix: [], scope: null },
    { type: 'language', subtag: 'wnc', prefix: [], scope: null },
    { type: 'language', subtag: 'wnd', prefix: [], scope: null },
    { type: 'language', subtag: 'wne', prefix: [], scope: null },
    { type: 'language', subtag: 'wng', prefix: [], scope: null },
    { type: 'language', subtag: 'wni', prefix: [], scope: null },
    { type: 'language', subtag: 'wnk', prefix: [], scope: null },
    { type: 'language', subtag: 'wnm', prefix: [], scope: null },
    { type: 'language', subtag: 'wnn', prefix: [], scope: null },
    { type: 'language', subtag: 'wno', prefix: [], scope: null },
    { type: 'language', subtag: 'wnp', prefix: [], scope: null },
    { type: 'language', subtag: 'wnu', prefix: [], scope: null },
    { type: 'language', subtag: 'wnw', prefix: [], scope: null },
    { type: 'language', subtag: 'wny', prefix: [], scope: null },
    { type: 'language', subtag: 'woa', prefix: [], scope: null },
    { type: 'language', subtag: 'wob', prefix: [], scope: null },
    { type: 'language', subtag: 'woc', prefix: [], scope: null },
    { type: 'language', subtag: 'wod', prefix: [], scope: null },
    { type: 'language', subtag: 'woe', prefix: [], scope: null },
    { type: 'language', subtag: 'wof', prefix: [], scope: null },
    { type: 'language', subtag: 'wog', prefix: [], scope: null },
    { type: 'language', subtag: 'woi', prefix: [], scope: null },
    { type: 'language', subtag: 'wok', prefix: [], scope: null },
    { type: 'language', subtag: 'wom', prefix: [], scope: null },
    { type: 'language', subtag: 'won', prefix: [], scope: null },
    { type: 'language', subtag: 'woo', prefix: [], scope: null },
    { type: 'language', subtag: 'wor', prefix: [], scope: null },
    { type: 'language', subtag: 'wos', prefix: [], scope: null },
    { type: 'language', subtag: 'wow', prefix: [], scope: null },
    { type: 'language', subtag: 'woy', prefix: [], scope: null },
    { type: 'language', subtag: 'wpc', prefix: [], scope: null },
    { type: 'language', subtag: 'wra', prefix: [], scope: null },
    { type: 'language', subtag: 'wrb', prefix: [], scope: null },
    { type: 'language', subtag: 'wrd', prefix: [], scope: null },
    { type: 'language', subtag: 'wrg', prefix: [], scope: null },
    { type: 'language', subtag: 'wrh', prefix: [], scope: null },
    { type: 'language', subtag: 'wri', prefix: [], scope: null },
    { type: 'language', subtag: 'wrk', prefix: [], scope: null },
    { type: 'language', subtag: 'wrl', prefix: [], scope: null },
    { type: 'language', subtag: 'wrm', prefix: [], scope: null },
    { type: 'language', subtag: 'wrn', prefix: [], scope: null },
    { type: 'language', subtag: 'wro', prefix: [], scope: null },
    { type: 'language', subtag: 'wrp', prefix: [], scope: null },
    { type: 'language', subtag: 'wrr', prefix: [], scope: null },
    { type: 'language', subtag: 'wrs', prefix: [], scope: null },
    { type: 'language', subtag: 'wru', prefix: [], scope: null },
    { type: 'language', subtag: 'wrv', prefix: [], scope: null },
    { type: 'language', subtag: 'wrw', prefix: [], scope: null },
    { type: 'language', subtag: 'wrx', prefix: [], scope: null },
    { type: 'language', subtag: 'wry', prefix: [], scope: null },
    { type: 'language', subtag: 'wrz', prefix: [], scope: null },
    { type: 'language', subtag: 'wsa', prefix: [], scope: null },
    { type: 'language', subtag: 'wsg', prefix: [], scope: null },
    { type: 'language', subtag: 'wsi', prefix: [], scope: null },
    { type: 'language', subtag: 'wsk', prefix: [], scope: null },
    { type: 'language', subtag: 'wsr', prefix: [], scope: null },
    { type: 'language', subtag: 'wss', prefix: [], scope: null },
    { type: 'language', subtag: 'wsu', prefix: [], scope: null },
    { type: 'language', subtag: 'wsv', prefix: [], scope: null },
    { type: 'language', subtag: 'wtf', prefix: [], scope: null },
    { type: 'language', subtag: 'wth', prefix: [], scope: null },
    { type: 'language', subtag: 'wti', prefix: [], scope: null },
    { type: 'language', subtag: 'wtk', prefix: [], scope: null },
    { type: 'language', subtag: 'wtm', prefix: [], scope: null },
    { type: 'language', subtag: 'wtw', prefix: [], scope: null },
    { type: 'language', subtag: 'wua', prefix: [], scope: null },
    { type: 'language', subtag: 'wub', prefix: [], scope: null },
    { type: 'language', subtag: 'wud', prefix: [], scope: null },
    { type: 'language', subtag: 'wuh', prefix: [], scope: null },
    { type: 'language', subtag: 'wul', prefix: [], scope: null },
    { type: 'language', subtag: 'wum', prefix: [], scope: null },
    { type: 'language', subtag: 'wun', prefix: [], scope: null },
    { type: 'language', subtag: 'wur', prefix: [], scope: null },
    { type: 'language', subtag: 'wut', prefix: [], scope: null },
    { type: 'language', subtag: 'wuu', prefix: [], scope: null },
    { type: 'language', subtag: 'wuv', prefix: [], scope: null },
    { type: 'language', subtag: 'wux', prefix: [], scope: null },
    { type: 'language', subtag: 'wuy', prefix: [], scope: null },
    { type: 'language', subtag: 'wwa', prefix: [], scope: null },
    { type: 'language', subtag: 'wwb', prefix: [], scope: null },
    { type: 'language', subtag: 'wwo', prefix: [], scope: null },
    { type: 'language', subtag: 'wwr', prefix: [], scope: null },
    { type: 'language', subtag: 'www', prefix: [], scope: null },
    { type: 'language', subtag: 'wxa', prefix: [], scope: null },
    { type: 'language', subtag: 'wxw', prefix: [], scope: null },
    { type: 'language', subtag: 'wya', prefix: [], scope: null },
    { type: 'language', subtag: 'wyb', prefix: [], scope: null },
    { type: 'language', subtag: 'wyi', prefix: [], scope: null },
    { type: 'language', subtag: 'wym', prefix: [], scope: null },
    { type: 'language', subtag: 'wyn', prefix: [], scope: null },
    { type: 'language', subtag: 'wyr', prefix: [], scope: null },
    { type: 'language', subtag: 'wyy', prefix: [], scope: null },
    { type: 'language', subtag: 'xaa', prefix: [], scope: null },
    { type: 'language', subtag: 'xab', prefix: [], scope: null },
    { type: 'language', subtag: 'xac', prefix: [], scope: null },
    { type: 'language', subtag: 'xad', prefix: [], scope: null },
    { type: 'language', subtag: 'xae', prefix: [], scope: null },
    { type: 'language', subtag: 'xag', prefix: [], scope: null },
    { type: 'language', subtag: 'xai', prefix: [], scope: null },
    { type: 'language', subtag: 'xaj', prefix: [], scope: null },
    { type: 'language', subtag: 'xak', prefix: [], scope: null },
    { type: 'language', subtag: 'xal', prefix: [], scope: null },
    { type: 'language', subtag: 'xam', prefix: [], scope: null },
    { type: 'language', subtag: 'xan', prefix: [], scope: null },
    { type: 'language', subtag: 'xao', prefix: [], scope: null },
    { type: 'language', subtag: 'xap', prefix: [], scope: null },
    { type: 'language', subtag: 'xaq', prefix: [], scope: null },
    { type: 'language', subtag: 'xar', prefix: [], scope: null },
    { type: 'language', subtag: 'xas', prefix: [], scope: null },
    { type: 'language', subtag: 'xat', prefix: [], scope: null },
    { type: 'language', subtag: 'xau', prefix: [], scope: null },
    { type: 'language', subtag: 'xav', prefix: [], scope: null },
    { type: 'language', subtag: 'xaw', prefix: [], scope: null },
    { type: 'language', subtag: 'xay', prefix: [], scope: null },
    { type: 'language', subtag: 'xba', prefix: [], scope: null },
    { type: 'language', subtag: 'xbb', prefix: [], scope: null },
    { type: 'language', subtag: 'xbc', prefix: [], scope: null },
    { type: 'language', subtag: 'xbd', prefix: [], scope: null },
    { type: 'language', subtag: 'xbe', prefix: [], scope: null },
    { type: 'language', subtag: 'xbg', prefix: [], scope: null },
    { type: 'language', subtag: 'xbi', prefix: [], scope: null },
    { type: 'language', subtag: 'xbj', prefix: [], scope: null },
    { type: 'language', subtag: 'xbm', prefix: [], scope: null },
    { type: 'language', subtag: 'xbn', prefix: [], scope: null },
    { type: 'language', subtag: 'xbo', prefix: [], scope: null },
    { type: 'language', subtag: 'xbp', prefix: [], scope: null },
    { type: 'language', subtag: 'xbr', prefix: [], scope: null },
    { type: 'language', subtag: 'xbw', prefix: [], scope: null },
    { type: 'language', subtag: 'xbx', prefix: [], scope: null },
    { type: 'language', subtag: 'xby', prefix: [], scope: null },
    { type: 'language', subtag: 'xcb', prefix: [], scope: null },
    { type: 'language', subtag: 'xcc', prefix: [], scope: null },
    { type: 'language', subtag: 'xce', prefix: [], scope: null },
    { type: 'language', subtag: 'xcg', prefix: [], scope: null },
    { type: 'language', subtag: 'xch', prefix: [], scope: null },
    { type: 'language', subtag: 'xcl', prefix: [], scope: null },
    { type: 'language', subtag: 'xcm', prefix: [], scope: null },
    { type: 'language', subtag: 'xcn', prefix: [], scope: null },
    { type: 'language', subtag: 'xco', prefix: [], scope: null },
    { type: 'language', subtag: 'xcr', prefix: [], scope: null },
    { type: 'language', subtag: 'xct', prefix: [], scope: null },
    { type: 'language', subtag: 'xcu', prefix: [], scope: null },
    { type: 'language', subtag: 'xcv', prefix: [], scope: null },
    { type: 'language', subtag: 'xcw', prefix: [], scope: null },
    { type: 'language', subtag: 'xcy', prefix: [], scope: null },
    { type: 'language', subtag: 'xda', prefix: [], scope: null },
    { type: 'language', subtag: 'xdc', prefix: [], scope: null },
    { type: 'language', subtag: 'xdk', prefix: [], scope: null },
    { type: 'language', subtag: 'xdm', prefix: [], scope: null },
    { type: 'language', subtag: 'xdo', prefix: [], scope: null },
    { type: 'language', subtag: 'xdq', prefix: [], scope: null },
    { type: 'language', subtag: 'xdy', prefix: [], scope: null },
    { type: 'language', subtag: 'xeb', prefix: [], scope: null },
    { type: 'language', subtag: 'xed', prefix: [], scope: null },
    { type: 'language', subtag: 'xeg', prefix: [], scope: null },
    { type: 'language', subtag: 'xel', prefix: [], scope: null },
    { type: 'language', subtag: 'xem', prefix: [], scope: null },
    { type: 'language', subtag: 'xep', prefix: [], scope: null },
    { type: 'language', subtag: 'xer', prefix: [], scope: null },
    { type: 'language', subtag: 'xes', prefix: [], scope: null },
    { type: 'language', subtag: 'xet', prefix: [], scope: null },
    { type: 'language', subtag: 'xeu', prefix: [], scope: null },
    { type: 'language', subtag: 'xfa', prefix: [], scope: null },
    { type: 'language', subtag: 'xga', prefix: [], scope: null },
    { type: 'language', subtag: 'xgb', prefix: [], scope: null },
    { type: 'language', subtag: 'xgd', prefix: [], scope: null },
    { type: 'language', subtag: 'xgf', prefix: [], scope: null },
    { type: 'language', subtag: 'xgg', prefix: [], scope: null },
    { type: 'language', subtag: 'xgi', prefix: [], scope: null },
    { type: 'language', subtag: 'xgl', prefix: [], scope: null },
    { type: 'language', subtag: 'xgm', prefix: [], scope: null },
    { type: 'language', subtag: 'xgn', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'xgr', prefix: [], scope: null },
    { type: 'language', subtag: 'xgu', prefix: [], scope: null },
    { type: 'language', subtag: 'xgw', prefix: [], scope: null },
    { type: 'language', subtag: 'xha', prefix: [], scope: null },
    { type: 'language', subtag: 'xhc', prefix: [], scope: null },
    { type: 'language', subtag: 'xhd', prefix: [], scope: null },
    { type: 'language', subtag: 'xhe', prefix: [], scope: null },
    { type: 'language', subtag: 'xhm', prefix: [], scope: null },
    { type: 'language', subtag: 'xhr', prefix: [], scope: null },
    { type: 'language', subtag: 'xht', prefix: [], scope: null },
    { type: 'language', subtag: 'xhu', prefix: [], scope: null },
    { type: 'language', subtag: 'xhv', prefix: [], scope: null },
    { type: 'language', subtag: 'xia', prefix: [], scope: null },
    { type: 'language', subtag: 'xib', prefix: [], scope: null },
    { type: 'language', subtag: 'xii', prefix: [], scope: null },
    { type: 'language', subtag: 'xil', prefix: [], scope: null },
    { type: 'language', subtag: 'xin', prefix: [], scope: null },
    { type: 'language', subtag: 'xip', prefix: [], scope: null },
    { type: 'language', subtag: 'xir', prefix: [], scope: null },
    { type: 'language', subtag: 'xis', prefix: [], scope: null },
    { type: 'language', subtag: 'xiv', prefix: [], scope: null },
    { type: 'language', subtag: 'xiy', prefix: [], scope: null },
    { type: 'language', subtag: 'xjb', prefix: [], scope: null },
    { type: 'language', subtag: 'xjt', prefix: [], scope: null },
    { type: 'language', subtag: 'xka', prefix: [], scope: null },
    { type: 'language', subtag: 'xkb', prefix: [], scope: null },
    { type: 'language', subtag: 'xkc', prefix: [], scope: null },
    { type: 'language', subtag: 'xkd', prefix: [], scope: null },
    { type: 'language', subtag: 'xke', prefix: [], scope: null },
    { type: 'language', subtag: 'xkf', prefix: [], scope: null },
    { type: 'language', subtag: 'xkg', prefix: [], scope: null },
    { type: 'language', subtag: 'xkh', prefix: [], scope: null },
    { type: 'language', subtag: 'xki', prefix: [], scope: null },
    { type: 'language', subtag: 'xkj', prefix: [], scope: null },
    { type: 'language', subtag: 'xkk', prefix: [], scope: null },
    { type: 'language', subtag: 'xkl', prefix: [], scope: null },
    { type: 'language', subtag: 'xkn', prefix: [], scope: null },
    { type: 'language', subtag: 'xko', prefix: [], scope: null },
    { type: 'language', subtag: 'xkp', prefix: [], scope: null },
    { type: 'language', subtag: 'xkq', prefix: [], scope: null },
    { type: 'language', subtag: 'xkr', prefix: [], scope: null },
    { type: 'language', subtag: 'xks', prefix: [], scope: null },
    { type: 'language', subtag: 'xkt', prefix: [], scope: null },
    { type: 'language', subtag: 'xku', prefix: [], scope: null },
    { type: 'language', subtag: 'xkv', prefix: [], scope: null },
    { type: 'language', subtag: 'xkw', prefix: [], scope: null },
    { type: 'language', subtag: 'xkx', prefix: [], scope: null },
    { type: 'language', subtag: 'xky', prefix: [], scope: null },
    { type: 'language', subtag: 'xkz', prefix: [], scope: null },
    { type: 'language', subtag: 'xla', prefix: [], scope: null },
    { type: 'language', subtag: 'xlb', prefix: [], scope: null },
    { type: 'language', subtag: 'xlc', prefix: [], scope: null },
    { type: 'language', subtag: 'xld', prefix: [], scope: null },
    { type: 'language', subtag: 'xle', prefix: [], scope: null },
    { type: 'language', subtag: 'xlg', prefix: [], scope: null },
    { type: 'language', subtag: 'xli', prefix: [], scope: null },
    { type: 'language', subtag: 'xln', prefix: [], scope: null },
    { type: 'language', subtag: 'xlo', prefix: [], scope: null },
    { type: 'language', subtag: 'xlp', prefix: [], scope: null },
    { type: 'language', subtag: 'xls', prefix: [], scope: null },
    { type: 'language', subtag: 'xlu', prefix: [], scope: null },
    { type: 'language', subtag: 'xly', prefix: [], scope: null },
    { type: 'language', subtag: 'xma', prefix: [], scope: null },
    { type: 'language', subtag: 'xmb', prefix: [], scope: null },
    { type: 'language', subtag: 'xmc', prefix: [], scope: null },
    { type: 'language', subtag: 'xmd', prefix: [], scope: null },
    { type: 'language', subtag: 'xme', prefix: [], scope: null },
    { type: 'language', subtag: 'xmf', prefix: [], scope: null },
    { type: 'language', subtag: 'xmg', prefix: [], scope: null },
    { type: 'language', subtag: 'xmh', prefix: [], scope: null },
    { type: 'language', subtag: 'xmj', prefix: [], scope: null },
    { type: 'language', subtag: 'xmk', prefix: [], scope: null },
    { type: 'language', subtag: 'xml', prefix: [], scope: null },
    { type: 'language', subtag: 'xmm', prefix: [], scope: null },
    { type: 'language', subtag: 'xmn', prefix: [], scope: null },
    { type: 'language', subtag: 'xmo', prefix: [], scope: null },
    { type: 'language', subtag: 'xmp', prefix: [], scope: null },
    { type: 'language', subtag: 'xmq', prefix: [], scope: null },
    { type: 'language', subtag: 'xmr', prefix: [], scope: null },
    { type: 'language', subtag: 'xms', prefix: [], scope: null },
    { type: 'language', subtag: 'xmt', prefix: [], scope: null },
    { type: 'language', subtag: 'xmu', prefix: [], scope: null },
    { type: 'language', subtag: 'xmv', prefix: [], scope: null },
    { type: 'language', subtag: 'xmw', prefix: [], scope: null },
    { type: 'language', subtag: 'xmx', prefix: [], scope: null },
    { type: 'language', subtag: 'xmy', prefix: [], scope: null },
    { type: 'language', subtag: 'xmz', prefix: [], scope: null },
    { type: 'language', subtag: 'xna', prefix: [], scope: null },
    { type: 'language', subtag: 'xnb', prefix: [], scope: null },
    { type: 'language', subtag: 'xnd', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'xng', prefix: [], scope: null },
    { type: 'language', subtag: 'xnh', prefix: [], scope: null },
    { type: 'language', subtag: 'xni', prefix: [], scope: null },
    { type: 'language', subtag: 'xnj', prefix: [], scope: null },
    { type: 'language', subtag: 'xnk', prefix: [], scope: null },
    { type: 'language', subtag: 'xnm', prefix: [], scope: null },
    { type: 'language', subtag: 'xnn', prefix: [], scope: null },
    { type: 'language', subtag: 'xno', prefix: [], scope: null },
    { type: 'language', subtag: 'xnq', prefix: [], scope: null },
    { type: 'language', subtag: 'xnr', prefix: [], scope: null },
    { type: 'language', subtag: 'xns', prefix: [], scope: null },
    { type: 'language', subtag: 'xnt', prefix: [], scope: null },
    { type: 'language', subtag: 'xnu', prefix: [], scope: null },
    { type: 'language', subtag: 'xny', prefix: [], scope: null },
    { type: 'language', subtag: 'xnz', prefix: [], scope: null },
    { type: 'language', subtag: 'xoc', prefix: [], scope: null },
    { type: 'language', subtag: 'xod', prefix: [], scope: null },
    { type: 'language', subtag: 'xog', prefix: [], scope: null },
    { type: 'language', subtag: 'xoi', prefix: [], scope: null },
    { type: 'language', subtag: 'xok', prefix: [], scope: null },
    { type: 'language', subtag: 'xom', prefix: [], scope: null },
    { type: 'language', subtag: 'xon', prefix: [], scope: null },
    { type: 'language', subtag: 'xoo', prefix: [], scope: null },
    { type: 'language', subtag: 'xop', prefix: [], scope: null },
    { type: 'language', subtag: 'xor', prefix: [], scope: null },
    { type: 'language', subtag: 'xow', prefix: [], scope: null },
    { type: 'language', subtag: 'xpa', prefix: [], scope: null },
    { type: 'language', subtag: 'xpb', prefix: [], scope: null },
    { type: 'language', subtag: 'xpc', prefix: [], scope: null },
    { type: 'language', subtag: 'xpd', prefix: [], scope: null },
    { type: 'language', subtag: 'xpe', prefix: [], scope: null },
    { type: 'language', subtag: 'xpf', prefix: [], scope: null },
    { type: 'language', subtag: 'xpg', prefix: [], scope: null },
    { type: 'language', subtag: 'xph', prefix: [], scope: null },
    { type: 'language', subtag: 'xpi', prefix: [], scope: null },
    { type: 'language', subtag: 'xpj', prefix: [], scope: null },
    { type: 'language', subtag: 'xpk', prefix: [], scope: null },
    { type: 'language', subtag: 'xpl', prefix: [], scope: null },
    { type: 'language', subtag: 'xpm', prefix: [], scope: null },
    { type: 'language', subtag: 'xpn', prefix: [], scope: null },
    { type: 'language', subtag: 'xpo', prefix: [], scope: null },
    { type: 'language', subtag: 'xpp', prefix: [], scope: null },
    { type: 'language', subtag: 'xpq', prefix: [], scope: null },
    { type: 'language', subtag: 'xpr', prefix: [], scope: null },
    { type: 'language', subtag: 'xps', prefix: [], scope: null },
    { type: 'language', subtag: 'xpt', prefix: [], scope: null },
    { type: 'language', subtag: 'xpu', prefix: [], scope: null },
    { type: 'language', subtag: 'xpv', prefix: [], scope: null },
    { type: 'language', subtag: 'xpw', prefix: [], scope: null },
    { type: 'language', subtag: 'xpx', prefix: [], scope: null },
    { type: 'language', subtag: 'xpy', prefix: [], scope: null },
    { type: 'language', subtag: 'xpz', prefix: [], scope: null },
    { type: 'language', subtag: 'xqa', prefix: [], scope: null },
    { type: 'language', subtag: 'xqt', prefix: [], scope: null },
    { type: 'language', subtag: 'xra', prefix: [], scope: null },
    { type: 'language', subtag: 'xrb', prefix: [], scope: null },
    { type: 'language', subtag: 'xrd', prefix: [], scope: null },
    { type: 'language', subtag: 'xre', prefix: [], scope: null },
    { type: 'language', subtag: 'xrg', prefix: [], scope: null },
    { type: 'language', subtag: 'xri', prefix: [], scope: null },
    { type: 'language', subtag: 'xrm', prefix: [], scope: null },
    { type: 'language', subtag: 'xrn', prefix: [], scope: null },
    { type: 'language', subtag: 'xrq', prefix: [], scope: null },
    { type: 'language', subtag: 'xrr', prefix: [], scope: null },
    { type: 'language', subtag: 'xrt', prefix: [], scope: null },
    { type: 'language', subtag: 'xru', prefix: [], scope: null },
    { type: 'language', subtag: 'xrw', prefix: [], scope: null },
    { type: 'language', subtag: 'xsa', prefix: [], scope: null },
    { type: 'language', subtag: 'xsb', prefix: [], scope: null },
    { type: 'language', subtag: 'xsc', prefix: [], scope: null },
    { type: 'language', subtag: 'xsd', prefix: [], scope: null },
    { type: 'language', subtag: 'xse', prefix: [], scope: null },
    { type: 'language', subtag: 'xsh', prefix: [], scope: null },
    { type: 'language', subtag: 'xsi', prefix: [], scope: null },
    { type: 'language', subtag: 'xsj', prefix: [], scope: null },
    { type: 'language', subtag: 'xsl', prefix: [], scope: null },
    { type: 'language', subtag: 'xsm', prefix: [], scope: null },
    { type: 'language', subtag: 'xsn', prefix: [], scope: null },
    { type: 'language', subtag: 'xso', prefix: [], scope: null },
    { type: 'language', subtag: 'xsp', prefix: [], scope: null },
    { type: 'language', subtag: 'xsq', prefix: [], scope: null },
    { type: 'language', subtag: 'xsr', prefix: [], scope: null },
    { type: 'language', subtag: 'xss', prefix: [], scope: null },
    { type: 'language', subtag: 'xsu', prefix: [], scope: null },
    { type: 'language', subtag: 'xsv', prefix: [], scope: null },
    { type: 'language', subtag: 'xsy', prefix: [], scope: null },
    { type: 'language', subtag: 'xta', prefix: [], scope: null },
    { type: 'language', subtag: 'xtb', prefix: [], scope: null },
    { type: 'language', subtag: 'xtc', prefix: [], scope: null },
    { type: 'language', subtag: 'xtd', prefix: [], scope: null },
    { type: 'language', subtag: 'xte', prefix: [], scope: null },
    { type: 'language', subtag: 'xtg', prefix: [], scope: null },
    { type: 'language', subtag: 'xth', prefix: [], scope: null },
    { type: 'language', subtag: 'xti', prefix: [], scope: null },
    { type: 'language', subtag: 'xtj', prefix: [], scope: null },
    { type: 'language', subtag: 'xtl', prefix: [], scope: null },
    { type: 'language', subtag: 'xtm', prefix: [], scope: null },
    { type: 'language', subtag: 'xtn', prefix: [], scope: null },
    { type: 'language', subtag: 'xto', prefix: [], scope: null },
    { type: 'language', subtag: 'xtp', prefix: [], scope: null },
    { type: 'language', subtag: 'xtq', prefix: [], scope: null },
    { type: 'language', subtag: 'xtr', prefix: [], scope: null },
    { type: 'language', subtag: 'xts', prefix: [], scope: null },
    { type: 'language', subtag: 'xtt', prefix: [], scope: null },
    { type: 'language', subtag: 'xtu', prefix: [], scope: null },
    { type: 'language', subtag: 'xtv', prefix: [], scope: null },
    { type: 'language', subtag: 'xtw', prefix: [], scope: null },
    { type: 'language', subtag: 'xty', prefix: [], scope: null },
    { type: 'language', subtag: 'xtz', prefix: [], scope: null },
    { type: 'language', subtag: 'xua', prefix: [], scope: null },
    { type: 'language', subtag: 'xub', prefix: [], scope: null },
    { type: 'language', subtag: 'xud', prefix: [], scope: null },
    { type: 'language', subtag: 'xug', prefix: [], scope: null },
    { type: 'language', subtag: 'xuj', prefix: [], scope: null },
    { type: 'language', subtag: 'xul', prefix: [], scope: null },
    { type: 'language', subtag: 'xum', prefix: [], scope: null },
    { type: 'language', subtag: 'xun', prefix: [], scope: null },
    { type: 'language', subtag: 'xuo', prefix: [], scope: null },
    { type: 'language', subtag: 'xup', prefix: [], scope: null },
    { type: 'language', subtag: 'xur', prefix: [], scope: null },
    { type: 'language', subtag: 'xut', prefix: [], scope: null },
    { type: 'language', subtag: 'xuu', prefix: [], scope: null },
    { type: 'language', subtag: 'xve', prefix: [], scope: null },
    { type: 'language', subtag: 'xvi', prefix: [], scope: null },
    { type: 'language', subtag: 'xvn', prefix: [], scope: null },
    { type: 'language', subtag: 'xvo', prefix: [], scope: null },
    { type: 'language', subtag: 'xvs', prefix: [], scope: null },
    { type: 'language', subtag: 'xwa', prefix: [], scope: null },
    { type: 'language', subtag: 'xwc', prefix: [], scope: null },
    { type: 'language', subtag: 'xwd', prefix: [], scope: null },
    { type: 'language', subtag: 'xwe', prefix: [], scope: null },
    { type: 'language', subtag: 'xwg', prefix: [], scope: null },
    { type: 'language', subtag: 'xwj', prefix: [], scope: null },
    { type: 'language', subtag: 'xwk', prefix: [], scope: null },
    { type: 'language', subtag: 'xwl', prefix: [], scope: null },
    { type: 'language', subtag: 'xwo', prefix: [], scope: null },
    { type: 'language', subtag: 'xwr', prefix: [], scope: null },
    { type: 'language', subtag: 'xwt', prefix: [], scope: null },
    { type: 'language', subtag: 'xww', prefix: [], scope: null },
    { type: 'language', subtag: 'xxb', prefix: [], scope: null },
    { type: 'language', subtag: 'xxk', prefix: [], scope: null },
    { type: 'language', subtag: 'xxm', prefix: [], scope: null },
    { type: 'language', subtag: 'xxr', prefix: [], scope: null },
    { type: 'language', subtag: 'xxt', prefix: [], scope: null },
    { type: 'language', subtag: 'xya', prefix: [], scope: null },
    { type: 'language', subtag: 'xyb', prefix: [], scope: null },
    { type: 'language', subtag: 'xyj', prefix: [], scope: null },
    { type: 'language', subtag: 'xyk', prefix: [], scope: null },
    { type: 'language', subtag: 'xyl', prefix: [], scope: null },
    { type: 'language', subtag: 'xyt', prefix: [], scope: null },
    { type: 'language', subtag: 'xyy', prefix: [], scope: null },
    { type: 'language', subtag: 'xzh', prefix: [], scope: null },
    { type: 'language', subtag: 'xzm', prefix: [], scope: null },
    { type: 'language', subtag: 'xzp', prefix: [], scope: null },
    { type: 'language', subtag: 'yaa', prefix: [], scope: null },
    { type: 'language', subtag: 'yab', prefix: [], scope: null },
    { type: 'language', subtag: 'yac', prefix: [], scope: null },
    { type: 'language', subtag: 'yad', prefix: [], scope: null },
    { type: 'language', subtag: 'yae', prefix: [], scope: null },
    { type: 'language', subtag: 'yaf', prefix: [], scope: null },
    { type: 'language', subtag: 'yag', prefix: [], scope: null },
    { type: 'language', subtag: 'yah', prefix: [], scope: null },
    { type: 'language', subtag: 'yai', prefix: [], scope: null },
    { type: 'language', subtag: 'yaj', prefix: [], scope: null },
    { type: 'language', subtag: 'yak', prefix: [], scope: null },
    { type: 'language', subtag: 'yal', prefix: [], scope: null },
    { type: 'language', subtag: 'yam', prefix: [], scope: null },
    { type: 'language', subtag: 'yan', prefix: [], scope: null },
    { type: 'language', subtag: 'yao', prefix: [], scope: null },
    { type: 'language', subtag: 'yap', prefix: [], scope: null },
    { type: 'language', subtag: 'yaq', prefix: [], scope: null },
    { type: 'language', subtag: 'yar', prefix: [], scope: null },
    { type: 'language', subtag: 'yas', prefix: [], scope: null },
    { type: 'language', subtag: 'yat', prefix: [], scope: null },
    { type: 'language', subtag: 'yau', prefix: [], scope: null },
    { type: 'language', subtag: 'yav', prefix: [], scope: null },
    { type: 'language', subtag: 'yaw', prefix: [], scope: null },
    { type: 'language', subtag: 'yax', prefix: [], scope: null },
    { type: 'language', subtag: 'yay', prefix: [], scope: null },
    { type: 'language', subtag: 'yaz', prefix: [], scope: null },
    { type: 'language', subtag: 'yba', prefix: [], scope: null },
    { type: 'language', subtag: 'ybb', prefix: [], scope: null },
    { type: 'language', subtag: 'ybd', prefix: [], scope: null },
    { type: 'language', subtag: 'ybe', prefix: [], scope: null },
    { type: 'language', subtag: 'ybh', prefix: [], scope: null },
    { type: 'language', subtag: 'ybi', prefix: [], scope: null },
    { type: 'language', subtag: 'ybj', prefix: [], scope: null },
    { type: 'language', subtag: 'ybk', prefix: [], scope: null },
    { type: 'language', subtag: 'ybl', prefix: [], scope: null },
    { type: 'language', subtag: 'ybm', prefix: [], scope: null },
    { type: 'language', subtag: 'ybn', prefix: [], scope: null },
    { type: 'language', subtag: 'ybo', prefix: [], scope: null },
    { type: 'language', subtag: 'ybx', prefix: [], scope: null },
    { type: 'language', subtag: 'yby', prefix: [], scope: null },
    { type: 'language', subtag: 'ych', prefix: [], scope: null },
    { type: 'language', subtag: 'ycl', prefix: [], scope: null },
    { type: 'language', subtag: 'ycn', prefix: [], scope: null },
    { type: 'language', subtag: 'ycp', prefix: [], scope: null },
    { type: 'language', subtag: 'yda', prefix: [], scope: null },
    { type: 'language', subtag: 'ydd', prefix: [], scope: null },
    { type: 'language', subtag: 'yde', prefix: [], scope: null },
    { type: 'language', subtag: 'ydg', prefix: [], scope: null },
    { type: 'language', subtag: 'ydk', prefix: [], scope: null },
    { type: 'language', subtag: 'yds', prefix: [], scope: null },
    { type: 'language', subtag: 'yea', prefix: [], scope: null },
    { type: 'language', subtag: 'yec', prefix: [], scope: null },
    { type: 'language', subtag: 'yee', prefix: [], scope: null },
    { type: 'language', subtag: 'yei', prefix: [], scope: null },
    { type: 'language', subtag: 'yej', prefix: [], scope: null },
    { type: 'language', subtag: 'yel', prefix: [], scope: null },
    { type: 'language', subtag: 'yen', prefix: [], scope: null },
    { type: 'language', subtag: 'yer', prefix: [], scope: null },
    { type: 'language', subtag: 'yes', prefix: [], scope: null },
    { type: 'language', subtag: 'yet', prefix: [], scope: null },
    { type: 'language', subtag: 'yeu', prefix: [], scope: null },
    { type: 'language', subtag: 'yev', prefix: [], scope: null },
    { type: 'language', subtag: 'yey', prefix: [], scope: null },
    { type: 'language', subtag: 'yga', prefix: [], scope: null },
    { type: 'language', subtag: 'ygi', prefix: [], scope: null },
    { type: 'language', subtag: 'ygl', prefix: [], scope: null },
    { type: 'language', subtag: 'ygm', prefix: [], scope: null },
    { type: 'language', subtag: 'ygp', prefix: [], scope: null },
    { type: 'language', subtag: 'ygr', prefix: [], scope: null },
    { type: 'language', subtag: 'ygs', prefix: [], scope: null },
    { type: 'language', subtag: 'ygu', prefix: [], scope: null },
    { type: 'language', subtag: 'ygw', prefix: [], scope: null },
    { type: 'language', subtag: 'yha', prefix: [], scope: null },
    { type: 'language', subtag: 'yhd', prefix: [], scope: null },
    { type: 'language', subtag: 'yhl', prefix: [], scope: null },
    { type: 'language', subtag: 'yhs', prefix: [], scope: null },
    { type: 'language', subtag: 'yia', prefix: [], scope: null },
    { type: 'language', subtag: 'yif', prefix: [], scope: null },
    { type: 'language', subtag: 'yig', prefix: [], scope: null },
    { type: 'language', subtag: 'yih', prefix: [], scope: null },
    { type: 'language', subtag: 'yii', prefix: [], scope: null },
    { type: 'language', subtag: 'yij', prefix: [], scope: null },
    { type: 'language', subtag: 'yik', prefix: [], scope: null },
    { type: 'language', subtag: 'yil', prefix: [], scope: null },
    { type: 'language', subtag: 'yim', prefix: [], scope: null },
    { type: 'language', subtag: 'yin', prefix: [], scope: null },
    { type: 'language', subtag: 'yip', prefix: [], scope: null },
    { type: 'language', subtag: 'yiq', prefix: [], scope: null },
    { type: 'language', subtag: 'yir', prefix: [], scope: null },
    { type: 'language', subtag: 'yis', prefix: [], scope: null },
    { type: 'language', subtag: 'yit', prefix: [], scope: null },
    { type: 'language', subtag: 'yiu', prefix: [], scope: null },
    { type: 'language', subtag: 'yiv', prefix: [], scope: null },
    { type: 'language', subtag: 'yix', prefix: [], scope: null },
    { type: 'language', subtag: 'yiy', prefix: [], scope: null },
    { type: 'language', subtag: 'yiz', prefix: [], scope: null },
    { type: 'language', subtag: 'yka', prefix: [], scope: null },
    { type: 'language', subtag: 'ykg', prefix: [], scope: null },
    { type: 'language', subtag: 'yki', prefix: [], scope: null },
    { type: 'language', subtag: 'ykk', prefix: [], scope: null },
    { type: 'language', subtag: 'ykl', prefix: [], scope: null },
    { type: 'language', subtag: 'ykm', prefix: [], scope: null },
    { type: 'language', subtag: 'ykn', prefix: [], scope: null },
    { type: 'language', subtag: 'yko', prefix: [], scope: null },
    { type: 'language', subtag: 'ykr', prefix: [], scope: null },
    { type: 'language', subtag: 'ykt', prefix: [], scope: null },
    { type: 'language', subtag: 'yku', prefix: [], scope: null },
    { type: 'language', subtag: 'yky', prefix: [], scope: null },
    { type: 'language', subtag: 'yla', prefix: [], scope: null },
    { type: 'language', subtag: 'ylb', prefix: [], scope: null },
    { type: 'language', subtag: 'yle', prefix: [], scope: null },
    { type: 'language', subtag: 'ylg', prefix: [], scope: null },
    { type: 'language', subtag: 'yli', prefix: [], scope: null },
    { type: 'language', subtag: 'yll', prefix: [], scope: null },
    { type: 'language', subtag: 'ylm', prefix: [], scope: null },
    { type: 'language', subtag: 'yln', prefix: [], scope: null },
    { type: 'language', subtag: 'ylo', prefix: [], scope: null },
    { type: 'language', subtag: 'ylr', prefix: [], scope: null },
    { type: 'language', subtag: 'ylu', prefix: [], scope: null },
    { type: 'language', subtag: 'yly', prefix: [], scope: null },
    { type: 'language', subtag: 'yma', prefix: [], scope: null },
    { type: 'language', subtag: 'ymb', prefix: [], scope: null },
    { type: 'language', subtag: 'ymc', prefix: [], scope: null },
    { type: 'language', subtag: 'ymd', prefix: [], scope: null },
    { type: 'language', subtag: 'yme', prefix: [], scope: null },
    { type: 'language', subtag: 'ymg', prefix: [], scope: null },
    { type: 'language', subtag: 'ymh', prefix: [], scope: null },
    { type: 'language', subtag: 'ymi', prefix: [], scope: null },
    { type: 'language', subtag: 'ymk', prefix: [], scope: null },
    { type: 'language', subtag: 'yml', prefix: [], scope: null },
    { type: 'language', subtag: 'ymm', prefix: [], scope: null },
    { type: 'language', subtag: 'ymn', prefix: [], scope: null },
    { type: 'language', subtag: 'ymo', prefix: [], scope: null },
    { type: 'language', subtag: 'ymp', prefix: [], scope: null },
    { type: 'language', subtag: 'ymq', prefix: [], scope: null },
    { type: 'language', subtag: 'ymr', prefix: [], scope: null },
    { type: 'language', subtag: 'yms', prefix: [], scope: null },
    { type: 'language', subtag: 'ymt', prefix: [], scope: null },
    { type: 'language', subtag: 'ymx', prefix: [], scope: null },
    { type: 'language', subtag: 'ymz', prefix: [], scope: null },
    { type: 'language', subtag: 'yna', prefix: [], scope: null },
    { type: 'language', subtag: 'ynd', prefix: [], scope: null },
    { type: 'language', subtag: 'yne', prefix: [], scope: null },
    { type: 'language', subtag: 'yng', prefix: [], scope: null },
    { type: 'language', subtag: 'ynh', prefix: [], scope: null },
    { type: 'language', subtag: 'ynk', prefix: [], scope: null },
    { type: 'language', subtag: 'ynl', prefix: [], scope: null },
    { type: 'language', subtag: 'ynn', prefix: [], scope: null },
    { type: 'language', subtag: 'yno', prefix: [], scope: null },
    { type: 'language', subtag: 'ynq', prefix: [], scope: null },
    { type: 'language', subtag: 'yns', prefix: [], scope: null },
    { type: 'language', subtag: 'ynu', prefix: [], scope: null },
    { type: 'language', subtag: 'yob', prefix: [], scope: null },
    { type: 'language', subtag: 'yog', prefix: [], scope: null },
    { type: 'language', subtag: 'yoi', prefix: [], scope: null },
    { type: 'language', subtag: 'yok', prefix: [], scope: null },
    { type: 'language', subtag: 'yol', prefix: [], scope: null },
    { type: 'language', subtag: 'yom', prefix: [], scope: null },
    { type: 'language', subtag: 'yon', prefix: [], scope: null },
    { type: 'language', subtag: 'yos', prefix: [], scope: null },
    { type: 'language', subtag: 'yot', prefix: [], scope: null },
    { type: 'language', subtag: 'yox', prefix: [], scope: null },
    { type: 'language', subtag: 'yoy', prefix: [], scope: null },
    { type: 'language', subtag: 'ypa', prefix: [], scope: null },
    { type: 'language', subtag: 'ypb', prefix: [], scope: null },
    { type: 'language', subtag: 'ypg', prefix: [], scope: null },
    { type: 'language', subtag: 'yph', prefix: [], scope: null },
    { type: 'language', subtag: 'ypk', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'ypm', prefix: [], scope: null },
    { type: 'language', subtag: 'ypn', prefix: [], scope: null },
    { type: 'language', subtag: 'ypo', prefix: [], scope: null },
    { type: 'language', subtag: 'ypp', prefix: [], scope: null },
    { type: 'language', subtag: 'ypz', prefix: [], scope: null },
    { type: 'language', subtag: 'yra', prefix: [], scope: null },
    { type: 'language', subtag: 'yrb', prefix: [], scope: null },
    { type: 'language', subtag: 'yre', prefix: [], scope: null },
    { type: 'language', subtag: 'yri', prefix: [], scope: null },
    { type: 'language', subtag: 'yrk', prefix: [], scope: null },
    { type: 'language', subtag: 'yrl', prefix: [], scope: null },
    { type: 'language', subtag: 'yrm', prefix: [], scope: null },
    { type: 'language', subtag: 'yrn', prefix: [], scope: null },
    { type: 'language', subtag: 'yro', prefix: [], scope: null },
    { type: 'language', subtag: 'yrs', prefix: [], scope: null },
    { type: 'language', subtag: 'yrw', prefix: [], scope: null },
    { type: 'language', subtag: 'yry', prefix: [], scope: null },
    { type: 'language', subtag: 'ysc', prefix: [], scope: null },
    { type: 'language', subtag: 'ysd', prefix: [], scope: null },
    { type: 'language', subtag: 'ysg', prefix: [], scope: null },
    { type: 'language', subtag: 'ysl', prefix: [], scope: null },
    { type: 'language', subtag: 'ysm', prefix: [], scope: null },
    { type: 'language', subtag: 'ysn', prefix: [], scope: null },
    { type: 'language', subtag: 'yso', prefix: [], scope: null },
    { type: 'language', subtag: 'ysp', prefix: [], scope: null },
    { type: 'language', subtag: 'ysr', prefix: [], scope: null },
    { type: 'language', subtag: 'yss', prefix: [], scope: null },
    { type: 'language', subtag: 'ysy', prefix: [], scope: null },
    { type: 'language', subtag: 'yta', prefix: [], scope: null },
    { type: 'language', subtag: 'ytl', prefix: [], scope: null },
    { type: 'language', subtag: 'ytp', prefix: [], scope: null },
    { type: 'language', subtag: 'ytw', prefix: [], scope: null },
    { type: 'language', subtag: 'yty', prefix: [], scope: null },
    { type: 'language', subtag: 'yua', prefix: [], scope: null },
    { type: 'language', subtag: 'yub', prefix: [], scope: null },
    { type: 'language', subtag: 'yuc', prefix: [], scope: null },
    { type: 'language', subtag: 'yud', prefix: [], scope: null },
    { type: 'language', subtag: 'yue', prefix: [], scope: null },
    { type: 'language', subtag: 'yuf', prefix: [], scope: null },
    { type: 'language', subtag: 'yug', prefix: [], scope: null },
    { type: 'language', subtag: 'yui', prefix: [], scope: null },
    { type: 'language', subtag: 'yuj', prefix: [], scope: null },
    { type: 'language', subtag: 'yuk', prefix: [], scope: null },
    { type: 'language', subtag: 'yul', prefix: [], scope: null },
    { type: 'language', subtag: 'yum', prefix: [], scope: null },
    { type: 'language', subtag: 'yun', prefix: [], scope: null },
    { type: 'language', subtag: 'yup', prefix: [], scope: null },
    { type: 'language', subtag: 'yuq', prefix: [], scope: null },
    { type: 'language', subtag: 'yur', prefix: [], scope: null },
    { type: 'language', subtag: 'yut', prefix: [], scope: null },
    { type: 'language', subtag: 'yuu', prefix: [], scope: null },
    { type: 'language', subtag: 'yuw', prefix: [], scope: null },
    { type: 'language', subtag: 'yux', prefix: [], scope: null },
    { type: 'language', subtag: 'yuy', prefix: [], scope: null },
    { type: 'language', subtag: 'yuz', prefix: [], scope: null },
    { type: 'language', subtag: 'yva', prefix: [], scope: null },
    { type: 'language', subtag: 'yvt', prefix: [], scope: null },
    { type: 'language', subtag: 'ywa', prefix: [], scope: null },
    { type: 'language', subtag: 'ywg', prefix: [], scope: null },
    { type: 'language', subtag: 'ywl', prefix: [], scope: null },
    { type: 'language', subtag: 'ywn', prefix: [], scope: null },
    { type: 'language', subtag: 'ywq', prefix: [], scope: null },
    { type: 'language', subtag: 'ywr', prefix: [], scope: null },
    { type: 'language', subtag: 'ywt', prefix: [], scope: null },
    { type: 'language', subtag: 'ywu', prefix: [], scope: null },
    { type: 'language', subtag: 'yww', prefix: [], scope: null },
    { type: 'language', subtag: 'yxa', prefix: [], scope: null },
    { type: 'language', subtag: 'yxg', prefix: [], scope: null },
    { type: 'language', subtag: 'yxl', prefix: [], scope: null },
    { type: 'language', subtag: 'yxm', prefix: [], scope: null },
    { type: 'language', subtag: 'yxu', prefix: [], scope: null },
    { type: 'language', subtag: 'yxy', prefix: [], scope: null },
    { type: 'language', subtag: 'yyr', prefix: [], scope: null },
    { type: 'language', subtag: 'yyu', prefix: [], scope: null },
    { type: 'language', subtag: 'yyz', prefix: [], scope: null },
    { type: 'language', subtag: 'yzg', prefix: [], scope: null },
    { type: 'language', subtag: 'yzk', prefix: [], scope: null },
    { type: 'language', subtag: 'zaa', prefix: [], scope: null },
    { type: 'language', subtag: 'zab', prefix: [], scope: null },
    { type: 'language', subtag: 'zac', prefix: [], scope: null },
    { type: 'language', subtag: 'zad', prefix: [], scope: null },
    { type: 'language', subtag: 'zae', prefix: [], scope: null },
    { type: 'language', subtag: 'zaf', prefix: [], scope: null },
    { type: 'language', subtag: 'zag', prefix: [], scope: null },
    { type: 'language', subtag: 'zah', prefix: [], scope: null },
    { type: 'language', subtag: 'zai', prefix: [], scope: null },
    { type: 'language', subtag: 'zaj', prefix: [], scope: null },
    { type: 'language', subtag: 'zak', prefix: [], scope: null },
    { type: 'language', subtag: 'zal', prefix: [], scope: null },
    { type: 'language', subtag: 'zam', prefix: [], scope: null },
    { type: 'language', subtag: 'zao', prefix: [], scope: null },
    { type: 'language', subtag: 'zap', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'zaq', prefix: [], scope: null },
    { type: 'language', subtag: 'zar', prefix: [], scope: null },
    { type: 'language', subtag: 'zas', prefix: [], scope: null },
    { type: 'language', subtag: 'zat', prefix: [], scope: null },
    { type: 'language', subtag: 'zau', prefix: [], scope: null },
    { type: 'language', subtag: 'zav', prefix: [], scope: null },
    { type: 'language', subtag: 'zaw', prefix: [], scope: null },
    { type: 'language', subtag: 'zax', prefix: [], scope: null },
    { type: 'language', subtag: 'zay', prefix: [], scope: null },
    { type: 'language', subtag: 'zaz', prefix: [], scope: null },
    { type: 'language', subtag: 'zba', prefix: [], scope: null },
    { type: 'language', subtag: 'zbc', prefix: [], scope: null },
    { type: 'language', subtag: 'zbe', prefix: [], scope: null },
    { type: 'language', subtag: 'zbl', prefix: [], scope: null },
    { type: 'language', subtag: 'zbt', prefix: [], scope: null },
    { type: 'language', subtag: 'zbu', prefix: [], scope: null },
    { type: 'language', subtag: 'zbw', prefix: [], scope: null },
    { type: 'language', subtag: 'zca', prefix: [], scope: null },
    { type: 'language', subtag: 'zcd', prefix: [], scope: null },
    { type: 'language', subtag: 'zch', prefix: [], scope: null },
    { type: 'language', subtag: 'zdj', prefix: [], scope: null },
    { type: 'language', subtag: 'zea', prefix: [], scope: null },
    { type: 'language', subtag: 'zeg', prefix: [], scope: null },
    { type: 'language', subtag: 'zeh', prefix: [], scope: null },
    { type: 'language', subtag: 'zen', prefix: [], scope: null },
    { type: 'language', subtag: 'zga', prefix: [], scope: null },
    { type: 'language', subtag: 'zgb', prefix: [], scope: null },
    { type: 'language', subtag: 'zgh', prefix: [], scope: null },
    { type: 'language', subtag: 'zgm', prefix: [], scope: null },
    { type: 'language', subtag: 'zgn', prefix: [], scope: null },
    { type: 'language', subtag: 'zgr', prefix: [], scope: null },
    { type: 'language', subtag: 'zhb', prefix: [], scope: null },
    { type: 'language', subtag: 'zhd', prefix: [], scope: null },
    { type: 'language', subtag: 'zhi', prefix: [], scope: null },
    { type: 'language', subtag: 'zhn', prefix: [], scope: null },
    { type: 'language', subtag: 'zhw', prefix: [], scope: null },
    { type: 'language', subtag: 'zhx', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'zia', prefix: [], scope: null },
    { type: 'language', subtag: 'zib', prefix: [], scope: null },
    { type: 'language', subtag: 'zik', prefix: [], scope: null },
    { type: 'language', subtag: 'zil', prefix: [], scope: null },
    { type: 'language', subtag: 'zim', prefix: [], scope: null },
    { type: 'language', subtag: 'zin', prefix: [], scope: null },
    { type: 'language', subtag: 'zir', prefix: [], scope: null },
    { type: 'language', subtag: 'ziw', prefix: [], scope: null },
    { type: 'language', subtag: 'ziz', prefix: [], scope: null },
    { type: 'language', subtag: 'zka', prefix: [], scope: null },
    { type: 'language', subtag: 'zkb', prefix: [], scope: null },
    { type: 'language', subtag: 'zkd', prefix: [], scope: null },
    { type: 'language', subtag: 'zkg', prefix: [], scope: null },
    { type: 'language', subtag: 'zkh', prefix: [], scope: null },
    { type: 'language', subtag: 'zkk', prefix: [], scope: null },
    { type: 'language', subtag: 'zkn', prefix: [], scope: null },
    { type: 'language', subtag: 'zko', prefix: [], scope: null },
    { type: 'language', subtag: 'zkp', prefix: [], scope: null },
    { type: 'language', subtag: 'zkr', prefix: [], scope: null },
    { type: 'language', subtag: 'zkt', prefix: [], scope: null },
    { type: 'language', subtag: 'zku', prefix: [], scope: null },
    { type: 'language', subtag: 'zkv', prefix: [], scope: null },
    { type: 'language', subtag: 'zkz', prefix: [], scope: null },
    { type: 'language', subtag: 'zla', prefix: [], scope: null },
    { type: 'language', subtag: 'zle', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'zlj', prefix: [], scope: null },
    { type: 'language', subtag: 'zlm', prefix: [], scope: null },
    { type: 'language', subtag: 'zln', prefix: [], scope: null },
    { type: 'language', subtag: 'zlq', prefix: [], scope: null },
    { type: 'language', subtag: 'zls', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'zlw', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'zma', prefix: [], scope: null },
    { type: 'language', subtag: 'zmb', prefix: [], scope: null },
    { type: 'language', subtag: 'zmc', prefix: [], scope: null },
    { type: 'language', subtag: 'zmd', prefix: [], scope: null },
    { type: 'language', subtag: 'zme', prefix: [], scope: null },
    { type: 'language', subtag: 'zmf', prefix: [], scope: null },
    { type: 'language', subtag: 'zmg', prefix: [], scope: null },
    { type: 'language', subtag: 'zmh', prefix: [], scope: null },
    { type: 'language', subtag: 'zmi', prefix: [], scope: null },
    { type: 'language', subtag: 'zmj', prefix: [], scope: null },
    { type: 'language', subtag: 'zmk', prefix: [], scope: null },
    { type: 'language', subtag: 'zml', prefix: [], scope: null },
    { type: 'language', subtag: 'zmm', prefix: [], scope: null },
    { type: 'language', subtag: 'zmn', prefix: [], scope: null },
    { type: 'language', subtag: 'zmo', prefix: [], scope: null },
    { type: 'language', subtag: 'zmp', prefix: [], scope: null },
    { type: 'language', subtag: 'zmq', prefix: [], scope: null },
    { type: 'language', subtag: 'zmr', prefix: [], scope: null },
    { type: 'language', subtag: 'zms', prefix: [], scope: null },
    { type: 'language', subtag: 'zmt', prefix: [], scope: null },
    { type: 'language', subtag: 'zmu', prefix: [], scope: null },
    { type: 'language', subtag: 'zmv', prefix: [], scope: null },
    { type: 'language', subtag: 'zmw', prefix: [], scope: null },
    { type: 'language', subtag: 'zmx', prefix: [], scope: null },
    { type: 'language', subtag: 'zmy', prefix: [], scope: null },
    { type: 'language', subtag: 'zmz', prefix: [], scope: null },
    { type: 'language', subtag: 'zna', prefix: [], scope: null },
    { type: 'language', subtag: 'znd', prefix: [], scope: 'collection' },
    { type: 'language', subtag: 'zne', prefix: [], scope: null },
    { type: 'language', subtag: 'zng', prefix: [], scope: null },
    { type: 'language', subtag: 'znk', prefix: [], scope: null },
    { type: 'language', subtag: 'zns', prefix: [], scope: null },
    { type: 'language', subtag: 'zoc', prefix: [], scope: null },
    { type: 'language', subtag: 'zoh', prefix: [], scope: null },
    { type: 'language', subtag: 'zom', prefix: [], scope: null },
    { type: 'language', subtag: 'zoo', prefix: [], scope: null },
    { type: 'language', subtag: 'zoq', prefix: [], scope: null },
    { type: 'language', subtag: 'zor', prefix: [], scope: null },
    { type: 'language', subtag: 'zos', prefix: [], scope: null },
    { type: 'language', subtag: 'zpa', prefix: [], scope: null },
    { type: 'language', subtag: 'zpb', prefix: [], scope: null },
    { type: 'language', subtag: 'zpc', prefix: [], scope: null },
    { type: 'language', subtag: 'zpd', prefix: [], scope: null },
    { type: 'language', subtag: 'zpe', prefix: [], scope: null },
    { type: 'language', subtag: 'zpf', prefix: [], scope: null },
    { type: 'language', subtag: 'zpg', prefix: [], scope: null },
    { type: 'language', subtag: 'zph', prefix: [], scope: null },
    { type: 'language', subtag: 'zpi', prefix: [], scope: null },
    { type: 'language', subtag: 'zpj', prefix: [], scope: null },
    { type: 'language', subtag: 'zpk', prefix: [], scope: null },
    { type: 'language', subtag: 'zpl', prefix: [], scope: null },
    { type: 'language', subtag: 'zpm', prefix: [], scope: null },
    { type: 'language', subtag: 'zpn', prefix: [], scope: null },
    { type: 'language', subtag: 'zpo', prefix: [], scope: null },
    { type: 'language', subtag: 'zpp', prefix: [], scope: null },
    { type: 'language', subtag: 'zpq', prefix: [], scope: null },
    { type: 'language', subtag: 'zpr', prefix: [], scope: null },
    { type: 'language', subtag: 'zps', prefix: [], scope: null },
    { type: 'language', subtag: 'zpt', prefix: [], scope: null },
    { type: 'language', subtag: 'zpu', prefix: [], scope: null },
    { type: 'language', subtag: 'zpv', prefix: [], scope: null },
    { type: 'language', subtag: 'zpw', prefix: [], scope: null },
    { type: 'language', subtag: 'zpx', prefix: [], scope: null },
    { type: 'language', subtag: 'zpy', prefix: [], scope: null },
    { type: 'language', subtag: 'zpz', prefix: [], scope: null },
    { type: 'language', subtag: 'zqe', prefix: [], scope: null },
    { type: 'language', subtag: 'zra', prefix: [], scope: null },
    { type: 'language', subtag: 'zrg', prefix: [], scope: null },
    { type: 'language', subtag: 'zrn', prefix: [], scope: null },
    { type: 'language', subtag: 'zro', prefix: [], scope: null },
    { type: 'language', subtag: 'zrp', prefix: [], scope: null },
    { type: 'language', subtag: 'zrs', prefix: [], scope: null },
    { type: 'language', subtag: 'zsa', prefix: [], scope: null },
    { type: 'language', subtag: 'zsk', prefix: [], scope: null },
    { type: 'language', subtag: 'zsl', prefix: [], scope: null },
    { type: 'language', subtag: 'zsm', prefix: [], scope: null },
    { type: 'language', subtag: 'zsr', prefix: [], scope: null },
    { type: 'language', subtag: 'zsu', prefix: [], scope: null },
    { type: 'language', subtag: 'zte', prefix: [], scope: null },
    { type: 'language', subtag: 'ztg', prefix: [], scope: null },
    { type: 'language', subtag: 'ztl', prefix: [], scope: null },
    { type: 'language', subtag: 'ztm', prefix: [], scope: null },
    { type: 'language', subtag: 'ztn', prefix: [], scope: null },
    { type: 'language', subtag: 'ztp', prefix: [], scope: null },
    { type: 'language', subtag: 'ztq', prefix: [], scope: null },
    { type: 'language', subtag: 'zts', prefix: [], scope: null },
    { type: 'language', subtag: 'ztt', prefix: [], scope: null },
    { type: 'language', subtag: 'ztu', prefix: [], scope: null },
    { type: 'language', subtag: 'ztx', prefix: [], scope: null },
    { type: 'language', subtag: 'zty', prefix: [], scope: null },
    { type: 'language', subtag: 'zua', prefix: [], scope: null },
    { type: 'language', subtag: 'zuh', prefix: [], scope: null },
    { type: 'language', subtag: 'zum', prefix: [], scope: null },
    { type: 'language', subtag: 'zun', prefix: [], scope: null },
    { type: 'language', subtag: 'zuy', prefix: [], scope: null },
    { type: 'language', subtag: 'zwa', prefix: [], scope: null },
    { type: 'language', subtag: 'zxx', prefix: [], scope: 'special' },
    { type: 'language', subtag: 'zyb', prefix: [], scope: null },
    { type: 'language', subtag: 'zyg', prefix: [], scope: null },
    { type: 'language', subtag: 'zyj', prefix: [], scope: null },
    { type: 'language', subtag: 'zyn', prefix: [], scope: null },
    { type: 'language', subtag: 'zyp', prefix: [], scope: null },
    { type: 'language', subtag: 'zza', prefix: [], scope: 'macrolanguage' },
    { type: 'language', subtag: 'zzj', prefix: [], scope: null },
    { type: 'extlang', subtag: 'aao', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'abh', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'abv', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'acm', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'acq', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'acw', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'acx', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'acy', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'adf', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ads', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'aeb', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'aec', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'aed', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'aen', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'afb', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'afg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ajp', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ajs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'apc', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'apd', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'arb', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'arq', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ars', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ary', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'arz', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ase', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'asf', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'asp', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'asq', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'asw', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'auz', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'avl', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ayh', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ayl', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ayn', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ayp', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'bbz', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'bfi', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'bfk', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'bjn', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'bog', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'bqn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'bqy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'btj', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'bve', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'bvl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'bvu', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'bzs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'cdo', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'cds', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'cjy', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'cmn', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'cnp', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'coa', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'cpx', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'csc', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csd', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'cse', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csf', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csp', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'csq', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'csx', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'czh', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'czo', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'doq', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'dse', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'dsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'dsz', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'dup', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'ecs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ehs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'esl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'esn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'eso', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'eth', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'fcs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'fse', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'fsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'fss', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gan', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'gds', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gom', prefix: ['kok'], scope: null },
    { type: 'extlang', subtag: 'gse', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gsg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gsm', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gss', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'gus', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hab', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'haf', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hak', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'hds', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hji', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'hks', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hos', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hps', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hsh', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'hsn', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'icl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'iks', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ils', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'inl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ins', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ise', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'isg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'isr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jak', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'jax', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'jcs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jhs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jks', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jls', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jos', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'jus', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'kgi', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'knn', prefix: ['kok'], scope: null },
    { type: 'extlang', subtag: 'kvb', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'kvk', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'kvr', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'kxd', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'lbs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lce', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'lcf', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'liw', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'lls', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsb', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsc', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lso', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsp', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lst', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsv', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsw', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lsy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ltg', prefix: ['lv'], scope: null },
    { type: 'extlang', subtag: 'lvs', prefix: ['lv'], scope: null },
    { type: 'extlang', subtag: 'lws', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'lzh', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'max', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mdl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'meo', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mfa', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mfb', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mfs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'min', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mnp', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'mqg', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mre', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'msd', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'msi', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'msr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'mui', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'mzc', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'mzg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'mzy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nan', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'nbs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ncs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nsi', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nsp', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nsr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'nzs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'okl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'orn', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'ors', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'pel', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'pga', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'pgz', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'pks', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'prl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'prz', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'psc', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'psd', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'pse', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'psg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'psl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'pso', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'psp', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'psr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'pys', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rib', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rms', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rnb', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rsi', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rsm', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'rsn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sdl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sfb', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sfs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sgg', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sgx', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'shu', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'slf', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sls', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sqk', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sqs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'sqx', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ssh', prefix: ['ar'], scope: null },
    { type: 'extlang', subtag: 'ssp', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ssr', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'svk', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'swc', prefix: ['sw'], scope: null },
    { type: 'extlang', subtag: 'swh', prefix: ['sw'], scope: null },
    { type: 'extlang', subtag: 'swl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'syy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'szs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tmw', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'tse', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tsm', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tsq', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tss', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tsy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'tza', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ugn', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ugy', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ukl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'uks', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'urk', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'uzn', prefix: ['uz'], scope: null },
    { type: 'extlang', subtag: 'uzs', prefix: ['uz'], scope: null },
    { type: 'extlang', subtag: 'vgt', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'vkk', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'vkt', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'vsi', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'vsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'vsv', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'wbs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'wuu', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'xki', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'xml', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'xmm', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'xms', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'yds', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ygs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'yhs', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ysl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'ysm', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'yue', prefix: ['zh'], scope: null },
    { type: 'extlang', subtag: 'zib', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'zlm', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'zmi', prefix: ['ms'], scope: null },
    { type: 'extlang', subtag: 'zsl', prefix: ['sgn'], scope: null },
    { type: 'extlang', subtag: 'zsm', prefix: ['ms'], scope: null },
    { type: 'script', subtag: 'Adlm', prefix: [], scope: null },
    { type: 'script', subtag: 'Afak', prefix: [], scope: null },
    { type: 'script', subtag: 'Aghb', prefix: [], scope: null },
    { type: 'script', subtag: 'Ahom', prefix: [], scope: null },
    { type: 'script', subtag: 'Arab', prefix: [], scope: null },
    { type: 'script', subtag: 'Aran', prefix: [], scope: null },
    { type: 'script', subtag: 'Armi', prefix: [], scope: null },
    { type: 'script', subtag: 'Armn', prefix: [], scope: null },
    { type: 'script', subtag: 'Avst', prefix: [], scope: null },
    { type: 'script', subtag: 'Bali', prefix: [], scope: null },
    { type: 'script', subtag: 'Bamu', prefix: [], scope: null },
    { type: 'script', subtag: 'Bass', prefix: [], scope: null },
    { type: 'script', subtag: 'Batk', prefix: [], scope: null },
    { type: 'script', subtag: 'Beng', prefix: [], scope: null },
    { type: 'script', subtag: 'Bhks', prefix: [], scope: null },
    { type: 'script', subtag: 'Blis', prefix: [], scope: null },
    { type: 'script', subtag: 'Bopo', prefix: [], scope: null },
    { type: 'script', subtag: 'Brah', prefix: [], scope: null },
    { type: 'script', subtag: 'Brai', prefix: [], scope: null },
    { type: 'script', subtag: 'Bugi', prefix: [], scope: null },
    { type: 'script', subtag: 'Buhd', prefix: [], scope: null },
    { type: 'script', subtag: 'Cakm', prefix: [], scope: null },
    { type: 'script', subtag: 'Cans', prefix: [], scope: null },
    { type: 'script', subtag: 'Cari', prefix: [], scope: null },
    { type: 'script', subtag: 'Cham', prefix: [], scope: null },
    { type: 'script', subtag: 'Cher', prefix: [], scope: null },
    { type: 'script', subtag: 'Chrs', prefix: [], scope: null },
    { type: 'script', subtag: 'Cirt', prefix: [], scope: null },
    { type: 'script', subtag: 'Copt', prefix: [], scope: null },
    { type: 'script', subtag: 'Cpmn', prefix: [], scope: null },
    { type: 'script', subtag: 'Cprt', prefix: [], scope: null },
    { type: 'script', subtag: 'Cyrl', prefix: [], scope: null },
    { type: 'script', subtag: 'Cyrs', prefix: [], scope: null },
    { type: 'script', subtag: 'Deva', prefix: [], scope: null },
    { type: 'script', subtag: 'Diak', prefix: [], scope: null },
    { type: 'script', subtag: 'Dogr', prefix: [], scope: null },
    { type: 'script', subtag: 'Dsrt', prefix: [], scope: null },
    { type: 'script', subtag: 'Dupl', prefix: [], scope: null },
    { type: 'script', subtag: 'Egyd', prefix: [], scope: null },
    { type: 'script', subtag: 'Egyh', prefix: [], scope: null },
    { type: 'script', subtag: 'Egyp', prefix: [], scope: null },
    { type: 'script', subtag: 'Elba', prefix: [], scope: null },
    { type: 'script', subtag: 'Elym', prefix: [], scope: null },
    { type: 'script', subtag: 'Ethi', prefix: [], scope: null },
    { type: 'script', subtag: 'Geok', prefix: [], scope: null },
    { type: 'script', subtag: 'Geor', prefix: [], scope: null },
    { type: 'script', subtag: 'Glag', prefix: [], scope: null },
    { type: 'script', subtag: 'Gong', prefix: [], scope: null },
    { type: 'script', subtag: 'Gonm', prefix: [], scope: null },
    { type: 'script', subtag: 'Goth', prefix: [], scope: null },
    { type: 'script', subtag: 'Gran', prefix: [], scope: null },
    { type: 'script', subtag: 'Grek', prefix: [], scope: null },
    { type: 'script', subtag: 'Gujr', prefix: [], scope: null },
    { type: 'script', subtag: 'Guru', prefix: [], scope: null },
    { type: 'script', subtag: 'Hanb', prefix: [], scope: null },
    { type: 'script', subtag: 'Hang', prefix: [], scope: null },
    { type: 'script', subtag: 'Hani', prefix: [], scope: null },
    { type: 'script', subtag: 'Hano', prefix: [], scope: null },
    { type: 'script', subtag: 'Hans', prefix: [], scope: null },
    { type: 'script', subtag: 'Hant', prefix: [], scope: null },
    { type: 'script', subtag: 'Hatr', prefix: [], scope: null },
    { type: 'script', subtag: 'Hebr', prefix: [], scope: null },
    { type: 'script', subtag: 'Hira', prefix: [], scope: null },
    { type: 'script', subtag: 'Hluw', prefix: [], scope: null },
    { type: 'script', subtag: 'Hmng', prefix: [], scope: null },
    { type: 'script', subtag: 'Hmnp', prefix: [], scope: null },
    { type: 'script', subtag: 'Hrkt', prefix: [], scope: null },
    { type: 'script', subtag: 'Hung', prefix: [], scope: null },
    { type: 'script', subtag: 'Inds', prefix: [], scope: null },
    { type: 'script', subtag: 'Ital', prefix: [], scope: null },
    { type: 'script', subtag: 'Jamo', prefix: [], scope: null },
    { type: 'script', subtag: 'Java', prefix: [], scope: null },
    { type: 'script', subtag: 'Jpan', prefix: [], scope: null },
    { type: 'script', subtag: 'Jurc', prefix: [], scope: null },
    { type: 'script', subtag: 'Kali', prefix: [], scope: null },
    { type: 'script', subtag: 'Kana', prefix: [], scope: null },
    { type: 'script', subtag: 'Kawi', prefix: [], scope: null },
    { type: 'script', subtag: 'Khar', prefix: [], scope: null },
    { type: 'script', subtag: 'Khmr', prefix: [], scope: null },
    { type: 'script', subtag: 'Khoj', prefix: [], scope: null },
    { type: 'script', subtag: 'Kitl', prefix: [], scope: null },
    { type: 'script', subtag: 'Kits', prefix: [], scope: null },
    { type: 'script', subtag: 'Knda', prefix: [], scope: null },
    { type: 'script', subtag: 'Kore', prefix: [], scope: null },
    { type: 'script', subtag: 'Kpel', prefix: [], scope: null },
    { type: 'script', subtag: 'Kthi', prefix: [], scope: null },
    { type: 'script', subtag: 'Lana', prefix: [], scope: null },
    { type: 'script', subtag: 'Laoo', prefix: [], scope: null },
    { type: 'script', subtag: 'Latf', prefix: [], scope: null },
    { type: 'script', subtag: 'Latg', prefix: [], scope: null },
    { type: 'script', subtag: 'Latn', prefix: [], scope: null },
    { type: 'script', subtag: 'Leke', prefix: [], scope: null },
    { type: 'script', subtag: 'Lepc', prefix: [], scope: null },
    { type: 'script', subtag: 'Limb', prefix: [], scope: null },
    { type: 'script', subtag: 'Lina', prefix: [], scope: null },
    { type: 'script', subtag: 'Linb', prefix: [], scope: null },
    { type: 'script', subtag: 'Lisu', prefix: [], scope: null },
    { type: 'script', subtag: 'Loma', prefix: [], scope: null },
    { type: 'script', subtag: 'Lyci', prefix: [], scope: null },
    { type: 'script', subtag: 'Lydi', prefix: [], scope: null },
    { type: 'script', subtag: 'Mahj', prefix: [], scope: null },
    { type: 'script', subtag: 'Maka', prefix: [], scope: null },
    { type: 'script', subtag: 'Mand', prefix: [], scope: null },
    { type: 'script', subtag: 'Mani', prefix: [], scope: null },
    { type: 'script', subtag: 'Marc', prefix: [], scope: null },
    { type: 'script', subtag: 'Maya', prefix: [], scope: null },
    { type: 'script', subtag: 'Medf', prefix: [], scope: null },
    { type: 'script', subtag: 'Mend', prefix: [], scope: null },
    { type: 'script', subtag: 'Merc', prefix: [], scope: null },
    { type: 'script', subtag: 'Mero', prefix: [], scope: null },
    { type: 'script', subtag: 'Mlym', prefix: [], scope: null },
    { type: 'script', subtag: 'Modi', prefix: [], scope: null },
    { type: 'script', subtag: 'Mong', prefix: [], scope: null },
    { type: 'script', subtag: 'Moon', prefix: [], scope: null },
    { type: 'script', subtag: 'Mroo', prefix: [], scope: null },
    { type: 'script', subtag: 'Mtei', prefix: [], scope: null },
    { type: 'script', subtag: 'Mult', prefix: [], scope: null },
    { type: 'script', subtag: 'Mymr', prefix: [], scope: null },
    { type: 'script', subtag: 'Nagm', prefix: [], scope: null },
    { type: 'script', subtag: 'Nand', prefix: [], scope: null },
    { type: 'script', subtag: 'Narb', prefix: [], scope: null },
    { type: 'script', subtag: 'Nbat', prefix: [], scope: null },
    { type: 'script', subtag: 'Newa', prefix: [], scope: null },
    { type: 'script', subtag: 'Nkdb', prefix: [], scope: null },
    { type: 'script', subtag: 'Nkgb', prefix: [], scope: null },
    { type: 'script', subtag: 'Nkoo', prefix: [], scope: null },
    { type: 'script', subtag: 'Nshu', prefix: [], scope: null },
    { type: 'script', subtag: 'Ogam', prefix: [], scope: null },
    { type: 'script', subtag: 'Olck', prefix: [], scope: null },
    { type: 'script', subtag: 'Orkh', prefix: [], scope: null },
    { type: 'script', subtag: 'Orya', prefix: [], scope: null },
    { type: 'script', subtag: 'Osge', prefix: [], scope: null },
    { type: 'script', subtag: 'Osma', prefix: [], scope: null },
    { type: 'script', subtag: 'Ougr', prefix: [], scope: null },
    { type: 'script', subtag: 'Palm', prefix: [], scope: null },
    { type: 'script', subtag: 'Pauc', prefix: [], scope: null },
    { type: 'script', subtag: 'Pcun', prefix: [], scope: null },
    { type: 'script', subtag: 'Pelm', prefix: [], scope: null },
    { type: 'script', subtag: 'Perm', prefix: [], scope: null },
    { type: 'script', subtag: 'Phag', prefix: [], scope: null },
    { type: 'script', subtag: 'Phli', prefix: [], scope: null },
    { type: 'script', subtag: 'Phlp', prefix: [], scope: null },
    { type: 'script', subtag: 'Phlv', prefix: [], scope: null },
    { type: 'script', subtag: 'Phnx', prefix: [], scope: null },
    { type: 'script', subtag: 'Piqd', prefix: [], scope: null },
    { type: 'script', subtag: 'Plrd', prefix: [], scope: null },
    { type: 'script', subtag: 'Prti', prefix: [], scope: null },
    { type: 'script', subtag: 'Psin', prefix: [], scope: null },
    { type: 'script', subtag: 'Qaaa..Qabx', prefix: [], scope: 'private-use' },
    { type: 'script', subtag: 'Ranj', prefix: [], scope: null },
    { type: 'script', subtag: 'Rjng', prefix: [], scope: null },
    { type: 'script', subtag: 'Rohg', prefix: [], scope: null },
    { type: 'script', subtag: 'Roro', prefix: [], scope: null },
    { type: 'script', subtag: 'Runr', prefix: [], scope: null },
    { type: 'script', subtag: 'Samr', prefix: [], scope: null },
    { type: 'script', subtag: 'Sara', prefix: [], scope: null },
    { type: 'script', subtag: 'Sarb', prefix: [], scope: null },
    { type: 'script', subtag: 'Saur', prefix: [], scope: null },
    { type: 'script', subtag: 'Sgnw', prefix: [], scope: null },
    { type: 'script', subtag: 'Shaw', prefix: [], scope: null },
    { type: 'script', subtag: 'Shrd', prefix: [], scope: null },
    { type: 'script', subtag: 'Shui', prefix: [], scope: null },
    { type: 'script', subtag: 'Sidd', prefix: [], scope: null },
    { type: 'script', subtag: 'Sind', prefix: [], scope: null },
    { type: 'script', subtag: 'Sinh', prefix: [], scope: null },
    { type: 'script', subtag: 'Sogd', prefix: [], scope: null },
    { type: 'script', subtag: 'Sogo', prefix: [], scope: null },
    { type: 'script', subtag: 'Sora', prefix: [], scope: null },
    { type: 'script', subtag: 'Soyo', prefix: [], scope: null },
    { type: 'script', subtag: 'Sund', prefix: [], scope: null },
    { type: 'script', subtag: 'Sunu', prefix: [], scope: null },
    { type: 'script', subtag: 'Sylo', prefix: [], scope: null },
    { type: 'script', subtag: 'Syrc', prefix: [], scope: null },
    { type: 'script', subtag: 'Syre', prefix: [], scope: null },
    { type: 'script', subtag: 'Syrj', prefix: [], scope: null },
    { type: 'script', subtag: 'Syrn', prefix: [], scope: null },
    { type: 'script', subtag: 'Tagb', prefix: [], scope: null },
    { type: 'script', subtag: 'Takr', prefix: [], scope: null },
    { type: 'script', subtag: 'Tale', prefix: [], scope: null },
    { type: 'script', subtag: 'Talu', prefix: [], scope: null },
    { type: 'script', subtag: 'Taml', prefix: [], scope: null },
    { type: 'script', subtag: 'Tang', prefix: [], scope: null },
    { type: 'script', subtag: 'Tavt', prefix: [], scope: null },
    { type: 'script', subtag: 'Telu', prefix: [], scope: null },
    { type: 'script', subtag: 'Teng', prefix: [], scope: null },
    { type: 'script', subtag: 'Tfng', prefix: [], scope: null },
    { type: 'script', subtag: 'Tglg', prefix: [], scope: null },
    { type: 'script', subtag: 'Thaa', prefix: [], scope: null },
    { type: 'script', subtag: 'Thai', prefix: [], scope: null },
    { type: 'script', subtag: 'Tibt', prefix: [], scope: null },
    { type: 'script', subtag: 'Tirh', prefix: [], scope: null },
    { type: 'script', subtag: 'Tnsa', prefix: [], scope: null },
    { type: 'script', subtag: 'Toto', prefix: [], scope: null },
    { type: 'script', subtag: 'Ugar', prefix: [], scope: null },
    { type: 'script', subtag: 'Vaii', prefix: [], scope: null },
    { type: 'script', subtag: 'Visp', prefix: [], scope: null },
    { type: 'script', subtag: 'Vith', prefix: [], scope: null },
    { type: 'script', subtag: 'Wara', prefix: [], scope: null },
    { type: 'script', subtag: 'Wcho', prefix: [], scope: null },
    { type: 'script', subtag: 'Wole', prefix: [], scope: null },
    { type: 'script', subtag: 'Xpeo', prefix: [], scope: null },
    { type: 'script', subtag: 'Xsux', prefix: [], scope: null },
    { type: 'script', subtag: 'Yezi', prefix: [], scope: null },
    { type: 'script', subtag: 'Yiii', prefix: [], scope: null },
    { type: 'script', subtag: 'Zanb', prefix: [], scope: null },
    { type: 'script', subtag: 'Zinh', prefix: [], scope: null },
    { type: 'script', subtag: 'Zmth', prefix: [], scope: null },
    { type: 'script', subtag: 'Zsye', prefix: [], scope: null },
    { type: 'script', subtag: 'Zsym', prefix: [], scope: null },
    { type: 'script', subtag: 'Zxxx', prefix: [], scope: null },
    { type: 'script', subtag: 'Zyyy', prefix: [], scope: null },
    { type: 'script', subtag: 'Zzzz', prefix: [], scope: null },
    { type: 'region', subtag: 'AA', prefix: [], scope: 'private-use' },
    { type: 'region', subtag: 'AC', prefix: [], scope: null },
    { type: 'region', subtag: 'AD', prefix: [], scope: null },
    { type: 'region', subtag: 'AE', prefix: [], scope: null },
    { type: 'region', subtag: 'AF', prefix: [], scope: null },
    { type: 'region', subtag: 'AG', prefix: [], scope: null },
    { type: 'region', subtag: 'AI', prefix: [], scope: null },
    { type: 'region', subtag: 'AL', prefix: [], scope: null },
    { type: 'region', subtag: 'AM', prefix: [], scope: null },
    { type: 'region', subtag: 'AN', prefix: [], scope: null },
    { type: 'region', subtag: 'AO', prefix: [], scope: null },
    { type: 'region', subtag: 'AQ', prefix: [], scope: null },
    { type: 'region', subtag: 'AR', prefix: [], scope: null },
    { type: 'region', subtag: 'AS', prefix: [], scope: null },
    { type: 'region', subtag: 'AT', prefix: [], scope: null },
    { type: 'region', subtag: 'AU', prefix: [], scope: null },
    { type: 'region', subtag: 'AW', prefix: [], scope: null },
    { type: 'region', subtag: 'AX', prefix: [], scope: null },
    { type: 'region', subtag: 'AZ', prefix: [], scope: null },
    { type: 'region', subtag: 'BA', prefix: [], scope: null },
    { type: 'region', subtag: 'BB', prefix: [], scope: null },
    { type: 'region', subtag: 'BD', prefix: [], scope: null },
    { type: 'region', subtag: 'BE', prefix: [], scope: null },
    { type: 'region', subtag: 'BF', prefix: [], scope: null },
    { type: 'region', subtag: 'BG', prefix: [], scope: null },
    { type: 'region', subtag: 'BH', prefix: [], scope: null },
    { type: 'region', subtag: 'BI', prefix: [], scope: null },
    { type: 'region', subtag: 'BJ', prefix: [], scope: null },
    { type: 'region', subtag: 'BL', prefix: [], scope: null },
    { type: 'region', subtag: 'BM', prefix: [], scope: null },
    { type: 'region', subtag: 'BN', prefix: [], scope: null },
    { type: 'region', subtag: 'BO', prefix: [], scope: null },
    { type: 'region', subtag: 'BQ', prefix: [], scope: null },
    { type: 'region', subtag: 'BR', prefix: [], scope: null },
    { type: 'region', subtag: 'BS', prefix: [], scope: null },
    { type: 'region', subtag: 'BT', prefix: [], scope: null },
    { type: 'region', subtag: 'BU', prefix: [], scope: null },
    { type: 'region', subtag: 'BV', prefix: [], scope: null },
    { type: 'region', subtag: 'BW', prefix: [], scope: null },
    { type: 'region', subtag: 'BY', prefix: [], scope: null },
    { type: 'region', subtag: 'BZ', prefix: [], scope: null },
    { type: 'region', subtag: 'CA', prefix: [], scope: null },
    { type: 'region', subtag: 'CC', prefix: [], scope: null },
    { type: 'region', subtag: 'CD', prefix: [], scope: null },
    { type: 'region', subtag: 'CF', prefix: [], scope: null },
    { type: 'region', subtag: 'CG', prefix: [], scope: null },
    { type: 'region', subtag: 'CH', prefix: [], scope: null },
    { type: 'region', subtag: 'CI', prefix: [], scope: null },
    { type: 'region', subtag: 'CK', prefix: [], scope: null },
    { type: 'region', subtag: 'CL', prefix: [], scope: null },
    { type: 'region', subtag: 'CM', prefix: [], scope: null },
    { type: 'region', subtag: 'CN', prefix: [], scope: null },
    { type: 'region', subtag: 'CO', prefix: [], scope: null },
    { type: 'region', subtag: 'CP', prefix: [], scope: null },
    { type: 'region', subtag: 'CR', prefix: [], scope: null },
    { type: 'region', subtag: 'CS', prefix: [], scope: null },
    { type: 'region', subtag: 'CU', prefix: [], scope: null },
    { type: 'region', subtag: 'CV', prefix: [], scope: null },
    { type: 'region', subtag: 'CW', prefix: [], scope: null },
    { type: 'region', subtag: 'CX', prefix: [], scope: null },
    { type: 'region', subtag: 'CY', prefix: [], scope: null },
    { type: 'region', subtag: 'CZ', prefix: [], scope: null },
    { type: 'region', subtag: 'DD', prefix: [], scope: null },
    { type: 'region', subtag: 'DE', prefix: [], scope: null },
    { type: 'region', subtag: 'DG', prefix: [], scope: null },
    { type: 'region', subtag: 'DJ', prefix: [], scope: null },
    { type: 'region', subtag: 'DK', prefix: [], scope: null },
    { type: 'region', subtag: 'DM', prefix: [], scope: null },
    { type: 'region', subtag: 'DO', prefix: [], scope: null },
    { type: 'region', subtag: 'DZ', prefix: [], scope: null },
    { type: 'region', subtag: 'EA', prefix: [], scope: null },
    { type: 'region', subtag: 'EC', prefix: [], scope: null },
    { type: 'region', subtag: 'EE', prefix: [], scope: null },
    { type: 'region', subtag: 'EG', prefix: [], scope: null },
    { type: 'region', subtag: 'EH', prefix: [], scope: null },
    { type: 'region', subtag: 'ER', prefix: [], scope: null },
    { type: 'region', subtag: 'ES', prefix: [], scope: null },
    { type: 'region', subtag: 'ET', prefix: [], scope: null },
    { type: 'region', subtag: 'EU', prefix: [], scope: null },
    { type: 'region', subtag: 'EZ', prefix: [], scope: null },
    { type: 'region', subtag: 'FI', prefix: [], scope: null },
    { type: 'region', subtag: 'FJ', prefix: [], scope: null },
    { type: 'region', subtag: 'FK', prefix: [], scope: null },
    { type: 'region', subtag: 'FM', prefix: [], scope: null },
    { type: 'region', subtag: 'FO', prefix: [], scope: null },
    { type: 'region', subtag: 'FR', prefix: [], scope: null },
    { type: 'region', subtag: 'FX', prefix: [], scope: null },
    { type: 'region', subtag: 'GA', prefix: [], scope: null },
    { type: 'region', subtag: 'GB', prefix: [], scope: null },
    { type: 'region', subtag: 'GD', prefix: [], scope: null },
    { type: 'region', subtag: 'GE', prefix: [], scope: null },
    { type: 'region', subtag: 'GF', prefix: [], scope: null },
    { type: 'region', subtag: 'GG', prefix: [], scope: null },
    { type: 'region', subtag: 'GH', prefix: [], scope: null },
    { type: 'region', subtag: 'GI', prefix: [], scope: null },
    { type: 'region', subtag: 'GL', prefix: [], scope: null },
    { type: 'region', subtag: 'GM', prefix: [], scope: null },
    { type: 'region', subtag: 'GN', prefix: [], scope: null },
    { type: 'region', subtag: 'GP', prefix: [], scope: null },
    { type: 'region', subtag: 'GQ', prefix: [], scope: null },
    { type: 'region', subtag: 'GR', prefix: [], scope: null },
    { type: 'region', subtag: 'GS', prefix: [], scope: null },
    { type: 'region', subtag: 'GT', prefix: [], scope: null },
    { type: 'region', subtag: 'GU', prefix: [], scope: null },
    { type: 'region', subtag: 'GW', prefix: [], scope: null },
    { type: 'region', subtag: 'GY', prefix: [], scope: null },
    { type: 'region', subtag: 'HK', prefix: [], scope: null },
    { type: 'region', subtag: 'HM', prefix: [], scope: null },
    { type: 'region', subtag: 'HN', prefix: [], scope: null },
    { type: 'region', subtag: 'HR', prefix: [], scope: null },
    { type: 'region', subtag: 'HT', prefix: [], scope: null },
    { type: 'region', subtag: 'HU', prefix: [], scope: null },
    { type: 'region', subtag: 'IC', prefix: [], scope: null },
    { type: 'region', subtag: 'ID', prefix: [], scope: null },
    { type: 'region', subtag: 'IE', prefix: [], scope: null },
    { type: 'region', subtag: 'IL', prefix: [], scope: null },
    { type: 'region', subtag: 'IM', prefix: [], scope: null },
    { type: 'region', subtag: 'IN', prefix: [], scope: null },
    { type: 'region', subtag: 'IO', prefix: [], scope: null },
    { type: 'region', subtag: 'IQ', prefix: [], scope: null },
    { type: 'region', subtag: 'IR', prefix: [], scope: null },
    { type: 'region', subtag: 'IS', prefix: [], scope: null },
    { type: 'region', subtag: 'IT', prefix: [], scope: null },
    { type: 'region', subtag: 'JE', prefix: [], scope: null },
    { type: 'region', subtag: 'JM', prefix: [], scope: null },
    { type: 'region', subtag: 'JO', prefix: [], scope: null },
    { type: 'region', subtag: 'JP', prefix: [], scope: null },
    { type: 'region', subtag: 'KE', prefix: [], scope: null },
    { type: 'region', subtag: 'KG', prefix: [], scope: null },
    { type: 'region', subtag: 'KH', prefix: [], scope: null },
    { type: 'region', subtag: 'KI', prefix: [], scope: null },
    { type: 'region', subtag: 'KM', prefix: [], scope: null },
    { type: 'region', subtag: 'KN', prefix: [], scope: null },
    { type: 'region', subtag: 'KP', prefix: [], scope: null },
    { type: 'region', subtag: 'KR', prefix: [], scope: null },
    { type: 'region', subtag: 'KW', prefix: [], scope: null },
    { type: 'region', subtag: 'KY', prefix: [], scope: null },
    { type: 'region', subtag: 'KZ', prefix: [], scope: null },
    { type: 'region', subtag: 'LA', prefix: [], scope: null },
    { type: 'region', subtag: 'LB', prefix: [], scope: null },
    { type: 'region', subtag: 'LC', prefix: [], scope: null },
    { type: 'region', subtag: 'LI', prefix: [], scope: null },
    { type: 'region', subtag: 'LK', prefix: [], scope: null },
    { type: 'region', subtag: 'LR', prefix: [], scope: null },
    { type: 'region', subtag: 'LS', prefix: [], scope: null },
    { type: 'region', subtag: 'LT', prefix: [], scope: null },
    { type: 'region', subtag: 'LU', prefix: [], scope: null },
    { type: 'region', subtag: 'LV', prefix: [], scope: null },
    { type: 'region', subtag: 'LY', prefix: [], scope: null },
    { type: 'region', subtag: 'MA', prefix: [], scope: null },
    { type: 'region', subtag: 'MC', prefix: [], scope: null },
    { type: 'region', subtag: 'MD', prefix: [], scope: null },
    { type: 'region', subtag: 'ME', prefix: [], scope: null },
    { type: 'region', subtag: 'MF', prefix: [], scope: null },
    { type: 'region', subtag: 'MG', prefix: [], scope: null },
    { type: 'region', subtag: 'MH', prefix: [], scope: null },
    { type: 'region', subtag: 'MK', prefix: [], scope: null },
    { type: 'region', subtag: 'ML', prefix: [], scope: null },
    { type: 'region', subtag: 'MM', prefix: [], scope: null },
    { type: 'region', subtag: 'MN', prefix: [], scope: null },
    { type: 'region', subtag: 'MO', prefix: [], scope: null },
    { type: 'region', subtag: 'MP', prefix: [], scope: null },
    { type: 'region', subtag: 'MQ', prefix: [], scope: null },
    { type: 'region', subtag: 'MR', prefix: [], scope: null },
    { type: 'region', subtag: 'MS', prefix: [], scope: null },
    { type: 'region', subtag: 'MT', prefix: [], scope: null },
    { type: 'region', subtag: 'MU', prefix: [], scope: null },
    { type: 'region', subtag: 'MV', prefix: [], scope: null },
    { type: 'region', subtag: 'MW', prefix: [], scope: null },
    { type: 'region', subtag: 'MX', prefix: [], scope: null },
    { type: 'region', subtag: 'MY', prefix: [], scope: null },
    { type: 'region', subtag: 'MZ', prefix: [], scope: null },
    { type: 'region', subtag: 'NA', prefix: [], scope: null },
    { type: 'region', subtag: 'NC', prefix: [], scope: null },
    { type: 'region', subtag: 'NE', prefix: [], scope: null },
    { type: 'region', subtag: 'NF', prefix: [], scope: null },
    { type: 'region', subtag: 'NG', prefix: [], scope: null },
    { type: 'region', subtag: 'NI', prefix: [], scope: null },
    { type: 'region', subtag: 'NL', prefix: [], scope: null },
    { type: 'region', subtag: 'NO', prefix: [], scope: null },
    { type: 'region', subtag: 'NP', prefix: [], scope: null },
    { type: 'region', subtag: 'NR', prefix: [], scope: null },
    { type: 'region', subtag: 'NT', prefix: [], scope: null },
    { type: 'region', subtag: 'NU', prefix: [], scope: null },
    { type: 'region', subtag: 'NZ', prefix: [], scope: null },
    { type: 'region', subtag: 'OM', prefix: [], scope: null },
    { type: 'region', subtag: 'PA', prefix: [], scope: null },
    { type: 'region', subtag: 'PE', prefix: [], scope: null },
    { type: 'region', subtag: 'PF', prefix: [], scope: null },
    { type: 'region', subtag: 'PG', prefix: [], scope: null },
    { type: 'region', subtag: 'PH', prefix: [], scope: null },
    { type: 'region', subtag: 'PK', prefix: [], scope: null },
    { type: 'region', subtag: 'PL', prefix: [], scope: null },
    { type: 'region', subtag: 'PM', prefix: [], scope: null },
    { type: 'region', subtag: 'PN', prefix: [], scope: null },
    { type: 'region', subtag: 'PR', prefix: [], scope: null },
    { type: 'region', subtag: 'PS', prefix: [], scope: null },
    { type: 'region', subtag: 'PT', prefix: [], scope: null },
    { type: 'region', subtag: 'PW', prefix: [], scope: null },
    { type: 'region', subtag: 'PY', prefix: [], scope: null },
    { type: 'region', subtag: 'QA', prefix: [], scope: null },
    { type: 'region', subtag: 'QM..QZ', prefix: [], scope: 'private-use' },
    { type: 'region', subtag: 'RE', prefix: [], scope: null },
    { type: 'region', subtag: 'RO', prefix: [], scope: null },
    { type: 'region', subtag: 'RS', prefix: [], scope: null },
    { type: 'region', subtag: 'RU', prefix: [], scope: null },
    { type: 'region', subtag: 'RW', prefix: [], scope: null },
    { type: 'region', subtag: 'SA', prefix: [], scope: null },
    { type: 'region', subtag: 'SB', prefix: [], scope: null },
    { type: 'region', subtag: 'SC', prefix: [], scope: null },
    { type: 'region', subtag: 'SD', prefix: [], scope: null },
    { type: 'region', subtag: 'SE', prefix: [], scope: null },
    { type: 'region', subtag: 'SG', prefix: [], scope: null },
    { type: 'region', subtag: 'SH', prefix: [], scope: null },
    { type: 'region', subtag: 'SI', prefix: [], scope: null },
    { type: 'region', subtag: 'SJ', prefix: [], scope: null },
    { type: 'region', subtag: 'SK', prefix: [], scope: null },
    { type: 'region', subtag: 'SL', prefix: [], scope: null },
    { type: 'region', subtag: 'SM', prefix: [], scope: null },
    { type: 'region', subtag: 'SN', prefix: [], scope: null },
    { type: 'region', subtag: 'SO', prefix: [], scope: null },
    { type: 'region', subtag: 'SR', prefix: [], scope: null },
    { type: 'region', subtag: 'SS', prefix: [], scope: null },
    { type: 'region', subtag: 'ST', prefix: [], scope: null },
    { type: 'region', subtag: 'SU', prefix: [], scope: null },
    { type: 'region', subtag: 'SV', prefix: [], scope: null },
    { type: 'region', subtag: 'SX', prefix: [], scope: null },
    { type: 'region', subtag: 'SY', prefix: [], scope: null },
    { type: 'region', subtag: 'SZ', prefix: [], scope: null },
    { type: 'region', subtag: 'TA', prefix: [], scope: null },
    { type: 'region', subtag: 'TC', prefix: [], scope: null },
    { type: 'region', subtag: 'TD', prefix: [], scope: null },
    { type: 'region', subtag: 'TF', prefix: [], scope: null },
    { type: 'region', subtag: 'TG', prefix: [], scope: null },
    { type: 'region', subtag: 'TH', prefix: [], scope: null },
    { type: 'region', subtag: 'TJ', prefix: [], scope: null },
    { type: 'region', subtag: 'TK', prefix: [], scope: null },
    { type: 'region', subtag: 'TL', prefix: [], scope: null },
    { type: 'region', subtag: 'TM', prefix: [], scope: null },
    { type: 'region', subtag: 'TN', prefix: [], scope: null },
    { type: 'region', subtag: 'TO', prefix: [], scope: null },
    { type: 'region', subtag: 'TP', prefix: [], scope: null },
    { type: 'region', subtag: 'TR', prefix: [], scope: null },
    { type: 'region', subtag: 'TT', prefix: [], scope: null },
    { type: 'region', subtag: 'TV', prefix: [], scope: null },
    { type: 'region', subtag: 'TW', prefix: [], scope: null },
    { type: 'region', subtag: 'TZ', prefix: [], scope: null },
    { type: 'region', subtag: 'UA', prefix: [], scope: null },
    { type: 'region', subtag: 'UG', prefix: [], scope: null },
    { type: 'region', subtag: 'UM', prefix: [], scope: null },
    { type: 'region', subtag: 'UN', prefix: [], scope: null },
    { type: 'region', subtag: 'US', prefix: [], scope: null },
    { type: 'region', subtag: 'UY', prefix: [], scope: null },
    { type: 'region', subtag: 'UZ', prefix: [], scope: null },
    { type: 'region', subtag: 'VA', prefix: [], scope: null },
    { type: 'region', subtag: 'VC', prefix: [], scope: null },
    { type: 'region', subtag: 'VE', prefix: [], scope: null },
    { type: 'region', subtag: 'VG', prefix: [], scope: null },
    { type: 'region', subtag: 'VI', prefix: [], scope: null },
    { type: 'region', subtag: 'VN', prefix: [], scope: null },
    { type: 'region', subtag: 'VU', prefix: [], scope: null },
    { type: 'region', subtag: 'WF', prefix: [], scope: null },
    { type: 'region', subtag: 'WS', prefix: [], scope: null },
    { type: 'region', subtag: 'XA..XZ', prefix: [], scope: 'private-use' },
    { type: 'region', subtag: 'YD', prefix: [], scope: null },
    { type: 'region', subtag: 'YE', prefix: [], scope: null },
    { type: 'region', subtag: 'YT', prefix: [], scope: null },
    { type: 'region', subtag: 'YU', prefix: [], scope: null },
    { type: 'region', subtag: 'ZA', prefix: [], scope: null },
    { type: 'region', subtag: 'ZM', prefix: [], scope: null },
    { type: 'region', subtag: 'ZR', prefix: [], scope: null },
    { type: 'region', subtag: 'ZW', prefix: [], scope: null },
    { type: 'region', subtag: 'ZZ', prefix: [], scope: 'private-use' },
    { type: 'region', subtag: '001', prefix: [], scope: null },
    { type: 'region', subtag: '002', prefix: [], scope: null },
    { type: 'region', subtag: '003', prefix: [], scope: null },
    { type: 'region', subtag: '005', prefix: [], scope: null },
    { type: 'region', subtag: '009', prefix: [], scope: null },
    { type: 'region', subtag: '011', prefix: [], scope: null },
    { type: 'region', subtag: '013', prefix: [], scope: null },
    { type: 'region', subtag: '014', prefix: [], scope: null },
    { type: 'region', subtag: '015', prefix: [], scope: null },
    { type: 'region', subtag: '017', prefix: [], scope: null },
    { type: 'region', subtag: '018', prefix: [], scope: null },
    { type: 'region', subtag: '019', prefix: [], scope: null },
    { type: 'region', subtag: '021', prefix: [], scope: null },
    { type: 'region', subtag: '029', prefix: [], scope: null },
    { type: 'region', subtag: '030', prefix: [], scope: null },
    { type: 'region', subtag: '034', prefix: [], scope: null },
    { type: 'region', subtag: '035', prefix: [], scope: null },
    { type: 'region', subtag: '039', prefix: [], scope: null },
    { type: 'region', subtag: '053', prefix: [], scope: null },
    { type: 'region', subtag: '054', prefix: [], scope: null },
    { type: 'region', subtag: '057', prefix: [], scope: null },
    { type: 'region', subtag: '061', prefix: [], scope: null },
    { type: 'region', subtag: '142', prefix: [], scope: null },
    { type: 'region', subtag: '143', prefix: [], scope: null },
    { type: 'region', subtag: '145', prefix: [], scope: null },
    { type: 'region', subtag: '150', prefix: [], scope: null },
    { type: 'region', subtag: '151', prefix: [], scope: null },
    { type: 'region', subtag: '154', prefix: [], scope: null },
    { type: 'region', subtag: '155', prefix: [], scope: null },
    { type: 'region', subtag: '202', prefix: [], scope: null },
    { type: 'region', subtag: '419', prefix: [], scope: null },
    { type: 'variant', subtag: '1606nict', prefix: ['frm'], scope: null },
    { type: 'variant', subtag: '1694acad', prefix: ['fr'], scope: null },
    { type: 'variant', subtag: '1901', prefix: ['de'], scope: null },
    { type: 'variant', subtag: '1959acad', prefix: ['be'], scope: null },
    {
      type: 'variant',
      subtag: '1994',
      prefix: [
        'sl-rozaj',
        'sl-rozaj-biske',
        'sl-rozaj-njiva',
        'sl-rozaj-osojs',
        'sl-rozaj-solba',
      ],
      scope: null,
    },
    { type: 'variant', subtag: '1996', prefix: ['de'], scope: null },
    { type: 'variant', subtag: 'abl1943', prefix: ['pt-BR'], scope: null },
    { type: 'variant', subtag: 'akuapem', prefix: ['tw'], scope: null },
    { type: 'variant', subtag: 'alalc97', prefix: [], scope: null },
    { type: 'variant', subtag: 'aluku', prefix: ['djk'], scope: null },
    { type: 'variant', subtag: 'ao1990', prefix: ['pt', 'gl'], scope: null },
    { type: 'variant', subtag: 'aranes', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'arevela', prefix: ['hy'], scope: null },
    { type: 'variant', subtag: 'arevmda', prefix: ['hy'], scope: null },
    { type: 'variant', subtag: 'arkaika', prefix: ['eo'], scope: null },
    { type: 'variant', subtag: 'asante', prefix: ['tw'], scope: null },
    { type: 'variant', subtag: 'auvern', prefix: ['oc'], scope: null },
    {
      type: 'variant',
      subtag: 'baku1926',
      prefix: ['az', 'ba', 'crh', 'kk', 'krc', 'ky', 'sah', 'tk', 'tt', 'uz'],
      scope: null,
    },
    { type: 'variant', subtag: 'balanka', prefix: ['blo'], scope: null },
    { type: 'variant', subtag: 'barla', prefix: ['kea'], scope: null },
    { type: 'variant', subtag: 'basiceng', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'bauddha', prefix: ['sa'], scope: null },
    { type: 'variant', subtag: 'biscayan', prefix: ['eu'], scope: null },
    { type: 'variant', subtag: 'biske', prefix: ['sl-rozaj'], scope: null },
    { type: 'variant', subtag: 'bohoric', prefix: ['sl'], scope: null },
    { type: 'variant', subtag: 'boont', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'bornholm', prefix: ['da'], scope: null },
    { type: 'variant', subtag: 'cisaup', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'colb1945', prefix: ['pt'], scope: null },
    { type: 'variant', subtag: 'cornu', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'creiss', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'dajnko', prefix: ['sl'], scope: null },
    {
      type: 'variant',
      subtag: 'ekavsk',
      prefix: ['sr', 'sr-Latn', 'sr-Cyrl'],
      scope: null,
    },
    { type: 'variant', subtag: 'emodeng', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'fonipa', prefix: [], scope: null },
    { type: 'variant', subtag: 'fonkirsh', prefix: [], scope: null },
    { type: 'variant', subtag: 'fonnapa', prefix: [], scope: null },
    { type: 'variant', subtag: 'fonupa', prefix: [], scope: null },
    { type: 'variant', subtag: 'fonxsamp', prefix: [], scope: null },
    { type: 'variant', subtag: 'gallo', prefix: ['fr'], scope: null },
    { type: 'variant', subtag: 'gascon', prefix: ['oc'], scope: null },
    {
      type: 'variant',
      subtag: 'grclass',
      prefix: [
        'oc',
        'oc-aranes',
        'oc-auvern',
        'oc-cisaup',
        'oc-creiss',
        'oc-gascon',
        'oc-lemosin',
        'oc-lengadoc',
        'oc-nicard',
        'oc-provenc',
        'oc-vivaraup',
      ],
      scope: null,
    },
    {
      type: 'variant',
      subtag: 'grital',
      prefix: ['oc', 'oc-cisaup', 'oc-nicard', 'oc-provenc'],
      scope: null,
    },
    {
      type: 'variant',
      subtag: 'grmistr',
      prefix: [
        'oc',
        'oc-aranes',
        'oc-auvern',
        'oc-cisaup',
        'oc-creiss',
        'oc-gascon',
        'oc-lemosin',
        'oc-lengadoc',
        'oc-nicard',
        'oc-provenc',
        'oc-vivaraup',
      ],
      scope: null,
    },
    { type: 'variant', subtag: 'hepburn', prefix: ['ja-Latn'], scope: null },
    {
      type: 'variant',
      subtag: 'heploc',
      prefix: ['ja-Latn-hepburn'],
      scope: null,
    },
    { type: 'variant', subtag: 'hognorsk', prefix: ['nn'], scope: null },
    { type: 'variant', subtag: 'hsistemo', prefix: ['eo'], scope: null },
    {
      type: 'variant',
      subtag: 'ijekavsk',
      prefix: ['sr', 'sr-Latn', 'sr-Cyrl'],
      scope: null,
    },
    { type: 'variant', subtag: 'itihasa', prefix: ['sa'], scope: null },
    { type: 'variant', subtag: 'ivanchov', prefix: ['bg'], scope: null },
    { type: 'variant', subtag: 'jauer', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'jyutping', prefix: ['yue'], scope: null },
    { type: 'variant', subtag: 'kkcor', prefix: ['kw'], scope: null },
    { type: 'variant', subtag: 'kociewie', prefix: ['pl'], scope: null },
    { type: 'variant', subtag: 'kscor', prefix: ['kw'], scope: null },
    { type: 'variant', subtag: 'laukika', prefix: ['sa'], scope: null },
    { type: 'variant', subtag: 'lemosin', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'lengadoc', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'lipaw', prefix: ['sl-rozaj'], scope: null },
    { type: 'variant', subtag: 'luna1918', prefix: ['ru'], scope: null },
    { type: 'variant', subtag: 'metelko', prefix: ['sl'], scope: null },
    { type: 'variant', subtag: 'monoton', prefix: ['el'], scope: null },
    { type: 'variant', subtag: 'ndyuka', prefix: ['djk'], scope: null },
    { type: 'variant', subtag: 'nedis', prefix: ['sl'], scope: null },
    { type: 'variant', subtag: 'newfound', prefix: ['en-CA'], scope: null },
    { type: 'variant', subtag: 'nicard', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'njiva', prefix: ['sl-rozaj'], scope: null },
    { type: 'variant', subtag: 'nulik', prefix: ['vo'], scope: null },
    { type: 'variant', subtag: 'osojs', prefix: ['sl-rozaj'], scope: null },
    { type: 'variant', subtag: 'oxendict', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'pahawh2', prefix: ['mww', 'hnj'], scope: null },
    { type: 'variant', subtag: 'pahawh3', prefix: ['mww', 'hnj'], scope: null },
    { type: 'variant', subtag: 'pahawh4', prefix: ['mww', 'hnj'], scope: null },
    { type: 'variant', subtag: 'pamaka', prefix: ['djk'], scope: null },
    { type: 'variant', subtag: 'peano', prefix: ['la'], scope: null },
    { type: 'variant', subtag: 'petr1708', prefix: ['ru'], scope: null },
    {
      type: 'variant',
      subtag: 'pinyin',
      prefix: ['zh-Latn', 'bo-Latn'],
      scope: null,
    },
    { type: 'variant', subtag: 'polyton', prefix: ['el'], scope: null },
    { type: 'variant', subtag: 'provenc', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'puter', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'rigik', prefix: ['vo'], scope: null },
    { type: 'variant', subtag: 'rozaj', prefix: ['sl'], scope: null },
    { type: 'variant', subtag: 'rumgr', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'scotland', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'scouse', prefix: ['en'], scope: null },
    { type: 'variant', subtag: 'simple', prefix: [], scope: null },
    { type: 'variant', subtag: 'solba', prefix: ['sl-rozaj'], scope: null },
    { type: 'variant', subtag: 'sotav', prefix: ['kea'], scope: null },
    { type: 'variant', subtag: 'spanglis', prefix: ['en', 'es'], scope: null },
    { type: 'variant', subtag: 'surmiran', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'sursilv', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'sutsilv', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'synnejyl', prefix: ['da'], scope: null },
    { type: 'variant', subtag: 'tarask', prefix: ['be'], scope: null },
    { type: 'variant', subtag: 'tongyong', prefix: ['zh-Latn'], scope: null },
    { type: 'variant', subtag: 'tunumiit', prefix: ['kl'], scope: null },
    { type: 'variant', subtag: 'uccor', prefix: ['kw'], scope: null },
    { type: 'variant', subtag: 'ucrcor', prefix: ['kw'], scope: null },
    { type: 'variant', subtag: 'ulster', prefix: ['sco'], scope: null },
    {
      type: 'variant',
      subtag: 'unifon',
      prefix: ['en', 'hup', 'kyh', 'tol', 'yur'],
      scope: null,
    },
    { type: 'variant', subtag: 'vaidika', prefix: ['sa'], scope: null },
    { type: 'variant', subtag: 'valencia', prefix: ['ca'], scope: null },
    { type: 'variant', subtag: 'vallader', prefix: ['rm'], scope: null },
    { type: 'variant', subtag: 'vecdruka', prefix: ['lv'], scope: null },
    { type: 'variant', subtag: 'vivaraup', prefix: ['oc'], scope: null },
    { type: 'variant', subtag: 'wadegile', prefix: ['zh-Latn'], scope: null },
    { type: 'variant', subtag: 'xsistemo', prefix: ['eo'], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'grandfathered', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
    { type: 'redundant', subtag: '', prefix: [], scope: null },
  ],
});

/** @type {Set<string>} */
const extensionIdentifierSet = new Set(extensions.map((e) => e.identifier));

/**
 * @param {string} tag
 */
function bcpLanguageTagChecker (tag) {
  const parsed = lib.parse(tag);

  return (
    parsed !== null &&
    (parsed.langtag.language.language === null ||
      icann.subtags.some((s) => {
        return (
          s.type === 'language' &&
          stringMatchesSubtag(
            /** @type {string} */ (parsed.langtag.language.language),
            s.subtag
          )
        )
      })) &&
    parsed.langtag.language.extlang.length <= 1 &&
    parsed.langtag.language.extlang.every((extlang) =>
      icann.subtags.some(
        (s) =>
          s.subtag.toLowerCase() === extlang.toLowerCase() &&
          s.type === 'extlang' &&
          s.prefix.some((p) => stringMatchesSubtagPrefix(tag, extlang, p))
      )
    ) &&
    (parsed.langtag.script === null ||
      icann.subtags.some(
        (s) =>
          s.type === 'script' &&
          stringMatchesSubtag(
            /** @type {string} */ (parsed.langtag.script),
            s.subtag
          )
      )) &&
    (parsed.langtag.region === null ||
      icann.subtags.some(
        (s) =>
          s.type === 'region' &&
          stringMatchesSubtag(
            /** @type {string} */ (parsed.langtag.region),
            s.subtag
          )
      )) &&
    parsed.langtag.variant.every((variant) =>
      icann.subtags.some(
        (s) =>
          s.subtag.toLowerCase() === variant.toLowerCase() &&
          s.type === 'variant' &&
          s.prefix.some((p) => stringMatchesSubtagPrefix(tag, variant, p))
      )
    ) &&
    parsed.langtag.variant.filter(
      (item, index) => parsed.langtag.variant.indexOf(item) !== index
    ).length === 0 &&
    parsed.langtag.extension.filter(
      (extension, index) =>
        parsed.langtag.extension.findIndex(
          (e) => e.singleton === extension.singleton
        ) !== index
    ).length === 0 &&
    parsed.langtag.extension.every((extension) =>
      extensionIdentifierSet.has(extension.singleton)
    )
  )
}

/**
 * @param {string} tag
 */
function isPrivateLanguage(tag) {
  const parsed = lib.parse(tag);

  return (
    parsed &&
    typeof parsed.langtag.language.language === 'string' &&
    icann.subtags.some((s) => {
      return (
        (s.type === 'language' &&
          stringMatchesSubtag(
            /** @type {string} */ (parsed.langtag.language.language),
            s.subtag
          ) &&
          s.scope === 'private-use') ||
        (s.type === 'region' &&
          typeof parsed.langtag.region === 'string' &&
          stringMatchesSubtag(parsed.langtag.region, s.subtag) &&
          s.scope === 'private-use') ||
        (s.type === 'script' &&
          typeof parsed.langtag.script === 'string' &&
          stringMatchesSubtag(parsed.langtag.script, s.subtag) &&
          s.scope === 'private-use')
      )
    })
  )
}

/**
 * @param {string} str
 * @param {string} subtag
 * @returns
 */
function stringMatchesSubtag(str, subtag) {
  const tag = /** @type {string} */ (str).toLowerCase();
  const rangeMatch = subtag.match(/^([a-zA-Z]+)\.\.([a-zA-Z]+)$/);
  if (rangeMatch) {
    return (
      rangeMatch[1].toLowerCase() <= tag && tag <= rangeMatch[2].toLowerCase()
    )
  }
  return subtag.toLowerCase() === tag
}

/**
 * @param {string} str
 * @param {string} subtag
 * @param {string} prefix
 */
function stringMatchesSubtagPrefix(str, subtag, prefix) {
  return str
    .substring(0, str.toLowerCase().indexOf(subtag.toLowerCase()) - 1)
    .toLowerCase()
    .startsWith(prefix.toLowerCase())
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_12(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (hasLangField(doc) && !bcpLanguageTagChecker(doc.document.lang)) {
    isValid = false;
    errors.push({
      message: 'is not a valid language-tag',
      instancePath: '/document/lang',
    });
  }

  if (hasSourceLangField(doc)) {
    if (!bcpLanguageTagChecker(doc.document.source_lang)) {
      isValid = false;
      errors.push({
        message: 'is not a valid language-tag',
        instancePath: '/document/source_lang',
      });
    }
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 * @returns {doc is { document: { lang: string } }}
 */
const hasLangField = (doc) =>
  doc && doc.document && typeof doc.document.lang === 'string' ? true : false;

/**
 * @param {any} doc
 * @returns {doc is { document: { source_lang: string } }}
 */
const hasSourceLangField = (doc) =>
  doc && doc.document && typeof doc.document.source_lang === 'string'
    ? true
    : false;

/*!
Copyright (c) the purl authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

const KnownQualifierNames = Object.freeze({
  // known qualifiers as defined here:
  // https://github.com/package-url/purl-spec/blob/master/PURL-SPECIFICATION.rst#known-qualifiers-keyvalue-pairs
  RepositoryUrl: 'repository_url',
  DownloadUrl: 'download_url',
  VcsUrl: 'vcs_url',
  FileName: 'file_name',
  Checksum: 'checksum'
});

let PackageURL$2 = class PackageURL {

  static get KnownQualifierNames() {
    return KnownQualifierNames;
  }

  constructor(type, namespace, name, version, qualifiers, subpath) {
    let required = { 'type': type, 'name': name };
    Object.keys(required).forEach(key => {
      if (!required[key]) {
        throw new Error('Invalid purl: "' + key + '" is a required field.');
      }
    });

    let strings = { 'type': type, 'namespace': namespace, 'name': name, 'versions': version, 'subpath': subpath };
    Object.keys(strings).forEach(key => {
      if (strings[key] && typeof strings[key] === 'string' || !strings[key]) {
        return;
      }
      throw new Error('Invalid purl: "' + key + '" argument must be a string.');
    });

    if (qualifiers) {
      if (typeof qualifiers !== 'object') {
        throw new Error('Invalid purl: "qualifiers" argument must be a dictionary.');
      }
      Object.keys(qualifiers).forEach(key => {
        if (!/^[a-z]+$/i.test(key) && !/[\.-_]/.test(key)) {
          throw new Error('Invalid purl: qualifier "' + key + '" contains an illegal character.');
        }
      });
    }

    this.type = type;
    this.name = name;
    this.namespace = namespace;
    this.version = version;
    this.qualifiers = qualifiers;
    this.subpath = subpath;
  }

  _handlePyPi() {
    this.name = this.name.toLowerCase().replace(/_/g, '-');
  }
  _handlePub() {
    this.name = this.name.toLowerCase();
    if (!/^[a-z0-9_]+$/i.test(this.name)) {
      throw new Error('Invalid purl: contains an illegal character.');
    }
  }

  toString() {
    var purl = ['pkg:', encodeURIComponent(this.type), '/'];

    if (this.type === 'pypi') {
      this._handlePyPi();
    }
    if (this.type === 'pub') {
      this._handlePub();
    }

    if (this.namespace) {
      purl.push(
        encodeURIComponent(this.namespace)
          .replace(/%3A/g, ':')
          .replace(/%2F/g, '/')
        );
      purl.push('/');
    }

    purl.push(encodeURIComponent(this.name).replace(/%3A/g, ':'));

    if (this.version) {
      purl.push('@');
      purl.push(encodeURIComponent(this.version).replace(/%3A/g, ':').replace(/%2B/g,'+'));
    }

    if (this.qualifiers) {
      purl.push('?');

      let qualifiers = this.qualifiers;
      let qualifierString = [];
      Object.keys(qualifiers).sort().forEach(key => {
        qualifierString.push(
          encodeURIComponent(key).replace(/%3A/g, ':')
          + '='
          + encodeURIComponent(qualifiers[key]).replace(/%2F/g, '/')
        );
      });

      purl.push(qualifierString.join('&'));
    }

    if (this.subpath) {
      purl.push('#');
      purl.push(encodeURIComponent(this.subpath)
        .replace(/%3A/g, ':')
        .replace(/%2F/g, '/'));
    }

    return purl.join('');
  }

  static fromString(purl) {
    if (!purl || typeof purl !== 'string' || !purl.trim()) {
      throw new Error('A purl string argument is required.');
    }

    let scheme = purl.slice(0, purl.indexOf(':'));
    let remainder = purl.slice(purl.indexOf(':') + 1);
    if (scheme !== 'pkg') {
      throw new Error('purl is missing the required "pkg" scheme component.');
    }
    // this strip '/, // and /// as possible in :// or :///
    // from https://gist.github.com/refo/47632c8a547f2d9b6517#file-remove-leading-slash
    remainder = remainder.trim().replace(/^\/+/g, '');

    let type;
    [type, remainder] = remainder.split('/', 2);
    if (!type || !remainder) {
      throw new Error('purl is missing the required "type" component.');
    }
    type = decodeURIComponent(type);

    let url = new URL(purl);

    let qualifiers = null;
    url.searchParams.forEach((value, key) => {
      if (!qualifiers) {
        qualifiers = {};
      }
      qualifiers[key] = value;
    });
    let subpath = url.hash;
    if (subpath.indexOf('#') === 0) {
      subpath = subpath.substring(1);
    }
    subpath = subpath.length === 0
      ? null
      : decodeURIComponent(subpath);

    if (url.username !== '' || url.password !== '') {
      throw new Error('Invalid purl: cannot contain a "user:pass@host:port"');
    }

    // this strip '/, // and /// as possible in :// or :///
    // from https://gist.github.com/refo/47632c8a547f2d9b6517#file-remove-leading-slash
    let path = url.pathname.trim().replace(/^\/+/g, '');

    // version is optional - check for existence
    let version = null;
    if (path.includes('@')) {
      let index = path.indexOf('@');
      let rawVersion= path.substring(index + 1);
      version = decodeURIComponent(rawVersion);

      // Convert percent-encoded colons (:) back, to stay in line with the `toString`
      // implementation of this library.
      // https://github.com/package-url/packageurl-js/blob/58026c86978c6e356e5e07f29ecfdccbf8829918/src/package-url.js#L98C10-L98C10
      let versionEncoded = encodeURIComponent(version).replace(/%3A/g, ':').replace(/%2B/g,'+');

      if (rawVersion !== versionEncoded) {
        throw new Error('Invalid purl: version must be percent-encoded');
      }

      remainder = path.substring(0, index);
    } else {
      remainder = path;
    }

    // The 'remainder' should now consist of an optional namespace and the name
    let remaining = remainder.split('/').slice(1);
    let name = null;
    let namespace = null;
    if (remaining.length > 1) {
      let nameIndex = remaining.length - 1;
      let namespaceComponents = remaining.slice(0, nameIndex);
      name = decodeURIComponent(remaining[nameIndex]);
      namespace = decodeURIComponent(namespaceComponents.join('/'));
    } else if (remaining.length === 1) {
      name = decodeURIComponent(remaining[0]);
    }

    if (name === '') {
      throw new Error('purl is missing the required "name" component.');
    }

    return new PackageURL(type, namespace, name, version, qualifiers, subpath);
  }

};
var packageUrl = PackageURL$2;

/*!
Copyright (c) the purl authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

const PackageURL$1 = packageUrl;

var packageurlJs = {
  PackageURL: PackageURL$1
};

var pkgURL = /*@__PURE__*/getDefaultExportFromCjs(packageurlJs);

const { PackageURL } = pkgURL;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_13(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (Array.isArray(doc.product_tree?.full_product_names)) {
    doc.product_tree?.full_product_names.forEach(
      (
        /** @type {any} */ fullProductName,
        /** @type {number} */ fullProductNameIndex
      ) => {
        checkProductIdentificationHelperPURL(fullProductName, () => {
          isValid = false;
          errors.push({
            instancePath: `/product_tree/full_product_names/${fullProductNameIndex}/product_identification_helper/purl`,
            message: `invalid purl`,
          });
        });
      }
    );
  }

  if (Array.isArray(doc.product_tree?.relationships)) {
    doc.product_tree.relationships.forEach(
      (
        /** @type {any} */ relationship,
        /** @type {number} */ relationshipIndex
      ) => {
        checkProductIdentificationHelperPURL(
          relationship.full_product_name,
          () => {
            isValid = false;
            errors.push({
              instancePath: `/product_tree/relationships/${relationshipIndex}/full_product_name/product_identification_helper/purl`,
              message: `invalid purl`,
            });
          }
        );
      }
    );
  }

  if (doc.product_tree) {
    checkBranchesForInvalidPURLs(doc.product_tree, ({ branchIndexes }) => {
      isValid = false;
      const branchPathPart = branchIndexes.reduce(
        (str, index) => `${str}/branches/${index}`,
        '/product_tree'
      );
      errors.push({
        instancePath: `${branchPathPart}/product/product_identification_helper/purl`,
        message: `invalid purl`,
      });
    });
  }

  return { errors, isValid }
}

/**
 *
 * @param {any} parent
 * @param {(error: { branchIndexes: number[] }) => void} onError
 * @param {number[]} [branchIndexes]
 */
const checkBranchesForInvalidPURLs = (parent, onError, branchIndexes = []) => {
  if (Array.isArray(parent.branches)) {
    parent.branches.forEach(
      (/** @type {any} */ branch, /** @type {number} */ branchIndex) => {
        const currentBranchIndexes = branchIndexes.concat([branchIndex]);

        checkProductIdentificationHelperPURL(branch.product, () => {
          onError({
            branchIndexes: currentBranchIndexes,
          });
        });
        checkBranchesForInvalidPURLs(branch, onError, currentBranchIndexes);
      }
    );
  }
};

/**
 * @param {any} productALike
 * @param {() => void} onError
 * @returns
 */
const checkProductIdentificationHelperPURL = (productALike, onError) => {
  if (typeof productALike?.product_identification_helper?.purl !== 'string')
    return
  try {
    PackageURL.fromString(productALike?.product_identification_helper?.purl);
  } catch (e) {
    onError();
  }
};

//! @version @js-joda/core - 5.6.1
//! @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

function createErrorType(name, init, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init && init.apply(this, arguments);
    this.toString = function () {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
var DateTimeException = createErrorType('DateTimeException', messageWithCause);
var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);
var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);
var ArithmeticException = createErrorType('ArithmeticException');
var IllegalArgumentException = createErrorType('IllegalArgumentException');
var IllegalStateException = createErrorType('IllegalStateException');
var NullPointerException = createErrorType('NullPointerException');
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = '';
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function () {
    return text;
  };
  this.errorIndex = function () {
    return index;
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ''));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError("abstract method \"" + methodName + "\" is not implemented");
}

var assert$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    assert: assert,
    requireNonNull: requireNonNull,
    requireInstance: requireInstance,
    abstractMethodFail: abstractMethodFail
});

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_SAFE_INTEGER = 9007199254740991;
var MIN_SAFE_INTEGER = -9007199254740991;
var MathUtil = function () {
  function MathUtil() {}
  MathUtil.intDiv = function intDiv(x, y) {
    var r = x / y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };
  MathUtil.intMod = function intMod(x, y) {
    var r = x - MathUtil.intDiv(x, y) * y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };
  MathUtil.roundDown = function roundDown(r) {
    if (r < 0) {
      return Math.ceil(r);
    } else {
      return Math.floor(r);
    }
  };
  MathUtil.floorDiv = function floorDiv(x, y) {
    var r = Math.floor(x / y);
    return MathUtil.safeZero(r);
  };
  MathUtil.floorMod = function floorMod(x, y) {
    var r = x - MathUtil.floorDiv(x, y) * y;
    return MathUtil.safeZero(r);
  };
  MathUtil.safeAdd = function safeAdd(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 0) {
      return MathUtil.safeZero(y);
    }
    if (y === 0) {
      return MathUtil.safeZero(x);
    }
    var r = MathUtil.safeToInt(x + y);
    if (r === x || r === y) {
      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');
    }
    return r;
  };
  MathUtil.safeSubtract = function safeSubtract(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 0 && y === 0) {
      return 0;
    } else if (x === 0) {
      return MathUtil.safeZero(-1 * y);
    } else if (y === 0) {
      return MathUtil.safeZero(x);
    }
    return MathUtil.safeToInt(x - y);
  };
  MathUtil.safeMultiply = function safeMultiply(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 1) {
      return MathUtil.safeZero(y);
    }
    if (y === 1) {
      return MathUtil.safeZero(x);
    }
    if (x === 0 || y === 0) {
      return 0;
    }
    var r = MathUtil.safeToInt(x * y);
    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
      throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
    }
    return r;
  };
  MathUtil.parseInt = function (_parseInt) {
    function parseInt(_x) {
      return _parseInt.apply(this, arguments);
    }
    parseInt.toString = function () {
      return _parseInt.toString();
    };
    return parseInt;
  }(function (value) {
    var r = parseInt(value);
    return MathUtil.safeToInt(r);
  });
  MathUtil.safeToInt = function safeToInt(value) {
    MathUtil.verifyInt(value);
    return MathUtil.safeZero(value);
  };
  MathUtil.verifyInt = function verifyInt(value) {
    if (value == null) {
      throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
    }
    if (isNaN(value)) {
      throw new ArithmeticException('Invalid int value, using NaN as argument');
    }
    if (value % 1 !== 0) {
      throw new ArithmeticException("Invalid value: '" + value + "' is a float");
    }
    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
      throw new ArithmeticException("Calculation overflows an int: " + value);
    }
  };
  MathUtil.safeZero = function safeZero(value) {
    return value === 0 ? 0 : +value;
  };
  MathUtil.compareNumbers = function compareNumbers(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  };
  MathUtil.smi = function smi(int) {
    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;
  };
  MathUtil.hash = function hash(number) {
    if (number !== number || number === Infinity) {
      return 0;
    }
    var result = number;
    while (number > 0xFFFFFFFF) {
      number /= 0xFFFFFFFF;
      result ^= number;
    }
    return MathUtil.smi(result);
  };
  MathUtil.hashCode = function hashCode() {
    var result = 17;
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
      var n = _numbers[_i];
      result = (result << 5) - result + MathUtil.hash(n);
    }
    return MathUtil.hash(result);
  };
  return MathUtil;
}();
MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var Enum = function () {
  function Enum(name) {
    this._name = name;
  }
  var _proto = Enum.prototype;
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Enum;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAmount = function () {
  function TemporalAmount() {}
  var _proto = TemporalAmount.prototype;
  _proto.get = function get(unit) {
    abstractMethodFail('get');
  };
  _proto.units = function units() {
    abstractMethodFail('units');
  };
  _proto.addTo = function addTo(temporal) {
    abstractMethodFail('addTo');
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    abstractMethodFail('subtractFrom');
  };
  return TemporalAmount;
}();
if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  TemporalAmount.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }
    throw new TypeError('A conversion from TemporalAmount to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalUnit = function () {
  function TemporalUnit() {}
  var _proto = TemporalUnit.prototype;
  _proto.duration = function duration() {
    abstractMethodFail('duration');
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    abstractMethodFail('isDurationEstimated');
  };
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };
  _proto.addTo = function addTo(dateTime, periodToAdd) {
    abstractMethodFail('addTo');
  };
  _proto.between = function between(temporal1, temporal2) {
    abstractMethodFail('between');
  };
  return TemporalUnit;
}();

var Duration = function (_TemporalAmount) {
  _inheritsLoose(Duration, _TemporalAmount);
  function Duration(seconds, nanos) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanos);
    return _this;
  }
  Duration.ofDays = function ofDays(days) {
    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
  };
  Duration.ofHours = function ofHours(hours) {
    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
  };
  Duration.ofMinutes = function ofMinutes(minutes) {
    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Duration._create(secs, nos);
  };
  Duration.ofMillis = function ofMillis(millis) {
    var secs = MathUtil.intDiv(millis, 1000);
    var mos = MathUtil.intMod(millis, 1000);
    if (mos < 0) {
      mos += 1000;
      secs--;
    }
    return Duration._create(secs, mos * 1000000);
  };
  Duration.ofNanos = function ofNanos(nanos) {
    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
    if (nos < 0) {
      nos += LocalTime.NANOS_PER_SECOND;
      secs--;
    }
    return this._create(secs, nos);
  };
  Duration.of = function of(amount, unit) {
    return Duration.ZERO.plus(amount, unit);
  };
  Duration.from = function from(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount);
    var duration = Duration.ZERO;
    amount.units().forEach(function (unit) {
      duration = duration.plus(amount.get(unit), unit);
    });
    return duration;
  };
  Duration.between = function between(startInclusive, endExclusive) {
    requireNonNull(startInclusive, 'startInclusive');
    requireNonNull(endExclusive, 'endExclusive');
    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
    var nanos = 0;
    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
      try {
        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
        if (secs > 0 && nanos < 0) {
          nanos += LocalTime.NANOS_PER_SECOND;
        } else if (secs < 0 && nanos > 0) {
          nanos -= LocalTime.NANOS_PER_SECOND;
        } else if (secs === 0 && nanos !== 0) {
          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
        }
      } catch (e) {}
    }
    return this.ofSeconds(secs, nanos);
  };
  Duration.parse = function parse(text) {
    requireNonNull(text, 'text');
    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');
    var matches = PATTERN.exec(text);
    if (matches !== null) {
      if ('T' === matches[3] === false) {
        var negate = '-' === matches[1];
        var dayMatch = matches[2];
        var hourMatch = matches[4];
        var minuteMatch = matches[5];
        var secondMatch = matches[6];
        var fractionMatch = matches[7];
        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');
          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');
          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');
          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');
          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';
          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
          try {
            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
          } catch (ex) {
            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);
          }
        }
      }
    }
    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);
  };
  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
    if (parsed == null) {
      return 0;
    }
    try {
      if (parsed[0] === '+') {
        parsed = parsed.substring(1);
      }
      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
    } catch (ex) {
      throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
    }
  };
  Duration._parseFraction = function _parseFraction(text, parsed, negate) {
    if (parsed == null || parsed.length === 0) {
      return 0;
    }
    parsed = (parsed + "000000000").substring(0, 9);
    return parseFloat(parsed) * negate;
  };
  Duration._create = function _create() {
    if (arguments.length <= 2) {
      return Duration._createSecondsNanos(arguments[0], arguments[1]);
    } else {
      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
    }
  };
  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
    if (negate) {
      return Duration.ofSeconds(seconds, nanos).negated();
    }
    return Duration.ofSeconds(seconds, nanos);
  };
  Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
    if (seconds === void 0) {
      seconds = 0;
    }
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    if (seconds === 0 && nanoAdjustment === 0) {
      return Duration.ZERO;
    }
    return new Duration(seconds, nanoAdjustment);
  };
  var _proto = Duration.prototype;
  _proto.get = function get(unit) {
    if (unit === ChronoUnit.SECONDS) {
      return this._seconds;
    } else if (unit === ChronoUnit.NANOS) {
      return this._nanos;
    } else {
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
  };
  _proto.units = function units() {
    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
  };
  _proto.isZero = function isZero() {
    return this._seconds === 0 && this._nanos === 0;
  };
  _proto.isNegative = function isNegative() {
    return this._seconds < 0;
  };
  _proto.seconds = function seconds() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto.withSeconds = function withSeconds(seconds) {
    return Duration._create(seconds, this._nanos);
  };
  _proto.withNanos = function withNanos(nanoOfSecond) {
    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
    return Duration._create(this._seconds, nanoOfSecond);
  };
  _proto.plusDuration = function plusDuration(duration) {
    requireNonNull(duration, 'duration');
    return this.plus(duration.seconds(), duration.nano());
  };
  _proto.plus = function plus(durationOrNumber, unitOrNumber) {
    if (arguments.length === 1) {
      return this.plusDuration(durationOrNumber);
    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
      return this.plusAmountUnit(durationOrNumber, unitOrNumber);
    } else {
      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
    }
  };
  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.DAYS) {
      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
    }
    if (unit.isDurationEstimated()) {
      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');
    }
    if (amountToAdd === 0) {
      return this;
    }
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
      }
      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
    }
    var duration = unit.duration().multipliedBy(amountToAdd);
    return this.plusSecondsNanos(duration.seconds(), duration.nano());
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this.plusSecondsNanos(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this.plusSecondsNanos(0, nanosToAdd);
  };
  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
    requireNonNull(secondsToAdd, 'secondsToAdd');
    requireNonNull(nanosToAdd, 'nanosToAdd');
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
    return Duration.ofSeconds(epochSec, nanoAdjustment);
  };
  _proto.minus = function minus(durationOrNumber, unit) {
    if (arguments.length === 1) {
      return this.minusDuration(durationOrNumber);
    } else {
      return this.minusAmountUnit(durationOrNumber, unit);
    }
  };
  _proto.minusDuration = function minusDuration(duration) {
    requireNonNull(duration, 'duration');
    var secsToSubtract = duration.seconds();
    var nanosToSubtract = duration.nano();
    if (secsToSubtract === MIN_SAFE_INTEGER) {
      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
    }
    return this.plus(-secsToSubtract, -nanosToSubtract);
  };
  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(multiplicand) {
    if (multiplicand === 0) {
      return Duration.ZERO;
    }
    if (multiplicand === 1) {
      return this;
    }
    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
    return Duration.ofSeconds(secs, nos);
  };
  _proto.dividedBy = function dividedBy(divisor) {
    if (divisor === 0) {
      throw new ArithmeticException('Cannot divide by zero');
    }
    if (divisor === 1) {
      return this;
    }
    var secs = MathUtil.intDiv(this._seconds, divisor);
    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intDiv(this._nanos, divisor);
    nos = secsMod + nos;
    return Duration.ofSeconds(secs, nos);
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.abs = function abs() {
    return this.isNegative() ? this.negated() : this;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._seconds !== 0) {
      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._seconds !== 0) {
      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.toDays = function toDays() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
  };
  _proto.toHours = function toHours() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
  };
  _proto.toMinutes = function toMinutes() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
  };
  _proto.toMillis = function toMillis() {
    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));
    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));
    return millis;
  };
  _proto.toNanos = function toNanos() {
    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
    return totalNanos;
  };
  _proto.compareTo = function compareTo(otherDuration) {
    requireNonNull(otherDuration, 'otherDuration');
    requireInstance(otherDuration, Duration, 'otherDuration');
    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
    if (cmp !== 0) {
      return cmp;
    }
    return this._nanos - otherDuration.nano();
  };
  _proto.equals = function equals(otherDuration) {
    if (this === otherDuration) {
      return true;
    }
    if (otherDuration instanceof Duration) {
      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
    }
    return false;
  };
  _proto.toString = function toString() {
    if (this === Duration.ZERO) {
      return 'PT0S';
    }
    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
    var rval = 'PT';
    if (hours !== 0) {
      rval += hours + "H";
    }
    if (minutes !== 0) {
      rval += minutes + "M";
    }
    if (secs === 0 && this._nanos === 0 && rval.length > 2) {
      return rval;
    }
    if (secs < 0 && this._nanos > 0) {
      if (secs === -1) {
        rval += '-0';
      } else {
        rval += secs + 1;
      }
    } else {
      rval += secs;
    }
    if (this._nanos > 0) {
      rval += '.';
      var nanoString;
      if (secs < 0) {
        nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
      } else {
        nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
      }
      nanoString = nanoString.slice(1, nanoString.length);
      rval += nanoString;
      while (rval.charAt(rval.length - 1) === '0') {
        rval = rval.slice(0, rval.length - 1);
      }
    }
    rval += 'S';
    return rval;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Duration;
}(TemporalAmount);
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
 */var YearConstants = function YearConstants() {};
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}

var ChronoUnit = function (_TemporalUnit) {
  _inheritsLoose(ChronoUnit, _TemporalUnit);
  function ChronoUnit(name, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto = ChronoUnit.prototype;
  _proto.duration = function duration() {
    return this._duration;
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    return this.isDateBased() || this === ChronoUnit.FOREVER;
  };
  _proto.isDateBased = function isDateBased() {
    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;
  };
  _proto.isTimeBased = function isTimeBased() {
    return this.compareTo(ChronoUnit.DAYS) < 0;
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    if (this === ChronoUnit.FOREVER) {
      return false;
    }
    try {
      temporal.plus(1, this);
      return true;
    } catch (e) {
      try {
        temporal.plus(-1, this);
        return true;
      } catch (e2) {
        return false;
      }
    }
  };
  _proto.addTo = function addTo(temporal, amount) {
    return temporal.plus(amount, this);
  };
  _proto.between = function between(temporal1, temporal2) {
    return temporal1.until(temporal2, this);
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    return this.duration().compareTo(other.duration());
  };
  return ChronoUnit;
}(TemporalUnit);
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));
  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));
  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));
  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalField = function () {
  function TemporalField() {}
  var _proto = TemporalField.prototype;
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };
  _proto.baseUnit = function baseUnit() {
    abstractMethodFail('baseUnit');
  };
  _proto.rangeUnit = function rangeUnit() {
    abstractMethodFail('rangeUnit');
  };
  _proto.range = function range() {
    abstractMethodFail('range');
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    abstractMethodFail('rangeRefinedBy');
  };
  _proto.getFrom = function getFrom(temporal) {
    abstractMethodFail('getFrom');
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    abstractMethodFail('adjustInto');
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };
  _proto.displayName = function displayName() {
    abstractMethodFail('displayName');
  };
  _proto.equals = function equals(other) {
    abstractMethodFail('equals');
  };
  _proto.name = function name() {
    abstractMethodFail('name');
  };
  return TemporalField;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ValueRange = function () {
  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {
    assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
    assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
    assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
    this._minSmallest = minSmallest;
    this._minLargest = minLargest;
    this._maxLargest = maxLargest;
    this._maxSmallest = maxSmallest;
  }
  var _proto = ValueRange.prototype;
  _proto.isFixed = function isFixed() {
    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
  };
  _proto.minimum = function minimum() {
    return this._minSmallest;
  };
  _proto.largestMinimum = function largestMinimum() {
    return this._minLargest;
  };
  _proto.maximum = function maximum() {
    return this._maxLargest;
  };
  _proto.smallestMaximum = function smallestMaximum() {
    return this._maxSmallest;
  };
  _proto.isValidValue = function isValidValue(value) {
    return this.minimum() <= value && value <= this.maximum();
  };
  _proto.checkValidValue = function checkValidValue(value, field) {
    var msg;
    if (!this.isValidValue(value)) {
      if (field != null) {
        msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
      } else {
        msg = "Invalid value (valid values " + this.toString() + "): " + value;
      }
      return assert(false, msg, DateTimeException);
    }
    return value;
  };
  _proto.checkValidIntValue = function checkValidIntValue(value, field) {
    if (this.isValidIntValue(value) === false) {
      throw new DateTimeException("Invalid int value for " + field + ": " + value);
    }
    return value;
  };
  _proto.isValidIntValue = function isValidIntValue(value) {
    return this.isIntValue() && this.isValidValue(value);
  };
  _proto.isIntValue = function isIntValue() {
    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ValueRange) {
      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
  };
  _proto.toString = function toString() {
    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : '');
    str += ' - ';
    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : '');
    return str;
  };
  ValueRange.of = function of() {
    if (arguments.length === 2) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);
    } else if (arguments.length === 3) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);
    } else if (arguments.length === 4) {
      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);
    } else {
      return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
    }
  };
  return ValueRange;
}();

var ChronoField = function (_TemporalField) {
  _inheritsLoose(ChronoField, _TemporalField);
  ChronoField.byName = function byName(fieldName) {
    for (var prop in ChronoField) {
      if (ChronoField[prop]) {
        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {
          return ChronoField[prop];
        }
      }
    }
  };
  function ChronoField(name, baseUnit, rangeUnit, range) {
    var _this;
    _this = _TemporalField.call(this) || this;
    _this._name = name;
    _this._baseUnit = baseUnit;
    _this._rangeUnit = rangeUnit;
    _this._range = range;
    return _this;
  }
  var _proto = ChronoField.prototype;
  _proto.name = function name() {
    return this._name;
  };
  _proto.baseUnit = function baseUnit() {
    return this._baseUnit;
  };
  _proto.rangeUnit = function rangeUnit() {
    return this._rangeUnit;
  };
  _proto.range = function range() {
    return this._range;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.checkValidValue = function checkValidValue(value) {
    return this.range().checkValidValue(value, this);
  };
  _proto.checkValidIntValue = function checkValidIntValue(value) {
    return this.range().checkValidIntValue(value, this);
  };
  _proto.isDateBased = function isDateBased() {
    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.PROLEPTIC_MONTH || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;
    return dateBased;
  };
  _proto.isTimeBased = function isTimeBased() {
    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;
    return timeBased;
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return temporal.range(this);
  };
  _proto.getFrom = function getFrom(temporal) {
    return temporal.getLong(this);
  };
  _proto.toString = function toString() {
    return this.name();
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    return temporal.with(this, newValue);
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(this);
  };
  return ChronoField;
}(TemporalField);
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');
  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');
  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');
  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var TemporalQueries = function () {
  function TemporalQueries() {}
  TemporalQueries.zoneId = function zoneId() {
    return TemporalQueries.ZONE_ID;
  };
  TemporalQueries.chronology = function chronology() {
    return TemporalQueries.CHRONO;
  };
  TemporalQueries.precision = function precision() {
    return TemporalQueries.PRECISION;
  };
  TemporalQueries.zone = function zone() {
    return TemporalQueries.ZONE;
  };
  TemporalQueries.offset = function offset() {
    return TemporalQueries.OFFSET;
  };
  TemporalQueries.localDate = function localDate() {
    return TemporalQueries.LOCAL_DATE;
  };
  TemporalQueries.localTime = function localTime() {
    return TemporalQueries.LOCAL_TIME;
  };
  return TemporalQueries;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAccessor = function () {
  function TemporalAccessor() {}
  var _proto = TemporalAccessor.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    abstractMethodFail('getLong');
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (this.isSupported(field)) {
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.isSupported = function isSupported(field) {
    abstractMethodFail('isSupported');
  };
  return TemporalAccessor;
}();

var TemporalQuery = function (_Enum) {
  _inheritsLoose(TemporalQuery, _Enum);
  function TemporalQuery() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TemporalQuery.prototype;
  _proto.queryFrom = function queryFrom(temporal) {
    abstractMethodFail('queryFrom');
  };
  return TemporalQuery;
}(Enum);
function createTemporalQuery(name, queryFromFunction) {
  var ExtendedTemporalQuery = function (_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);
    function ExtendedTemporalQuery() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name);
}

var DayOfWeek = function (_TemporalAccessor) {
  _inheritsLoose(DayOfWeek, _TemporalAccessor);
  function DayOfWeek(ordinal, name) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._ordinal = ordinal;
    _this._name = name;
    return _this;
  }
  var _proto = DayOfWeek.prototype;
  _proto.ordinal = function ordinal() {
    return this._ordinal;
  };
  _proto.name = function name() {
    return this._name;
  };
  DayOfWeek.values = function values() {
    return ENUMS.slice();
  };
  DayOfWeek.valueOf = function valueOf(name) {
    var ordinal = 0;
    for (ordinal; ordinal < ENUMS.length; ordinal++) {
      if (ENUMS[ordinal].name() === name) {
        break;
      }
    }
    return DayOfWeek.of(ordinal + 1);
  };
  DayOfWeek.of = function of(dayOfWeek) {
    if (dayOfWeek < 1 || dayOfWeek > 7) {
      throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
    }
    return ENUMS[dayOfWeek - 1];
  };
  DayOfWeek.from = function from(temporal) {
    assert(temporal != null, 'temporal', NullPointerException);
    if (temporal instanceof DayOfWeek) {
      return temporal;
    }
    try {
      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
    } catch (ex) {
      if (ex instanceof DateTimeException) {
        throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''), ex);
      } else {
        throw ex;
      }
    }
  };
  _proto.value = function value() {
    return this._ordinal + 1;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.DAY_OF_WEEK;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(days) {
    var amount = MathUtil.floorMod(days, 7);
    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
  };
  _proto.minus = function minus(days) {
    return this.plus(-1 * MathUtil.floorMod(days, 7));
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    assert(_query != null, 'query', NullPointerException);
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, DayOfWeek, 'other');
    return this._ordinal - other._ordinal;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return DayOfWeek;
}(TemporalAccessor);
var ENUMS;
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');
  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');
  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');
  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');
  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');
  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');
  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}

var Month = function (_TemporalAccessor) {
  _inheritsLoose(Month, _TemporalAccessor);
  function Month(value, name) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._value = MathUtil.safeToInt(value);
    _this._name = name;
    return _this;
  }
  var _proto = Month.prototype;
  _proto.value = function value() {
    return this._value;
  };
  _proto.ordinal = function ordinal() {
    return this._value - 1;
  };
  _proto.name = function name() {
    return this._name;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };
  _proto.isSupported = function isSupported(field) {
    if (null === field) {
      return false;
    }
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.get = function get(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(months) {
    var amount = MathUtil.intMod(months, 12) + 12;
    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
    return Month.of(newMonthVal);
  };
  _proto.minus = function minus(months) {
    return this.plus(-1 * MathUtil.intMod(months, 12));
  };
  _proto.length = function length(leapYear) {
    switch (this) {
      case Month.FEBRUARY:
        return leapYear ? 29 : 28;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.minLength = function minLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 28;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.maxLength = function maxLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 29;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
    var leap = leapYear ? 1 : 0;
    switch (this) {
      case Month.JANUARY:
        return 1;
      case Month.FEBRUARY:
        return 32;
      case Month.MARCH:
        return 60 + leap;
      case Month.APRIL:
        return 91 + leap;
      case Month.MAY:
        return 121 + leap;
      case Month.JUNE:
        return 152 + leap;
      case Month.JULY:
        return 182 + leap;
      case Month.AUGUST:
        return 213 + leap;
      case Month.SEPTEMBER:
        return 244 + leap;
      case Month.OCTOBER:
        return 274 + leap;
      case Month.NOVEMBER:
        return 305 + leap;
      case Month.DECEMBER:
      default:
        return 335 + leap;
    }
  };
  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
    switch (this) {
      case Month.JANUARY:
      case Month.FEBRUARY:
      case Month.MARCH:
        return Month.JANUARY;
      case Month.APRIL:
      case Month.MAY:
      case Month.JUNE:
        return Month.APRIL;
      case Month.JULY:
      case Month.AUGUST:
      case Month.SEPTEMBER:
        return Month.JULY;
      case Month.OCTOBER:
      case Month.NOVEMBER:
      case Month.DECEMBER:
      default:
        return Month.OCTOBER;
    }
  };
  _proto.query = function query(_query) {
    assert(_query != null, 'query() parameter must not be null', DateTimeException);
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.toString = function toString() {
    switch (this) {
      case Month.JANUARY:
        return 'JANUARY';
      case Month.FEBRUARY:
        return 'FEBRUARY';
      case Month.MARCH:
        return 'MARCH';
      case Month.APRIL:
        return 'APRIL';
      case Month.MAY:
        return 'MAY';
      case Month.JUNE:
        return 'JUNE';
      case Month.JULY:
        return 'JULY';
      case Month.AUGUST:
        return 'AUGUST';
      case Month.SEPTEMBER:
        return 'SEPTEMBER';
      case Month.OCTOBER:
        return 'OCTOBER';
      case Month.NOVEMBER:
        return 'NOVEMBER';
      case Month.DECEMBER:
        return 'DECEMBER';
      default:
        return "unknown Month, value: " + this.value();
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Month, 'other');
    return this._value - other._value;
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  Month.valueOf = function valueOf(name) {
    var ordinal = 0;
    for (ordinal; ordinal < MONTHS.length; ordinal++) {
      if (MONTHS[ordinal].name() === name) {
        break;
      }
    }
    return Month.of(ordinal + 1);
  };
  Month.values = function values() {
    return MONTHS.slice();
  };
  Month.of = function of(month) {
    if (month < 1 || month > 12) {
      assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
    }
    return MONTHS[month - 1];
  };
  Month.from = function from(temporal) {
    if (temporal instanceof Month) {
      return temporal;
    }
    try {
      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);
    }
  };
  return Month;
}(TemporalAccessor);
var MONTHS;
function _init$i() {
  Month.JANUARY = new Month(1, 'JANUARY');
  Month.FEBRUARY = new Month(2, 'FEBRUARY');
  Month.MARCH = new Month(3, 'MARCH');
  Month.APRIL = new Month(4, 'APRIL');
  Month.MAY = new Month(5, 'MAY');
  Month.JUNE = new Month(6, 'JUNE');
  Month.JULY = new Month(7, 'JULY');
  Month.AUGUST = new Month(8, 'AUGUST');
  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');
  Month.OCTOBER = new Month(10, 'OCTOBER');
  Month.NOVEMBER = new Month(11, 'NOVEMBER');
  Month.DECEMBER = new Month(12, 'DECEMBER');
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}

var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
var Period = function (_TemporalAmount) {
  _inheritsLoose(Period, _TemporalAmount);
  function Period(years, months, days) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    var _years = MathUtil.safeToInt(years);
    var _months = MathUtil.safeToInt(months);
    var _days = MathUtil.safeToInt(days);
    if (_years === 0 && _months === 0 && _days === 0) {
      if (!Period.ZERO) {
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        Period.ZERO = _assertThisInitialized(_this);
      }
      return Period.ZERO || _assertThisInitialized(_this);
    }
    _this._years = _years;
    _this._months = _months;
    _this._days = _days;
    return _this;
  }
  Period.ofYears = function ofYears(years) {
    return Period.create(years, 0, 0);
  };
  Period.ofMonths = function ofMonths(months) {
    return Period.create(0, months, 0);
  };
  Period.ofWeeks = function ofWeeks(weeks) {
    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));
  };
  Period.ofDays = function ofDays(days) {
    return Period.create(0, 0, days);
  };
  Period.of = function of(years, months, days) {
    return Period.create(years, months, days);
  };
  Period.from = function from(amount) {
    if (amount instanceof Period) {
      return amount;
    }
    requireNonNull(amount, 'amount');
    var years = 0;
    var months = 0;
    var days = 0;
    var units = amount.units();
    for (var i = 0; i < units.length; i++) {
      var unit = units[i];
      var unitAmount = amount.get(unit);
      if (unit === ChronoUnit.YEARS) {
        years = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.MONTHS) {
        months = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.DAYS) {
        days = MathUtil.safeToInt(unitAmount);
      } else {
        throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
      }
    }
    return Period.create(years, months, days);
  };
  Period.between = function between(startDate, endDate) {
    requireNonNull(startDate, 'startDate');
    requireNonNull(endDate, 'endDate');
    requireInstance(startDate, LocalDate, 'startDate');
    requireInstance(endDate, LocalDate, 'endDate');
    return startDate.until(endDate);
  };
  Period.parse = function parse(text) {
    requireNonNull(text, 'text');
    try {
      return Period._parse(text);
    } catch (ex) {
      if (ex instanceof ArithmeticException) {
        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);
      } else {
        throw ex;
      }
    }
  };
  Period._parse = function _parse(text) {
    var matches = PATTERN.exec(text);
    if (matches != null) {
      var negate = '-' === matches[1] ? -1 : 1;
      var yearMatch = matches[2];
      var monthMatch = matches[3];
      var weekMatch = matches[4];
      var dayMatch = matches[5];
      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
        var years = Period._parseNumber(text, yearMatch, negate);
        var months = Period._parseNumber(text, monthMatch, negate);
        var weeks = Period._parseNumber(text, weekMatch, negate);
        var days = Period._parseNumber(text, dayMatch, negate);
        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
        return Period.create(years, months, days);
      }
    }
    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);
  };
  Period._parseNumber = function _parseNumber(text, str, negate) {
    if (str == null) {
      return 0;
    }
    var val = MathUtil.parseInt(str);
    return MathUtil.safeMultiply(val, negate);
  };
  Period.create = function create(years, months, days) {
    return new Period(years, months, days);
  };
  var _proto = Period.prototype;
  _proto.units = function units() {
    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.get = function get(unit) {
    if (unit === ChronoUnit.YEARS) {
      return this._years;
    }
    if (unit === ChronoUnit.MONTHS) {
      return this._months;
    }
    if (unit === ChronoUnit.DAYS) {
      return this._days;
    }
    throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
  };
  _proto.isZero = function isZero() {
    return this === Period.ZERO;
  };
  _proto.isNegative = function isNegative() {
    return this._years < 0 || this._months < 0 || this._days < 0;
  };
  _proto.years = function years() {
    return this._years;
  };
  _proto.months = function months() {
    return this._months;
  };
  _proto.days = function days() {
    return this._days;
  };
  _proto.withYears = function withYears(years) {
    if (years === this._years) {
      return this;
    }
    return Period.create(years, this._months, this._days);
  };
  _proto.withMonths = function withMonths(months) {
    if (months === this._months) {
      return this;
    }
    return Period.create(this._years, months, this._days);
  };
  _proto.withDays = function withDays(days) {
    if (days === this._days) {
      return this;
    }
    return Period.create(this._years, this._months, days);
  };
  _proto.plus = function plus(amountToAdd) {
    var amount = Period.from(amountToAdd);
    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
  };
  _proto.minus = function minus(amountToSubtract) {
    var amount = Period.from(amountToSubtract);
    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(-1 * yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(-1 * monthsToSubtract);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(-1 * daysToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(scalar) {
    if (this === Period.ZERO || scalar === 1) {
      return this;
    }
    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.normalized = function normalized() {
    var totalMonths = this.toTotalMonths();
    var splitYears = MathUtil.intDiv(totalMonths, 12);
    var splitMonths = MathUtil.intMod(totalMonths, 12);
    if (splitYears === this._years && splitMonths === this._months) {
      return this;
    }
    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
  };
  _proto.toTotalMonths = function toTotalMonths() {
    return this._years * 12 + this._months;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.plus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.plus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.minus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.minus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof Period) {
      var other = obj;
      return this._years === other._years && this._months === other._months && this._days === other._days;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._years, this._months, this._days);
  };
  _proto.toString = function toString() {
    if (this === Period.ZERO) {
      return 'P0D';
    } else {
      var buf = 'P';
      if (this._years !== 0) {
        buf += this._years + "Y";
      }
      if (this._months !== 0) {
        buf += this._months + "M";
      }
      if (this._days !== 0) {
        buf += this._days + "D";
      }
      return buf;
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Period;
}(TemporalAmount);
function _init$h() {
  Period.ofDays(0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var ParsePosition = function () {
  function ParsePosition(index) {
    this._index = index;
    this._errorIndex = -1;
  }
  var _proto = ParsePosition.prototype;
  _proto.getIndex = function getIndex() {
    return this._index;
  };
  _proto.setIndex = function setIndex(index) {
    this._index = index;
  };
  _proto.getErrorIndex = function getErrorIndex() {
    return this._errorIndex;
  };
  _proto.setErrorIndex = function setErrorIndex(errorIndex) {
    this._errorIndex = errorIndex;
  };
  return ParsePosition;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var EnumMap = function () {
  function EnumMap() {
    this._map = {};
  }
  var _proto = EnumMap.prototype;
  _proto.putAll = function putAll(otherMap) {
    for (var key in otherMap._map) {
      this._map[key] = otherMap._map[key];
    }
    return this;
  };
  _proto.containsKey = function containsKey(key) {
    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;
  };
  _proto.get = function get(key) {
    return this._map[key.name()];
  };
  _proto.put = function put(key, val) {
    return this.set(key, val);
  };
  _proto.set = function set(key, val) {
    this._map[key.name()] = val;
    return this;
  };
  _proto.retainAll = function retainAll(keyList) {
    var map = {};
    for (var i = 0; i < keyList.length; i++) {
      var key = keyList[i].name();
      map[key] = this._map[key];
    }
    this._map = map;
    return this;
  };
  _proto.remove = function remove(key) {
    var keyName = key.name();
    var val = this._map[keyName];
    this._map[keyName] = undefined;
    return val;
  };
  _proto.keySet = function keySet() {
    return this._map;
  };
  _proto.clear = function clear() {
    this._map = {};
  };
  return EnumMap;
}();

var ResolverStyle = function (_Enum) {
  _inheritsLoose(ResolverStyle, _Enum);
  function ResolverStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  return ResolverStyle;
}(Enum);
ResolverStyle.STRICT = new ResolverStyle('STRICT');
ResolverStyle.SMART = new ResolverStyle('SMART');
ResolverStyle.LENIENT = new ResolverStyle('LENIENT');

var Temporal = function (_TemporalAccessor) {
  _inheritsLoose(Temporal, _TemporalAccessor);
  function Temporal() {
    return _TemporalAccessor.apply(this, arguments) || this;
  }
  var _proto = Temporal.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    abstractMethodFail('isSupported');
  };
  _proto.minus = function minus(amount, unit) {
    if (arguments.length < 2) {
      return this._minusAmount(amount);
    } else {
      return this._minusUnit(amount, unit);
    }
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    return this._plusUnit(-amountToSubtract, unit);
  };
  _proto.plus = function plus(amount, unit) {
    if (arguments.length < 2) {
      return this._plusAmount(amount);
    } else {
      return this._plusUnit(amount, unit);
    }
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    abstractMethodFail('_plusUnit');
  };
  _proto.until = function until(endTemporal, unit) {
    abstractMethodFail('until');
  };
  _proto.with = function _with(adjusterOrField, newValue) {
    if (arguments.length < 2) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, newValue);
    }
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    assert(typeof adjuster.adjustInto === 'function', 'adjuster must be a TemporalAdjuster', IllegalArgumentException);
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    abstractMethodFail('_withField');
  };
  return Temporal;
}(TemporalAccessor);
if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  Temporal.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }
    throw new TypeError('A conversion from Temporal to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

var ChronoLocalDate = function (_Temporal) {
  _inheritsLoose(ChronoLocalDate, _Temporal);
  function ChronoLocalDate() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDate.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toEpochDay());
    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  return ChronoLocalDate;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringUtil = function () {
  function StringUtil() {}
  StringUtil.startsWith = function startsWith(text, pattern) {
    return text.indexOf(pattern) === 0;
  };
  StringUtil.hashCode = function hashCode(text) {
    var len = text.length;
    if (len === 0) {
      return 0;
    }
    var hash = 0;
    for (var i = 0; i < len; i++) {
      var chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return MathUtil.smi(hash);
  };
  return StringUtil;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneId = function () {
  function ZoneId() {}
  ZoneId.systemDefault = function systemDefault() {
    throw new DateTimeException('not supported operation');
  };
  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {
    throw new DateTimeException('not supported operation');
  };
  ZoneId.of = function of(zoneId) {
    throw new DateTimeException("not supported operation" + zoneId);
  };
  ZoneId.ofOffset = function ofOffset(prefix, offset) {
    throw new DateTimeException("not supported operation" + prefix + offset);
  };
  ZoneId.from = function from(temporal) {
    throw new DateTimeException("not supported operation" + temporal);
  };
  var _proto = ZoneId.prototype;
  _proto.id = function id() {
    abstractMethodFail('ZoneId.id');
  };
  _proto.rules = function rules() {
    abstractMethodFail('ZoneId.rules');
  };
  _proto.normalized = function normalized() {
    var rules = this.rules();
    if (rules.isFixedOffset()) {
      return rules.offset(Instant.EPOCH);
    }
    return this;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZoneId) {
      return this.id() === other.id();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return StringUtil.hashCode(this.id());
  };
  _proto.toString = function toString() {
    return this.id();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneId;
}();

var ZoneRules = function () {
  function ZoneRules() {}
  ZoneRules.of = function of(offset) {
    requireNonNull(offset, 'offset');
    return new Fixed(offset);
  };
  var _proto = ZoneRules.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    abstractMethodFail('ZoneRules.isFixedOffset');
  };
  _proto.offset = function offset(instantOrLocalDateTime) {
    if (instantOrLocalDateTime instanceof Instant) {
      return this.offsetOfInstant(instantOrLocalDateTime);
    } else {
      return this.offsetOfLocalDateTime(instantOrLocalDateTime);
    }
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    abstractMethodFail('ZoneRules.offsetInstant');
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    abstractMethodFail('ZoneRules.offsetOfEpochMilli');
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    abstractMethodFail('ZoneRules.offsetLocalDateTime');
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    abstractMethodFail('ZoneRules.validOffsets');
  };
  _proto.transition = function transition(localDateTime) {
    abstractMethodFail('ZoneRules.transition');
  };
  _proto.standardOffset = function standardOffset(instant) {
    abstractMethodFail('ZoneRules.standardOffset');
  };
  _proto.daylightSavings = function daylightSavings(instant) {
    abstractMethodFail('ZoneRules.daylightSavings');
  };
  _proto.isDaylightSavings = function isDaylightSavings(instant) {
    abstractMethodFail('ZoneRules.isDaylightSavings');
  };
  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
    abstractMethodFail('ZoneRules.isValidOffset');
  };
  _proto.nextTransition = function nextTransition(instant) {
    abstractMethodFail('ZoneRules.nextTransition');
  };
  _proto.previousTransition = function previousTransition(instant) {
    abstractMethodFail('ZoneRules.previousTransition');
  };
  _proto.transitions = function transitions() {
    abstractMethodFail('ZoneRules.transitions');
  };
  _proto.transitionRules = function transitionRules() {
    abstractMethodFail('ZoneRules.transitionRules');
  };
  _proto.toString = function toString() {
    abstractMethodFail('ZoneRules.toString');
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneRules;
}();
var Fixed = function (_ZoneRules) {
  _inheritsLoose(Fixed, _ZoneRules);
  function Fixed(offset) {
    var _this;
    _this = _ZoneRules.call(this) || this;
    _this._offset = offset;
    return _this;
  }
  var _proto2 = Fixed.prototype;
  _proto2.isFixedOffset = function isFixedOffset() {
    return true;
  };
  _proto2.offsetOfInstant = function offsetOfInstant() {
    return this._offset;
  };
  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
    return this._offset;
  };
  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
    return this._offset;
  };
  _proto2.validOffsets = function validOffsets() {
    return [this._offset];
  };
  _proto2.transition = function transition() {
    return null;
  };
  _proto2.standardOffset = function standardOffset() {
    return this._offset;
  };
  _proto2.daylightSavings = function daylightSavings() {
    return Duration.ZERO;
  };
  _proto2.isDaylightSavings = function isDaylightSavings() {
    return false;
  };
  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
    return this._offset.equals(offset);
  };
  _proto2.nextTransition = function nextTransition() {
    return null;
  };
  _proto2.previousTransition = function previousTransition() {
    return null;
  };
  _proto2.transitions = function transitions() {
    return [];
  };
  _proto2.transitionRules = function transitionRules() {
    return [];
  };
  _proto2.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Fixed) {
      return this._offset.equals(other._offset);
    }
    return false;
  };
  _proto2.toString = function toString() {
    return "FixedRules:" + this._offset.toString();
  };
  return Fixed;
}(ZoneRules);

var SECONDS_CACHE = {};
var ID_CACHE = {};
var ZoneOffset = function (_ZoneId) {
  _inheritsLoose(ZoneOffset, _ZoneId);
  function ZoneOffset(totalSeconds) {
    var _this;
    _this = _ZoneId.call(this) || this;
    ZoneOffset._validateTotalSeconds(totalSeconds);
    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
    _this._rules = ZoneRules.of(_assertThisInitialized(_this));
    _this._id = ZoneOffset._buildId(totalSeconds);
    return _this;
  }
  var _proto = ZoneOffset.prototype;
  _proto.totalSeconds = function totalSeconds() {
    return this._totalSeconds;
  };
  _proto.id = function id() {
    return this._id;
  };
  ZoneOffset._buildId = function _buildId(totalSeconds) {
    if (totalSeconds === 0) {
      return 'Z';
    } else {
      var absTotalSeconds = Math.abs(totalSeconds);
      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
      var buf = "" + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;
      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
      if (absSeconds !== 0) {
        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;
      }
      return buf;
    }
  };
  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };
  ZoneOffset._validate = function _validate(hours, minutes, seconds) {
    if (hours < -18 || hours > 18) {
      throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
    }
    if (hours > 0) {
      if (minutes < 0 || seconds < 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');
      }
    } else if (hours < 0) {
      if (minutes > 0 || seconds > 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');
      }
    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');
    }
    if (Math.abs(minutes) > 59) {
      throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
    }
    if (Math.abs(seconds) > 59) {
      throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
    }
    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };
  ZoneOffset.of = function of(offsetId) {
    requireNonNull(offsetId, 'offsetId');
    var offset = ID_CACHE[offsetId];
    if (offset != null) {
      return offset;
    }
    var hours, minutes, seconds;
    switch (offsetId.length) {
      case 2:
        offsetId = offsetId[0] + "0" + offsetId[1];
      case 3:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = 0;
        seconds = 0;
        break;
      case 5:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = 0;
        break;
      case 6:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = 0;
        break;
      case 7:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = ZoneOffset._parseNumber(offsetId, 5, false);
        break;
      case 9:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = ZoneOffset._parseNumber(offsetId, 7, true);
        break;
      default:
        throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
    }
    var first = offsetId[0];
    if (first !== '+' && first !== '-') {
      throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
    }
    if (first === '-') {
      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
    } else {
      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);
    }
  };
  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
    if (precededByColon && offsetId[pos - 1] !== ':') {
      throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
    }
    var ch1 = offsetId[pos];
    var ch2 = offsetId[pos + 1];
    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
    }
    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
  };
  ZoneOffset.ofHours = function ofHours(hours) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);
  };
  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);
  };
  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
    ZoneOffset._validate(hours, minutes, seconds);
    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
      var totalSecs = totalSeconds;
      var result = SECONDS_CACHE[totalSecs];
      if (result == null) {
        result = new ZoneOffset(totalSeconds);
        SECONDS_CACHE[totalSecs] = result;
        ID_CACHE[result.id()] = result;
      }
      return result;
    } else {
      return new ZoneOffset(totalSeconds);
    }
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.OFFSET_SECONDS) {
      return this._totalSeconds;
    } else if (field instanceof ChronoField) {
      throw new DateTimeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    return other._totalSeconds - this._totalSeconds;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof ZoneOffset) {
      return this._totalSeconds === obj._totalSeconds;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._totalSeconds;
  };
  _proto.toString = function toString() {
    return this._id;
  };
  return ZoneOffset;
}(ZoneId);
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}

var DateTimeBuilder = function (_TemporalAccessor) {
  _inheritsLoose(DateTimeBuilder, _TemporalAccessor);
  DateTimeBuilder.create = function create(field, value) {
    var dtb = new DateTimeBuilder();
    dtb._addFieldValue(field, value);
    return dtb;
  };
  function DateTimeBuilder() {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this.fieldValues = new EnumMap();
    _this.chrono = null;
    _this.zone = null;
    _this.date = null;
    _this.time = null;
    _this.leapSecond = false;
    _this.excessDays = null;
    return _this;
  }
  var _proto = DateTimeBuilder.prototype;
  _proto.getFieldValue0 = function getFieldValue0(field) {
    return this.fieldValues.get(field);
  };
  _proto._addFieldValue = function _addFieldValue(field, value) {
    requireNonNull(field, 'field');
    var old = this.getFieldValue0(field);
    if (old != null && old !== value) {
      throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
    }
    return this._putFieldValue0(field, value);
  };
  _proto._putFieldValue0 = function _putFieldValue0(field, value) {
    this.fieldValues.put(field, value);
    return this;
  };
  _proto.resolve = function resolve(resolverStyle, resolverFields) {
    if (resolverFields != null) {
      this.fieldValues.retainAll(resolverFields);
    }
    this._mergeDate(resolverStyle);
    this._mergeTime(resolverStyle);
    this._resolveTimeInferZeroes(resolverStyle);
    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
      this.date = this.date.plus(this.excessDays);
      this.excessDays = Period.ZERO;
    }
    this._resolveInstant();
    return this;
  };
  _proto._mergeDate = function _mergeDate(resolverStyle) {
    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
  };
  _proto._checkDate = function _checkDate(date) {
    if (date != null) {
      this._addObject(date);
      for (var fieldName in this.fieldValues.keySet()) {
        var field = ChronoField.byName(fieldName);
        if (field) {
          if (this.fieldValues.get(field) !== undefined) {
            if (field.isDateBased()) {
              var val1 = void 0;
              try {
                val1 = date.getLong(field);
              } catch (ex) {
                if (ex instanceof DateTimeException) {
                  continue;
                } else {
                  throw ex;
                }
              }
              var val2 = this.fieldValues.get(field);
              if (val1 !== val2) {
                throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
              }
            }
          }
        }
      }
    }
  };
  _proto._mergeTime = function _mergeTime(resolverStyle) {
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
    }
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
      }
      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
    }
    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.NANO_OF_DAY.checkValidValue(nod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));
      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MICRO_OF_DAY.checkValidValue(cod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));
      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MILLI_OF_DAY.checkValidValue(lod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));
      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));
    }
    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.SECOND_OF_DAY.checkValidValue(sod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
    }
    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
      }
      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));
      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));
      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);
    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);
    }
  };
  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
    if (hod == null) {
      return;
    }
    if (moh == null && (som != null || nos != null)) {
      return;
    }
    if (moh != null && som == null && nos != null) {
      return;
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (hod != null) {
        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
          hod = 0;
          this.excessDays = Period.ofDays(1);
        }
        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
        if (moh != null) {
          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
          if (som != null) {
            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
            if (nos != null) {
              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
            } else {
              this._addObject(LocalTime.of(hodVal, mohVal, somVal));
            }
          } else {
            if (nos == null) {
              this._addObject(LocalTime.of(hodVal, mohVal));
            }
          }
        } else {
          if (som == null && nos == null) {
            this._addObject(LocalTime.of(hodVal, 0));
          }
        }
      }
    } else {
      if (hod != null) {
        var _hodVal = hod;
        if (moh != null) {
          if (som != null) {
            if (nos == null) {
              nos = 0;
            }
            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, nos);
            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);
            var nod = MathUtil.floorMod(totalNanos, 86400000000000);
            this._addObject(LocalTime.ofNanoOfDay(nod));
            this.excessDays = Period.ofDays(excessDays);
          } else {
            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
            var sod = MathUtil.floorMod(totalSecs, 86400);
            this._addObject(LocalTime.ofSecondOfDay(sod));
            this.excessDays = Period.ofDays(_excessDays);
          }
        } else {
          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
          _hodVal = MathUtil.floorMod(_hodVal, 24);
          this._addObject(LocalTime.of(_hodVal, 0));
          this.excessDays = Period.ofDays(_excessDays2);
        }
      }
    }
    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
  };
  _proto._addObject = function _addObject(dateOrTime) {
    if (dateOrTime instanceof ChronoLocalDate) {
      this.date = dateOrTime;
    } else if (dateOrTime instanceof LocalTime) {
      this.time = dateOrTime;
    }
  };
  _proto._resolveInstant = function _resolveInstant() {
    if (this.date != null && this.time != null) {
      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
      if (offsetSecs != null) {
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
      } else if (this.zone != null) {
        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
      }
    }
  };
  _proto.build = function build(type) {
    return type.queryFrom(this);
  };
  _proto.isSupported = function isSupported(field) {
    if (field == null) {
      return false;
    }
    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    var value = this.getFieldValue0(field);
    if (value == null) {
      if (this.date != null && this.date.isSupported(field)) {
        return this.date.getLong(field);
      }
      if (this.time != null && this.time.isSupported(field)) {
        return this.time.getLong(field);
      }
      throw new DateTimeException("Field not found: " + field);
    }
    return value;
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId()) {
      return this.zone;
    } else if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    } else if (_query === TemporalQueries.localDate()) {
      return this.date != null ? LocalDate.from(this.date) : null;
    } else if (_query === TemporalQueries.localTime()) {
      return this.time;
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return _query.queryFrom(this);
    } else if (_query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  return DateTimeBuilder;
}(TemporalAccessor);

var DateTimeParseContext = function () {
  function DateTimeParseContext() {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DateTimeParseContext) {
        this._constructorSelf.apply(this, arguments);
        return;
      } else {
        this._constructorFormatter.apply(this, arguments);
      }
    } else {
      this._constructorParam.apply(this, arguments);
    }
    this._caseSensitive = true;
    this._strict = true;
    this._parsed = [new Parsed(this)];
  }
  var _proto = DateTimeParseContext.prototype;
  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
    this._locale = locale;
    this._symbols = symbols;
    this._overrideChronology = chronology;
  };
  _proto._constructorFormatter = function _constructorFormatter(formatter) {
    this._locale = formatter.locale();
    this._symbols = formatter.decimalStyle();
    this._overrideChronology = formatter.chronology();
  };
  _proto._constructorSelf = function _constructorSelf(other) {
    this._locale = other._locale;
    this._symbols = other._symbols;
    this._overrideChronology = other._overrideChronology;
    this._overrideZone = other._overrideZone;
    this._caseSensitive = other._caseSensitive;
    this._strict = other._strict;
    this._parsed = [new Parsed(this)];
  };
  _proto.copy = function copy() {
    return new DateTimeParseContext(this);
  };
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.isStrict = function isStrict() {
    return this._strict;
  };
  _proto.setStrict = function setStrict(strict) {
    this._strict = strict;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  _proto.startOptional = function startOptional() {
    this._parsed.push(this.currentParsed().copy());
  };
  _proto.endOptional = function endOptional(successful) {
    if (successful) {
      this._parsed.splice(this._parsed.length - 2, 1);
    } else {
      this._parsed.splice(this._parsed.length - 1, 1);
    }
  };
  _proto.isCaseSensitive = function isCaseSensitive() {
    return this._caseSensitive;
  };
  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
    this._caseSensitive = caseSensitive;
  };
  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
      return false;
    }
    if (!this.isCaseSensitive()) {
      cs1 = cs1.toLowerCase();
      cs2 = cs2.toLowerCase();
    }
    for (var i = 0; i < length; i++) {
      var ch1 = cs1[offset1 + i];
      var ch2 = cs2[offset2 + i];
      if (ch1 !== ch2) {
        return false;
      }
    }
    return true;
  };
  _proto.charEquals = function charEquals(ch1, ch2) {
    if (this.isCaseSensitive()) {
      return ch1 === ch2;
    }
    return this.charEqualsIgnoreCase(ch1, ch2);
  };
  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
  };
  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
    var currentParsedFieldValues = this.currentParsed().fieldValues;
    var old = currentParsedFieldValues.get(field);
    currentParsedFieldValues.set(field, value);
    return old != null && old !== value ? ~errorPos : successPos;
  };
  _proto.setParsedZone = function setParsedZone(zone) {
    requireNonNull(zone, 'zone');
    this.currentParsed().zone = zone;
  };
  _proto.getParsed = function getParsed(field) {
    return this.currentParsed().fieldValues.get(field);
  };
  _proto.toParsed = function toParsed() {
    return this.currentParsed();
  };
  _proto.currentParsed = function currentParsed() {
    return this._parsed[this._parsed.length - 1];
  };
  _proto.setParsedLeapSecond = function setParsedLeapSecond() {
    this.currentParsed().leapSecond = true;
  };
  _proto.getEffectiveChronology = function getEffectiveChronology() {
    var chrono = this.currentParsed().chrono;
    if (chrono == null) {
      chrono = this._overrideChronology;
      if (chrono == null) {
        chrono = IsoChronology.INSTANCE;
      }
    }
    return chrono;
  };
  return DateTimeParseContext;
}();
var Parsed = function (_Temporal) {
  _inheritsLoose(Parsed, _Temporal);
  function Parsed(dateTimeParseContext) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this.chrono = null;
    _this.zone = null;
    _this.fieldValues = new EnumMap();
    _this.leapSecond = false;
    _this.dateTimeParseContext = dateTimeParseContext;
    return _this;
  }
  var _proto2 = Parsed.prototype;
  _proto2.copy = function copy() {
    var cloned = new Parsed();
    cloned.chrono = this.chrono;
    cloned.zone = this.zone;
    cloned.fieldValues.putAll(this.fieldValues);
    cloned.leapSecond = this.leapSecond;
    cloned.dateTimeParseContext = this.dateTimeParseContext;
    return cloned;
  };
  _proto2.toString = function toString() {
    return this.fieldValues + ", " + this.chrono + ", " + this.zone;
  };
  _proto2.isSupported = function isSupported(field) {
    return this.fieldValues.containsKey(field);
  };
  _proto2.get = function get(field) {
    var val = this.fieldValues.get(field);
    assert(val != null);
    return val;
  };
  _proto2.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    }
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto2.toBuilder = function toBuilder() {
    var builder = new DateTimeBuilder();
    builder.fieldValues.putAll(this.fieldValues);
    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
    if (this.zone != null) {
      builder.zone = this.zone;
    } else {
      builder.zone = this.overrideZone;
    }
    builder.leapSecond = this.leapSecond;
    builder.excessDays = this.excessDays;
    return builder;
  };
  return Parsed;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimePrintContext = function () {
  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {
    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);
      this._locale = localeOrFormatter.locale();
      this._symbols = localeOrFormatter.decimalStyle();
    } else {
      this._temporal = temporal;
      this._locale = localeOrFormatter;
      this._symbols = symbols;
    }
    this._optional = 0;
  }
  DateTimePrintContext.adjust = function adjust(temporal, formatter) {
    return temporal;
  };
  var _proto = DateTimePrintContext.prototype;
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.startOptional = function startOptional() {
    this._optional++;
  };
  _proto.endOptional = function endOptional() {
    this._optional--;
  };
  _proto.getValueQuery = function getValueQuery(query) {
    var result = this._temporal.query(query);
    if (result == null && this._optional === 0) {
      throw new DateTimeException("Unable to extract value: " + this._temporal);
    }
    return result;
  };
  _proto.getValue = function getValue(field) {
    try {
      return this._temporal.getLong(field);
    } catch (ex) {
      if (ex instanceof DateTimeException && this._optional > 0) {
        return null;
      }
      throw ex;
    }
  };
  _proto.temporal = function temporal() {
    return this._temporal;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setDateTime = function setDateTime(temporal) {
    this._temporal = temporal;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  return DateTimePrintContext;
}();

var IsoFields = {};
var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
var Field = function (_TemporalField) {
  _inheritsLoose(Field, _TemporalField);
  function Field() {
    return _TemporalField.apply(this, arguments) || this;
  }
  var _proto = Field.prototype;
  _proto.isDateBased = function isDateBased() {
    return true;
  };
  _proto.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto._isIso = function _isIso() {
    return true;
  };
  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
    var wby = Field._getWeekBasedYear(date);
    return ValueRange.of(1, Field._getWeekRangeByYear(wby));
  };
  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
    var date = LocalDate.of(wby, 1, 1);
    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
      return 53;
    }
    return 52;
  };
  Field._getWeek = function _getWeek(date) {
    var dow0 = date.dayOfWeek().ordinal();
    var doy0 = date.dayOfYear() - 1;
    var doyThu0 = doy0 + (3 - dow0);
    var alignedWeek = MathUtil.intDiv(doyThu0, 7);
    var firstThuDoy0 = doyThu0 - alignedWeek * 7;
    var firstMonDoy0 = firstThuDoy0 - 3;
    if (firstMonDoy0 < -3) {
      firstMonDoy0 += 7;
    }
    if (doy0 < firstMonDoy0) {
      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
    }
    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
    if (week === 53) {
      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
        week = 1;
      }
    }
    return week;
  };
  Field._getWeekBasedYear = function _getWeekBasedYear(date) {
    var year = date.year();
    var doy = date.dayOfYear();
    if (doy <= 3) {
      var dow = date.dayOfWeek().ordinal();
      if (doy - dow < -2) {
        year--;
      }
    } else if (doy >= 363) {
      var _dow = date.dayOfWeek().ordinal();
      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
      if (doy - _dow >= 0) {
        year++;
      }
    }
    return year;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.resolve = function resolve() {
    return null;
  };
  _proto.name = function name() {
    return this.toString();
  };
  return Field;
}(TemporalField);
var DAY_OF_QUARTER_FIELD = function (_Field) {
  _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);
  function DAY_OF_QUARTER_FIELD() {
    return _Field.apply(this, arguments) || this;
  }
  var _proto2 = DAY_OF_QUARTER_FIELD.prototype;
  _proto2.toString = function toString() {
    return 'DayOfQuarter';
  };
  _proto2.baseUnit = function baseUnit() {
    return ChronoUnit.DAYS;
  };
  _proto2.rangeUnit = function rangeUnit() {
    return QUARTER_YEARS;
  };
  _proto2.range = function range() {
    return ValueRange.of(1, 90, 92);
  };
  _proto2.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
  };
  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }
    var qoy = temporal.getLong(QUARTER_OF_YEAR);
    if (qoy === 1) {
      var year = temporal.getLong(ChronoField.YEAR);
      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
    } else if (qoy === 2) {
      return ValueRange.of(1, 91);
    } else if (qoy === 3 || qoy === 4) {
      return ValueRange.of(1, 92);
    }
    return this.range();
  };
  _proto2.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }
    var doy = temporal.get(ChronoField.DAY_OF_YEAR);
    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
    var year = temporal.getLong(ChronoField.YEAR);
    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
  };
  _proto2.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
  };
  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var yearLong = fieldValues.get(ChronoField.YEAR);
    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
    if (yearLong == null || qoyLong == null) {
      return null;
    }
    var y = ChronoField.YEAR.checkValidIntValue(yearLong);
    var doq = fieldValues.get(DAY_OF_QUARTER);
    var date;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var qoy = qoyLong;
      date = LocalDate.of(y, 1, 1);
      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
      date = date.plusDays(MathUtil.safeSubtract(doq, 1));
    } else {
      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
      if (resolverStyle === ResolverStyle.STRICT) {
        var max = 92;
        if (_qoy === 1) {
          max = IsoChronology.isLeapYear(y) ? 91 : 90;
        } else if (_qoy === 2) {
          max = 91;
        }
        ValueRange.of(1, max).checkValidValue(doq, this);
      } else {
        this.range().checkValidValue(doq, this);
      }
      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
    }
    fieldValues.remove(this);
    fieldValues.remove(ChronoField.YEAR);
    fieldValues.remove(QUARTER_OF_YEAR);
    return date;
  };
  return DAY_OF_QUARTER_FIELD;
}(Field);
var QUARTER_OF_YEAR_FIELD = function (_Field2) {
  _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);
  function QUARTER_OF_YEAR_FIELD() {
    return _Field2.apply(this, arguments) || this;
  }
  var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;
  _proto3.toString = function toString() {
    return 'QuarterOfYear';
  };
  _proto3.baseUnit = function baseUnit() {
    return QUARTER_YEARS;
  };
  _proto3.rangeUnit = function rangeUnit() {
    return ChronoUnit.YEARS;
  };
  _proto3.range = function range() {
    return ValueRange.of(1, 4);
  };
  _proto3.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
  };
  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return this.range();
  };
  _proto3.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');
    }
    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
    return MathUtil.intDiv(moy + 2, 3);
  };
  _proto3.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
  };
  return QUARTER_OF_YEAR_FIELD;
}(Field);
var WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {
  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);
  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {
    return _Field3.apply(this, arguments) || this;
  }
  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;
  _proto4.toString = function toString() {
    return 'WeekOfWeekBasedYear';
  };
  _proto4.baseUnit = function baseUnit() {
    return ChronoUnit.WEEKS;
  };
  _proto4.rangeUnit = function rangeUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto4.range = function range() {
    return ValueRange.of(1, 52, 53);
  };
  _proto4.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }
    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
  };
  _proto4.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }
    return Field._getWeek(LocalDate.from(temporal));
  };
  _proto4.adjustInto = function adjustInto(temporal, newValue) {
    this.range().checkValidValue(newValue, this);
    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
  };
  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
    if (wbyLong == null || dowLong == null) {
      return null;
    }
    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
    var date;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var dow = dowLong;
      var weeks = 0;
      if (dow > 7) {
        weeks = MathUtil.intDiv(dow - 1, 7);
        dow = MathUtil.intMod(dow - 1, 7) + 1;
      } else if (dow < 1) {
        weeks = MathUtil.intDiv(dow, 7) - 1;
        dow = MathUtil.intMod(dow, 7) + 7;
      }
      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
    } else {
      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
      if (resolverStyle === ResolverStyle.STRICT) {
        var temp = LocalDate.of(wby, 1, 4);
        var range = Field._getWeekRangeByLocalDate(temp);
        range.checkValidValue(wowby, this);
      } else {
        this.range().checkValidValue(wowby, this);
      }
      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
    }
    fieldValues.remove(this);
    fieldValues.remove(WEEK_BASED_YEAR);
    fieldValues.remove(ChronoField.DAY_OF_WEEK);
    return date;
  };
  _proto4.displayName = function displayName() {
    return 'Week';
  };
  return WEEK_OF_WEEK_BASED_YEAR_FIELD;
}(Field);
var WEEK_BASED_YEAR_FIELD = function (_Field4) {
  _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);
  function WEEK_BASED_YEAR_FIELD() {
    return _Field4.apply(this, arguments) || this;
  }
  var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;
  _proto5.toString = function toString() {
    return 'WeekBasedYear';
  };
  _proto5.baseUnit = function baseUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto5.rangeUnit = function rangeUnit() {
    return ChronoUnit.FOREVER;
  };
  _proto5.range = function range() {
    return ChronoField.YEAR.range();
  };
  _proto5.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return ChronoField.YEAR.range();
  };
  _proto5.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }
    return Field._getWeekBasedYear(LocalDate.from(temporal));
  };
  _proto5.adjustInto = function adjustInto(temporal, newValue) {
    if (this.isSupportedBy(temporal) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }
    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
    var date = LocalDate.from(temporal);
    var dow = date.get(ChronoField.DAY_OF_WEEK);
    var week = Field._getWeek(date);
    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
      week = 52;
    }
    var resolved = LocalDate.of(newWby, 1, 4);
    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
    resolved = resolved.plusDays(days);
    return temporal.with(resolved);
  };
  return WEEK_BASED_YEAR_FIELD;
}(Field);
var Unit = function (_TemporalUnit) {
  _inheritsLoose(Unit, _TemporalUnit);
  function Unit(name, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto6 = Unit.prototype;
  _proto6.duration = function duration() {
    return this._duration;
  };
  _proto6.isDurationEstimated = function isDurationEstimated() {
    return true;
  };
  _proto6.isDateBased = function isDateBased() {
    return true;
  };
  _proto6.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto6.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY);
  };
  _proto6.addTo = function addTo(temporal, periodToAdd) {
    switch (this) {
      case WEEK_BASED_YEARS:
        {
          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
          return temporal.with(WEEK_BASED_YEAR, added);
        }
      case QUARTER_YEARS:
        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
      default:
        throw new IllegalStateException('Unreachable');
    }
  };
  _proto6.between = function between(temporal1, temporal2) {
    switch (this) {
      case WEEK_BASED_YEARS:
        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
      case QUARTER_YEARS:
        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
      default:
        throw new IllegalStateException('Unreachable');
    }
  };
  _proto6.toString = function toString() {
    return this._name;
  };
  return Unit;
}(TemporalUnit);
var DAY_OF_QUARTER = null;
var QUARTER_OF_YEAR = null;
var WEEK_OF_WEEK_BASED_YEAR = null;
var WEEK_BASED_YEAR = null;
var WEEK_BASED_YEARS = null;
var QUARTER_YEARS = null;
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function () {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function () {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var DecimalStyle = function () {
  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
    this._zeroDigit = zeroChar;
    this._zeroDigitCharCode = zeroChar.charCodeAt(0);
    this._positiveSign = positiveSignChar;
    this._negativeSign = negativeSignChar;
    this._decimalSeparator = decimalPointChar;
  }
  var _proto = DecimalStyle.prototype;
  _proto.positiveSign = function positiveSign() {
    return this._positiveSign;
  };
  _proto.withPositiveSign = function withPositiveSign(positiveSign) {
    if (positiveSign === this._positiveSign) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.negativeSign = function negativeSign() {
    return this._negativeSign;
  };
  _proto.withNegativeSign = function withNegativeSign(negativeSign) {
    if (negativeSign === this._negativeSign) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
  };
  _proto.zeroDigit = function zeroDigit() {
    return this._zeroDigit;
  };
  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
    if (zeroDigit === this._zeroDigit) {
      return this;
    }
    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.decimalSeparator = function decimalSeparator() {
    return this._decimalSeparator;
  };
  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
    if (decimalSeparator === this._decimalSeparator) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
  };
  _proto.convertToDigit = function convertToDigit(char) {
    var val = char.charCodeAt(0) - this._zeroDigitCharCode;
    return val >= 0 && val <= 9 ? val : -1;
  };
  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
    if (this._zeroDigit === '0') {
      return numericText;
    }
    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);
    var convertedText = '';
    for (var i = 0; i < numericText.length; i++) {
      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
    }
    return convertedText;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof DecimalStyle) {
      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
  };
  _proto.toString = function toString() {
    return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
  };
  DecimalStyle.of = function of() {
    throw new Error('not yet supported');
  };
  DecimalStyle.availableLocales = function availableLocales() {
    throw new Error('not yet supported');
  };
  return DecimalStyle;
}();
DecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');

var SignStyle = function (_Enum) {
  _inheritsLoose(SignStyle, _Enum);
  function SignStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SignStyle.prototype;
  _proto.parse = function parse(positive, strict, fixedWidth) {
    switch (this) {
      case SignStyle.NORMAL:
        return !positive || !strict;
      case SignStyle.ALWAYS:
      case SignStyle.EXCEEDS_PAD:
        return true;
      default:
        return !strict && !fixedWidth;
    }
  };
  return SignStyle;
}(Enum);
SignStyle.NORMAL = new SignStyle('NORMAL');
SignStyle.NEVER = new SignStyle('NEVER');
SignStyle.ALWAYS = new SignStyle('ALWAYS');
SignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');
SignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');

var TextStyle = function (_Enum) {
  _inheritsLoose(TextStyle, _Enum);
  function TextStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TextStyle.prototype;
  _proto.isStandalone = function isStandalone() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
      case TextStyle.SHORT_STANDALONE:
      case TextStyle.NARROW_STANDALONE:
        return true;
      default:
        return false;
    }
  };
  _proto.asStandalone = function asStandalone() {
    switch (this) {
      case TextStyle.FULL:
        return TextStyle.FULL_STANDALONE;
      case TextStyle.SHORT:
        return TextStyle.SHORT_STANDALONE;
      case TextStyle.NARROW:
        return TextStyle.NARROW_STANDALONE;
      default:
        return this;
    }
  };
  _proto.asNormal = function asNormal() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
        return TextStyle.FULL;
      case TextStyle.SHORT_STANDALONE:
        return TextStyle.SHORT;
      case TextStyle.NARROW_STANDALONE:
        return TextStyle.NARROW;
      default:
        return this;
    }
  };
  return TextStyle;
}(Enum);
TextStyle.FULL = new TextStyle('FULL');
TextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');
TextStyle.SHORT = new TextStyle('SHORT');
TextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');
TextStyle.NARROW = new TextStyle('NARROW');
TextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var CharLiteralPrinterParser = function () {
  function CharLiteralPrinterParser(literal) {
    if (literal.length > 1) {
      throw new IllegalArgumentException("invalid literal, too long: \"" + literal + "\"");
    }
    this._literal = literal;
  }
  var _proto = CharLiteralPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position === length) {
      return ~position;
    }
    var ch = text.charAt(position);
    if (context.charEquals(this._literal, ch) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString() {
    if (this._literal === '\'') {
      return "''";
    }
    return "'" + this._literal + "'";
  };
  return CharLiteralPrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var CompositePrinterParser = function () {
  function CompositePrinterParser(printerParsers, optional) {
    this._printerParsers = printerParsers;
    this._optional = optional;
  }
  var _proto = CompositePrinterParser.prototype;
  _proto.withOptional = function withOptional(optional) {
    if (optional === this._optional) {
      return this;
    }
    return new CompositePrinterParser(this._printerParsers, optional);
  };
  _proto.print = function print(context, buf) {
    var length = buf.length();
    if (this._optional) {
      context.startOptional();
    }
    try {
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        if (pp.print(context, buf) === false) {
          buf.setLength(length);
          return true;
        }
      }
    } finally {
      if (this._optional) {
        context.endOptional();
      }
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    if (this._optional) {
      context.startOptional();
      var pos = position;
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        pos = pp.parse(context, text, pos);
        if (pos < 0) {
          context.endOptional(false);
          return position;
        }
      }
      context.endOptional(true);
      return pos;
    } else {
      for (var _i = 0; _i < this._printerParsers.length; _i++) {
        var _pp = this._printerParsers[_i];
        position = _pp.parse(context, text, position);
        if (position < 0) {
          break;
        }
      }
      return position;
    }
  };
  _proto.toString = function toString() {
    var buf = '';
    if (this._printerParsers != null) {
      buf += this._optional ? '[' : '(';
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        buf += pp.toString();
      }
      buf += this._optional ? ']' : ')';
    }
    return buf;
  };
  return CompositePrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var FractionPrinterParser = function () {
  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {
    requireNonNull(field, 'field');
    if (field.range().isFixed() === false) {
      throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
    }
    if (minWidth < 0 || minWidth > 9) {
      throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > 9) {
      throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    this.field = field;
    this.minWidth = minWidth;
    this.maxWidth = maxWidth;
    this.decimalPoint = decimalPoint;
  }
  var _proto = FractionPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    var value = context.getValue(this.field);
    if (value === null) {
      return false;
    }
    var symbols = context.symbols();
    if (value === 0) {
      if (this.minWidth > 0) {
        if (this.decimalPoint) {
          buf.append(symbols.decimalSeparator());
        }
        for (var i = 0; i < this.minWidth; i++) {
          buf.append(symbols.zeroDigit());
        }
      }
    } else {
      var fraction = this.convertToFraction(value, symbols.zeroDigit());
      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
      fraction = fraction.substr(0, outputScale);
      if (fraction * 1 > 0) {
        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {
          fraction = fraction.substr(0, fraction.length - 1);
        }
      }
      var str = fraction;
      str = symbols.convertNumberToI18N(str);
      if (this.decimalPoint) {
        buf.append(symbols.decimalSeparator());
      }
      buf.append(str);
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var effectiveMin = context.isStrict() ? this.minWidth : 0;
    var effectiveMax = context.isStrict() ? this.maxWidth : 9;
    var length = text.length;
    if (position === length) {
      return effectiveMin > 0 ? ~position : position;
    }
    if (this.decimalPoint) {
      if (text[position] !== context.symbols().decimalSeparator()) {
        return effectiveMin > 0 ? ~position : position;
      }
      position++;
    }
    var minEndPos = position + effectiveMin;
    if (minEndPos > length) {
      return ~position;
    }
    var maxEndPos = Math.min(position + effectiveMax, length);
    var total = 0;
    var pos = position;
    while (pos < maxEndPos) {
      var ch = text.charAt(pos++);
      var digit = context.symbols().convertToDigit(ch);
      if (digit < 0) {
        if (pos < minEndPos) {
          return ~position;
        }
        pos--;
        break;
      }
      total = total * 10 + digit;
    }
    var moveLeft = pos - position;
    var scale = Math.pow(10, moveLeft);
    var value = this.convertFromFraction(total, scale);
    return context.setParsedField(this.field, value, position, pos);
  };
  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
    var range = this.field.range();
    range.checkValidValue(value, this.field);
    var _min = range.minimum();
    var _range = range.maximum() - _min + 1;
    var _value = value - _min;
    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);
    var fraction = "" + _scaled;
    while (fraction.length < 9) {
      fraction = zeroDigit + fraction;
    }
    return fraction;
  };
  _proto.convertFromFraction = function convertFromFraction(total, scale) {
    var range = this.field.range();
    var _min = range.minimum();
    var _range = range.maximum() - _min + 1;
    var _value = MathUtil.intDiv(total * _range, scale);
    return _value;
  };
  _proto.toString = function toString() {
    var decimal = this.decimalPoint ? ',DecimalPoint' : '';
    return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
  };
  return FractionPrinterParser;
}();

var MAX_WIDTH$1 = 15;
var EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
var NumberPrinterParser = function () {
  function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {
    if (subsequentWidth === void 0) {
      subsequentWidth = 0;
    }
    this._field = field;
    this._minWidth = minWidth;
    this._maxWidth = maxWidth;
    this._signStyle = signStyle;
    this._subsequentWidth = subsequentWidth;
  }
  var _proto = NumberPrinterParser.prototype;
  _proto.field = function field() {
    return this._field;
  };
  _proto.minWidth = function minWidth() {
    return this._minWidth;
  };
  _proto.maxWidth = function maxWidth() {
    return this._maxWidth;
  };
  _proto.signStyle = function signStyle() {
    return this._signStyle;
  };
  _proto.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
  };
  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
  };
  _proto._isFixedWidth = function _isFixedWidth() {
    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
  };
  _proto.print = function print(context, buf) {
    var contextValue = context.getValue(this._field);
    if (contextValue == null) {
      return false;
    }
    var value = this._getValue(context, contextValue);
    var symbols = context.symbols();
    var str = "" + Math.abs(value);
    if (str.length > this._maxWidth) {
      throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
    }
    str = symbols.convertNumberToI18N(str);
    if (value >= 0) {
      switch (this._signStyle) {
        case SignStyle.EXCEEDS_PAD:
          if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
            buf.append(symbols.positiveSign());
          }
          break;
        case SignStyle.ALWAYS:
          buf.append(symbols.positiveSign());
          break;
      }
    } else {
      switch (this._signStyle) {
        case SignStyle.NORMAL:
        case SignStyle.EXCEEDS_PAD:
        case SignStyle.ALWAYS:
          buf.append(symbols.negativeSign());
          break;
        case SignStyle.NOT_NEGATIVE:
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
      }
    }
    for (var i = 0; i < this._minWidth - str.length; i++) {
      buf.append(symbols.zeroDigit());
    }
    buf.append(str);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position === length) {
      return ~position;
    }
    assert(position >= 0 && position < length);
    var sign = text.charAt(position);
    var negative = false;
    var positive = false;
    if (sign === context.symbols().positiveSign()) {
      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      positive = true;
      position++;
    } else if (sign === context.symbols().negativeSign()) {
      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      negative = true;
      position++;
    } else {
      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
        return ~position;
      }
    }
    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
    var minEndPos = position + effMinWidth;
    if (minEndPos > length) {
      return ~position;
    }
    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
    var total = 0;
    var pos = position;
    for (var pass = 0; pass < 2; pass++) {
      var maxEndPos = Math.min(pos + effMaxWidth, length);
      while (pos < maxEndPos) {
        var ch = text.charAt(pos++);
        var digit = context.symbols().convertToDigit(ch);
        if (digit < 0) {
          pos--;
          if (pos < minEndPos) {
            return ~position;
          }
          break;
        }
        if (pos - position > MAX_WIDTH$1) {
          throw new ArithmeticException('number text exceeds length');
        } else {
          total = total * 10 + digit;
        }
      }
      if (this._subsequentWidth > 0 && pass === 0) {
        var parseLen = pos - position;
        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
        pos = position;
        total = 0;
      } else {
        break;
      }
    }
    if (negative) {
      if (total === 0 && context.isStrict()) {
        return ~(position - 1);
      }
      if (total !== 0) {
        total = -total;
      }
    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
      var _parseLen = pos - position;
      if (positive) {
        if (_parseLen <= this._minWidth) {
          return ~(position - 1);
        }
      } else {
        if (_parseLen > this._minWidth) {
          return ~position;
        }
      }
    }
    return this._setValue(context, total, position, pos);
  };
  _proto._getValue = function _getValue(context, value) {
    return value;
  };
  _proto._setValue = function _setValue(context, value, errorPos, successPos) {
    return context.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto.toString = function toString() {
    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
      return "Value(" + this._field + ")";
    }
    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
      return "Value(" + this._field + "," + this._minWidth + ")";
    }
    return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
  };
  return NumberPrinterParser;
}();
var ReducedPrinterParser = function (_NumberPrinterParser) {
  _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);
  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {
    var _this;
    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
    if (width < 1 || width > 10) {
      throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
    }
    if (maxWidth < 1 || maxWidth > 10) {
      throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
    }
    if (maxWidth < width) {
      throw new IllegalArgumentException('The maxWidth must be greater than the width');
    }
    if (baseDate === null) {
      if (field.range().isValidValue(baseValue) === false) {
        throw new IllegalArgumentException('The base value must be within the range of the field');
      }
      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');
      }
    }
    _this._baseValue = baseValue;
    _this._baseDate = baseDate;
    return _this;
  }
  var _proto2 = ReducedPrinterParser.prototype;
  _proto2._getValue = function _getValue(context, value) {
    var absValue = Math.abs(value);
    var baseValue = this._baseValue;
    if (this._baseDate !== null) {
      context.temporal();
      var chrono = IsoChronology.INSTANCE;
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
      return absValue % EXCEED_POINTS[this._minWidth];
    }
    return absValue % EXCEED_POINTS[this._maxWidth];
  };
  _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
    var baseValue = this._baseValue;
    if (this._baseDate != null) {
      var chrono = context.getEffectiveChronology();
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    var parseLen = successPos - errorPos;
    if (parseLen === this._minWidth && value >= 0) {
      var range = EXCEED_POINTS[this._minWidth];
      var lastPart = baseValue % range;
      var basePart = baseValue - lastPart;
      if (baseValue > 0) {
        value = basePart + value;
      } else {
        value = basePart - value;
      }
      if (value < baseValue) {
        value += range;
      }
    }
    return context.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto2.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
  };
  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
  };
  _proto2.isFixedWidth = function isFixedWidth(context) {
    if (context.isStrict() === false) {
      return false;
    }
    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
  };
  _proto2.toString = function toString() {
    return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
  };
  return ReducedPrinterParser;
}(NumberPrinterParser);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];
var OffsetIdPrinterParser = function () {
  function OffsetIdPrinterParser(noOffsetText, pattern) {
    requireNonNull(noOffsetText, 'noOffsetText');
    requireNonNull(pattern, 'pattern');
    this.noOffsetText = noOffsetText;
    this.type = this._checkPattern(pattern);
  }
  var _proto = OffsetIdPrinterParser.prototype;
  _proto._checkPattern = function _checkPattern(pattern) {
    for (var i = 0; i < PATTERNS.length; i++) {
      if (PATTERNS[i] === pattern) {
        return i;
      }
    }
    throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
  };
  _proto.print = function print(context, buf) {
    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
    if (offsetSecs == null) {
      return false;
    }
    var totalSecs = MathUtil.safeToInt(offsetSecs);
    if (totalSecs === 0) {
      buf.append(this.noOffsetText);
    } else {
      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
      var bufPos = buf.length();
      var output = absHours;
      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
        output += absMinutes;
        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
          output += absSeconds;
        }
      }
      if (output === 0) {
        buf.setLength(bufPos);
        buf.append(this.noOffsetText);
      }
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    var noOffsetLen = this.noOffsetText.length;
    if (noOffsetLen === 0) {
      if (position === length) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
      }
    } else {
      if (position === length) {
        return ~position;
      }
      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
      }
    }
    var sign = text[position];
    if (sign === '+' || sign === '-') {
      var negative = sign === '-' ? -1 : 1;
      var array = [0, 0, 0, 0];
      array[0] = position + 1;
      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
      }
    }
    if (noOffsetLen === 0) {
      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
    }
    return ~position;
  };
  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
    if ((this.type + 3) / 2 < arrayIndex) {
      return false;
    }
    var pos = array[0];
    if (this.type % 2 === 0 && arrayIndex > 1) {
      if (pos + 1 > parseText.length || parseText[pos] !== ':') {
        return required;
      }
      pos++;
    }
    if (pos + 2 > parseText.length) {
      return required;
    }
    var ch1 = parseText[pos++];
    var ch2 = parseText[pos++];
    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      return required;
    }
    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
    if (value < 0 || value > 59) {
      return required;
    }
    array[arrayIndex] = value;
    array[0] = pos;
    return false;
  };
  _proto.toString = function toString() {
    var converted = this.noOffsetText.replace('\'', '\'\'');
    return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
  };
  return OffsetIdPrinterParser;
}();
OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');
OffsetIdPrinterParser.PATTERNS = PATTERNS;

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PadPrinterParserDecorator = function () {
  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {
    this._printerParser = printerParser;
    this._padWidth = padWidth;
    this._padChar = padChar;
  }
  var _proto = PadPrinterParserDecorator.prototype;
  _proto.print = function print(context, buf) {
    var preLen = buf.length();
    if (this._printerParser.print(context, buf) === false) {
      return false;
    }
    var len = buf.length() - preLen;
    if (len > this._padWidth) {
      throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
    }
    for (var i = 0; i < this._padWidth - len; i++) {
      buf.insert(preLen, this._padChar);
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var strict = context.isStrict();
    var caseSensitive = context.isCaseSensitive();
    assert(!(position > text.length));
    assert(position >= 0);
    if (position === text.length) {
      return ~position;
    }
    var endPos = position + this._padWidth;
    if (endPos > text.length) {
      if (strict) {
        return ~position;
      }
      endPos = text.length;
    }
    var pos = position;
    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
      pos++;
    }
    text = text.substring(0, endPos);
    var resultPos = this._printerParser.parse(context, text, pos);
    if (resultPos !== endPos && strict) {
      return ~(position + pos);
    }
    return resultPos;
  };
  _proto.toString = function toString() {
    return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === ' ' ? ')' : ",'" + this._padChar + "')");
  };
  return PadPrinterParserDecorator;
}();

var SettingsParser = function (_Enum) {
  _inheritsLoose(SettingsParser, _Enum);
  function SettingsParser() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SettingsParser.prototype;
  _proto.print = function print() {
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    switch (this) {
      case SettingsParser.SENSITIVE:
        context.setCaseSensitive(true);
        break;
      case SettingsParser.INSENSITIVE:
        context.setCaseSensitive(false);
        break;
      case SettingsParser.STRICT:
        context.setStrict(true);
        break;
      case SettingsParser.LENIENT:
        context.setStrict(false);
        break;
    }
    return position;
  };
  _proto.toString = function toString() {
    switch (this) {
      case SettingsParser.SENSITIVE:
        return 'ParseCaseSensitive(true)';
      case SettingsParser.INSENSITIVE:
        return 'ParseCaseSensitive(false)';
      case SettingsParser.STRICT:
        return 'ParseStrict(true)';
      case SettingsParser.LENIENT:
        return 'ParseStrict(false)';
    }
  };
  return SettingsParser;
}(Enum);
SettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');
SettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');
SettingsParser.STRICT = new SettingsParser('STRICT');
SettingsParser.LENIENT = new SettingsParser('LENIENT');

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringLiteralPrinterParser = function () {
  function StringLiteralPrinterParser(literal) {
    this._literal = literal;
  }
  var _proto = StringLiteralPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    assert(!(position > length || position < 0));
    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString() {
    var converted = this._literal.replace("'", "''");
    return "'" + converted + "'";
  };
  return StringLiteralPrinterParser;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneRulesProvider = function () {
  function ZoneRulesProvider() {}
  ZoneRulesProvider.getRules = function getRules(zoneId) {
    throw new DateTimeException("unsupported ZoneId:" + zoneId);
  };
  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {
    return [];
  };
  return ZoneRulesProvider;
}();

var ZoneRegion = function (_ZoneId) {
  _inheritsLoose(ZoneRegion, _ZoneId);
  ZoneRegion.ofId = function ofId(zoneId) {
    var rules = ZoneRulesProvider.getRules(zoneId);
    return new ZoneRegion(zoneId, rules);
  };
  function ZoneRegion(id, rules) {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._id = id;
    _this._rules = rules;
    return _this;
  }
  var _proto = ZoneRegion.prototype;
  _proto.id = function id() {
    return this._id;
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  return ZoneRegion;
}(ZoneId);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdPrinterParser = function () {
  function ZoneIdPrinterParser(query, description) {
    this.query = query;
    this.description = description;
  }
  var _proto = ZoneIdPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    var zone = context.getValueQuery(this.query);
    if (zone == null) {
      return false;
    }
    buf.append(zone.id());
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position > length) {
      return ~position;
    }
    if (position === length) {
      return ~position;
    }
    var nextChar = text.charAt(position);
    if (nextChar === '+' || nextChar === '-') {
      var newContext = context.copy();
      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
      if (endPos < 0) {
        return endPos;
      }
      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
      var zone = ZoneOffset.ofTotalSeconds(offset);
      context.setParsedZone(zone);
      return endPos;
    } else if (length >= position + 2) {
      var nextNextChar = text.charAt(position + 1);
      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {
        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {
          return this._parsePrefixedOffset(context, text, position, position + 3);
        }
        return this._parsePrefixedOffset(context, text, position, position + 2);
      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {
        return this._parsePrefixedOffset(context, text, position, position + 3);
      }
    }
    if (text.substr(position, 6) === 'SYSTEM') {
      context.setParsedZone(ZoneId.systemDefault());
      return position + 6;
    }
    if (context.charEquals(nextChar, 'Z')) {
      context.setParsedZone(ZoneOffset.UTC);
      return position + 1;
    }
    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
    if (zoneIdTree.size !== availableZoneIds.length) {
      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
    }
    var maxParseLength = length - position;
    var treeMap = zoneIdTree.treeMap;
    var parsedZoneId = null;
    var parseLength = 0;
    while (treeMap != null) {
      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
      treeMap = treeMap.get(parsedSubZoneId);
      if (treeMap != null && treeMap.isLeaf) {
        parsedZoneId = parsedSubZoneId;
        parseLength = treeMap.length;
      }
    }
    if (parsedZoneId != null) {
      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
      return position + parseLength;
    }
    return ~position;
  };
  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
    var prefix = text.substring(prefixPos, position).toUpperCase();
    var newContext = context.copy();
    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
    if (endPos < 0) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
    context.setParsedZone(ZoneId.ofOffset(prefix, offset));
    return endPos;
  };
  _proto.toString = function toString() {
    return this.description;
  };
  return ZoneIdPrinterParser;
}();
var ZoneIdTree = function () {
  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {
    var sortedZoneIds = availableZoneIds.sort(function (a, b) {
      return a.length - b.length;
    });
    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
    for (var i = 0; i < sortedZoneIds.length; i++) {
      treeMap.add(sortedZoneIds[i]);
    }
    return new ZoneIdTree(sortedZoneIds.length, treeMap);
  };
  function ZoneIdTree(size, treeMap) {
    this.size = size;
    this.treeMap = treeMap;
  }
  return ZoneIdTree;
}();
var ZoneIdTreeMap = function () {
  function ZoneIdTreeMap(length, isLeaf) {
    if (length === void 0) {
      length = 0;
    }
    if (isLeaf === void 0) {
      isLeaf = false;
    }
    this.length = length;
    this.isLeaf = isLeaf;
    this._treeMap = {};
  }
  var _proto2 = ZoneIdTreeMap.prototype;
  _proto2.add = function add(zoneId) {
    var idLength = zoneId.length;
    if (idLength === this.length) {
      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);
    } else if (idLength > this.length) {
      var subZoneId = zoneId.substr(0, this.length);
      var subTreeMap = this._treeMap[subZoneId];
      if (subTreeMap == null) {
        subTreeMap = new ZoneIdTreeMap(idLength, false);
        this._treeMap[subZoneId] = subTreeMap;
      }
      subTreeMap.add(zoneId);
    }
  };
  _proto2.get = function get(zoneId) {
    return this._treeMap[zoneId];
  };
  return ZoneIdTreeMap;
}();
var zoneIdTree = new ZoneIdTree([]);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_WIDTH = 15;
var DateTimeFormatterBuilder = function () {
  function DateTimeFormatterBuilder() {
    this._active = this;
    this._parent = null;
    this._printerParsers = [];
    this._optional = false;
    this._padNextWidth = 0;
    this._padNextChar = null;
    this._valueParserIndex = -1;
  }
  DateTimeFormatterBuilder._of = function _of(parent, optional) {
    requireNonNull(parent, 'parent');
    requireNonNull(optional, 'optional');
    var dtFormatterBuilder = new DateTimeFormatterBuilder();
    dtFormatterBuilder._parent = parent;
    dtFormatterBuilder._optional = optional;
    return dtFormatterBuilder;
  };
  var _proto = DateTimeFormatterBuilder.prototype;
  _proto.parseCaseSensitive = function parseCaseSensitive() {
    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
    return this;
  };
  _proto.parseCaseInsensitive = function parseCaseInsensitive() {
    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
    return this;
  };
  _proto.parseStrict = function parseStrict() {
    this._appendInternalPrinterParser(SettingsParser.STRICT);
    return this;
  };
  _proto.parseLenient = function parseLenient() {
    this._appendInternalPrinterParser(SettingsParser.LENIENT);
    return this;
  };
  _proto.parseDefaulting = function parseDefaulting(field, value) {
    requireNonNull(field);
    this._appendInternal(new DefaultingParser(field, value));
    return this;
  };
  _proto.appendValue = function appendValue() {
    if (arguments.length === 1) {
      return this._appendValue1.apply(this, arguments);
    } else if (arguments.length === 2) {
      return this._appendValue2.apply(this, arguments);
    } else {
      return this._appendValue4.apply(this, arguments);
    }
  };
  _proto._appendValue1 = function _appendValue1(field) {
    requireNonNull(field);
    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
    return this;
  };
  _proto._appendValue2 = function _appendValue2(field, width) {
    requireNonNull(field);
    if (width < 1 || width > MAX_WIDTH) {
      throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
    }
    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
    requireNonNull(field);
    requireNonNull(signStyle);
    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
      return this._appendValue2(field, maxWidth);
    }
    if (minWidth < 1 || minWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto.appendValueReduced = function appendValueReduced() {
    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
    } else {
      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
    }
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
    requireNonNull(field, 'field');
    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
    requireNonNull(field, 'field');
    requireNonNull(baseDate, 'baseDate');
    requireInstance(baseDate, ChronoLocalDate, 'baseDate');
    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
    assert(pp != null);
    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
      var activeValueParser = this._active._valueParserIndex;
      var basePP = this._active._printerParsers[activeValueParser];
      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
        basePP = basePP.withSubsequentWidth(pp.maxWidth());
        this._appendInternal(pp.withFixedWidth());
        this._active._valueParserIndex = activeValueParser;
      } else {
        basePP = basePP.withFixedWidth();
        this._active._valueParserIndex = this._appendInternal(pp);
      }
      this._active._printerParsers[activeValueParser] = basePP;
    } else {
      this._active._valueParserIndex = this._appendInternal(pp);
    }
    return this;
  };
  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
    return this;
  };
  _proto.appendInstant = function appendInstant(fractionalDigits) {
    if (fractionalDigits === void 0) {
      fractionalDigits = -2;
    }
    if (fractionalDigits < -2 || fractionalDigits > 9) {
      throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
    }
    this._appendInternal(new InstantPrinterParser(fractionalDigits));
    return this;
  };
  _proto.appendOffsetId = function appendOffsetId() {
    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
    return this;
  };
  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
    return this;
  };
  _proto.appendZoneId = function appendZoneId() {
    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));
    return this;
  };
  _proto.appendPattern = function appendPattern(pattern) {
    requireNonNull(pattern, 'pattern');
    this._parsePattern(pattern);
    return this;
  };
  _proto.appendZoneText = function appendZoneText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendText = function appendText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendLocalizedOffset = function appendLocalizedOffset() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendWeekField = function appendWeekField() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto._parsePattern = function _parsePattern(pattern) {
    var FIELD_MAP = {
      'G': ChronoField.ERA,
      'y': ChronoField.YEAR_OF_ERA,
      'u': ChronoField.YEAR,
      'Q': IsoFields.QUARTER_OF_YEAR,
      'q': IsoFields.QUARTER_OF_YEAR,
      'M': ChronoField.MONTH_OF_YEAR,
      'L': ChronoField.MONTH_OF_YEAR,
      'D': ChronoField.DAY_OF_YEAR,
      'd': ChronoField.DAY_OF_MONTH,
      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
      'E': ChronoField.DAY_OF_WEEK,
      'c': ChronoField.DAY_OF_WEEK,
      'e': ChronoField.DAY_OF_WEEK,
      'a': ChronoField.AMPM_OF_DAY,
      'H': ChronoField.HOUR_OF_DAY,
      'k': ChronoField.CLOCK_HOUR_OF_DAY,
      'K': ChronoField.HOUR_OF_AMPM,
      'h': ChronoField.CLOCK_HOUR_OF_AMPM,
      'm': ChronoField.MINUTE_OF_HOUR,
      's': ChronoField.SECOND_OF_MINUTE,
      'S': ChronoField.NANO_OF_SECOND,
      'A': ChronoField.MILLI_OF_DAY,
      'n': ChronoField.NANO_OF_SECOND,
      'N': ChronoField.NANO_OF_DAY
    };
    for (var pos = 0; pos < pattern.length; pos++) {
      var cur = pattern.charAt(pos);
      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
        var start = pos++;
        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);
        var count = pos - start;
        if (cur === 'p') {
          var pad = 0;
          if (pos < pattern.length) {
            cur = pattern.charAt(pos);
            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
              pad = count;
              start = pos++;
              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);
              count = pos - start;
            }
          }
          if (pad === 0) {
            throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
          }
          this.padNext(pad);
        }
        var field = FIELD_MAP[cur];
        if (field != null) {
          this._parseField(cur, count, field);
        } else if (cur === 'z') {
          if (count > 4) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          } else if (count === 4) {
            this.appendZoneText(TextStyle.FULL);
          } else {
            this.appendZoneText(TextStyle.SHORT);
          }
        } else if (cur === 'V') {
          if (count !== 2) {
            throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
          }
          this.appendZoneId();
        } else if (cur === 'Z') {
          if (count < 4) {
            this.appendOffset('+HHMM', '+0000');
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else if (count === 5) {
            this.appendOffset('+HH:MM:ss', 'Z');
          } else {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
        } else if (cur === 'O') {
          if (count === 1) {
            this.appendLocalizedOffset(TextStyle.SHORT);
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else {
            throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
          }
        } else if (cur === 'X') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');
        } else if (cur === 'x') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
        } else if (cur === 'W') {
          if (count > 1) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField('W', count);
        } else if (cur === 'w') {
          if (count > 2) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField('w', count);
        } else if (cur === 'Y') {
          this.appendWeekField('Y', count);
        } else {
          throw new IllegalArgumentException("Unknown pattern letter: " + cur);
        }
        pos--;
      } else if (cur === '\'') {
        var _start = pos++;
        for (; pos < pattern.length; pos++) {
          if (pattern.charAt(pos) === '\'') {
            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\'') {
              pos++;
            } else {
              break;
            }
          }
        }
        if (pos >= pattern.length) {
          throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
        }
        var str = pattern.substring(_start + 1, pos);
        if (str.length === 0) {
          this.appendLiteral('\'');
        } else {
          this.appendLiteral(str.replace('\'\'', '\''));
        }
      } else if (cur === '[') {
        this.optionalStart();
      } else if (cur === ']') {
        if (this._active._parent === null) {
          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');
        }
        this.optionalEnd();
      } else if (cur === '{' || cur === '}' || cur === '#') {
        throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
      } else {
        this.appendLiteral(cur);
      }
    }
  };
  _proto._parseField = function _parseField(cur, count, field) {
    switch (cur) {
      case 'u':
      case 'y':
        if (count === 2) {
          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
        } else if (count < 4) {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
        } else {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
        }
        break;
      case 'M':
      case 'Q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'L':
      case 'q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'e':
        switch (count) {
          case 1:
          case 2:
            this.appendWeekField('e', count);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'c':
        switch (count) {
          case 1:
            this.appendWeekField('c', count);
            break;
          case 2:
            throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'a':
        if (count === 1) {
          this.appendText(field, TextStyle.SHORT);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'E':
      case 'G':
        switch (count) {
          case 1:
          case 2:
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'S':
        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
        break;
      case 'F':
        if (count === 1) {
          this.appendValue(field);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'd':
      case 'h':
      case 'H':
      case 'k':
      case 'K':
      case 'm':
      case 's':
        if (count === 1) {
          this.appendValue(field);
        } else if (count === 2) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'D':
        if (count === 1) {
          this.appendValue(field);
        } else if (count <= 3) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      default:
        if (count === 1) {
          this.appendValue(field);
        } else {
          this.appendValue(field, count);
        }
        break;
    }
  };
  _proto.padNext = function padNext() {
    if (arguments.length === 1) {
      return this._padNext1.apply(this, arguments);
    } else {
      return this._padNext2.apply(this, arguments);
    }
  };
  _proto._padNext1 = function _padNext1(padWidth) {
    return this._padNext2(padWidth, ' ');
  };
  _proto._padNext2 = function _padNext2(padWidth, padChar) {
    if (padWidth < 1) {
      throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
    }
    this._active._padNextWidth = padWidth;
    this._active._padNextChar = padChar;
    this._active._valueParserIndex = -1;
    return this;
  };
  _proto.optionalStart = function optionalStart() {
    this._active._valueParserIndex = -1;
    this._active = DateTimeFormatterBuilder._of(this._active, true);
    return this;
  };
  _proto.optionalEnd = function optionalEnd() {
    if (this._active._parent == null) {
      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');
    }
    if (this._active._printerParsers.length > 0) {
      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
      this._active = this._active._parent;
      this._appendInternal(cpp);
    } else {
      this._active = this._active._parent;
    }
    return this;
  };
  _proto._appendInternal = function _appendInternal(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.appendLiteral = function appendLiteral(literal) {
    assert(literal != null);
    if (literal.length > 0) {
      if (literal.length === 1) {
        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
      } else {
        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
      }
    }
    return this;
  };
  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.append = function append(formatter) {
    requireNonNull(formatter, 'formatter');
    this._appendInternal(formatter._toPrinterParser(false));
    return this;
  };
  _proto.toFormatter = function toFormatter(resolverStyle) {
    if (resolverStyle === void 0) {
      resolverStyle = ResolverStyle.SMART;
    }
    while (this._active._parent != null) {
      this.optionalEnd();
    }
    var pp = new CompositePrinterParser(this._printerParsers, false);
    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
  };
  return DateTimeFormatterBuilder;
}();
var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
var InstantPrinterParser = function () {
  function InstantPrinterParser(fractionalDigits) {
    this.fractionalDigits = fractionalDigits;
  }
  var _proto2 = InstantPrinterParser.prototype;
  _proto2.print = function print(context, buf) {
    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
    var inNanos = 0;
    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
    }
    if (inSecs == null) {
      return false;
    }
    var inSec = inSecs;
    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
    if (inSec >= -SECONDS_0000_TO_1970) {
      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      if (hi > 0) {
        buf.append('+').append(hi);
      }
      buf.append(ldt.toString());
      if (ldt.second() === 0) {
        buf.append(':00');
      }
    } else {
      var _zeroSecs = inSec + SECONDS_0000_TO_1970;
      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      var pos = buf.length();
      buf.append(_ldt.toString());
      if (_ldt.second() === 0) {
        buf.append(':00');
      }
      if (_hi < 0) {
        if (_ldt.year() === -10000) {
          buf.replace(pos, pos + 2, "" + (_hi - 1));
        } else if (_lo === 0) {
          buf.insert(pos, _hi);
        } else {
          buf.insert(pos + 1, Math.abs(_hi));
        }
      }
    }
    if (this.fractionalDigits === -2) {
      if (inNano !== 0) {
        buf.append('.');
        if (MathUtil.intMod(inNano, 1000000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));
        } else if (MathUtil.intMod(inNano, 1000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));
        } else {
          buf.append(("" + (inNano + 1000000000)).substring(1));
        }
      }
    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
      buf.append('.');
      var div = 100000000;
      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
        var digit = MathUtil.intDiv(inNano, div);
        buf.append(digit);
        inNano = inNano - digit * div;
        div = MathUtil.intDiv(div, 10);
      }
    }
    buf.append('Z');
    return true;
  };
  _proto2.parse = function parse(context, text, position) {
    var newContext = context.copy();
    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);
    var pos = parser.parse(newContext, text, position);
    if (pos < 0) {
      return pos;
    }
    var yearParsed = newContext.getParsed(ChronoField.YEAR);
    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
    var sec = secVal != null ? secVal : 0;
    var nano = nanoVal != null ? nanoVal : 0;
    var year = MathUtil.intMod(yearParsed, 10000);
    var days = 0;
    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
      hour = 0;
      days = 1;
    } else if (hour === 23 && min === 59 && sec === 60) {
      context.setParsedLeapSecond();
      sec = 59;
    }
    var instantSecs;
    try {
      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);
    } catch (ex) {
      return ~position;
    }
    var successPos = pos;
    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
  };
  _proto2.toString = function toString() {
    return 'Instant()';
  };
  return InstantPrinterParser;
}();
var DefaultingParser = function () {
  function DefaultingParser(field, value) {
    this._field = field;
    this._value = value;
  }
  var _proto3 = DefaultingParser.prototype;
  _proto3.print = function print() {
    return true;
  };
  _proto3.parse = function parse(context, text, position) {
    if (context.getParsed(this._field) == null) {
      context.setParsedField(this._field, this._value, position, position);
    }
    return position;
  };
  return DefaultingParser;
}();
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var StringBuilder = function () {
  function StringBuilder() {
    this._str = '';
  }
  var _proto = StringBuilder.prototype;
  _proto.append = function append(str) {
    this._str += str;
    return this;
  };
  _proto.appendChar = function appendChar(str) {
    this._str += str[0];
    return this;
  };
  _proto.insert = function insert(offset, str) {
    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
    return this;
  };
  _proto.replace = function replace(start, end, str) {
    this._str = this._str.slice(0, start) + str + this._str.slice(end);
    return this;
  };
  _proto.length = function length() {
    return this._str.length;
  };
  _proto.setLength = function setLength(length) {
    this._str = this._str.slice(0, length);
    return this;
  };
  _proto.toString = function toString() {
    return this._str;
  };
  return StringBuilder;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimeFormatter = function () {
  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {
    return DateTimeFormatter.PARSED_EXCESS_DAYS;
  };
  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {
    return DateTimeFormatter.PARSED_LEAP_SECOND;
  };
  DateTimeFormatter.ofPattern = function ofPattern(pattern) {
    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
  };
  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
    if (chrono === void 0) {
      chrono = IsoChronology.INSTANCE;
    }
    assert(printerParser != null);
    assert(decimalStyle != null);
    assert(resolverStyle != null);
    this._printerParser = printerParser;
    this._locale = locale;
    this._decimalStyle = decimalStyle;
    this._resolverStyle = resolverStyle;
    this._resolverFields = resolverFields;
    this._chrono = chrono;
    this._zone = zone;
  }
  var _proto = DateTimeFormatter.prototype;
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.decimalStyle = function decimalStyle() {
    return this._decimalStyle;
  };
  _proto.chronology = function chronology() {
    return this._chrono;
  };
  _proto.withChronology = function withChronology(chrono) {
    if (this._chrono != null && this._chrono.equals(chrono)) {
      return this;
    }
    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
  };
  _proto.withLocale = function withLocale() {
    return this;
  };
  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
    requireNonNull(resolverStyle, 'resolverStyle');
    if (resolverStyle.equals(this._resolverStyle)) {
      return this;
    }
    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
  };
  _proto.format = function format(temporal) {
    var buf = new StringBuilder(32);
    this._formatTo(temporal, buf);
    return buf.toString();
  };
  _proto._formatTo = function _formatTo(temporal, appendable) {
    requireNonNull(temporal, 'temporal');
    requireNonNull(appendable, 'appendable');
    var context = new DateTimePrintContext(temporal, this);
    this._printerParser.print(context, appendable);
  };
  _proto.parse = function parse(text, type) {
    if (arguments.length === 1) {
      return this.parse1(text);
    } else {
      return this.parse2(text, type);
    }
  };
  _proto.parse1 = function parse1(text) {
    requireNonNull(text, 'text');
    try {
      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };
  _proto.parse2 = function parse2(text, type) {
    requireNonNull(text, 'text');
    requireNonNull(type, 'type');
    try {
      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
      return builder.build(type);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };
  _proto._createError = function _createError(text, ex) {
    var abbr = '';
    if (text.length > 64) {
      abbr = text.substring(0, 64) + "...";
    } else {
      abbr = text;
    }
    return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
  };
  _proto._parseToBuilder = function _parseToBuilder(text, position) {
    var pos = position != null ? position : new ParsePosition(0);
    var result = this._parseUnresolved0(text, pos);
    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
      var abbr = '';
      if (text.length > 64) {
        abbr = text.substr(0, 64).toString() + "...";
      } else {
        abbr = text;
      }
      if (pos.getErrorIndex() >= 0) {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
      } else {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
      }
    }
    return result.toBuilder();
  };
  _proto.parseUnresolved = function parseUnresolved(text, position) {
    return this._parseUnresolved0(text, position);
  };
  _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
    assert(text != null, 'text', NullPointerException);
    assert(position != null, 'position', NullPointerException);
    var context = new DateTimeParseContext(this);
    var pos = position.getIndex();
    pos = this._printerParser.parse(context, text, pos);
    if (pos < 0) {
      position.setErrorIndex(~pos);
      return null;
    }
    position.setIndex(pos);
    return context.toParsed();
  };
  _proto._toPrinterParser = function _toPrinterParser(optional) {
    return this._printerParser.withOptional(optional);
  };
  _proto.toString = function toString() {
    var pattern = this._printerParser.toString();
    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);
  };
  return DateTimeFormatter;
}();
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-W').appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral('-').appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}

var MonthDay = function (_TemporalAccessor) {
  _inheritsLoose(MonthDay, _TemporalAccessor);
  MonthDay.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return MonthDay.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return MonthDay.nowZoneId(zoneIdOrClock);
    } else {
      return MonthDay.nowClock(zoneIdOrClock);
    }
  };
  MonthDay.now0 = function now0() {
    return this.nowClock(Clock.systemDefaultZone());
  };
  MonthDay.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    return this.nowClock(Clock.system(zone));
  };
  MonthDay.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    var now = LocalDate.now(clock);
    return MonthDay.of(now.month(), now.dayOfMonth());
  };
  MonthDay.of = function of(monthOrNumber, number) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return MonthDay.ofMonthNumber(monthOrNumber, number);
    } else {
      return MonthDay.ofNumberNumber(monthOrNumber, number);
    }
  };
  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > month.maxLength()) {
      throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
    }
    return new MonthDay(month.value(), dayOfMonth);
  };
  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');
    return MonthDay.of(Month.of(month), dayOfMonth);
  };
  MonthDay.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');
    if (temporal instanceof MonthDay) {
      return temporal;
    }
    try {
      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  MonthDay.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return MonthDay.parseString(text);
    } else {
      return MonthDay.parseStringFormatter(text, formatter);
    }
  };
  MonthDay.parseString = function parseString(text) {
    return MonthDay.parseStringFormatter(text, PARSER$2);
  };
  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, MonthDay.FROM);
  };
  function MonthDay(month, dayOfMonth) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    return _this;
  }
  var _proto = MonthDay.prototype;
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return field.range();
    } else if (field === ChronoField.DAY_OF_MONTH) {
      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
    }
    return _TemporalAccessor.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.DAY_OF_MONTH:
          return this._day;
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isValidYear = function isValidYear(year) {
    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
  };
  _proto.withMonth = function withMonth(month) {
    return this.with(Month.of(month));
  };
  _proto.with = function _with(month) {
    requireNonNull(month, 'month');
    if (month.value() === this._month) {
      return this;
    }
    var day = Math.min(this._day, month.maxLength());
    return new MonthDay(month.value(), day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (dayOfMonth === this._day) {
      return this;
    }
    return MonthDay.of(this._month, dayOfMonth);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
  };
  _proto.atYear = function atYear(year) {
    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    var cmp = this._month - other.monthValue();
    if (cmp === 0) {
      cmp = this._day - other.dayOfMonth();
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof MonthDay) {
      var other = obj;
      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
    }
    return false;
  };
  _proto.toString = function toString() {
    return "--" + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  return MonthDay;
}(TemporalAccessor);
var PARSER$2;
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {
    return MonthDay.from(temporal);
  });
}

var YearMonth = function (_Temporal) {
  _inheritsLoose(YearMonth, _Temporal);
  YearMonth.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return YearMonth.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return YearMonth.nowZoneId(zoneIdOrClock);
    } else {
      return YearMonth.nowClock(zoneIdOrClock);
    }
  };
  YearMonth.now0 = function now0() {
    return YearMonth.nowClock(Clock.systemDefaultZone());
  };
  YearMonth.nowZoneId = function nowZoneId(zone) {
    return YearMonth.nowClock(Clock.system(zone));
  };
  YearMonth.nowClock = function nowClock(clock) {
    var now = LocalDate.now(clock);
    return YearMonth.of(now.year(), now.month());
  };
  YearMonth.of = function of(year, monthOrNumber) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return YearMonth.ofNumberMonth(year, monthOrNumber);
    } else {
      return YearMonth.ofNumberNumber(year, monthOrNumber);
    }
  };
  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.ofNumberNumber(year, month.value());
  };
  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(year, month);
  };
  YearMonth.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof YearMonth) {
      return temporal;
    }
    try {
      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  YearMonth.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return YearMonth.parseString(text);
    } else {
      return YearMonth.parseStringFormatter(text, formatter);
    }
  };
  YearMonth.parseString = function parseString(text) {
    return YearMonth.parseStringFormatter(text, PARSER$1);
  };
  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, YearMonth.FROM);
  };
  function YearMonth(year, month) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    return _this;
  }
  var _proto = YearMonth.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.YEAR_OF_ERA) {
      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
        case ChronoField.PROLEPTIC_MONTH:
          return this._getProlepticMonth();
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto._getProlepticMonth = function _getProlepticMonth() {
    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.isValidDay = function isValidDay(dayOfMonth) {
    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    return this.month().length(this.isLeapYear());
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto.with = function _with(adjusterOrField, value) {
    if (arguments.length === 1) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, value);
    }
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    ChronoField.YEAR.checkValidValue(year);
    return new YearMonth(year, this._month);
  };
  _proto.withMonth = function withMonth(month) {
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(this._year, month);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return this.withYear(newYear);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return new YearMonth(newYear, newMonth);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, Temporal, 'temporal');
    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    requireInstance(endExclusive, Temporal, 'endExclusive');
    requireInstance(unit, TemporalUnit, 'unit');
    var end = YearMonth.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
      switch (unit) {
        case ChronoUnit.MONTHS:
          return monthsUntil;
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(monthsUntil, 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(monthsUntil, 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(monthsUntil, 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(monthsUntil, 12000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.atDay = function atDay(dayOfMonth) {
    requireNonNull(dayOfMonth, 'dayOfMonth');
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };
  _proto.atEndOfMonth = function atEndOfMonth() {
    return LocalDate.of(this._year, this._month, this.lengthOfMonth());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, YearMonth, 'other');
    var cmp = this._year - other.year();
    if (cmp === 0) {
      cmp = this._month - other.monthValue();
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof YearMonth) {
      var other = obj;
      return this.year() === other.year() && this.monthValue() === other.monthValue();
    }
    return false;
  };
  _proto.toString = function toString() {
    return PARSER$1.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return YearMonth;
}(Temporal);
var PARSER$1;
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {
    return YearMonth.from(temporal);
  });
}

var Year = function (_Temporal) {
  _inheritsLoose(Year, _Temporal);
  function Year(value) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(value);
    return _this;
  }
  var _proto = Year.prototype;
  _proto.value = function value() {
    return this._year;
  };
  Year.now = function now(zoneIdOrClock) {
    if (zoneIdOrClock === void 0) {
      zoneIdOrClock = undefined;
    }
    if (zoneIdOrClock === undefined) {
      return Year.now0();
    } else if (zoneIdOrClock instanceof ZoneId) {
      return Year.nowZoneId(zoneIdOrClock);
    } else {
      return Year.nowClock(zoneIdOrClock);
    }
  };
  Year.now0 = function now0() {
    return Year.nowClock(Clock.systemDefaultZone());
  };
  Year.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    return Year.nowClock(Clock.system(zone));
  };
  Year.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    requireInstance(clock, Clock, 'clock');
    var now = LocalDate.now(clock);
    return Year.of(now.year());
  };
  Year.of = function of(isoYear) {
    requireNonNull(isoYear, 'isoYear');
    ChronoField.YEAR.checkValidValue(isoYear);
    return new Year(isoYear);
  };
  Year.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');
    if (temporal instanceof Year) {
      return temporal;
    }
    try {
      return Year.of(temporal.get(ChronoField.YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  Year.parse = function parse(text, formatter) {
    if (arguments.length <= 1) {
      return Year.parseText(text);
    } else {
      return Year.parseTextFormatter(text, formatter);
    }
  };
  Year.parseText = function parseText(text) {
    requireNonNull(text, 'text');
    return Year.parse(text, PARSER);
  };
  Year.parseTextFormatter = function parseTextFormatter(text, formatter) {
    if (formatter === void 0) {
      formatter = PARSER;
    }
    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, Year.FROM);
  };
  Year.isLeap = function isLeap(year) {
    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (this.isSupported(field)) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isLeap = function isLeap() {
    return Year.isLeap(this._year);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return Year.of(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return Year.of(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.YEAR, this._year);
  };
  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
    return monthDay != null && monthDay.isValidYear(this._year);
  };
  _proto.length = function length() {
    return this.isLeap() ? 366 : 365;
  };
  _proto.atDay = function atDay(dayOfYear) {
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };
  _proto.atMonth = function atMonth(monthOrNumber) {
    if (arguments.length === 1 && monthOrNumber instanceof Month) {
      return this.atMonthMonth(monthOrNumber);
    } else {
      return this.atMonthNumber(monthOrNumber);
    }
  };
  _proto.atMonthMonth = function atMonthMonth(month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthNumber = function atMonthNumber(month) {
    requireNonNull(month, 'month');
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthDay = function atMonthDay(monthDay) {
    requireNonNull(monthDay, 'monthDay');
    requireInstance(monthDay, MonthDay, 'monthDay');
    return monthDay.atYear(this._year);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query()');
    requireInstance(_query, TemporalQuery, 'query()');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.YEARS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year - other._year;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year > other._year;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year < other._year;
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Year) {
      return this.value() === other.value();
    }
    return false;
  };
  _proto.toString = function toString() {
    return "" + this._year;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.until = function until(endExclusive, unit) {
    var end = Year.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var yearsUntil = end.value() - this.value();
      switch (unit) {
        case ChronoUnit.YEARS:
          return yearsUntil;
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(yearsUntil, 10);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(yearsUntil, 100);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(yearsUntil, 1000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  return Year;
}(Temporal);
var PARSER;
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {
    return Year.from(temporal);
  });
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAdjuster = function () {
  function TemporalAdjuster() {}
  var _proto = TemporalAdjuster.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    abstractMethodFail('adjustInto');
  };
  return TemporalAdjuster;
}();

var TemporalAdjusters = function () {
  function TemporalAdjusters() {}
  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {
    return Impl.FIRST_DAY_OF_MONTH;
  };
  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {
    return Impl.LAST_DAY_OF_MONTH;
  };
  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {
    return Impl.FIRST_DAY_OF_NEXT_MONTH;
  };
  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {
    return Impl.FIRST_DAY_OF_YEAR;
  };
  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {
    return Impl.LAST_DAY_OF_YEAR;
  };
  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {
    return Impl.FIRST_DAY_OF_NEXT_YEAR;
  };
  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(1, dayOfWeek);
  };
  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(-1, dayOfWeek);
  };
  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(ordinal, dayOfWeek);
  };
  TemporalAdjusters.next = function next(dayOfWeek) {
    return new RelativeDayOfWeek(2, dayOfWeek);
  };
  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(0, dayOfWeek);
  };
  TemporalAdjusters.previous = function previous(dayOfWeek) {
    return new RelativeDayOfWeek(3, dayOfWeek);
  };
  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(1, dayOfWeek);
  };
  return TemporalAdjusters;
}();
var Impl = function (_TemporalAdjuster) {
  _inheritsLoose(Impl, _TemporalAdjuster);
  function Impl(ordinal) {
    var _this;
    _this = _TemporalAdjuster.call(this) || this;
    _this._ordinal = ordinal;
    return _this;
  }
  var _proto = Impl.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    switch (this._ordinal) {
      case 0:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1);
      case 1:
        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      case 2:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
      case 3:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1);
      case 4:
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
      case 5:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
    }
    throw new IllegalStateException('Unreachable');
  };
  return Impl;
}(TemporalAdjuster);
Impl.FIRST_DAY_OF_MONTH = new Impl(0);
Impl.LAST_DAY_OF_MONTH = new Impl(1);
Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
Impl.FIRST_DAY_OF_YEAR = new Impl(3);
Impl.LAST_DAY_OF_YEAR = new Impl(4);
Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
var DayOfWeekInMonth = function (_TemporalAdjuster2) {
  _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);
  function DayOfWeekInMonth(ordinal, dow) {
    var _this2;
    _this2 = _TemporalAdjuster2.call(this) || this;
    _this2._ordinal = ordinal;
    _this2._dowValue = dow.value();
    return _this2;
  }
  var _proto2 = DayOfWeekInMonth.prototype;
  _proto2.adjustInto = function adjustInto(temporal) {
    if (this._ordinal >= 0) {
      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
      var curDow = temp.get(ChronoField.DAY_OF_WEEK);
      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
      dowDiff += (this._ordinal - 1) * 7;
      return temp.plus(dowDiff, ChronoUnit.DAYS);
    } else {
      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
      var daysDiff = this._dowValue - _curDow;
      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
      daysDiff -= (-this._ordinal - 1) * 7;
      return _temp.plus(daysDiff, ChronoUnit.DAYS);
    }
  };
  return DayOfWeekInMonth;
}(TemporalAdjuster);
var RelativeDayOfWeek = function (_TemporalAdjuster3) {
  _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);
  function RelativeDayOfWeek(relative, dayOfWeek) {
    var _this3;
    _this3 = _TemporalAdjuster3.call(this) || this;
    requireNonNull(dayOfWeek, 'dayOfWeek');
    _this3._relative = relative;
    _this3._dowValue = dayOfWeek.value();
    return _this3;
  }
  var _proto3 = RelativeDayOfWeek.prototype;
  _proto3.adjustInto = function adjustInto(temporal) {
    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
    if (this._relative < 2 && calDow === this._dowValue) {
      return temporal;
    }
    if ((this._relative & 1) === 0) {
      var daysDiff = calDow - this._dowValue;
      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
    } else {
      var _daysDiff = this._dowValue - calDow;
      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
    }
  };
  return RelativeDayOfWeek;
}(TemporalAdjuster);

var IsoChronology = function (_Enum) {
  _inheritsLoose(IsoChronology, _Enum);
  function IsoChronology() {
    return _Enum.apply(this, arguments) || this;
  }
  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {
    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
  };
  var _proto = IsoChronology.prototype;
  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
    requireNonNull(fieldValues, 'fieldValues');
    requireNonNull(field, 'field');
    var current = fieldValues.get(field);
    if (current != null && current !== value) {
      throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
    }
    fieldValues.put(field, value);
  };
  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
    }
    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
    if (prolepticMonth != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
      }
      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
    }
    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
    if (yoeLong != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
      }
      var era = fieldValues.remove(ChronoField.ERA);
      if (era == null) {
        var year = fieldValues.get(ChronoField.YEAR);
        if (resolverStyle === ResolverStyle.STRICT) {
          if (year != null) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
          } else {
            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
          }
        } else {
          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
        }
      } else if (era === 1) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
      } else if (era === 0) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
      } else {
        throw new DateTimeException("Invalid value for era: " + era);
      }
    } else if (fieldValues.containsKey(ChronoField.ERA)) {
      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
    }
    if (fieldValues.containsKey(ChronoField.YEAR)) {
      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
          if (resolverStyle === ResolverStyle.LENIENT) {
            var months = moy - 1;
            var days = dom - 1;
            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
          } else if (resolverStyle === ResolverStyle.SMART) {
            ChronoField.DAY_OF_MONTH.checkValidValue(dom);
            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
              dom = Math.min(dom, 30);
            } else if (moy === 2) {
              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
            }
            return LocalDate.of(y, moy, dom);
          } else {
            return LocalDate.of(y, moy, dom);
          }
        }
      }
      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
        if (resolverStyle === ResolverStyle.LENIENT) {
          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
          return LocalDate.ofYearDay(_y, 1).plusDays(_days);
        }
        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
        return LocalDate.ofYearDay(_y, doy);
      }
      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
          }
          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
            throw new DateTimeException('Strict mode rejected date parsed to a different year');
          }
          return date;
        }
        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
          }
          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
            throw new DateTimeException('Strict mode rejected date parsed to a different month');
          }
          return _date;
        }
      }
    }
    return null;
  };
  _proto.date = function date(temporal) {
    return LocalDate.from(temporal);
  };
  return IsoChronology;
}(Enum);
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');
}

var OffsetTime = function (_Temporal) {
  _inheritsLoose(OffsetTime, _Temporal);
  OffsetTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof OffsetTime) {
      return temporal;
    } else if (temporal instanceof OffsetDateTime) {
      return temporal.toOffsetTime();
    }
    try {
      var time = LocalTime.from(temporal);
      var offset = ZoneOffset.from(temporal);
      return new OffsetTime(time, offset);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  OffsetTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return OffsetTime._now(clockOrZone);
    } else {
      return OffsetTime._now(Clock.system(clockOrZone));
    }
  };
  OffsetTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    var now = clock.instant();
    return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));
  };
  OffsetTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetTime.ofTimeAndOffset.apply(this, arguments);
    } else {
      return OffsetTime.ofNumbers.apply(this, arguments);
    }
  };
  OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new OffsetTime(time, offset);
  };
  OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
    return new OffsetTime(time, offset);
  };
  OffsetTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }
    var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
    return new OffsetTime(time, offset);
  };
  OffsetTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetTime.FROM);
  };
  function OffsetTime(time, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(time, 'time');
    requireInstance(time, LocalTime, 'time');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._time = time;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetTime.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.atDate = function atDate(date) {
    return OffsetDateTime.of(date, this._time, this._offset);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this, OffsetTime.FROM);
  };
  _proto.get = function get(field) {
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._offset.totalSeconds();
      }
      return this._time.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() > other._toEpochNano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() < other._toEpochNano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() === other._toEpochNano();
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount);
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localTime()) {
      return this._time;
    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._time.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = OffsetTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end._toEpochNano() - this._toEpochNano();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1000);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1000000);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.withHour = function withHour(hour) {
    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nano) {
    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._time.plusSeconds(difference);
    return new OffsetTime(adjusted, offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);
  };
  _proto._toEpochNano = function _toEpochNano() {
    var nod = this._time.toNanoOfDay();
    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
    return nod - offsetNanos;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalTime) {
      return this._withLocalTimeOffset(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withLocalTimeOffset(this._time, adjuster);
    } else if (adjuster instanceof OffsetTime) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
      }
      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
    if (this._time === time && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetTime(time, offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetTime, 'other');
    if (this._offset.equals(other._offset)) {
      return this._time.compareTo(other._time);
    }
    var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
    if (compare === 0) {
      return this._time.compareTo(other._time);
    }
    return compare;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetTime) {
      return this._time.equals(other._time) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._time.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString() {
    return this._time.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return OffsetTime;
}(Temporal);
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', function (temporal) {
    return OffsetTime.from(temporal);
  });
}

var ChronoZonedDateTime = function (_Temporal) {
  _inheritsLoose(ChronoZonedDateTime, _Temporal);
  function ChronoZonedDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoZonedDateTime.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone();
    } else if (_query === TemporalQueries.chronology()) {
      return this.toLocalDate().chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  _proto.toInstant = function toInstant() {
    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond() {
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= this.offset().totalSeconds();
    return secs;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
        if (cmp === 0) {
          cmp = strcmp(this.zone().id(), other.zone().id());
        }
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ChronoZonedDateTime) {
      return this.compareTo(other) === 0;
    }
    return false;
  };
  return ChronoZonedDateTime;
}(Temporal);
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

var ZonedDateTime = function (_ChronoZonedDateTime) {
  _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);
  ZonedDateTime.now = function now(clockOrZone) {
    var clock;
    if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
    }
    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());
  };
  ZonedDateTime.of = function of() {
    if (arguments.length <= 2) {
      return ZonedDateTime.of2.apply(this, arguments);
    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
      return ZonedDateTime.of3.apply(this, arguments);
    } else {
      return ZonedDateTime.of8.apply(this, arguments);
    }
  };
  ZonedDateTime.of3 = function of3(date, time, zone) {
    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);
  };
  ZonedDateTime.of2 = function of2(localDateTime, zone) {
    return ZonedDateTime.ofLocal(localDateTime, zone, null);
  };
  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return ZonedDateTime.ofLocal(dt, zone, null);
  };
  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(zone, 'zone');
    if (zone instanceof ZoneOffset) {
      return new ZonedDateTime(localDateTime, zone, zone);
    }
    var offset = null;
    var rules = zone.rules();
    var validOffsets = rules.validOffsets(localDateTime);
    if (validOffsets.length === 1) {
      offset = validOffsets[0];
    } else if (validOffsets.length === 0) {
      var trans = rules.transition(localDateTime);
      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
      offset = trans.offsetAfter();
    } else {
      if (preferredOffset != null && validOffsets.some(function (validOffset) {
        return validOffset.equals(preferredOffset);
      })) {
        offset = preferredOffset;
      } else {
        offset = requireNonNull(validOffsets[0], 'offset');
      }
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.ofInstant = function ofInstant() {
    if (arguments.length === 2) {
      return ZonedDateTime.ofInstant2.apply(this, arguments);
    } else {
      return ZonedDateTime.ofInstant3.apply(this, arguments);
    }
  };
  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);
  };
  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
  };
  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {
    var rules = zone.rules();
    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
    return new ZonedDateTime(ldt, offset, zone);
  };
  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();
    if (rules.isValidOffset(localDateTime, offset) === false) {
      var trans = rules.transition(localDateTime);
      if (trans != null && trans.isGap()) {
        throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
      }
      throw new DateTimeException("ZoneOffset \"" + offset + "\" is not valid for LocalDateTime \"" + localDateTime + "\" in zone \"" + zone + "\"");
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
      throw new IllegalArgumentException('ZoneId must match ZoneOffset');
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof ZonedDateTime) {
      return temporal;
    }
    var zone = ZoneId.from(temporal);
    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
      var zdt = ZonedDateTime._from(temporal, zone);
      if (zdt != null) return zdt;
    }
    var ldt = LocalDateTime.from(temporal);
    return ZonedDateTime.of2(ldt, zone);
  };
  ZonedDateTime._from = function _from(temporal, zone) {
    try {
      return ZonedDateTime.__from(temporal, zone);
    } catch (ex) {
      if (!(ex instanceof DateTimeException)) throw ex;
    }
  };
  ZonedDateTime.__from = function __from(temporal, zone) {
    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);
  };
  ZonedDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, ZonedDateTime.FROM);
  };
  function ZonedDateTime(dateTime, offset, zone) {
    var _this;
    requireNonNull(dateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    _this = _ChronoZonedDateTime.call(this) || this;
    _this._dateTime = dateTime;
    _this._offset = offset;
    _this._zone = zone;
    return _this;
  }
  var _proto = ZonedDateTime.prototype;
  _proto._resolveLocal = function _resolveLocal(newDateTime) {
    requireNonNull(newDateTime, 'newDateTime');
    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);
  };
  _proto._resolveInstant = function _resolveInstant(newDateTime) {
    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);
  };
  _proto._resolveOffset = function _resolveOffset(offset) {
    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
      return new ZonedDateTime(this._dateTime, offset, this._zone);
    }
    return this;
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return true;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this._offset.totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    requireNonNull(field, 'field');
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this._dateTime);
    if (trans != null && trans.isOverlap()) {
      var earlierOffset = trans.offsetBefore();
      if (earlierOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);
      }
    }
    return this;
  };
  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this.toLocalDateTime());
    if (trans != null) {
      var laterOffset = trans.offsetAfter();
      if (laterOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);
      }
    }
    return this;
  };
  _proto.zone = function zone() {
    return this._zone;
  };
  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
  };
  _proto.withFixedOffsetZone = function withFixedOffsetZone() {
    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    if (adjuster instanceof LocalDate) {
      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
    } else if (adjuster instanceof LocalTime) {
      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
    } else if (adjuster instanceof LocalDateTime) {
      return this._resolveLocal(adjuster);
    } else if (adjuster instanceof Instant) {
      var instant = adjuster;
      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);
    } else if (adjuster instanceof ZoneOffset) {
      return this._resolveOffset(adjuster);
    }
    return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return ZonedDateTime._create(newValue, this.nano(), this._zone);
        case ChronoField.OFFSET_SECONDS:
          {
            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
            return this._resolveOffset(offset);
          }
      }
      return this._resolveLocal(this._dateTime.with(field, newValue));
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._resolveLocal(this._dateTime.withYear(year));
  };
  _proto.withMonth = function withMonth(month) {
    return this._resolveLocal(this._dateTime.withMonth(month));
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
  };
  _proto.withHour = function withHour(hour) {
    return this._resolveLocal(this._dateTime.withHour(hour));
  };
  _proto.withMinute = function withMinute(minute) {
    return this._resolveLocal(this._dateTime.withMinute(minute));
  };
  _proto.withSecond = function withSecond(second) {
    return this._resolveLocal(this._dateTime.withSecond(second));
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._resolveLocal(this._dateTime.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      if (unit.isDateBased()) {
        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
      } else {
        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
      }
    }
    requireNonNull(unit, 'unit');
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._resolveLocal(this._dateTime.plusYears(years));
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._resolveLocal(this._dateTime.plusMonths(months));
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._resolveLocal(this._dateTime.plusWeeks(weeks));
  };
  _proto.plusDays = function plusDays(days) {
    return this._resolveLocal(this._dateTime.plusDays(days));
  };
  _proto.plusHours = function plusHours(hours) {
    return this._resolveInstant(this._dateTime.plusHours(hours));
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._resolveInstant(this._dateTime.plusMinutes(minutes));
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._resolveInstant(this._dateTime.plusSeconds(seconds));
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._resolveInstant(this._dateTime.plusNanos(nanos));
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this.plusHours(-1 * hours);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this.plusMinutes(-1 * minutes);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this.plusSeconds(-1 * seconds);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this.plusNanos(-1 * nanos);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    requireNonNull(_query, 'query');
    return _ChronoZonedDateTime.prototype.query.call(this, _query);
  };
  _proto.until = function until(endExclusive, unit) {
    var end = ZonedDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end = end.withZoneSameInstant(this._zone);
      if (unit.isDateBased()) {
        return this._dateTime.until(end._dateTime, unit);
      } else {
        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
        var adjustedEnd = end._dateTime.plusSeconds(difference);
        return this._dateTime.until(adjustedEnd, unit);
      }
    }
    return unit.between(this, end);
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetDateTime = function toOffsetDateTime() {
    return OffsetDateTime.of(this._dateTime, this._offset);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZonedDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
  };
  _proto.toString = function toString() {
    var str = this._dateTime.toString() + this._offset.toString();
    if (this._offset !== this._zone) {
      str += "[" + this._zone.toString() + "]";
    }
    return str;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    return _ChronoZonedDateTime.prototype.format.call(this, formatter);
  };
  return ZonedDateTime;
}(ChronoZonedDateTime);
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {
    return ZonedDateTime.from(temporal);
  });
}

var OffsetDateTime = function (_Temporal) {
  _inheritsLoose(OffsetDateTime, _Temporal);
  OffsetDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof OffsetDateTime) {
      return temporal;
    }
    try {
      var offset = ZoneOffset.from(temporal);
      try {
        var ldt = LocalDateTime.from(temporal);
        return OffsetDateTime.of(ldt, offset);
      } catch (_) {
        var instant = Instant.from(temporal);
        return OffsetDateTime.ofInstant(instant, offset);
      }
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  OffsetDateTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetDateTime.now(Clock.systemDefaultZone());
    } else {
      requireNonNull(clockOrZone, 'clockOrZone');
      if (clockOrZone instanceof ZoneId) {
        return OffsetDateTime.now(Clock.system(clockOrZone));
      } else if (clockOrZone instanceof Clock) {
        var now = clockOrZone.instant();
        return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));
      } else {
        throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');
      }
    }
  };
  OffsetDateTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetDateTime.ofDateTime.apply(this, arguments);
    } else if (arguments.length === 3) {
      return OffsetDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return OffsetDateTime.ofNumbers.apply(this, arguments);
    }
  };
  OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {
    return new OffsetDateTime(dateTime, offset);
  };
  OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {
    var dt = LocalDateTime.of(date, time);
    return new OffsetDateTime(dt, offset);
  };
  OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return new OffsetDateTime(dt, offset);
  };
  OffsetDateTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
    return new OffsetDateTime(ldt, offset);
  };
  OffsetDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetDateTime.FROM);
  };
  function OffsetDateTime(dateTime, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(dateTime, 'dateTime');
    requireInstance(dateTime, LocalDateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._dateTime = dateTime;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetDateTime.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.until = function until(endExclusive, unit) {
    var end = OffsetDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end = end.withOffsetSameInstant(this._offset);
      return this._dateTime.until(end._dateTime, unit);
    }
    return unit.between(this, end);
  };
  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
  };
  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          throw new DateTimeException("Field too large for an int: " + field);
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.get(field);
    }
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetTime = function toOffsetTime() {
    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
  };
  _proto.toZonedDateTime = function toZonedDateTime() {
    return ZonedDateTime.of(this._dateTime, this._offset);
  };
  _proto.toInstant = function toInstant() {
    return this._dateTime.toInstant(this._offset);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._dateTime.toEpochSecond(this._offset);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster);
    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
    } else if (adjuster instanceof Instant) {
      return OffsetDateTime.ofInstant(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withDateTimeOffset(this._dateTime, adjuster);
    } else if (adjuster instanceof OffsetDateTime) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field);
    if (field instanceof ChronoField) {
      var f = field;
      switch (f) {
        case ChronoField.INSTANT_SECONDS:
          return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
        case ChronoField.OFFSET_SECONDS:
          {
            return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
          }
      }
      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
    if (this._dateTime === dateTime && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetDateTime(dateTime, offset);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
  };
  _proto.withHour = function withHour(hour) {
    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    requireNonNull(offset, 'offset');
    return this._withDateTimeOffset(this._dateTime, offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._dateTime.plusSeconds(difference);
    return new OffsetDateTime(adjusted, offset);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
  };
  _proto.plusDays = function plusDays(days) {
    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
  };
  _proto.minusDays = function minusDays(days) {
    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetDateTime, 'other');
    if (this.offset().equals(other.offset())) {
      return this.toLocalDateTime().compareTo(other.toLocalDateTime());
    }
    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._dateTime.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString() {
    return this._dateTime.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return OffsetDateTime;
}(Temporal);
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', function (temporal) {
    return OffsetDateTime.from(temporal);
  });
}

var DAYS_PER_CYCLE = 146097;
var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
var LocalDate = function (_ChronoLocalDate) {
  _inheritsLoose(LocalDate, _ChronoLocalDate);
  LocalDate.now = function now(clockOrZone) {
    var clock;
    if (clockOrZone == null) {
      clock = Clock.systemDefaultZone();
    } else if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone;
    }
    return LocalDate.ofInstant(clock.instant(), clock.zone());
  };
  LocalDate.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, 'instant');
    var offset = zone.rules().offset(instant);
    var epochSec = instant.epochSecond() + offset.totalSeconds();
    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
    return LocalDate.ofEpochDay(epochDay);
  };
  LocalDate.of = function of(year, month, dayOfMonth) {
    return new LocalDate(year, month, dayOfMonth);
  };
  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {
    ChronoField.YEAR.checkValidValue(year);
    var leap = IsoChronology.isLeapYear(year);
    if (dayOfYear === 366 && leap === false) {
      assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
    }
    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
    if (dayOfYear > monthEnd) {
      moy = moy.plus(1);
    }
    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
    return new LocalDate(year, moy.value(), dom);
  };
  LocalDate.ofEpochDay = function ofEpochDay(epochDay) {
    if (epochDay === void 0) {
      epochDay = 0;
    }
    var adjust, adjustCycles, doyEst, yearEst, zeroDay;
    zeroDay = epochDay + DAYS_0000_TO_1970;
    zeroDay -= 60;
    adjust = 0;
    if (zeroDay < 0) {
      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
      adjust = adjustCycles * 400;
      zeroDay += -adjustCycles * DAYS_PER_CYCLE;
    }
    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    if (doyEst < 0) {
      yearEst--;
      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    }
    yearEst += adjust;
    var marchDoy0 = doyEst;
    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
    var month = (marchMonth0 + 2) % 12 + 1;
    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
    yearEst += MathUtil.intDiv(marchMonth0, 10);
    var year = yearEst;
    return new LocalDate(year, month, dom);
  };
  LocalDate.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var date = temporal.query(TemporalQueries.localDate());
    if (date == null) {
      throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return date;
  };
  LocalDate.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE;
    }
    assert(formatter != null, 'formatter', NullPointerException);
    return formatter.parse(text, LocalDate.FROM);
  };
  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
    switch (month) {
      case 2:
        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
        break;
      case 4:
      case 6:
      case 9:
      case 11:
        day = Math.min(day, 30);
        break;
    }
    return LocalDate.of(year, month, day);
  };
  function LocalDate(year, month, dayOfMonth) {
    var _this;
    _this = _ChronoLocalDate.call(this) || this;
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');
    if (month instanceof Month) {
      month = month.value();
    }
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    LocalDate._validate(_this._year, _this._month, _this._day);
    return _this;
  }
  LocalDate._validate = function _validate(year, month, dayOfMonth) {
    var dom;
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > 28) {
      dom = 31;
      switch (month) {
        case 2:
          dom = IsoChronology.isLeapYear(year) ? 29 : 28;
          break;
        case 4:
        case 6:
        case 9:
        case 11:
          dom = 30;
      }
      if (dayOfMonth > dom) {
        if (dayOfMonth === 29) {
          assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
        } else {
          assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
        }
      }
    }
  };
  var _proto = LocalDate.prototype;
  _proto.isSupported = function isSupported(field) {
    return _ChronoLocalDate.prototype.isSupported.call(this, field);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field.isDateBased()) {
        switch (field) {
          case ChronoField.DAY_OF_MONTH:
            return ValueRange.of(1, this.lengthOfMonth());
          case ChronoField.DAY_OF_YEAR:
            return ValueRange.of(1, this.lengthOfYear());
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
          case ChronoField.YEAR_OF_ERA:
            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    assert(field != null, '', NullPointerException);
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.DAY_OF_WEEK:
        return this.dayOfWeek().value();
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
        return MathUtil.intMod(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.DAY_OF_MONTH:
        return this._day;
      case ChronoField.DAY_OF_YEAR:
        return this.dayOfYear();
      case ChronoField.EPOCH_DAY:
        return this.toEpochDay();
      case ChronoField.ALIGNED_WEEK_OF_MONTH:
        return MathUtil.intDiv(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_WEEK_OF_YEAR:
        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.MONTH_OF_YEAR:
        return this._month;
      case ChronoField.PROLEPTIC_MONTH:
        return this._prolepticMonth();
      case ChronoField.YEAR_OF_ERA:
        return this._year >= 1 ? this._year : 1 - this._year;
      case ChronoField.YEAR:
        return this._year;
      case ChronoField.ERA:
        return this._year >= 1 ? 1 : 0;
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto._prolepticMonth = function _prolepticMonth() {
    return this._year * 12 + (this._month - 1);
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.dayOfYear = function dayOfYear() {
    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
  };
  _proto.dayOfWeek = function dayOfWeek() {
    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
    return DayOfWeek.of(dow0 + 1);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    switch (this._month) {
      case 2:
        return this.isLeapYear() ? 29 : 28;
      case 4:
      case 6:
      case 9:
      case 11:
        return 30;
      default:
        return 31;
    }
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalDate) {
      return adjuster;
    }
    return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    assert(field != null, 'field', NullPointerException);
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.DAY_OF_WEEK:
          return this.plusDays(newValue - this.dayOfWeek().value());
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
        case ChronoField.DAY_OF_MONTH:
          return this.withDayOfMonth(newValue);
        case ChronoField.DAY_OF_YEAR:
          return this.withDayOfYear(newValue);
        case ChronoField.EPOCH_DAY:
          return LocalDate.ofEpochDay(newValue);
        case ChronoField.ALIGNED_WEEK_OF_MONTH:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
        case ChronoField.ALIGNED_WEEK_OF_YEAR:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    if (this._year === year) {
      return this;
    }
    ChronoField.YEAR.checkValidValue(year);
    return LocalDate._resolvePreviousValid(year, this._month, this._day);
  };
  _proto.withMonth = function withMonth(month) {
    var m = month instanceof Month ? month.value() : month;
    if (this._month === m) {
      return this;
    }
    ChronoField.MONTH_OF_YEAR.checkValidValue(m);
    return LocalDate._resolvePreviousValid(this._year, m, this._day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (this._day === dayOfMonth) {
      return this;
    }
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    if (this.dayOfYear() === dayOfYear) {
      return this;
    }
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.plusDays(amountToAdd);
        case ChronoUnit.WEEKS:
          return this.plusWeeks(amountToAdd);
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);
  };
  _proto.plusWeeks = function plusWeeks(weeksToAdd) {
    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
    return LocalDate.ofEpochDay(mjDay);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(yearsToSubtract * -1);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(monthsToSubtract * -1);
  };
  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
    return this.plusWeeks(weeksToSubtract * -1);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(daysToSubtract * -1);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.localDate()) {
      return this;
    }
    return _ChronoLocalDate.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(p1, p2) {
    if (arguments.length < 2) {
      return this.until1(p1);
    } else {
      return this.until2(p1, p2);
    }
  };
  _proto.until2 = function until2(endExclusive, unit) {
    var end = LocalDate.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.daysUntil(end);
        case ChronoUnit.WEEKS:
          return MathUtil.intDiv(this.daysUntil(end), 7);
        case ChronoUnit.MONTHS:
          return this._monthsUntil(end);
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(this._monthsUntil(end), 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(this._monthsUntil(end), 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(this._monthsUntil(end), 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(this._monthsUntil(end), 12000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.daysUntil = function daysUntil(end) {
    return end.toEpochDay() - this.toEpochDay();
  };
  _proto._monthsUntil = function _monthsUntil(end) {
    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
    return MathUtil.intDiv(packed2 - packed1, 32);
  };
  _proto.until1 = function until1(endDate) {
    var end = LocalDate.from(endDate);
    var totalMonths = end._prolepticMonth() - this._prolepticMonth();
    var days = end._day - this._day;
    if (totalMonths > 0 && days < 0) {
      totalMonths--;
      var calcDate = this.plusMonths(totalMonths);
      days = end.toEpochDay() - calcDate.toEpochDay();
    } else if (totalMonths < 0 && days > 0) {
      totalMonths++;
      days -= end.lengthOfMonth();
    }
    var years = MathUtil.intDiv(totalMonths, 12);
    var months = MathUtil.intMod(totalMonths, 12);
    return Period.of(years, months, days);
  };
  _proto.atTime = function atTime() {
    if (arguments.length === 1) {
      return this.atTime1.apply(this, arguments);
    } else {
      return this.atTime4.apply(this, arguments);
    }
  };
  _proto.atTime1 = function atTime1(time) {
    requireNonNull(time, 'time');
    if (time instanceof LocalTime) {
      return LocalDateTime.of(this, time);
    } else if (time instanceof OffsetTime) {
      return this._atTimeOffsetTime(time);
    } else {
      throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ''));
    }
  };
  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
  };
  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
    return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
  };
  _proto.atStartOfDay = function atStartOfDay(zone) {
    if (zone != null) {
      return this._atStartOfDayWithZone(zone);
    } else {
      return LocalDateTime.of(this, LocalTime.MIDNIGHT);
    }
  };
  _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
    requireNonNull(zone, 'zone');
    var ldt = this.atTime(LocalTime.MIDNIGHT);
    if (zone instanceof ZoneOffset === false) {
      var trans = zone.rules().transition(ldt);
      if (trans != null && trans.isGap()) {
        ldt = trans.dateTimeAfter();
      }
    }
    return ZonedDateTime.of(ldt, zone);
  };
  _proto.toEpochDay = function toEpochDay() {
    var y = this._year;
    var m = this._month;
    var total = 0;
    total += 365 * y;
    if (y >= 0) {
      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
    } else {
      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
    }
    total += MathUtil.intDiv(367 * m - 362, 12);
    total += this.dayOfMonth() - 1;
    if (m > 2) {
      total--;
      if (!IsoChronology.isLeapYear(y)) {
        total--;
      }
    }
    return total - DAYS_0000_TO_1970;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDate, 'other');
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(otherDate) {
    var cmp = this._year - otherDate._year;
    if (cmp === 0) {
      cmp = this._month - otherDate._month;
      if (cmp === 0) {
        cmp = this._day - otherDate._day;
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDate) {
      return this._compareTo0(other) === 0;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
  };
  _proto.toString = function toString() {
    var dayString, monthString, yearString;
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    var absYear = Math.abs(yearValue);
    if (absYear < 1000) {
      if (yearValue < 0) {
        yearString = "-" + ("" + (yearValue - 10000)).slice(-4);
      } else {
        yearString = ("" + (yearValue + 10000)).slice(-4);
      }
    } else {
      if (yearValue > 9999) {
        yearString = "+" + yearValue;
      } else {
        yearString = "" + yearValue;
      }
    }
    if (monthValue < 10) {
      monthString = "-0" + monthValue;
    } else {
      monthString = "-" + monthValue;
    }
    if (dayValue < 10) {
      dayString = "-0" + dayValue;
    } else {
      dayString = "-" + dayValue;
    }
    return yearString + monthString + dayString;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return _ChronoLocalDate.prototype.format.call(this, formatter);
  };
  return LocalDate;
}(ChronoLocalDate);
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {
    return LocalDate.from(temporal);
  });
}

var ChronoLocalDateTime = function (_Temporal) {
  _inheritsLoose(ChronoLocalDateTime, _Temporal);
  function ChronoLocalDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDateTime.prototype;
  _proto.chronology = function chronology() {
    return this.toLocalDate().chronology();
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
  };
  _proto.toInstant = function toInstant(offset) {
    requireInstance(offset, ZoneOffset, 'zoneId');
    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond(offset) {
    requireNonNull(offset, 'offset');
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= offset.totalSeconds();
    return MathUtil.safeToInt(secs);
  };
  return ChronoLocalDateTime;
}(Temporal);

var LocalDateTime = function (_ChronoLocalDateTime) {
  _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);
  LocalDateTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalDateTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalDateTime._now(clockOrZone);
    } else {
      return LocalDateTime._now(Clock.system(clockOrZone));
    }
  };
  LocalDateTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    return LocalDateTime.ofInstant(clock.instant(), clock.zone());
  };
  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.of = function of() {
    if (arguments.length <= 2) {
      return LocalDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return LocalDateTime.ofNumbers.apply(this, arguments);
    }
  };
  LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var date = LocalDate.of(year, month, dayOfMonth);
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {
    requireNonNull(date, 'date');
    requireNonNull(time, 'time');
    return new LocalDateTime(date, time);
  };
  LocalDateTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    var offset = zone.rules().offset(instant);
    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
  };
  LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
    if (epochSecond === void 0) {
      epochSecond = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
      offset = nanoOfSecond;
      nanoOfSecond = 0;
    }
    requireNonNull(offset, 'offset');
    var localSecond = epochSecond + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof LocalDateTime) {
      return temporal;
    } else if (temporal instanceof ZonedDateTime) {
      return temporal.toLocalDateTime();
    }
    try {
      var date = LocalDate.from(temporal);
      var time = LocalTime.from(temporal);
      return new LocalDateTime(date, time);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  LocalDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalDateTime.FROM);
  };
  function LocalDateTime(date, time) {
    var _this;
    _this = _ChronoLocalDateTime.call(this) || this;
    requireInstance(date, LocalDate, 'date');
    requireInstance(time, LocalTime, 'time');
    _this._date = date;
    _this._time = time;
    return _this;
  }
  var _proto = LocalDateTime.prototype;
  _proto._withDateTime = function _withDateTime(newDate, newTime) {
    if (this._date.equals(newDate) && this._time.equals(newTime)) {
      return this;
    }
    return new LocalDateTime(newDate, newTime);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
    }
    return _ChronoLocalDateTime.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.year = function year() {
    return this._date.year();
  };
  _proto.monthValue = function monthValue() {
    return this._date.monthValue();
  };
  _proto.month = function month() {
    return this._date.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._date.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._date.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._date.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalDate) {
      return this._withDateTime(adjuster, this._time);
    } else if (adjuster instanceof LocalTime) {
      return this._withDateTime(this._date, adjuster);
    } else if (adjuster instanceof LocalDateTime) {
      return adjuster;
    }
    return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      if (field.isTimeBased()) {
        return this._withDateTime(this._date, this._time.with(field, newValue));
      } else {
        return this._withDateTime(this._date.with(field, newValue), this._time);
      }
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTime(this._date.withYear(year), this._time);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTime(this._date.withMonth(month), this._time);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
  };
  _proto.withHour = function withHour(hour) {
    var newTime = this._time.withHour(hour);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withMinute = function withMinute(minute) {
    var newTime = this._time.withMinute(minute);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withSecond = function withSecond(second) {
    var newTime = this._time.withSecond(second);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    var newTime = this._time.withNano(nanoOfSecond);
    return this._withDateTime(this._date, newTime);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTime(this._date, this._time.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
      }
      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    var newDate = this._date.plusYears(years);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusMonths = function plusMonths(months) {
    var newDate = this._date.plusMonths(months);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    var newDate = this._date.plusWeeks(weeks);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusDays = function plusDays(days) {
    var newDate = this._date.plusDays(days);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
  };
  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
      return this._withDateTime(newDate, this._time);
    }
    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
    totDays *= sign;
    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
    var curNoD = this._time.toNanoOfDay();
    totNanos = totNanos * sign + curNoD;
    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
    return this._withDateTime(newDate.plusDays(totDays), newTime);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    return _ChronoLocalDateTime.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      if (unit.isTimeBased()) {
        var daysUntil = this._date.daysUntil(end._date);
        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
        if (daysUntil > 0 && timeUntil < 0) {
          daysUntil--;
          timeUntil += LocalTime.NANOS_PER_DAY;
        } else if (daysUntil < 0 && timeUntil > 0) {
          daysUntil++;
          timeUntil -= LocalTime.NANOS_PER_DAY;
        }
        var amount = daysUntil;
        switch (unit) {
          case ChronoUnit.NANOS:
            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
            return MathUtil.safeAdd(amount, timeUntil);
          case ChronoUnit.MICROS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));
          case ChronoUnit.MILLIS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));
          case ChronoUnit.SECONDS:
            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
          case ChronoUnit.MINUTES:
            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
          case ChronoUnit.HOURS:
            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
          case ChronoUnit.HALF_DAYS:
            amount = MathUtil.safeMultiply(amount, 2);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      }
      var endDate = end._date;
      var endTime = end._time;
      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
        endDate = endDate.minusDays(1);
      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
        endDate = endDate.plusDays(1);
      }
      return this._date.until(endDate, unit);
    }
    return unit.between(this, end);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.of(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.of(this, zone);
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._date;
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDateTime, 'other');
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(other) {
    var cmp = this._date.compareTo(other.toLocalDate());
    if (cmp === 0) {
      cmp = this._time.compareTo(other.toLocalTime());
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDateTime) {
      return this._date.equals(other._date) && this._time.equals(other._time);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._date.hashCode() ^ this._time.hashCode();
  };
  _proto.toString = function toString() {
    return this._date.toString() + "T" + this._time.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return LocalDateTime;
}(ChronoLocalDateTime);
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {
    return LocalDateTime.from(temporal);
  });
}

var LocalTime = function (_Temporal) {
  _inheritsLoose(LocalTime, _Temporal);
  LocalTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalTime._now(clockOrZone);
    } else {
      return LocalTime._now(Clock.system(clockOrZone));
    }
  };
  LocalTime._now = function _now(clock) {
    if (clock === void 0) {
      clock = Clock.systemDefaultZone();
    }
    requireNonNull(clock, 'clock');
    return LocalTime.ofInstant(clock.instant(), clock.zone());
  };
  LocalTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    var offset = zone.rules().offset(instant);
    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);
    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);
    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }
    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
  };
  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {
    return new LocalTime(hour, minute, second, nanoOfSecond);
  };
  LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
    if (secondOfDay === void 0) {
      secondOfDay = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);
    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;
    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);
    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;
    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);
  };
  LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
    if (nanoOfDay === void 0) {
      nanoOfDay = 0;
    }
    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);
    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;
    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);
    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;
    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);
    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;
    return new LocalTime(hours, minutes, seconds, nanoOfDay);
  };
  LocalTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var time = temporal.query(TemporalQueries.localTime());
    if (time == null) {
      throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return time;
  };
  LocalTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalTime.FROM);
  };
  function LocalTime(hour, minute, second, nanoOfSecond) {
    var _this;
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    _this = _Temporal.call(this) || this;
    var _hour = MathUtil.safeToInt(hour);
    var _minute = MathUtil.safeToInt(minute);
    var _second = MathUtil.safeToInt(second);
    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);
    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
      if (!LocalTime.HOURS[_hour]) {
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        LocalTime.HOURS[_hour] = _assertThisInitialized(_this);
      }
      return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);
    }
    _this._hour = _hour;
    _this._minute = _minute;
    _this._second = _second;
    _this._nano = _nanoOfSecond;
    return _this;
  }
  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {
    ChronoField.HOUR_OF_DAY.checkValidValue(hour);
    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
  };
  var _proto = LocalTime.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    requireNonNull(field);
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.NANO_OF_SECOND:
        return this._nano;
      case ChronoField.NANO_OF_DAY:
        return this.toNanoOfDay();
      case ChronoField.MICRO_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000);
      case ChronoField.MICRO_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000);
      case ChronoField.MILLI_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000000);
      case ChronoField.MILLI_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);
      case ChronoField.SECOND_OF_MINUTE:
        return this._second;
      case ChronoField.SECOND_OF_DAY:
        return this.toSecondOfDay();
      case ChronoField.MINUTE_OF_HOUR:
        return this._minute;
      case ChronoField.MINUTE_OF_DAY:
        return this._hour * 60 + this._minute;
      case ChronoField.HOUR_OF_AMPM:
        return MathUtil.intMod(this._hour, 12);
      case ChronoField.CLOCK_HOUR_OF_AMPM:
        {
          var ham = MathUtil.intMod(this._hour, 12);
          return ham % 12 === 0 ? 12 : ham;
        }
      case ChronoField.HOUR_OF_DAY:
        return this._hour;
      case ChronoField.CLOCK_HOUR_OF_DAY:
        return this._hour === 0 ? 24 : this._hour;
      case ChronoField.AMPM_OF_DAY:
        return MathUtil.intDiv(this._hour, 12);
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto.hour = function hour() {
    return this._hour;
  };
  _proto.minute = function minute() {
    return this._minute;
  };
  _proto.second = function second() {
    return this._second;
  };
  _proto.nano = function nano() {
    return this._nano;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalTime) {
      return adjuster;
    }
    return _Temporal.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this.withNano(newValue);
        case ChronoField.NANO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue);
        case ChronoField.MICRO_OF_SECOND:
          return this.withNano(newValue * 1000);
        case ChronoField.MICRO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000);
        case ChronoField.MILLI_OF_SECOND:
          return this.withNano(newValue * 1000000);
        case ChronoField.MILLI_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000000);
        case ChronoField.SECOND_OF_MINUTE:
          return this.withSecond(newValue);
        case ChronoField.SECOND_OF_DAY:
          return this.plusSeconds(newValue - this.toSecondOfDay());
        case ChronoField.MINUTE_OF_HOUR:
          return this.withMinute(newValue);
        case ChronoField.MINUTE_OF_DAY:
          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
        case ChronoField.HOUR_OF_AMPM:
          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
        case ChronoField.CLOCK_HOUR_OF_AMPM:
          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
        case ChronoField.HOUR_OF_DAY:
          return this.withHour(newValue);
        case ChronoField.CLOCK_HOUR_OF_DAY:
          return this.withHour(newValue === 24 ? 0 : newValue);
        case ChronoField.AMPM_OF_DAY:
          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withHour = function withHour(hour) {
    if (hour === void 0) {
      hour = 0;
    }
    if (this._hour === hour) {
      return this;
    }
    return new LocalTime(hour, this._minute, this._second, this._nano);
  };
  _proto.withMinute = function withMinute(minute) {
    if (minute === void 0) {
      minute = 0;
    }
    if (this._minute === minute) {
      return this;
    }
    return new LocalTime(this._hour, minute, this._second, this._nano);
  };
  _proto.withSecond = function withSecond(second) {
    if (second === void 0) {
      second = 0;
    }
    if (this._second === second) {
      return this;
    }
    return new LocalTime(this._hour, this._minute, second, this._nano);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (this._nano === nanoOfSecond) {
      return this;
    }
    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }
    var nod = this.toNanoOfDay();
    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    if (hoursToAdd === 0) {
      return this;
    }
    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);
    return new LocalTime(newHour, this._minute, this._second, this._nano);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    if (minutesToAdd === 0) {
      return this;
    }
    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;
    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);
    if (mofd === newMofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);
    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);
    return new LocalTime(newHour, newMinute, this._second, this._nano);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    if (secondsToAdd === 0) {
      return this;
    }
    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;
    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);
    if (sofd === newSofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);
    return new LocalTime(newHour, newMinute, newSecond, this._nano);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    if (nanosToAdd === 0) {
      return this;
    }
    var nofd = this.toNanoOfDay();
    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);
    if (nofd === newNofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);
    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);
    return new LocalTime(newHour, newMinute, newSecond, newNano);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localTime()) {
      return this;
    }
    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1000);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1000000);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.atDate = function atDate(date) {
    return LocalDateTime.of(date, this);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetTime.of(this, offset);
  };
  _proto.toSecondOfDay = function toSecondOfDay() {
    var total = this._hour * LocalTime.SECONDS_PER_HOUR;
    total += this._minute * LocalTime.SECONDS_PER_MINUTE;
    total += this._second;
    return total;
  };
  _proto.toNanoOfDay = function toNanoOfDay() {
    var total = this._hour * LocalTime.NANOS_PER_HOUR;
    total += this._minute * LocalTime.NANOS_PER_MINUTE;
    total += this._second * LocalTime.NANOS_PER_SECOND;
    total += this._nano;
    return total;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalTime, 'other');
    var cmp = MathUtil.compareNumbers(this._hour, other._hour);
    if (cmp === 0) {
      cmp = MathUtil.compareNumbers(this._minute, other._minute);
      if (cmp === 0) {
        cmp = MathUtil.compareNumbers(this._second, other._second);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._nano, other._nano);
        }
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalTime) {
      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var nod = this.toNanoOfDay();
    return MathUtil.hash(nod);
  };
  _proto.toString = function toString() {
    var buf = '';
    var hourValue = this._hour;
    var minuteValue = this._minute;
    var secondValue = this._second;
    var nanoValue = this._nano;
    buf += hourValue < 10 ? '0' : '';
    buf += hourValue;
    buf += minuteValue < 10 ? ':0' : ':';
    buf += minuteValue;
    if (secondValue > 0 || nanoValue > 0) {
      buf += secondValue < 10 ? ':0' : ':';
      buf += secondValue;
      if (nanoValue > 0) {
        buf += '.';
        if (MathUtil.intMod(nanoValue, 1000000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);
        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);
        } else {
          buf += ("" + (nanoValue + 1000000000)).substring(1);
        }
      }
    }
    return buf;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return LocalTime;
}(Temporal);
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {
    return LocalTime.from(temporal);
  });
}
LocalTime.HOURS_PER_DAY = 24;
LocalTime.MINUTES_PER_HOUR = 60;
LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.SECONDS_PER_MINUTE = 60;
LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;
LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;
LocalTime.NANOS_PER_SECOND = 1000000000;
LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;

var NANOS_PER_MILLI = 1000000;
var Instant = function (_Temporal) {
  _inheritsLoose(Instant, _Temporal);
  Instant.now = function now(clock) {
    if (clock === void 0) {
      clock = Clock.systemUTC();
    }
    return clock.instant();
  };
  Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Instant._create(secs, nos);
  };
  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {
    var secs = MathUtil.floorDiv(epochMilli, 1000);
    var mos = MathUtil.floorMod(epochMilli, 1000);
    return Instant._create(secs, mos * 1000000);
  };
  Instant.ofEpochMicro = function ofEpochMicro(epochMicro) {
    var secs = MathUtil.floorDiv(epochMicro, 1000000);
    var mos = MathUtil.floorMod(epochMicro, 1000000);
    return Instant._create(secs, mos * 1000);
  };
  Instant.from = function from(temporal) {
    try {
      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
    }
  };
  Instant.parse = function parse(text) {
    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);
  };
  Instant._create = function _create(seconds, nanoOfSecond) {
    if (seconds === 0 && nanoOfSecond === 0) {
      return Instant.EPOCH;
    }
    return new Instant(seconds, nanoOfSecond);
  };
  Instant._validate = function _validate(seconds, nanoOfSecond) {
    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }
    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }
  };
  function Instant(seconds, nanoOfSecond) {
    var _this;
    _this = _Temporal.call(this) || this;
    Instant._validate(seconds, nanoOfSecond);
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanoOfSecond);
    return _this;
  }
  var _proto = Instant.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this._nanos;
        case ChronoField.MICRO_OF_SECOND:
          return MathUtil.intDiv(this._nanos, 1000);
        case ChronoField.MILLI_OF_SECOND:
          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
        case ChronoField.INSTANT_SECONDS:
          return this._seconds;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.epochSecond = function epochSecond() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.MILLI_OF_SECOND:
          {
            var nval = newValue * NANOS_PER_MILLI;
            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;
          }
        case ChronoField.MICRO_OF_SECOND:
          {
            var _nval = newValue * 1000;
            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;
          }
        case ChronoField.NANO_OF_SECOND:
          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;
        case ChronoField.INSTANT_SECONDS:
          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }
    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
    var result = MathUtil.intDiv(nod, dur) * dur;
    return this.plusNanos(result - nod);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusMicros(amountToAdd);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
        case ChronoUnit.HOURS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
        case ChronoUnit.HALF_DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
        case ChronoUnit.DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this._plus(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this._plus(0, nanosToAdd);
  };
  _proto.plusMicros = function plusMicros(microsToAdd) {
    return this._plus(MathUtil.intDiv(microsToAdd, 1000000), MathUtil.intMod(microsToAdd, 1000000) * 1000);
  };
  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = this._seconds + secondsToAdd;
    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
    return Instant.ofEpochSecond(epochSec, nanoAdjustment);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(secondsToSubtract * -1);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return this.plusMillis(-1 * millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * nanosToSubtract);
  };
  _proto.minusMicros = function minusMicros(microsToSubtract) {
    return this.plusMicros(-1 * microsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    }
    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = Instant.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this._nanosUntil(end);
        case ChronoUnit.MICROS:
          return this._microsUntil(end);
        case ChronoUnit.MILLIS:
          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
        case ChronoUnit.SECONDS:
          return this._secondsUntil(end);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto._microsUntil = function _microsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalMicros = MathUtil.safeMultiply(secsDiff, 1000000);
    return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1000));
  };
  _proto._nanosUntil = function _nanosUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
  };
  _proto._secondsUntil = function _secondsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var nanosDiff = end.nano() - this.nano();
    if (secsDiff > 0 && nanosDiff < 0) {
      secsDiff--;
    } else if (secsDiff < 0 && nanosDiff > 0) {
      secsDiff++;
    }
    return secsDiff;
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.ofInstant(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.ofInstant(this, zone);
  };
  _proto.toEpochMilli = function toEpochMilli() {
    var millis = MathUtil.safeMultiply(this._seconds, 1000);
    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
  };
  _proto.compareTo = function compareTo(otherInstant) {
    requireNonNull(otherInstant, 'otherInstant');
    requireInstance(otherInstant, Instant, 'otherInstant');
    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
    if (cmp !== 0) {
      return cmp;
    }
    return this._nanos - otherInstant._nanos;
  };
  _proto.isAfter = function isAfter(otherInstant) {
    return this.compareTo(otherInstant) > 0;
  };
  _proto.isBefore = function isBefore(otherInstant) {
    return this.compareTo(otherInstant) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Instant) {
      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._seconds, this._nanos);
  };
  _proto.toString = function toString() {
    return DateTimeFormatter.ISO_INSTANT.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Instant;
}(Temporal);
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {
    return Instant.from(temporal);
  });
}

var Clock = function () {
  function Clock() {}
  Clock.systemUTC = function systemUTC() {
    return new SystemClock(ZoneOffset.UTC);
  };
  Clock.systemDefaultZone = function systemDefaultZone() {
    return new SystemClock(ZoneId.systemDefault());
  };
  Clock.system = function system(zone) {
    return new SystemClock(zone);
  };
  Clock.fixed = function fixed(fixedInstant, zoneId) {
    return new FixedClock(fixedInstant, zoneId);
  };
  Clock.offset = function offset(baseClock, duration) {
    return new OffsetClock(baseClock, duration);
  };
  var _proto = Clock.prototype;
  _proto.millis = function millis() {
    abstractMethodFail('Clock.millis');
  };
  _proto.instant = function instant() {
    abstractMethodFail('Clock.instant');
  };
  _proto.zone = function zone() {
    abstractMethodFail('Clock.zone');
  };
  _proto.withZone = function withZone() {
    abstractMethodFail('Clock.withZone');
  };
  return Clock;
}();
var SystemClock = function (_Clock) {
  _inheritsLoose(SystemClock, _Clock);
  function SystemClock(zone) {
    var _this;
    requireNonNull(zone, 'zone');
    _this = _Clock.call(this) || this;
    _this._zone = zone;
    return _this;
  }
  var _proto2 = SystemClock.prototype;
  _proto2.zone = function zone() {
    return this._zone;
  };
  _proto2.millis = function millis() {
    return new Date().getTime();
  };
  _proto2.instant = function instant() {
    return Instant.ofEpochMilli(this.millis());
  };
  _proto2.equals = function equals(obj) {
    if (obj instanceof SystemClock) {
      return this._zone.equals(obj._zone);
    }
    return false;
  };
  _proto2.withZone = function withZone(zone) {
    if (zone.equals(this._zone)) {
      return this;
    }
    return new SystemClock(zone);
  };
  _proto2.toString = function toString() {
    return "SystemClock[" + this._zone.toString() + "]";
  };
  return SystemClock;
}(Clock);
var FixedClock = function (_Clock2) {
  _inheritsLoose(FixedClock, _Clock2);
  function FixedClock(fixedInstant, zoneId) {
    var _this2;
    _this2 = _Clock2.call(this) || this;
    _this2._instant = fixedInstant;
    _this2._zoneId = zoneId;
    return _this2;
  }
  var _proto3 = FixedClock.prototype;
  _proto3.instant = function instant() {
    return this._instant;
  };
  _proto3.millis = function millis() {
    return this._instant.toEpochMilli();
  };
  _proto3.zone = function zone() {
    return this._zoneId;
  };
  _proto3.toString = function toString() {
    return 'FixedClock[]';
  };
  _proto3.equals = function equals(obj) {
    if (obj instanceof FixedClock) {
      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
    }
    return false;
  };
  _proto3.withZone = function withZone(zone) {
    if (zone.equals(this._zoneId)) {
      return this;
    }
    return new FixedClock(this._instant, zone);
  };
  return FixedClock;
}(Clock);
var OffsetClock = function (_Clock3) {
  _inheritsLoose(OffsetClock, _Clock3);
  function OffsetClock(baseClock, offset) {
    var _this3;
    _this3 = _Clock3.call(this) || this;
    _this3._baseClock = baseClock;
    _this3._offset = offset;
    return _this3;
  }
  var _proto4 = OffsetClock.prototype;
  _proto4.zone = function zone() {
    return this._baseClock.zone();
  };
  _proto4.withZone = function withZone(zone) {
    if (zone.equals(this._baseClock.zone())) {
      return this;
    }
    return new OffsetClock(this._baseClock.withZone(zone), this._offset);
  };
  _proto4.millis = function millis() {
    return this._baseClock.millis() + this._offset.toMillis();
  };
  _proto4.instant = function instant() {
    return this._baseClock.instant().plus(this._offset);
  };
  _proto4.equals = function equals(obj) {
    if (obj instanceof OffsetClock) {
      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
    }
    return false;
  };
  _proto4.toString = function toString() {
    return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
  };
  return OffsetClock;
}(Clock);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneOffsetTransition = function () {
  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {
    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
  };
  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {
    requireNonNull(transition, 'transition');
    requireNonNull(offsetBefore, 'offsetBefore');
    requireNonNull(offsetAfter, 'offsetAfter');
    if (offsetBefore.equals(offsetAfter)) {
      throw new IllegalArgumentException('Offsets must not be equal');
    }
    if (transition.nano() !== 0) {
      throw new IllegalArgumentException('Nano-of-second must be zero');
    }
    if (transition instanceof LocalDateTime) {
      this._transition = transition;
    } else {
      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
    }
    this._offsetBefore = offsetBefore;
    this._offsetAfter = offsetAfter;
  }
  var _proto = ZoneOffsetTransition.prototype;
  _proto.instant = function instant() {
    return this._transition.toInstant(this._offsetBefore);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._transition.toEpochSecond(this._offsetBefore);
  };
  _proto.dateTimeBefore = function dateTimeBefore() {
    return this._transition;
  };
  _proto.dateTimeAfter = function dateTimeAfter() {
    return this._transition.plusSeconds(this.durationSeconds());
  };
  _proto.offsetBefore = function offsetBefore() {
    return this._offsetBefore;
  };
  _proto.offsetAfter = function offsetAfter() {
    return this._offsetAfter;
  };
  _proto.duration = function duration() {
    return Duration.ofSeconds(this.durationSeconds());
  };
  _proto.durationSeconds = function durationSeconds() {
    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
  };
  _proto.isGap = function isGap() {
    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
  };
  _proto.isOverlap = function isOverlap() {
    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
  };
  _proto.isValidOffset = function isValidOffset(offset) {
    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
  };
  _proto.validOffsets = function validOffsets() {
    if (this.isGap()) {
      return [];
    } else {
      return [this._offsetBefore, this._offsetAfter];
    }
  };
  _proto.compareTo = function compareTo(transition) {
    return this.instant().compareTo(transition.instant());
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ZoneOffsetTransition) {
      var d = other;
      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
  };
  _proto.toString = function toString() {
    return "Transition[" + (this.isGap() ? 'Gap' : 'Overlap') + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
  };
  return ZoneOffsetTransition;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}

var SystemDefaultZoneRules = function (_ZoneRules) {
  _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);
  function SystemDefaultZoneRules() {
    return _ZoneRules.apply(this, arguments) || this;
  }
  var _proto = SystemDefaultZoneRules.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    return false;
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;
    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;
    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    return [this.offsetOfLocalDateTime(localDateTime)];
  };
  _proto.transition = function transition() {
    return null;
  };
  _proto.standardOffset = function standardOffset(instant) {
    return this.offsetOfInstant(instant);
  };
  _proto.daylightSavings = function daylightSavings() {
    this._throwNotSupported();
  };
  _proto.isDaylightSavings = function isDaylightSavings() {
    this._throwNotSupported();
  };
  _proto.isValidOffset = function isValidOffset(dateTime, offset) {
    return this.offsetOfLocalDateTime(dateTime).equals(offset);
  };
  _proto.nextTransition = function nextTransition() {
    this._throwNotSupported();
  };
  _proto.previousTransition = function previousTransition() {
    this._throwNotSupported();
  };
  _proto.transitions = function transitions() {
    this._throwNotSupported();
  };
  _proto.transitionRules = function transitionRules() {
    this._throwNotSupported();
  };
  _proto._throwNotSupported = function _throwNotSupported() {
    throw new DateTimeException('not supported operation');
  };
  _proto.equals = function equals(other) {
    if (this === other || other instanceof SystemDefaultZoneRules) {
      return true;
    } else {
      return false;
    }
  };
  _proto.toString = function toString() {
    return 'SYSTEM';
  };
  return SystemDefaultZoneRules;
}(ZoneRules);

var SystemDefaultZoneId = function (_ZoneId) {
  _inheritsLoose(SystemDefaultZoneId, _ZoneId);
  function SystemDefaultZoneId() {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._rules = new SystemDefaultZoneRules();
    return _this;
  }
  var _proto = SystemDefaultZoneId.prototype;
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    return false;
  };
  _proto.id = function id() {
    return 'SYSTEM';
  };
  return SystemDefaultZoneId;
}(ZoneId);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdFactory = function () {
  function ZoneIdFactory() {}
  ZoneIdFactory.systemDefault = function systemDefault() {
    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  };
  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {
    return ZoneRulesProvider.getAvailableZoneIds();
  };
  ZoneIdFactory.of = function of(zoneId) {
    requireNonNull(zoneId, 'zoneId');
    if (zoneId === 'Z') {
      return ZoneOffset.UTC;
    }
    if (zoneId.length === 1) {
      throw new DateTimeException("Invalid zone: " + zoneId);
    }
    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {
      return ZoneOffset.of(zoneId);
    }
    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {
      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
    }
    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {
      var offset = ZoneOffset.of(zoneId.substring(3));
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
      }
      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
    }
    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {
      var _offset = ZoneOffset.of(zoneId.substring(2));
      if (_offset.totalSeconds() === 0) {
        return new ZoneRegion('UT', _offset.rules());
      }
      return new ZoneRegion("UT" + _offset.id(), _offset.rules());
    }
    if (zoneId === 'SYSTEM') {
      return ZoneId.systemDefault();
    }
    return ZoneRegion.ofId(zoneId);
  };
  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {
    requireNonNull(prefix, 'prefix');
    requireNonNull(offset, 'offset');
    if (prefix.length === 0) {
      return offset;
    }
    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(prefix, offset.rules());
      }
      return new ZoneRegion(prefix + offset.id(), offset.rules());
    }
    throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
  };
  ZoneIdFactory.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var obj = temporal.query(TemporalQueries.zone());
    if (obj == null) {
      throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return obj;
  };
  return ZoneIdFactory;
}();
var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var isInit = false;
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
init();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ToNativeJsConverter = function () {
  function ToNativeJsConverter(temporal, zone) {
    var zonedDateTime;
    if (temporal instanceof Instant) {
      this.instant = temporal;
      return;
    } else if (temporal instanceof LocalDate) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atStartOfDay(zone);
    } else if (temporal instanceof LocalDateTime) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atZone(zone);
    } else if (temporal instanceof ZonedDateTime) {
      if (zone == null) {
        zonedDateTime = temporal;
      } else {
        zonedDateTime = temporal.withZoneSameInstant(zone);
      }
    } else {
      throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
    }
    this.instant = zonedDateTime.toInstant();
  }
  var _proto = ToNativeJsConverter.prototype;
  _proto.toDate = function toDate() {
    return new Date(this.instant.toEpochMilli());
  };
  _proto.toEpochMilli = function toEpochMilli() {
    return this.instant.toEpochMilli();
  };
  return ToNativeJsConverter;
}();
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}

/*
 * @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, 'date');
  requireNonNull(zone, 'zone');
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException('date must be a javascript Date or a moment instance');
}

function bindUse(jsJoda) {
  var used = [];
  return function use(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var _ = {
  assert: assert$1,
  DateTimeBuilder: DateTimeBuilder,
  DateTimeParseContext: DateTimeParseContext,
  DateTimePrintContext: DateTimePrintContext,
  MathUtil: MathUtil,
  StringUtil: StringUtil,
  StringBuilder: StringBuilder
};
var jsJodaExports = {
  _: _,
  convert: convert,
  nativeJs: nativeJs,
  ArithmeticException: ArithmeticException,
  DateTimeException: DateTimeException,
  DateTimeParseException: DateTimeParseException,
  IllegalArgumentException: IllegalArgumentException,
  IllegalStateException: IllegalStateException,
  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,
  NullPointerException: NullPointerException,
  Clock: Clock,
  DayOfWeek: DayOfWeek,
  Duration: Duration,
  Instant: Instant,
  LocalDate: LocalDate,
  LocalTime: LocalTime,
  LocalDateTime: LocalDateTime,
  OffsetTime: OffsetTime,
  OffsetDateTime: OffsetDateTime,
  Month: Month,
  MonthDay: MonthDay,
  ParsePosition: ParsePosition,
  Period: Period,
  Year: Year,
  YearConstants: YearConstants,
  YearMonth: YearMonth,
  ZonedDateTime: ZonedDateTime,
  ZoneOffset: ZoneOffset,
  ZoneId: ZoneId,
  ZoneRegion: ZoneRegion,
  ZoneOffsetTransition: ZoneOffsetTransition,
  ZoneRules: ZoneRules,
  ZoneRulesProvider: ZoneRulesProvider,
  ChronoLocalDate: ChronoLocalDate,
  ChronoLocalDateTime: ChronoLocalDateTime,
  ChronoZonedDateTime: ChronoZonedDateTime,
  IsoChronology: IsoChronology,
  ChronoField: ChronoField,
  ChronoUnit: ChronoUnit,
  IsoFields: IsoFields,
  Temporal: Temporal,
  TemporalAccessor: TemporalAccessor,
  TemporalAdjuster: TemporalAdjuster,
  TemporalAdjusters: TemporalAdjusters,
  TemporalAmount: TemporalAmount,
  TemporalField: TemporalField,
  TemporalQueries: TemporalQueries,
  TemporalQuery: TemporalQuery,
  TemporalUnit: TemporalUnit,
  ValueRange: ValueRange,
  DateTimeFormatter: DateTimeFormatter,
  DateTimeFormatterBuilder: DateTimeFormatterBuilder,
  DecimalStyle: DecimalStyle,
  ResolverStyle: ResolverStyle,
  SignStyle: SignStyle,
  TextStyle: TextStyle
};
var use = bindUse(jsJodaExports);
jsJodaExports.use = use;

/**
 * compare ZonedDateTimes from js-joda
 * returns a negative number if a is less than b, positive if a is greater than b, and zero if they are equal.
 * This function also returns 0 if one of the given values could not be parsed.
 *
 * @param {ZonedDateTime | string} a
 * @param {ZonedDateTime | string} b
 * @returns {0|1|-1}
 *
 */
const compareZonedDateTimes = (a, b) => {
  // catch js-joda exception if a or b can't be parsed
  try {
    const date1 = a instanceof ZonedDateTime ? a : ZonedDateTime.parse(a);
    const date2 = b instanceof ZonedDateTime ? b : ZonedDateTime.parse(b);
    const duration = Duration.between(date1, date2);

    // return number based on js sort function
    // > negative if a is less than b, positive if a is greater than b, and zero if they are equal.
    // [Sort Documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#comparefn)
    if (duration.isZero()) {
      return 0
    } else if (duration.isNegative()) {
      return 1
    } else {
      return -1
    }
  } catch(e) {
    return 0
  }
};

const { gt, valid: valid$4 } = semver$1;

/**
 * @param {unknown} doc
 */
function mandatoryTest_6_1_14(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (preconditionMatches(doc)) {
    const sortedNumbers = Array.from(
      new Set(
        doc.document.tracking.revision_history
          .slice()
          .sort(
            (a, z) =>
              compareZonedDateTimes(a.date, z.date) ||
              compareVersions(z.number, a.number)
          )
          .map((e) => valid$4(e.number) ?? `${e.number}.0.0`)
      ).keys()
    ).filter((n) => valid$4(n) !== null);
    const isAscending = sortedNumbers.every(
      (number, index, all) => index === 0 || gt(number, all[index - 1])
    );
    if (!isAscending) {
      isValid = false;
      errors.push({
        instancePath: `/document/tracking/revision_history`,
        message: 'the items must be in ascending order according to the date',
      });
    }
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 * @returns {doc is { document: { tracking: { revision_history: Array<{ number: string; date: string }> } } }}
 */
const preconditionMatches = (doc) =>
  Array.isArray(doc?.document?.tracking?.revision_history) &&
  doc.document.tracking.revision_history.every(
    (/** @type {any} */ r) =>
      typeof r.number === 'string' && typeof r.date === 'string'
  );

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_15(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    doc.document?.publisher?.category === 'translator' &&
    !doc.document.source_lang
  ) {
    isValid = false;
    errors.push({
      instancePath: '/document/publisher/category',
      message: 'source language attribute is missing',
    });
  }

  return { isValid, errors }
}

const {
  hasTrackingRevisionHistory: hasTrackingRevisionHistory$3,
  hasTrackingVersionField: hasTrackingVersionField$5,
  hasTrackingStatusField: hasTrackingStatusField$5,
} = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_16(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingRevisionHistory$3(doc) &&
    hasTrackingVersionField$5(doc) &&
    hasTrackingStatusField$5(doc) &&
    doc.document.tracking.revision_history.length > 0
  ) {
    /**
     * @param {string} version
     * @returns
     */
    const normalizeVersion = (version) =>
      doc.document.tracking.status == 'draft'
        ? version.split(/[+-]/)[0]
        : version.split('+')[0];

    if (
      normalizeVersion(
        doc.document.tracking.revision_history
          .slice()
          .sort(
            (a, z) =>
              compareZonedDateTimes(
                /** @type {string} */ (z.date),
                /** @type {string} */ (a.date)
              ) || compareVersions(a.number, z.number)
          )[0].number
      ) !== normalizeVersion(doc.document.tracking.version)
    ) {
      isValid = false;
      errors.push({
        message: 'version does not match latest revision',
        instancePath: '/document/tracking/version',
      });
    }
  }

  return { errors, isValid }
}

const { valid: valid$3, major: major$1, prerelease: prerelease$2 } = semver$1;
const { hasTrackingVersionField: hasTrackingVersionField$4, hasTrackingStatusField: hasTrackingStatusField$4 } = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_17(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingVersionField$4(doc) &&
    hasTrackingStatusField$4(doc) &&
    doc.document.tracking.status !== 'draft' &&
    (doc.document.tracking.version === '0' ||
      (valid$3(doc.document.tracking.version) &&
        (major$1(doc.document.tracking.version) === 0 ||
          prerelease$2(doc.document.tracking.version))))
  ) {
    isValid = false;
    errors.push({
      message: 'the status is not compatible with the version',
      instancePath: '/document/tracking/status',
    });
  }

  return { errors, isValid }
}

const { valid: valid$2, major } = semver$1;
const {
  hasTrackingVersionField: hasTrackingVersionField$3,
  hasTrackingStatusField: hasTrackingStatusField$3,
  hasTrackingRevisionHistory: hasTrackingRevisionHistory$2,
} = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_18(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingVersionField$3(doc) &&
    hasTrackingStatusField$3(doc) &&
    hasTrackingRevisionHistory$2(doc) &&
    (doc.document.tracking.status === 'final' ||
      doc.document.tracking.status === 'interim') &&
    doc.document.tracking.revision_history.some(
      (h) => h.number === '0' || (valid$2(h.number) && major(h.number) === 0)
    )
  ) {
    isValid = false;
    errors.push({
      message:
        'some revision-history entries are not compatible with the status',
      instancePath: '/document/tracking/status',
    });
  }

  return { errors, isValid }
}

const { valid: valid$1, prerelease: prerelease$1 } = semver$1;
const {
  hasTrackingVersionField: hasTrackingVersionField$2,
  hasTrackingStatusField: hasTrackingStatusField$2,
  hasTrackingRevisionHistory: hasTrackingRevisionHistory$1,
} = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_19(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingVersionField$2(doc) &&
    hasTrackingStatusField$2(doc) &&
    hasTrackingRevisionHistory$1(doc)
  ) {
    for (let i = 0; i < doc.document.tracking.revision_history.length; ++i) {
      const entry = doc.document.tracking.revision_history[i];
      if (valid$1(entry.number) && prerelease$1(entry.number)) {
        isValid = false;
        errors.push({
          message: 'contains prerelease part',
          instancePath: `/document/tracking/revision_history/${i}/number`,
        });
      }
    }
  }

  return { errors, isValid }
}

const { valid, prerelease } = semver$1;
const { hasTrackingVersionField: hasTrackingVersionField$1, hasTrackingStatusField: hasTrackingStatusField$1 } = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_20(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingVersionField$1(doc) &&
    hasTrackingStatusField$1(doc) &&
    (doc.document.tracking.status === 'final' ||
      doc.document.tracking.status === 'interim') &&
    valid(doc.document.tracking.version) &&
    prerelease(doc.document.tracking.version)
  ) {
    isValid = false;
    errors.push({
      message: 'pre-release part is not allowed for status',
      instancePath: `/document/tracking/version`,
    });
  }

  return { errors, isValid }
}

/**
 * @param {unknown} doc
 */
function mandatoryTest_6_1_21(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  // 6.1.21 Missing Item in Revision History
  if (preconditionFor_6_1_21_Matches(doc)) {
    const sortedNumbers = Array.from(
      new Set(
        doc.document.tracking.revision_history
          .slice()
          .sort((a, z) =>
            compareZonedDateTimes(
              /** @type {string} */ (a.date),
              /** @type {string} */ (z.date)
            )
          )
          .map((e) =>
            // By using `parseInt` here we can deal with numeric and semantic versions
            parseInt(e.number)
          )
      ).keys()
    );
    if (sortedNumbers.length > 0 && ![0, 1].includes(sortedNumbers[0])) {
      isValid = false;
      errors.push({
        instancePath: `/document/tracking/revision_history`,
        message: `revision history does not start with a version of 0 or 1 when sorted by date`,
      });
    }
    for (let i = 0; i < sortedNumbers.length; ++i) {
      const expectedVersionNumber = i + Number(sortedNumbers[0]);
      if (sortedNumbers[i] > expectedVersionNumber) {
        isValid = false;
        errors.push({
          instancePath: `/document/tracking/revision_history`,
          message: `major version ${expectedVersionNumber} was omitted`,
        });
      }
    }
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 * @returns {doc is { document: { tracking: { revision_history: Array<{ number: string; date: string }> } } }}
 */
const preconditionFor_6_1_21_Matches = (doc) =>
  Array.isArray(doc?.document?.tracking?.revision_history) &&
  doc.document.tracking.revision_history.every(
    (/** @type {any} */ r) =>
      typeof r.number === 'string' && typeof r.date === 'string'
  );

const {
  hasTrackingVersionField,
  hasTrackingStatusField,
  hasTrackingRevisionHistory,
} = docUtils;

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_22(doc) {
  let isValid = true;
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];

  if (
    hasTrackingVersionField(doc) &&
    hasTrackingStatusField(doc) &&
    hasTrackingRevisionHistory(doc)
  ) {
    /** @type {Record<string, number[]>} */
    let dupes = {};
    doc.document.tracking.revision_history.forEach((item, index) => {
      dupes[item.number] = dupes[item.number] ?? [];
      dupes[item.number].push(index);
      if (dupes[item.number].length > 1) {
        isValid = false;
        errors.push({
          message: 'version was already used',
          instancePath: `/document/tracking/revision_history/${index}/number`,
        });
      }
    });
  }

  return { errors, isValid }
}

/**
 * @param {unknown} doc
 */
function mandatoryTest_6_1_23(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  // 6.1.23 Multiple Use of Same CVE
  if (preconditionFor_6_1_23_Matches(doc)) {
    /** @type {Set<string>} */
    const cveStrings = new Set();

    doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (vulnerability.cve === undefined) return
      if (cveStrings.has(vulnerability.cve)) {
        isValid = false;
        errors.push({
          message: `CVE identifier was already used`,
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/cve`,
        });
      }
      cveStrings.add(vulnerability.cve);
    });
  }

  return { errors, isValid }
}

/**
 * @param {unknown} rawDoc
 * @returns {rawDoc is {
 *    vulnerabilities: Array<{
 *      cve?: string
 *    }>
 *  }}
 */
const preconditionFor_6_1_23_Matches = (rawDoc) => {
  if (typeof rawDoc !== 'object' || !rawDoc) return false
  /** @type {{ vulnerabilities?: unknown }} */
  const doc = rawDoc;
  return (
    Array.isArray(doc.vulnerabilities) &&
    doc.vulnerabilities.every(
      (vulnerability) =>
        typeof vulnerability.cve === 'string' || vulnerability.cve === undefined
    )
  )
};

/**
 * @param {unknown} doc
 */
function mandatoryTest_6_1_24(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  // 6.1.24 Definition in Involvements
  if (preconditionFor_6_1_24_Matches(doc)) {
    doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      /** @type {Map<string, Set<string>>} */
      const involvementMap = new Map();
      vulnerability.involvements.forEach((involvement, involvementIndex) => {
        if (
          typeof involvement.date === 'string' &&
          typeof involvement.party === 'string'
        ) {
          const set = involvementMap.get(involvement.date) ?? new Set();
          if (set.has(`${involvement.party}`)) {
            isValid = false;
            errors.push({
              message: `status for party was already given for the same date`,
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/involvements/${involvementIndex}`,
            });
          }
          set.add(`${involvement.party}`);
          involvementMap.set(involvement.date, set);
        }
      });
    });
  }

  return { errors, isValid }
}

/**
 * @param {unknown} rawDoc
 * @returns {rawDoc is {
 *    vulnerabilities: Array<{
 *      involvements: Array<{
 *        date?: string
 *        party?: string
 *        status?: string
 *      }>
 *    }>
 *  }}
 */
const preconditionFor_6_1_24_Matches = (rawDoc) => {
  if (typeof rawDoc !== 'object' || !rawDoc) return false
  /** @type {{ vulnerabilities?: unknown }} */
  const doc = rawDoc;
  return (
    Array.isArray(doc.vulnerabilities) &&
    doc.vulnerabilities.every(
      (vulnerability) =>
        Array.isArray(vulnerability.involvements) &&
        vulnerability.involvements.every(
          (/** @type {any} */ involvement) =>
            (typeof involvement.date === 'string' ||
              involvement.date === undefined) &&
            (typeof involvement.party === 'string' ||
              involvement.party === undefined) &&
            (typeof involvement.status === 'string' ||
              involvement.status === undefined)
        )
    )
  )
};

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_25(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  // 6.1.25 Multiple Use of Same Hash Algorithm
  if (Array.isArray(doc.product_tree?.full_product_names)) {
    doc.product_tree?.full_product_names.forEach(
      (
        /** @type {any} */ fullProductName,
        /** @type {number} */ fullProductNameIndex
      ) => {
        if (
          Array.isArray(fullProductName.product_identification_helper?.hashes)
        ) {
          fullProductName.product_identification_helper.hashes.forEach(
            (/** @type {any} */ hash, /** @type {number} */ hashIndex) => {
              checkDuplicateHashAlgorithms(
                hash,
                ({ fileHash, fileHashIndex }) => {
                  isValid = false;
                  errors.push({
                    instancePath: `/product_tree/full_product_names/${fullProductNameIndex}/product_identification_helper/hashes/${hashIndex}/file_hashes/${fileHashIndex}`,
                    message: `there is already a hash with the algorithm ${fileHash.algorithm}`,
                  });
                }
              );
            }
          );
        }
      }
    );
  }

  if (Array.isArray(doc.product_tree?.relationships)) {
    doc.product_tree.relationships.forEach(
      (
        /** @type {any} */ relationship,
        /** @type {number} */ relationshipIndex
      ) => {
        if (
          Array.isArray(
            relationship.full_product_name?.product_identification_helper
              ?.hashes
          )
        ) {
          relationship.full_product_name.product_identification_helper.hashes.forEach(
            (/** @type {any} */ hash, /** @type {number} */ hashIndex) => {
              checkDuplicateHashAlgorithms(
                hash,
                ({ fileHash, fileHashIndex }) => {
                  isValid = false;
                  errors.push({
                    instancePath: `/product_tree/relationships/${relationshipIndex}/full_product_name/product_identification_helper/hashes/${hashIndex}/file_hashes/${fileHashIndex}`,
                    message: `there is already a hash with the algorithm ${fileHash.algorithm}`,
                  });
                }
              );
            }
          );
        }
      }
    );
  }

  if (doc.product_tree) {
    checkBranchesForDuplicateHashAlgorithms(
      doc.product_tree,
      ({ branchIndexes, hashIndex, fileHashIndex, fileHash }) => {
        isValid = false;
        const branchPathPart = branchIndexes.reduce(
          (str, index) => `${str}/branches/${index}`,
          '/product_tree'
        );
        errors.push({
          instancePath: `${branchPathPart}/product/product_identification_helper/hashes/${hashIndex}/file_hashes/${fileHashIndex}`,
          message: `there is already a hash with the algorithm ${fileHash.algorithm}`,
        });
      }
    );
  }

  return { errors, isValid }
}

/**
 *
 * @param {any} parent
 * @param {(error: { branchIndexes: number[]; hashIndex: number; fileHash: { algorithm: string }, fileHashIndex: number }) => void} onError
 * @param {number[]} [branchIndexes]
 */
const checkBranchesForDuplicateHashAlgorithms = (
  parent,
  onError,
  branchIndexes = []
) => {
  if (Array.isArray(parent.branches)) {
    parent.branches.forEach(
      (/** @type {any} */ branch, /** @type {number} */ branchIndex) => {
        const currentBranchIndexes = branchIndexes.concat([branchIndex]);
        if (
          Array.isArray(branch.product?.product_identification_helper?.hashes)
        ) {
          branch.product.product_identification_helper.hashes.forEach(
            (/** @type {any} */ hash, /** @type {number} */ hashIndex) => {
              checkDuplicateHashAlgorithms(
                hash,
                ({ fileHash, fileHashIndex }) => {
                  onError({
                    branchIndexes: currentBranchIndexes,
                    hashIndex,
                    fileHash,
                    fileHashIndex,
                  });
                }
              );
            }
          );
        }
        checkBranchesForDuplicateHashAlgorithms(
          branch,
          onError,
          currentBranchIndexes
        );
      }
    );
  }
};

/**
 * @param {any} hash
 * @param {(error: { fileHash: { algorithm: string }, fileHashIndex: number }) => void} onError
 * @returns
 */
const checkDuplicateHashAlgorithms = (hash, onError) => {
  if (!Array.isArray(hash.file_hashes)) return
  /** @type {Set<string>} */
  const algorithmSet = new Set();
  hash.file_hashes.forEach(
    (/** @type {any} */ fileHash, /** @type {number} */ fileHashIndex) => {
      if (fileHash.algorithm == null) return
      if (algorithmSet.has(fileHash.algorithm)) {
        onError({
          fileHash,
          fileHashIndex,
        });
      }
      algorithmSet.add(fileHash.algorithm);
    }
  );
};

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_26(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (typeof doc.document?.category === 'string') {
    /** @type {string} */
    const category = doc.document.category;
    const profileValues = [
      'csaf_base',
      'csaf_security_incident_response',
      'csaf_informational_advisory',
      'csaf_security_advisory',
      'csaf_vex',
    ];
    const otherProfileValues = [
      'securityincidentresponse',
      'informationaladvisory',
      'securityadvisory',
      'vex',
    ];

    // Skip test if profile is not "CSAF Base" but one of the other profiles or matches exactly "csaf_base"
    if (profileValues.includes(category)) return { errors, isValid }

    // Fail on reserved prefix
    if (category.toLowerCase().startsWith('csaf_')) {
      isValid = false;
      errors.push({
        instancePath: `/document/category`,
        message: `reserved prefix used`,
      });

      return { errors, isValid }
    }

    // Fail on name similarity
    if (
      otherProfileValues.includes(
        category.replace(/[_-\s]+/g, '').toLowerCase()
      )
    ) {
      isValid = false;
      errors.push({
        instancePath: `/document/category`,
        message: `value prohibited`,
      });
    }
  }

  return { errors, isValid }
}

/**
 * @typedef {object} Note
 * @property {unknown} category
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_1(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set([
    'csaf_security_incident_response',
    'csaf_informational_advisory',
  ]);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  const mandatoryNoteCategories = new Set([
    'description',
    'details',
    'general',
    'summary',
  ]);

  isValid =
    Array.isArray(doc.document?.notes) &&
    /** @type {Note[]} */ (doc.document.notes).some((n) =>
      mandatoryNoteCategories.has(/** @type {string} */ (n.category))
    );

  if (!isValid) {
    errors.push({
      instancePath: '/document/notes',
      message:
        'need at least one document note with a category of description, details, general or summary',
    });
  }
  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_2(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set([
    'csaf_security_incident_response',
    'csaf_informational_advisory',
  ]);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  /**
   * @typedef {object} Reference
   * @property {unknown} category
   */

  const mandatoryReferenceCategories = new Set(['external']);

  isValid =
    Array.isArray(doc.document?.references) &&
    /** @type {Reference[]} */ (doc.document.references).some((r) =>
      mandatoryReferenceCategories.has(/** @type {string} */ (r.category))
    );

  if (!isValid) {
    errors.push({
      instancePath: '/document/references',
      message:
        'need at least one document reference with the category "external"',
    });
  }
  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_3(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set(['csaf_informational_advisory']);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  isValid = doc.vulnerabilities === undefined;

  if (!isValid) {
    errors.push({
      instancePath: '/vulnerabilities',
      message: 'must not exist',
    });
  }
  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_4(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set([
    'csaf_security_advisory',
    'csaf_vex',
  ]);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  isValid = Boolean(doc.product_tree);

  if (!isValid) {
    errors.push({
      instancePath: '/',
      message: 'needs a product_tree',
    });
  }
  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_5(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set([
    'csaf_security_advisory',
    'csaf_vex',
  ]);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (Array.isArray(vulnerabilities)) {
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (!vulnerability.notes) {
        isValid = false;
        errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}`,
          message: 'needs a `notes` attribute',
        });
      }
    });
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_6(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set(['csaf_security_advisory']);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (Array.isArray(vulnerabilities)) {
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (!vulnerability.product_status) {
        isValid = false;
        errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}`,
          message: 'needs a `product_status` attribute',
        });
      }
    });
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_7(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set(['csaf_vex']);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (Array.isArray(vulnerabilities)) {
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (!vulnerability.product_status) {
        isValid = false;
        errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}`,
          message: 'needs a `product_status` attribute',
        });
        return
      }
      const neededArrays = [
        'fixed',
        'known_affected',
        'known_not_affected',
        'under_investigation',
      ];
      if (
        !neededArrays.some((p) =>
          Array.isArray(vulnerability.product_status[p])
        )
      ) {
        isValid = false;
        errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status`,
          message:
            'needs at least one the following attributes: `fixed`, `known_affected`, `known_not_affected`, `under_investigation`',
        });
      }
    });
  }

  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_8(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set(['csaf_vex']);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (Array.isArray(vulnerabilities)) {
    vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
      if (['ids', 'cve'].every((p) => vulnerability[p] === undefined)) {
        isValid = false;
        errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}`,
          message: 'needs at least one the following attributes: `ids`, `cve`',
        });
      }
    });
  }

  return { errors, isValid }
}

/**
 * @typedef {object} VulnerabilityProductStatus
 * @property {unknown} known_not_affected
 */

/**
 * @typedef {object} Vulnerability
 * @property {unknown} flags
 * @property {VulnerabilityProductStatus} [product_status]
 * @property {unknown} threats
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_9(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (doc.document?.category !== 'csaf_vex' || !Array.isArray(vulnerabilities))
    return { errors, isValid }

  vulnerabilities.forEach(
    (
      /**
       * @type {Vulnerability | null} vulnerability
       */
      vulnerability,
      vulnerabilityIndex
    ) => {
      const productStatus = vulnerability?.product_status;
      if (
        !vulnerability ||
        !productStatus ||
        !Array.isArray(productStatus.known_not_affected)
      )
        return

      productStatus.known_not_affected.forEach((productId, productIdIndex) => {
        /**
         * @typedef {object} Threat
         * @property {unknown} category
         * @property {unknown} group_ids
         * @property {unknown} product_ids
         */

        /** @type {(Threat | null)[]} */
        const threats = Array.isArray(vulnerability.threats)
          ? vulnerability.threats
          : [];
        const hasMatchingThreat = threats.some((threat) => {
          if (!threat || threat.category !== 'impact') return false

          const threatHasMatchingProduct =
            Array.isArray(threat.product_ids) &&
            threat.product_ids.includes(productId);
          if (threatHasMatchingProduct) return true

          const productGroups = doc.product_tree?.product_groups;
          const threatHasMatchingProductGroup =
            Array.isArray(threat.group_ids) &&
            Array.isArray(productGroups) &&
            threat.group_ids.some((groupId) => {
              /** @type {{ product_ids: unknown } | undefined} */
              const group = productGroups.find((g) => g.group_id === groupId);
              return (
                group &&
                Array.isArray(group.product_ids) &&
                group.product_ids.includes(productId)
              )
            });

          if (threatHasMatchingProductGroup) return true
          return false
        });

        /**
         * @typedef {object} Flag
         * @property {unknown} label
         * @property {unknown} group_ids
         * @property {unknown} product_ids
         */

        /** @type {(Flag | null)[]} */
        const flags = Array.isArray(vulnerability.flags)
          ? vulnerability.flags
          : [];
        const hasMatchingFlag = flags.some((flag) => {
          if (!flag) return false

          const flagHasMatchingProduct =
            Array.isArray(flag.product_ids) &&
            flag.product_ids.includes(productId);
          if (flagHasMatchingProduct) return true

          const productGroups = doc.product_tree?.product_groups;
          const flagHasMatchingProductGroup =
            Array.isArray(flag.group_ids) &&
            Array.isArray(productGroups) &&
            flag.group_ids.some((groupId) => {
              /** @type {{ product_ids: unknown } | undefined} */
              const group = productGroups.find((g) => g.group_id === groupId);
              return (
                group &&
                Array.isArray(group.product_ids) &&
                group.product_ids.includes(productId)
              )
            });

          if (flagHasMatchingProductGroup) return true
          return false
        });

        if (!hasMatchingThreat && !hasMatchingFlag) {
          isValid = false;
          errors.push({
            instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status/known_not_affected/${productIdIndex}`,
            message: 'no suitable impact statement found',
          });
        }
      });
    }
  );

  return { errors, isValid }
}

/**
 * @typedef {object} VulnerabilityProductStatus
 * @property {unknown} known_affected
 */

/**
 * @typedef {object} Vulnerability
 * @property {VulnerabilityProductStatus} [product_status]
 * @property {unknown} remediations
 */

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_10(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  /** @type {unknown} */
  const vulnerabilities = doc.vulnerabilities;
  if (doc.document?.category !== 'csaf_vex' || !Array.isArray(vulnerabilities))
    return { errors, isValid }

  vulnerabilities.forEach(
    (
      /**
       * @type {Vulnerability | null} vulnerability
       */
      vulnerability,
      vulnerabilityIndex
    ) => {
      const productStatus = vulnerability?.product_status;
      if (
        !vulnerability ||
        !productStatus ||
        !Array.isArray(productStatus.known_affected)
      )
        return

      productStatus.known_affected.forEach((productId, productIdIndex) => {
        /**
         * @typedef {object} Remediation
         * @property {unknown} category
         * @property {unknown} group_ids
         * @property {unknown} product_ids
         */

        /** @type {(Remediation | null | undefined)[]} */
        const remediations = Array.isArray(vulnerability.remediations)
          ? vulnerability.remediations
          : [];
        const hasMatchingRemediation = remediations.some((remediation) => {
          if (!remediation) return false

          const remediationHasMatchingProduct =
            Array.isArray(remediation.product_ids) &&
            remediation.product_ids.includes(productId);
          if (remediationHasMatchingProduct) return true

          const productGroups = doc.product_tree?.product_groups;
          const remediationHasMatchingProductGroup =
            Array.isArray(remediation.group_ids) &&
            Array.isArray(productGroups) &&
            remediation.group_ids.some((groupId) => {
              /** @type {{ product_ids: unknown } | undefined} */
              const group = productGroups.find((g) => g.group_id === groupId);
              return (
                group &&
                Array.isArray(group.product_ids) &&
                group.product_ids.includes(productId)
              )
            });

          if (remediationHasMatchingProductGroup) return true
          return false
        });

        if (!hasMatchingRemediation) {
          isValid = false;
          errors.push({
            instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status/known_affected/${productIdIndex}`,
            message: 'no suitable action statement found',
          });
        }
      });
    }
  );

  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_27_11(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  const checkedDocumentCategories = new Set([
    'csaf_security_advisory',
    'csaf_vex',
  ]);

  if (!checkedDocumentCategories.has(doc.document?.category))
    return { errors, isValid }

  isValid = Boolean(doc.vulnerabilities);

  if (!isValid) {
    errors.push({
      instancePath: '/',
      message: 'needs vulnerabilities',
    });
  }
  return { errors, isValid }
}

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_28(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const errors = [];
  let isValid = true;

  if (
    typeof doc.document?.source_lang === 'string' &&
    typeof doc.document?.lang === 'string' &&
    doc.document.source_lang === doc.document.lang
  ) {
    isValid = false;
    errors.push(
      {
        instancePath: `/document/lang`,
        message: 'is the same as `/document/source_lang`',
      },
      {
        instancePath: `/document/source_lang`,
        message: 'is the same as `/document/lang`',
      }
    );
  }

  return { isValid, errors }
}

const ajv$k = new Ajv();

const inputSchema$j = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        properties: {
          remediations: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                group_ids: { elements: { type: 'string' } },
                product_ids: { elements: { type: 'string' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$e = ajv$k.compile(inputSchema$j);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_29(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$e(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    vulnerability.remediations.forEach((remediation, remediationIndex) => {
      if (!remediation.group_ids && !remediation.product_ids) {
        ctx.isValid = false;
        ctx.errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/remediations/${remediationIndex}`,
          message: 'remediation without product reference',
        });
      }
    });
  });

  return ctx
}

const ajv$j = new Ajv();

const inputSchema$i = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    document: {
      additionalProperties: true,
      properties: {
        tracking: {
          additionalProperties: true,
          optionalProperties: {
            revision_history: {
              elements: {
                additionalProperties: true,
                optionalProperties: {
                  number: { type: 'string' },
                },
              },
            },
            version: { type: 'string' },
          },
        },
      },
    },
  },
});

const validate$d = ajv$j.compile(inputSchema$i);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_30(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$d(doc)) {
    return ctx
  }

  /** @type {'SEMANTIC' | 'INTEGER' | null} */
  let versioningSchema = null;
  doc.document.tracking.revision_history?.forEach((revision, revisionIndex) => {
    if (typeof revision.number === 'string') {
      const revisionNumberVersioningSchema = detectVersionSchema(
        revision.number
      );
      if (versioningSchema === null) {
        versioningSchema = revisionNumberVersioningSchema;
      }
      if (versioningSchema !== revisionNumberVersioningSchema) {
        ctx.isValid = false;
        ctx.errors.push({
          instancePath: `/document/tracking/revisions/${revisionIndex}/number`,
          message: 'mixed integer and semantic versioning',
        });
      }
    }
  });
  if (versioningSchema != null && typeof doc.document.tracking.version === 'string') {
    if (
      versioningSchema !== detectVersionSchema(doc.document.tracking.version)
    ) {
      ctx.isValid = false;
      ctx.errors.push({
        instancePath: `/document/tracking/version`,
        message: 'mixed integer and semantic versioning',
      });
    }
  }

  return ctx
}

/**
 * @param {string} version
 */
function detectVersionSchema(version) {
  if (parseInt(version).toString() === version) return 'INTEGER'
  return 'SEMANTIC'
}

const ajv$i = new Ajv();

const inputSchema$h = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_tree: {
      additionalProperties: true,
      properties: {
        branches: {
          elements: {
            additionalProperties: true,
            properties: {},
          },
        },
      },
    },
  },
});

const branchSchema$4 = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    category: { type: 'string' },
    name: { type: 'string' },
    branches: {
      elements: {
        additionalProperties: true,
        properties: {},
      },
    },
  },
});

const validate$c = ajv$i.compile(inputSchema$h);
const validateBranch$4 = ajv$i.compile(branchSchema$4);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_31(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$c(doc)) {
    return ctx
  }

  /**
   * @param {object} params
   * @param {string} params.path
   * @param {unknown[]} params.branches
   */
  function checkBranches({ path, branches }) {
    branches.forEach((branch, branchIndex) => {
      if (validateBranch$4(branch)) {
        if (
          branch.category === 'product_version' &&
          typeof branch.name === 'string' &&
          (['<', '<=', '>', '>='].some((str) =>
            branch.name?.toLowerCase().includes(str)
          ) ||
            ['after', 'all', 'before', 'earlier', 'later', 'prior', 'versions'].some(
              (str) =>
                branch.name
                  ?.toLowerCase()
                  .split(/\s/)
                  .some((word) => {
                    return str === word
                  })
            ))
        ) {
          ctx.isValid = false;
          ctx.errors.push({
            instancePath: `${path}/${branchIndex}/name`,
            message: 'version range in product version',
          });
        }
        if (Array.isArray(branch.branches)) {
          checkBranches({
            path: `${path}/${branchIndex}/branches`,
            branches: branch.branches,
          });
        }
      }
    });
  }

  checkBranches({
    path: '/product_tree/branches',
    branches: doc.product_tree.branches,
  });

  return ctx
}

const ajv$h = new Ajv();

const inputSchema$g = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        properties: {
          flags: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                group_ids: { elements: { type: 'string' } },
                product_ids: { elements: { type: 'string' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$b = ajv$h.compile(inputSchema$g);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_32(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$b(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    vulnerability.flags.forEach((flag, flagIndex) => {
      if (!flag.group_ids && !flag.product_ids) {
        ctx.isValid = false;
        ctx.errors.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/flags/${flagIndex}`,
          message: 'flag without product reference',
        });
      }
    });
  });

  return ctx
}

const ajv$g = new Ajv();

const inputSchema$f = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_tree: {
      additionalProperties: true,
      optionalProperties: {
        product_groups: {
          elements: {
            optionalProperties: {
              group_id: { type: 'string' },
              product_ids: {
                elements: { type: 'string' },
              },
            },
          },
        },
      },
    },
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        properties: {
          flags: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                group_ids: { elements: { type: 'string' } },
                product_ids: { elements: { type: 'string' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$a = ajv$g.compile(inputSchema$f);

/**
 * @param {any} doc
 */
function mandatoryTest_6_1_33(doc) {
  const ctx = {
    errors:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
    isValid: true,
  };

  if (!validate$a(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    /** @type {Set<string>} */
    const productIDsWithVexJustificationCode = new Set();

    vulnerability.flags.forEach((flag, flagIndex) => {
      let flagReported = false;

      function error() {
        if (!flagReported) {
          ctx.isValid = false;
          ctx.errors.push({
            instancePath: `/vulnerabilities/${vulnerabilityIndex}/flags/${flagIndex}`,
            message: 'multiple flags with vex justification codes per product',
          });
        }
        flagReported = true;
      }

      flag.product_ids?.forEach((productID) => {
        if (productIDsWithVexJustificationCode.has(productID)) {
          error();
        }
        productIDsWithVexJustificationCode.add(productID);
      });
      flag.group_ids?.forEach((groupID) => {
        const productIDs = doc.product_tree.product_groups?.find(
          (group) => group.group_id === groupID
        )?.product_ids;
        productIDs?.forEach((productID) => {
          if (productIDsWithVexJustificationCode.has(productID)) {
            error();
          }
          productIDsWithVexJustificationCode.add(productID);
        });
      });
    });
  });

  return ctx
}

var mandatory = /*#__PURE__*/Object.freeze({
  __proto__: null,
  mandatoryTest_6_1_1: mandatoryTest_6_1_1,
  mandatoryTest_6_1_10: mandatoryTest_6_1_10,
  mandatoryTest_6_1_11: mandatoryTest_6_1_11,
  mandatoryTest_6_1_12: mandatoryTest_6_1_12,
  mandatoryTest_6_1_13: mandatoryTest_6_1_13,
  mandatoryTest_6_1_14: mandatoryTest_6_1_14,
  mandatoryTest_6_1_15: mandatoryTest_6_1_15,
  mandatoryTest_6_1_16: mandatoryTest_6_1_16,
  mandatoryTest_6_1_17: mandatoryTest_6_1_17,
  mandatoryTest_6_1_18: mandatoryTest_6_1_18,
  mandatoryTest_6_1_19: mandatoryTest_6_1_19,
  mandatoryTest_6_1_2: mandatoryTest_6_1_2,
  mandatoryTest_6_1_20: mandatoryTest_6_1_20,
  mandatoryTest_6_1_21: mandatoryTest_6_1_21,
  mandatoryTest_6_1_22: mandatoryTest_6_1_22,
  mandatoryTest_6_1_23: mandatoryTest_6_1_23,
  mandatoryTest_6_1_24: mandatoryTest_6_1_24,
  mandatoryTest_6_1_25: mandatoryTest_6_1_25,
  mandatoryTest_6_1_26: mandatoryTest_6_1_26,
  mandatoryTest_6_1_27_1: mandatoryTest_6_1_27_1,
  mandatoryTest_6_1_27_10: mandatoryTest_6_1_27_10,
  mandatoryTest_6_1_27_11: mandatoryTest_6_1_27_11,
  mandatoryTest_6_1_27_2: mandatoryTest_6_1_27_2,
  mandatoryTest_6_1_27_3: mandatoryTest_6_1_27_3,
  mandatoryTest_6_1_27_4: mandatoryTest_6_1_27_4,
  mandatoryTest_6_1_27_5: mandatoryTest_6_1_27_5,
  mandatoryTest_6_1_27_6: mandatoryTest_6_1_27_6,
  mandatoryTest_6_1_27_7: mandatoryTest_6_1_27_7,
  mandatoryTest_6_1_27_8: mandatoryTest_6_1_27_8,
  mandatoryTest_6_1_27_9: mandatoryTest_6_1_27_9,
  mandatoryTest_6_1_28: mandatoryTest_6_1_28,
  mandatoryTest_6_1_29: mandatoryTest_6_1_29,
  mandatoryTest_6_1_3: mandatoryTest_6_1_3,
  mandatoryTest_6_1_30: mandatoryTest_6_1_30,
  mandatoryTest_6_1_31: mandatoryTest_6_1_31,
  mandatoryTest_6_1_32: mandatoryTest_6_1_32,
  mandatoryTest_6_1_33: mandatoryTest_6_1_33,
  mandatoryTest_6_1_4: mandatoryTest_6_1_4,
  mandatoryTest_6_1_5: mandatoryTest_6_1_5,
  mandatoryTest_6_1_6: mandatoryTest_6_1_6,
  mandatoryTest_6_1_7: mandatoryTest_6_1_7,
  mandatoryTest_6_1_8: mandatoryTest_6_1_8,
  mandatoryTest_6_1_9: mandatoryTest_6_1_9
});

const ajv$f = new Ajv();

const inputSchema$e = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    product_tree: {
      additionalProperties: true,

      optionalProperties: {
        branches: {
          elements: {
            additionalProperties: true,

            properties: {},
          },
        },

        full_product_names: {
          elements: {
            additionalProperties: true,

            properties: {},
          },
        },

        relationships: {
          elements: {
            additionalProperties: true,

            properties: {},
          },
        },
      },
    },
  },

  optionalProperties: {
    document: {
      additionalProperties: true,

      optionalProperties: {
        category: { type: 'string' },
      },
    },
  },
});
const validate$9 = ajv$f.compile(inputSchema$e);

const fullProductNameSchema$1 = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    product_id: { type: 'string' },
  },
});
const validateFullProductName$1 = ajv$f.compile(fullProductNameSchema$1);

const branchSchema$3 = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    product: fullProductNameSchema$1,
    branches: {
      elements: {
        additionalProperties: true,
        properties: {},
      },
    },
  },
});
const validateBranch$3 = ajv$f.compile(branchSchema$3);

const relationshipSchema$2 = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    full_product_name: fullProductNameSchema$1,
  },
});
const validateRelationship$2 = ajv$f.compile(relationshipSchema$2);

/**
 * @param {any} doc
 */
function optionalTest_6_2_1(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (
    !validate$9(doc) ||
    doc.document?.category === 'csaf_informational_advisory'
  ) {
    return context
  }

  /**
   * @param {object} params
   * @param {string} params.path
   * @param {unknown[]} params.branches
   */
  function checkBranches({ path, branches }) {
    branches.forEach((branch, branchIndex) => {
      if (validateBranch$3(branch)) {
        if (
          typeof branch.product?.product_id === 'string' &&
          !isReferenced(doc, branch.product.product_id)
        ) {
          warnings.push({
            instancePath: `${path}/${branchIndex}/product/product_id`,
            message: 'is not referenced',
          });
        }

        if (Array.isArray(branch.branches)) {
          checkBranches({
            path: `${path}/${branchIndex}/branches`,
            branches: branch.branches,
          });
        }
      }
    });
  }

  checkBranches({
    path: '/product_tree/branches',
    branches: doc.product_tree?.branches ?? [],
  });

  doc.product_tree.full_product_names?.forEach(
    (fullProductName, fullProductNameIndex) => {
      if (!validateFullProductName$1(fullProductName)) return
      if (!isReferenced(doc, fullProductName.product_id)) {
        context.warnings.push({
          instancePath: `/product_tree/full_product_names/${fullProductNameIndex}/product_id`,
          message: 'is not referenced',
        });
      }
    }
  );

  doc.product_tree.relationships?.forEach((relationship, relationshipIndex) => {
    if (!validateRelationship$2(relationship)) return
    if (!isReferenced(doc, relationship.full_product_name.product_id)) {
      context.warnings.push({
        instancePath: `/product_tree/relationships/${relationshipIndex}/full_product_name/product_id`,
        message: 'is not referenced',
      });
    }
  });

  return context
}

const containsProductGroupsSchema = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    product_tree: {
      additionalProperties: true,

      properties: {
        product_groups: {
          elements: {
            additionalProperties: true,

            optionalProperties: {
              product_ids: {
                elements: { type: 'string' },
              },
            },
          },
        },
      },
    },
  },
});

const containsRelationshipWithReferencesSchema = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    product_tree: {
      additionalProperties: true,

      properties: {
        relationships: {
          elements: {
            additionalProperties: true,

            optionalProperties: {
              product_reference: { type: 'string' },
              relates_to_product_reference: { type: 'string' },
            },
          },
        },
      },
    },
  },
});

const containsVulnerabilitiesWithReferencesSchema = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,

        optionalProperties: {
          product_status: {
            additionalProperties: true,

            optionalProperties: {
              first_affected: { elements: { type: 'string' } },
              first_fixed: { elements: { type: 'string' } },
              fixed: { elements: { type: 'string' } },
              known_affected: { elements: { type: 'string' } },
              known_not_affected: { elements: { type: 'string' } },
              last_affected: { elements: { type: 'string' } },
              recommended: { elements: { type: 'string' } },
              under_investigation: { elements: { type: 'string' } },
            },
          },
        },
      },
    },
  },
});

const containsVulnerabilitiesWithOptionalReferencesSchema =
  /** @type {const} */ ({
    additionalProperties: true,

    properties: {
      vulnerabilities: {
        elements: {
          additionalProperties: true,

          optionalProperties: {
            remediations: {
              elements: {
                additionalProperties: true,

                optionalProperties: {
                  product_ids: {
                    elements: { type: 'string' },
                  },
                },
              },
            },
            scores: {
              elements: {
                additionalProperties: true,

                optionalProperties: {
                  products: {
                    elements: { type: 'string' },
                  },
                },
              },
            },
            threats: {
              elements: {
                additionalProperties: true,

                optionalProperties: {
                  product_ids: {
                    elements: { type: 'string' },
                  },
                },
              },
            },
          },
        },
      },
    },
  });

const validateContainsProductGroups = ajv$f.compile(containsProductGroupsSchema);
const validateContainsRelationshipWithReferences = ajv$f.compile(
  containsRelationshipWithReferencesSchema
);
const validateContainsVulnerabilitiesWithReferences = ajv$f.compile(
  containsVulnerabilitiesWithReferencesSchema
);
const validateContainsVulnerabilitiesWithOptionalReferences = ajv$f.compile(
  containsVulnerabilitiesWithOptionalReferencesSchema
);

/**
 * @param {unknown} doc
 * @param {string} productId
 */
function isReferenced(doc, productId) {
  let referenced = false;

  if (!referenced && validateContainsProductGroups(doc)) {
    referenced = doc.product_tree.product_groups.some((group) => {
      return group.product_ids?.includes(productId) ?? false
    });
  }

  if (!referenced && validateContainsRelationshipWithReferences(doc)) {
    referenced = doc.product_tree.relationships.some((relationship) => {
      return (
        relationship.product_reference === productId ||
        relationship.relates_to_product_reference === productId
      )
    });
  }

  if (!referenced && validateContainsVulnerabilitiesWithReferences(doc)) {
    referenced = doc.vulnerabilities.some((vulnerability) => {
      const keys = /** @type {const} */ ([
        'first_affected',
        'first_fixed',
        'fixed',
        'known_affected',
        'known_not_affected',
        'last_affected',
        'recommended',
        'under_investigation',
      ]);
      return keys.some(
        (key) =>
          vulnerability.product_status?.[key]?.includes(productId) ?? false
      )
    });
  }

  if (
    !referenced &&
    validateContainsVulnerabilitiesWithOptionalReferences(doc)
  ) {
    referenced = doc.vulnerabilities.some((vulnerability) => {
      return (
        vulnerability.remediations?.some((remediation) =>
          remediation.product_ids?.includes(productId)
        ) ||
        vulnerability.scores?.some((score) =>
          score.products?.includes(productId)
        ) ||
        vulnerability.threats?.some((threat) =>
          threat.product_ids?.includes(productId)
        ) ||
        false
      )
    });
  }

  return referenced
}

const ajv$e = new Ajv();

const inputSchema$d = /** @type {const} */ ({
  additionalProperties: true,

  optionalProperties: {
    product_tree: {
      additionalProperties: true,

      optionalProperties: {
        product_groups: {
          elements: {
            additionalProperties: true,

            optionalProperties: {
              group_id: { type: 'string' },
              product_ids: { elements: { type: 'string' } },
            },
          },
        },
      },
    },
  },

  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,

        properties: {
          product_status: {
            additionalProperties: true,
            optionalProperties: {
              first_affected: { elements: { type: 'string' } },
              known_affected: { elements: { type: 'string' } },
              last_affected: { elements: { type: 'string' } },
              under_investigation: { elements: { type: 'string' } },
            },
          },
        },

        optionalProperties: {
          remediations: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                product_ids: { elements: { type: 'string' } },
                group_ids: {
                  elements: { type: 'string' },
                },
              },
            },
          },
        },
      },
    },
  },
});

const validate$8 = ajv$e.compile(inputSchema$d);

/**
 * @param {any} doc
 */
function optionalTest_6_2_2(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (!validate$8(doc)) {
    return context
  }

  doc.vulnerabilities?.forEach((vulnerability, vulnerabilityIndex) => {
    const productStatus = vulnerability.product_status;
    const lists = /** @type {const} */ ([
      'first_affected',
      'known_affected',
      'last_affected',
      'under_investigation',
    ]);
    lists.forEach((listID) => {
      const listOfProductIDs = productStatus[listID];
      listOfProductIDs?.forEach((productID, productIDIndex) => {
        const hasMatchingRemediation = vulnerability.remediations?.some(
          (remediation) =>
            remediation.product_ids?.includes(productID) ||
            remediation.group_ids
              ?.map((id) =>
                doc.product_tree?.product_groups?.find((g) => g.group_id === id)
              )
              .some((g) => g?.product_ids?.includes(productID))
        );
        if (!hasMatchingRemediation) {
          context.warnings.push({
            message: 'missing remediation',
            instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status/${listID}/${productIDIndex}`,
          });
        }
      });
    });
  });

  return context
}

const ajv$d = new Ajv();

const inputSchema$c = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,

        properties: {
          product_status: {
            additionalProperties: true,
            optionalProperties: {
              first_affected: { elements: { type: 'string' } },
              known_affected: { elements: { type: 'string' } },
              last_affected: { elements: { type: 'string' } },
            },
          },
        },

        optionalProperties: {
          scores: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                products: { elements: { type: 'string' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$7 = ajv$d.compile(inputSchema$c);

/**
 * @param {any} doc
 */
function optionalTest_6_2_3(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (!validate$7(doc)) {
    return context
  }

  doc.vulnerabilities?.forEach((vulnerability, vulnerabilityIndex) => {
    const productStatus = vulnerability.product_status;
    const lists = /** @type {const} */ ([
      'first_affected',
      'known_affected',
      'last_affected',
    ]);
    lists.forEach((listID) => {
      const listOfProductIDs = productStatus[listID];
      listOfProductIDs?.forEach((productID, productIDIndex) => {
        const hasMatchingScore = vulnerability.scores?.some((score) =>
          score.products?.includes(productID)
        );
        if (!hasMatchingScore) {
          context.warnings.push({
            message: 'missing score',
            instancePath: `/vulnerabilities/${vulnerabilityIndex}/product_status/${listID}/${productIDIndex}`,
          });
        }
      });
    });
  });

  return context
}

const ajv$c = new Ajv();

const inputSchema$b = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    document: {
      additionalProperties: true,
      properties: {
        tracking: {
          additionalProperties: true,
          properties: {
            revision_history: {
              elements: { additionalProperties: true, properties: {} },
            },
          },
        },
      },
    },
  },
});

const validate$6 = ajv$c.compile(inputSchema$b);

/**
 * @param {any} doc
 */
function optionalTest_6_2_4(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (!validate$6(doc)) {
    return context
  }

  doc.document.tracking.revision_history?.forEach(
    (revisionHistoryItem, revisionHistoryItemIndex) => {
      const { number } = revisionHistoryItem;
      if (typeof number === 'string' && number.includes('+')) {
        warnings.push({
          message: 'build metadata in revision history',
          instancePath: `/document/tracking/revision_history/${revisionHistoryItemIndex}/number`,
        });
      }
    }
  );

  return context
}

const ajv$b = new Ajv();

const inputSchema$a = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    document: {
      additionalProperties: true,
      properties: {
        tracking: {
          additionalProperties: true,
          properties: {
            initial_release_date: { type: 'timestamp' },
            revision_history: {
              elements: {
                additionalProperties: true,
                properties: { date: { type: 'timestamp' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$5 = ajv$b.compile(inputSchema$a);

/**
 * @param {any} doc
 */
function optionalTest_6_2_5(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (!validate$5(doc)) {
    return context
  }

  const oldestRevisionHistoryItem = doc.document.tracking.revision_history
    .slice()
    .sort((a, z) =>
      compareZonedDateTimes(
        /** @type {string} */ (a.date),
        /** @type {string} */ (z.date)
      )
    )[0];
  if (
    oldestRevisionHistoryItem &&
    compareZonedDateTimes(
      /** @type {string} */ (doc.document.tracking.initial_release_date),
      /** @type {string} */ (oldestRevisionHistoryItem.date)
    ) < 0
  ) {
    warnings.push({
      message: 'older initial release date than revision history',
      instancePath: `/document/tracking/initial_release_date`,
    });
  }

  return context
}

const ajv$a = new Ajv();

const inputSchema$9 = /** @type {const} */ ({
  additionalProperties: true,

  properties: {
    document: {
      additionalProperties: true,
      properties: {
        tracking: {
          additionalProperties: true,
          properties: {
            current_release_date: { type: 'timestamp' },
            revision_history: {
              elements: {
                additionalProperties: true,
                properties: { date: { type: 'timestamp' } },
              },
            },
          },
        },
      },
    },
  },
});

const validate$4 = ajv$a.compile(inputSchema$9);

/**
 * @param {any} doc
 */
function optionalTest_6_2_6(doc) {
  /** @type {Array<{ message: string; instancePath: string }>} */
  const warnings = [];
  const context = { warnings };

  if (!validate$4(doc)) {
    return context
  }

  const newestRevisionHistoryItem = doc.document.tracking.revision_history
    .slice()
    .sort((a, z) =>
      compareZonedDateTimes(
        /** @type {string} */ (z.date),
        /** @type {string} */ (a.date)
      )
    )[0];
  if (
    newestRevisionHistoryItem &&
    compareZonedDateTimes(
      /** @type {string} */ (doc.document.tracking.current_release_date),
      /** @type {string} */ (newestRevisionHistoryItem.date)
    ) < 0
  ) {
    warnings.push({
      message: 'older current release date than revision history',
      instancePath: `/document/tracking/current_release_date`,
    });
  }

  return context
}

const ajv$9 = new Ajv();

const inputSchema$8 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        optionalProperties: {
          involvements: {
            elements: {
              additionalProperties: true,
              properties: {},
            },
          },
        },
      },
    },
  },
});

const validate$3 = ajv$9.compile(inputSchema$8);

/**
 * @param {any} doc
 */
function optionalTest_6_2_7(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validate$3(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    vulnerability.involvements?.forEach((involvement, involvementIndex) => {
      if (!involvement.date) {
        ctx.warnings.push({
          message: 'missing date',
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/involvements/${involvementIndex}`,
        });
      }
    });
  });

  return ctx
}

const ajv$8 = new Ajv();

const inputSchema$7 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_tree: {
      additionalProperties: true,
      optionalProperties: {
        branches: { elements: { additionalProperties: true, properties: {} } },
        full_product_names: {
          elements: { additionalProperties: true, properties: {} },
        },
        relationships: {
          elements: { additionalProperties: true, properties: {} },
        },
      },
    },
  },
});

const fullProductNameSchema = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_identification_helper: {
      additionalProperties: true,
      properties: {
        hashes: {
          elements: {
            additionalProperties: true,
            properties: {},
          },
        },
      },
    },
  },
});

const branchSchema$2 = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    product: {
      additionalProperties: true,
      properties: {
        product_identification_helper: {
          additionalProperties: true,
          properties: {
            hashes: {
              elements: {
                additionalProperties: true,
                properties: {},
              },
            },
          },
        },
      },
    },
  },
});

const relationshipSchema$1 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    full_product_name: {
      additionalProperties: true,
      properties: {
        product_identification_helper: {
          additionalProperties: true,
          properties: {
            hashes: {
              elements: {
                additionalProperties: true,
                properties: {},
              },
            },
          },
        },
      },
    },
  },
});

const validateInput$4 = ajv$8.compile(inputSchema$7);
const validateFullProductName = ajv$8.compile(fullProductNameSchema);
const validateRelationship$1 = ajv$8.compile(relationshipSchema$1);
const validateBranch$2 = ajv$8.compile(branchSchema$2);

/**
 * @param {any} doc
 * @param {(params: { path: string; hash: {} }) => void} onHashFound
 */
function walkHashes(doc, onHashFound) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateInput$4(doc)) {
    return ctx
  }

  doc.product_tree.full_product_names?.forEach(
    (fullProductName, fullProductNameIndex) => {
      if (!validateFullProductName(fullProductName)) {
        return
      }

      fullProductName.product_identification_helper.hashes.forEach(
        (hash, hashIndex) => {
          onHashFound({
            path: `/product_tree/full_product_names/${fullProductNameIndex}/product_identification_helper/hashes/${hashIndex}`,
            hash,
          });
        }
      );
    }
  );

  /**
   * @param {string} prefix
   * @param {unknown[]} branches
   */
  const checkBranches = (prefix, branches) => {
    branches.forEach((branch, branchIndex) => {
      if (!validateBranch$2(branch)) {
        return
      }

      branch.product?.product_identification_helper.hashes.forEach(
        (hash, hashIndex) => {
          onHashFound({
            path: `${prefix}${branchIndex}/product_identification_helper/hashes/${hashIndex}`,
            hash,
          });
        }
      );
      checkBranches(
        `${prefix}${branchIndex}/branches/`,
        Array.isArray(branch.branches) ? branch.branches : []
      );
    });
  };

  checkBranches('/product_tree/branches/', doc.product_tree.branches ?? []);

  doc.product_tree.relationships?.forEach((relationship, relationshipIndex) => {
    if (!validateRelationship$1(relationship)) {
      return
    }

    relationship.full_product_name.product_identification_helper.hashes.forEach(
      (hash, hashIndex) => {
        onHashFound({
          path: `/product_tree/relationships/${relationshipIndex}/product_identification_helper/hashes/${hashIndex}`,
          hash,
        });
      }
    );
  });

  return ctx
}

const ajv$7 = new Ajv();

const hashSchema = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    file_hashes: {
      elements: {
        additionalProperties: true,
        properties: {},
      },
    },
  },
});

const validateHash = ajv$7.compile(hashSchema);

/**
 * @param {any} doc
 * @param {string} hashName
 */
function checkForUnsafeHashAlgorithms (doc, hashName) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  walkHashes(doc, ({ path, hash }) => {
    if (!validateHash(hash)) return
    const hashSet = getHashAlgorithmSet(hash);
    if (hashSet.has(hashName) && hashSet.size === 1) {
      ctx.warnings.push({
        instancePath: path,
        message: `use of ${hashName} as the only hash algorithm`,
      });
    }
  });

  return ctx
}

/**
 *
 * @param {{ file_hashes: Array<{ algorithm?: unknown }> }} hash
 * @returns
 */
function getHashAlgorithmSet(hash) {
  return new Set(
    hash.file_hashes
      .map((h) => h.algorithm)
      .filter(
        /** @returns {v is string} */
        (v) => typeof v === 'string'
      )
  )
}

/**
 * @param {any} doc
 */
function optionalTest_6_2_8(doc) {
  return checkForUnsafeHashAlgorithms(doc, 'md5')
}

/**
 * @param {any} doc
 */
function optionalTest_6_2_9(doc) {
  return checkForUnsafeHashAlgorithms(doc, 'sha1')
}

const ajv$6 = new Ajv();

const inputSchema$6 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    document: {
      additionalProperties: true,
      properties: {
        distribution: {
          additionalProperties: true,
          properties: {
            tlp: {
              additionalProperties: true,
              properties: {
                label: { type: 'string' },
              },
            },
          },
        },
      },
    },
  },
});

const validate$2 = ajv$6.compile(inputSchema$6);

/**
 * @param {any} doc
 */
function optionalTest_6_2_10(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validate$2(doc)) {
    ctx.warnings.push({
      message: 'missing tlp label',
      instancePath: '/document',
    });
  }

  return ctx
}

const ajv$5 = new Ajv();

const inputSchema$5 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    document: {
      additionalProperties: true,
      properties: {
        references: {
          elements: {
            additionalProperties: true,
            properties: {},
          },
        },

        tracking: {
          additionalProperties: true,
          properties: {
            id: { type: 'string' },
          },
        },
      },
    },
  },
});

const referenceSchema = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    category: { type: 'string' },
    url: { type: 'string' },
  },
});

const validate$1 = ajv$5.compile(inputSchema$5);
const validateReference = ajv$5.compile(referenceSchema);

/**
 * @param {any} doc
 */
function optionalTest_6_2_11(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  function warn() {
    ctx.warnings.push({
      message: 'missing canonical url',
      instancePath: '/document/references',
    });
  }

  if (!validate$1(doc)) {
    warn();
    return ctx
  }

  const hasCanonicalURL = doc.document.references.some(
    (r) =>
      validateReference(r) &&
      r.category === 'self' &&
      r.url.startsWith('https://') &&
      r.url.endsWith(
        doc.document.tracking.id.toLowerCase().replace(/[^+\-a-z0-9]+/g, '_') +
          '.json'
      )
  );

  if (!hasCanonicalURL) {
    warn();
  }

  return ctx
}

const ajv$4 = new Ajv();

const inputSchema$4 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    document: {
      additionalProperties: true,
      properties: {
        lang: { type: 'string' },
      },
    },
  },
});

const validate = ajv$4.compile(inputSchema$4);

/**
 * @param {any} doc
 */
function optionalTest_6_2_12(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validate(doc)) {
    ctx.warnings.push({
      message: 'missing document language',
      instancePath: '/document',
    });
  }

  return ctx
}

/**
 * @param {any} doc
 */
function optionalTest_6_2_13(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  /**
   * @param {Intl.Collator} collator
   * @param {string} prefix
   * @param {unknown} obj
   * @returns {unknown}
   */
  const checkObjectKeysSorting = (collator, prefix, obj) => {
    if (typeof obj !== 'object' || obj == null) return
    if (Array.isArray(obj)) {
      obj.forEach((e, i) => {
        checkObjectKeysSorting(collator, prefix + '/' + i, e);
      });
    }

    const keys = /** @type {Array<keyof obj>} */ (Object.keys(obj));
    const expectedKeys = keys.slice().sort((a, z) => collator.compare(a, z));
    if (JSON.stringify(keys) !== JSON.stringify(expectedKeys)) {
      ctx.warnings.push({
        instancePath: prefix,
        message: 'not sorted alphabetically',
      });
    }
    for (const key of keys) {
      checkObjectKeysSorting(collator, prefix + '/' + key, obj[key]);
    }
  };

  checkObjectKeysSorting(new Intl.Collator(), '', doc);

  return ctx
}

/**
 * @param {any} doc
 */
function optionalTest_6_2_14(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (
    typeof doc.document?.lang === 'string' &&
    isPrivateLanguage(doc.document.lang)
  ) {
    ctx.warnings.push({
      instancePath: '/document/lang',
      message: 'use of private language',
    });
  }

  if (
    typeof doc.document?.source_lang === 'string' &&
    isPrivateLanguage(doc.document.source_lang)
  ) {
    ctx.warnings.push({
      instancePath: '/document/source_lang',
      message: 'use of private language',
    });
  }

  return ctx
}

/**
 * @param {any} doc
 */
function optionalTest_6_2_15(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  const defaultLanguage = 'i-default';

  if (doc.document?.lang === defaultLanguage) {
    ctx.warnings.push({
      instancePath: '/document/lang',
      message: 'use of default language',
    });
  }

  if (doc.document?.source_lang === defaultLanguage) {
    ctx.warnings.push({
      instancePath: '/document/source_lang',
      message: 'use of default language',
    });
  }

  return ctx
}

const ajv$3 = new Ajv();

const inputSchema$3 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_tree: {
      additionalProperties: true,
      optionalProperties: {
        branches: { elements: { additionalProperties: true, properties: {} } },
        full_product_names: {
          elements: { additionalProperties: true, properties: {} },
        },
        relationships: {
          elements: { additionalProperties: true, properties: {} },
        },
      },
    },
  },
});

const branchSchema$1 = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    product: {
      additionalProperties: true,
      optionalProperties: {
        product_identification_helper: {
          additionalProperties: true,
          properties: {},
        },
      },
    },
  },
});

const relationshipSchema = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    full_product_name: {
      additionalProperties: true,
      optionalProperties: {
        product_identification_helper: {
          additionalProperties: true,
          properties: {},
        },
      },
    },
  },
});

const validateInput$3 = ajv$3.compile(inputSchema$3);
const validateRelationship = ajv$3.compile(relationshipSchema);
const validateBranch$1 = ajv$3.compile(branchSchema$1);

/**
 * @param {any} doc
 */
function optionalTest_6_2_16(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateInput$3(doc)) {
    return ctx
  }

  doc.product_tree.full_product_names?.forEach(
    (fullProductName, fullProductNameIndex) => {
      if (!fullProductName.product_identification_helper) {
        ctx.warnings.push({
          instancePath: `/product_tree/full_product_names/${fullProductNameIndex}`,
          message: 'missing product identification helper',
        });
      }
    }
  );

  /**
   * @param {object} params
   * @param {string} params.path
   * @param {unknown[]} params.branches
   */
  function checkBranches({ path, branches }) {
    branches.forEach((branch, branchIndex) => {
      if (!validateBranch$1(branch)) {
        return
      }
      if (branch.product && !branch.product.product_identification_helper) {
        ctx.warnings.push({
          instancePath: `${path}/${branchIndex}/product`,
          message: 'missing product identification helper',
        });
      }
      if (Array.isArray(branch.branches)) {
        checkBranches({
          path: `${path}/${branchIndex}/branches`,
          branches: branch.branches,
        });
      }
    });
  }

  if (doc.product_tree.branches) {
    checkBranches({
      path: '/product_tree/branches',
      branches: doc.product_tree.branches,
    });
  }

  doc.product_tree.relationships?.forEach((relationship, relationshipIndex) => {
    if (!validateRelationship(relationship)) {
      return
    }

    if (!relationship.full_product_name.product_identification_helper) {
      ctx.warnings.push({
        instancePath: `/product_tree/relationships/${relationshipIndex}/full_product_name`,
        message: 'missing product identification helper',
      });
    }
  });

  return ctx
}

const ajv$2 = new Ajv();

const inputSchema$2 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        optionalProperties: {
          ids: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                text: { type: 'string' },
              },
            },
          },
        },
      },
    },
  },
});

const validateInput$2 = ajv$2.compile(inputSchema$2);

/**
 * @param {any} doc
 */
function optionalTest_6_2_17(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateInput$2(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    vulnerability.ids?.forEach((id, idIndex) => {
      if (id.text?.match(/^CVE-[0-9]{4}-[0-9]{4,}$/)) {
        ctx.warnings.push({
          instancePath: `/vulnerabilities/${vulnerabilityIndex}/ids/${idIndex}`,
          message: 'contains CVE',
        });
      }
    });
  });

  return ctx
}

const ajv$1 = new Ajv();

const inputSchema$1 = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    product_tree: {
      additionalProperties: true,
      optionalProperties: {
        branches: { elements: { additionalProperties: true, properties: {} } },
      },
    },
  },
});

const branchSchema = /** @type {const} */ ({
  additionalProperties: true,
  optionalProperties: {
    category: { type: 'string' },
    name: { type: 'string' },
  },
});

const validateInput$1 = ajv$1.compile(inputSchema$1);
const validateBranch = ajv$1.compile(branchSchema);

/**
 * @param {any} doc
 */
function optionalTest_6_2_18(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateInput$1(doc)) {
    return ctx
  }

  /**
   * @param {object} params
   * @param {string} params.path
   * @param {unknown[]} params.branches
   */
  function checkBranches({ path, branches }) {
    branches.forEach((branch, branchIndex) => {
      if (!validateBranch(branch)) {
        return
      }
      if (
        branch.category === 'product_version_range' &&
        typeof branch.name === 'string' &&
        !branch.name.match(
          new RegExp('^vers:[a-z\\.\\-\\+][a-z0-9\\.\\-\\+]*/.+')
        )
      ) {
        ctx.warnings.push({
          instancePath: `${path}/${branchIndex}`,
          message: 'product version range without vers',
        });
      }
      if (Array.isArray(branch.branches)) {
        checkBranches({
          path: `${path}/${branchIndex}/branches`,
          branches: branch.branches,
        });
      }
    });
  }

  if (doc.product_tree.branches) {
    checkBranches({
      path: '/product_tree/branches',
      branches: doc.product_tree.branches,
    });
  }

  return ctx
}

const ajv = new Ajv();

const inputSchema = /** @type {const} */ ({
  additionalProperties: true,
  properties: {
    vulnerabilities: {
      elements: {
        additionalProperties: true,
        optionalProperties: {
          product_status: {
            additionalProperties: true,
            optionalProperties: {
              fixed: {
                elements: { type: 'string' },
              },
              first_fixed: {
                elements: { type: 'string' },
              },
            },
          },
          scores: {
            elements: {
              additionalProperties: true,
              optionalProperties: {
                cvss_v3: {
                  additionalProperties: true,
                  optionalProperties: {
                    environmentalScore: { type: 'float64' },
                    vectorString: { type: 'string' },
                    version: { type: 'string' },
                  },
                },
                cvss_v2: {
                  additionalProperties: true,
                  optionalProperties: {
                    environmentalScore: { type: 'float64' },
                    vectorString: { type: 'string' },
                    version: { type: 'string' },
                  },
                },
                products: {
                  elements: { type: 'string' },
                },
              },
            },
          },
        },
      },
    },
  },
});
const validateInput = ajv.compile(inputSchema);

/**
 * @param {any} doc
 */
function optionalTest_6_2_19(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateInput(doc)) {
    return ctx
  }

  doc.vulnerabilities.forEach((vulnerability, vulnerabilityIndex) => {
    const fixedProductIDs = new Set([
      ...(vulnerability.product_status?.first_fixed ?? []),
      ...(vulnerability.product_status?.fixed ?? []),
    ]);
    for (const productID of fixedProductIDs) {
      vulnerability.scores?.forEach((score, scoreIndex) => {
        if (!score.products?.includes(productID)) return
        if (score.cvss_v3) {
          const calculatedValue =
            score.cvss_v3.version === '3.1' || score.cvss_v3.version === '3.0'
              ? calculateEnvironmentalScoreFromMetrics({
                  version: score.cvss_v3.version,
                  vectorString: score.cvss_v3.vectorString ?? '',
                  metrics: score.cvss_v3,
                })
              : null;
          if (
            (typeof score.cvss_v3.environmentalScore === 'number' &&
              score.cvss_v3.environmentalScore > 0) ||
            (typeof calculatedValue === 'number' && calculatedValue > 0) ||
            calculatedValue === null
          ) {
            ctx.warnings.push({
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v3`,
              message: `environmental score should be 0 since "${productID}" is listed as fixed`,
            });
          }
        }
        if (score.cvss_v2) {
          const calculatedValue = calculateEnvironmentalScoreFromMetrics({
            version: '2.0',
            vectorString: score.cvss_v2.vectorString ?? '',
            metrics: score.cvss_v2,
          });
          if (
            (typeof score.cvss_v2.environmentalScore === 'number' &&
              score.cvss_v2.environmentalScore > 0) ||
            (typeof calculatedValue === 'number' && calculatedValue !== 0) ||
            calculatedValue === null
          ) {
            ctx.warnings.push({
              instancePath: `/vulnerabilities/${vulnerabilityIndex}/scores/${scoreIndex}/cvss_v2`,
              message: `environmental score should be 0 since "${productID}" is listed as fixed`,
            });
          }
        }
      });
    }
  });

  return ctx
}

const cvss2Mapping =
  /** @type {ReadonlyArray<readonly [string, string, Record<string, string>]>} */ (
    mapping$1.map((mapping) => [
      mapping[0],
      mapping[1],
      Object.fromEntries(
        Object.entries(mapping[2]).map(([key, value]) => [key, value.id])
      ),
    ])
  );

const cvss3Mapping = mapping;

/**
 * @param {object} params
 * @param {'2.0' | '3.0' | '3.1'} params.version
 * @param {string} params.vectorString
 * @param {Record<string, unknown>} params.metrics
 */
function calculateEnvironmentalScoreFromMetrics({
  version,
  vectorString,
  metrics,
}) {
  const vectorFromVectorString = new Map(
    vectorString
      .split('/')
      .map((e) => {
        const [key, value] = e.split(':');
        return /** @type {const} */ ([key, value])
      })
      .filter(([, value]) => value)
  );
  if (version === '3.1' || version === '3.0') {
    const args = /**
     * @type {[
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     *   string,
     * ]}
     */ (
      calculateMetricArray({
        mapping: cvss3Mapping,
        metrics,
        vector: vectorFromVectorString,
      }).map((e) => e[1])
    );
    const score = (
      version === '3.1' ? cvss31 : cvss30
    ).calculateCVSSFromMetrics(...args);
    if (!score.success) return null
    return Number(score.environmentalMetricScore)
  } else {
    const vector = Object.fromEntries(
      calculateMetricArray({
        mapping: cvss2Mapping,
        metrics,
        vector: vectorFromVectorString,
      })
    );
    const score = safelyParseCVSSV2Vector(vector);
    if (!score.success) return null
    return score.environmentalMetricScore
  }
}

/**
 * This function takes a cvss vector and a metric object and extracts all cvss
 * values according to the mapping. It does this by first looking up every property
 * in the `vector`. If the property doesn't exist there but in the metrics objects,
 * it takes the value from the corresponding metrics object.
 *
 * @param {object} params
 * @param {Map<string, string>} params.vector
 * @param {Record<string, unknown>} params.metrics
 * @param {ReadonlyArray<readonly [string, string, Record<string, string>]>} params.mapping
 * @returns an array of pairs where the first element is the metric name (abbreviated) and the
 *    second is the value (abbreviated). If no value is found the value is `undefined`.
 *    The order of the array is the same as in the mapping.
 */
function calculateMetricArray({ vector, metrics, mapping }) {
  return mapping.map((e) => {
    const metricAbbrev = e[1];
    const metricPropertyName = e[0];
    /** @type {any} */
    const metricValueAbbrevMap = e[2];
    /** @type {any} */
    const metricValue = metrics[metricPropertyName];
    return [
      metricAbbrev,
      vector.get(metricAbbrev) ?? metricValueAbbrevMap[metricValue],
    ]
  })
}

/**
 * @param {string | {}} vectorString
 * @returns
 */
function safelyParseCVSSV2Vector(vectorString) {
  try {
    return {
      success: true,
      environmentalMetricScore:
        getEnvironmentalScoreFromVectorString(vectorString),
    }
  } catch (e) {
    return {
      success: false,
      environmentalMetricScore: -1,
    }
  }
}

const validateStrictSchema = csafAjv.compile(schema$3);

/**
 * @param {unknown} doc
 */
function optionalTest_6_2_20(doc) {
  const ctx = {
    warnings:
      /** @type {Array<{ instancePath: string; message: string }>} */ ([]),
  };

  if (!validateStrictSchema(doc)) {
    const additionalPropertiesErrors =
      validateStrictSchema.errors?.filter(
        (e) => e.keyword === 'additionalProperties'
      ) ?? [];
    for (const error of additionalPropertiesErrors) {
      ctx.warnings.push({
        instancePath: error.instancePath,
        message: error.message ?? '',
      });
    }
  }

  return ctx
}

var optional = /*#__PURE__*/Object.freeze({
  __proto__: null,
  optionalTest_6_2_1: optionalTest_6_2_1,
  optionalTest_6_2_10: optionalTest_6_2_10,
  optionalTest_6_2_11: optionalTest_6_2_11,
  optionalTest_6_2_12: optionalTest_6_2_12,
  optionalTest_6_2_13: optionalTest_6_2_13,
  optionalTest_6_2_14: optionalTest_6_2_14,
  optionalTest_6_2_15: optionalTest_6_2_15,
  optionalTest_6_2_16: optionalTest_6_2_16,
  optionalTest_6_2_17: optionalTest_6_2_17,
  optionalTest_6_2_18: optionalTest_6_2_18,
  optionalTest_6_2_19: optionalTest_6_2_19,
  optionalTest_6_2_2: optionalTest_6_2_2,
  optionalTest_6_2_20: optionalTest_6_2_20,
  optionalTest_6_2_3: optionalTest_6_2_3,
  optionalTest_6_2_4: optionalTest_6_2_4,
  optionalTest_6_2_5: optionalTest_6_2_5,
  optionalTest_6_2_6: optionalTest_6_2_6,
  optionalTest_6_2_7: optionalTest_6_2_7,
  optionalTest_6_2_8: optionalTest_6_2_8,
  optionalTest_6_2_9: optionalTest_6_2_9
});

// main script for the JS integration.
//
// Whenever you make changes to this script, you will need to re-run `npm build`.


async function runValidation(validations, doc) {
  let tests = [];

  for (const validation of validations) {
    switch (validation) {
      case "schema":
        tests = tests.concat(Object.values(schema$1));
        break;
      case "mandatory":
        tests = tests.concat(Object.values(mandatory));
        break;
      case "optional":
        tests = tests.concat(Object.values(optional));
        break;
      default:
        throw new Error(`Unknown validation set: ${validation}`);
    }
  }

  return validateLib(tests, doc);
}

Deno.core.ops.op_register_func(runValidation);
